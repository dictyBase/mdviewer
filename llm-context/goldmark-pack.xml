This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
_benchmark/
  cmark/
    _data.md
    .gitignore
    cmark_benchmark.c
    goldmark_benchmark.go
    Makefile
  go/
    _data.md
    benchmark_test.go
    go.mod
_test/
  extra.txt
  options.txt
  spec.json
_tools/
  gen-emb-structs.go
  gen-oss-fuzz-corpus.go
  gen-unicode-case-folding-map.go
  html5entities.json
  main.go
  unicode-case-folding-map.json
.github/
  ISSUE_TEMPLATE/
    general-issue-template.md
  workflows/
    stale.yaml
    test.yaml
  ISSUE_TEMPLATE.md
ast/
  ast_test.go
  ast.go
  block.go
  inline.go
extension/
  _test/
    definition_list.txt
    footnote.txt
    linkify.txt
    strikethrough.txt
    table.txt
    tasklist.txt
    typographer.txt
  ast/
    definition_list.go
    footnote.go
    strikethrough.go
    table.go
    tasklist.go
  ast_test.go
  cjk_test.go
  cjk.go
  definition_list_test.go
  definition_list.go
  footnote_test.go
  footnote.go
  gfm.go
  linkify_test.go
  linkify.go
  package.go
  strikethrough_test.go
  strikethrough.go
  table_test.go
  table.go
  tasklist_test.go
  tasklist.go
  typographer_test.go
  typographer.go
fuzz/
  fuzz_test.go
  oss_fuzz_test.go
parser/
  attribute.go
  atx_heading.go
  auto_link.go
  blockquote.go
  code_block.go
  code_span.go
  delimiter.go
  emphasis.go
  fcode_block.go
  html_block.go
  link_ref.go
  link.go
  list_item.go
  list.go
  paragraph.go
  parser.go
  raw_html.go
  setext_headings.go
  thematic_break.go
renderer/
  html/
    html.go
  renderer.go
testutil/
  testutil_test.go
  testutil.go
text/
  package.go
  reader_test.go
  reader.go
  segment.go
util/
  html5entities.gen.go
  html5entities.go
  unicode_case_folding.gen.go
  unicode_case_folding.go
  util_cjk.go
  util_safe.go
  util_unsafe_go120.go
  util_unsafe_go121.go
  util.go
.gitignore
.golangci.yml
ast_test.go
commonmark_test.go
extra_test.go
go.mod
LICENSE
Makefile
markdown.go
options_test.go
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_benchmark/cmark/_data.md">
# Introduction

## What is Markdown?

Markdown is a plain text format for writing structured documents,
based on conventions for indicating formatting in email
and usenet posts.  It was developed by John Gruber (with
help from Aaron Swartz) and released in 2004 in the form of a
[syntax description](http://daringfireball.net/projects/markdown/syntax)
and a Perl script (`Markdown.pl`) for converting Markdown to
HTML.  In the next decade, dozens of implementations were
developed in many languages.  Some extended the original
Markdown syntax with conventions for footnotes, tables, and
other document elements.  Some allowed Markdown documents to be
rendered in formats other than HTML.  Websites like Reddit,
StackOverflow, and GitHub had millions of people using Markdown.
And Markdown started to be used beyond the web, to author books,
articles, slide shows, letters, and lecture notes.

What distinguishes Markdown from many other lightweight markup
syntaxes, which are often easier to write, is its readability.
As Gruber writes:

> The overriding design goal for Markdown's formatting syntax is
> to make it as readable as possible. The idea is that a
> Markdown-formatted document should be publishable as-is, as
> plain text, without looking like it's been marked up with tags
> or formatting instructions.
> (<http://daringfireball.net/projects/markdown/>)

The point can be illustrated by comparing a sample of
[AsciiDoc](http://www.methods.co.nz/asciidoc/) with
an equivalent sample of Markdown.  Here is a sample of
AsciiDoc from the AsciiDoc manual:

```
1. List item one.
+
List item one continued with a second paragraph followed by an
Indented block.
+
.................
$ ls *.sh
$ mv *.sh ~/tmp
.................
+
List item continued with a third paragraph.

2. List item two continued with an open block.
+
--
This paragraph is part of the preceding list item.

a. This list is nested and does not require explicit item
continuation.
+
This paragraph is part of the preceding list item.

b. List item b.

This paragraph belongs to item two of the outer list.
--
```

And here is the equivalent in Markdown:
```
1.  List item one.

    List item one continued with a second paragraph followed by an
    Indented block.

        $ ls *.sh
        $ mv *.sh ~/tmp

    List item continued with a third paragraph.

2.  List item two continued with an open block.

    This paragraph is part of the preceding list item.

    1. This list is nested and does not require explicit item continuation.

       This paragraph is part of the preceding list item.

    2. List item b.

    This paragraph belongs to item two of the outer list.
```

The AsciiDoc version is, arguably, easier to write. You don't need
to worry about indentation.  But the Markdown version is much easier
to read.  The nesting of list items is apparent to the eye in the
source, not just in the processed document.

## Why is a spec needed?

John Gruber's [canonical description of Markdown's
syntax](http://daringfireball.net/projects/markdown/syntax)
does not specify the syntax unambiguously.  Here are some examples of
questions it does not answer:

1.  How much indentation is needed for a sublist?  The spec says that
    continuation paragraphs need to be indented four spaces, but is
    not fully explicit about sublists.  It is natural to think that
    they, too, must be indented four spaces, but `Markdown.pl` does
    not require that.  This is hardly a "corner case," and divergences
    between implementations on this issue often lead to surprises for
    users in real documents. (See [this comment by John
    Gruber](http://article.gmane.org/gmane.text.markdown.general/1997).)

2.  Is a blank line needed before a block quote or heading?
    Most implementations do not require the blank line.  However,
    this can lead to unexpected results in hard-wrapped text, and
    also to ambiguities in parsing (note that some implementations
    put the heading inside the blockquote, while others do not).
    (John Gruber has also spoken [in favor of requiring the blank
    lines](http://article.gmane.org/gmane.text.markdown.general/2146).)

3.  Is a blank line needed before an indented code block?
    (`Markdown.pl` requires it, but this is not mentioned in the
    documentation, and some implementations do not require it.)

    ``` markdown
    paragraph
        code?
    ```

4.  What is the exact rule for determining when list items get
    wrapped in `<p>` tags?  Can a list be partially "loose" and partially
    "tight"?  What should we do with a list like this?

    ``` markdown
    1. one

    2. two
    3. three
    ```

    Or this?

    ``` markdown
    1.  one
        - a

        - b
    2.  two
    ```

    (There are some relevant comments by John Gruber
    [here](http://article.gmane.org/gmane.text.markdown.general/2554).)

5.  Can list markers be indented?  Can ordered list markers be right-aligned?

    ``` markdown
     8. item 1
     9. item 2
    10. item 2a
    ```

6.  Is this one list with a thematic break in its second item,
    or two lists separated by a thematic break?

    ``` markdown
    * a
    * * * * *
    * b
    ```

7.  When list markers change from numbers to bullets, do we have
    two lists or one?  (The Markdown syntax description suggests two,
    but the perl scripts and many other implementations produce one.)

    ``` markdown
    1. fee
    2. fie
    -  foe
    -  fum
    ```

8.  What are the precedence rules for the markers of inline structure?
    For example, is the following a valid link, or does the code span
    take precedence ?

    ``` markdown
    [a backtick (`)](/url) and [another backtick (`)](/url).
    ```

9.  What are the precedence rules for markers of emphasis and strong
    emphasis?  For example, how should the following be parsed?

    ``` markdown
    *foo *bar* baz*
    ```

10. What are the precedence rules between block-level and inline-level
    structure?  For example, how should the following be parsed?

    ``` markdown
    - `a long code span can contain a hyphen like this
      - and it can screw things up`
    ```

11. Can list items include section headings?  (`Markdown.pl` does not
    allow this, but does allow blockquotes to include headings.)

    ``` markdown
    - # Heading
    ```

12. Can list items be empty?

    ``` markdown
    * a
    *
    * b
    ```

13. Can link references be defined inside block quotes or list items?

    ``` markdown
    > Blockquote [foo].
    >
    > [foo]: /url
    ```

14. If there are multiple definitions for the same reference, which takes
    precedence?

    ``` markdown
    [foo]: /url1
    [foo]: /url2

    [foo][]
    ```

In the absence of a spec, early implementers consulted `Markdown.pl`
to resolve these ambiguities.  But `Markdown.pl` was quite buggy, and
gave manifestly bad results in many cases, so it was not a
satisfactory replacement for a spec.

Because there is no unambiguous spec, implementations have diverged
considerably.  As a result, users are often surprised to find that
a document that renders one way on one system (say, a GitHub wiki)
renders differently on another (say, converting to docbook using
pandoc).  To make matters worse, because nothing in Markdown counts
as a "syntax error," the divergence often isn't discovered right away.

## About this document

This document attempts to specify Markdown syntax unambiguously.
It contains many examples with side-by-side Markdown and
HTML.  These are intended to double as conformance tests.  An
accompanying script `spec_tests.py` can be used to run the tests
against any Markdown program:

    python test/spec_tests.py --spec spec.txt --program PROGRAM

Since this document describes how Markdown is to be parsed into
an abstract syntax tree, it would have made sense to use an abstract
representation of the syntax tree instead of HTML.  But HTML is capable
of representing the structural distinctions we need to make, and the
choice of HTML for the tests makes it possible to run the tests against
an implementation without writing an abstract syntax tree renderer.

This document is generated from a text file, `spec.txt`, written
in Markdown with a small extension for the side-by-side tests.
The script `tools/makespec.py` can be used to convert `spec.txt` into
HTML or CommonMark (which can then be converted into other formats).

In the examples, the `→` character is used to represent tabs.

# Preliminaries

## Characters and lines

Any sequence of [characters] is a valid CommonMark
document.

A [character](@) is a Unicode code point.  Although some
code points (for example, combining accents) do not correspond to
characters in an intuitive sense, all code points count as characters
for purposes of this spec.

This spec does not specify an encoding; it thinks of lines as composed
of [characters] rather than bytes.  A conforming parser may be limited
to a certain encoding.

A [line](@) is a sequence of zero or more [characters]
other than newline (`U+000A`) or carriage return (`U+000D`),
followed by a [line ending] or by the end of file.

A [line ending](@) is a newline (`U+000A`), a carriage return
(`U+000D`) not followed by a newline, or a carriage return and a
following newline.

A line containing no characters, or a line containing only spaces
(`U+0020`) or tabs (`U+0009`), is called a [blank line](@).

The following definitions of character classes will be used in this spec:

A [whitespace character](@) is a space
(`U+0020`), tab (`U+0009`), newline (`U+000A`), line tabulation (`U+000B`),
form feed (`U+000C`), or carriage return (`U+000D`).

[Whitespace](@) is a sequence of one or more [whitespace
characters].

A [Unicode whitespace character](@) is
any code point in the Unicode `Zs` general category, or a tab (`U+0009`),
carriage return (`U+000D`), newline (`U+000A`), or form feed
(`U+000C`).

[Unicode whitespace](@) is a sequence of one
or more [Unicode whitespace characters].

A [space](@) is `U+0020`.

A [non-whitespace character](@) is any character
that is not a [whitespace character].

An [ASCII punctuation character](@)
is `!`, `"`, `#`, `$`, `%`, `&`, `'`, `(`, `)`,
`*`, `+`, `,`, `-`, `.`, `/` (U+0021–2F), 
`:`, `;`, `<`, `=`, `>`, `?`, `@` (U+003A–0040),
`[`, `\`, `]`, `^`, `_`, `` ` `` (U+005B–0060), 
`{`, `|`, `}`, or `~` (U+007B–007E).

A [punctuation character](@) is an [ASCII
punctuation character] or anything in
the general Unicode categories  `Pc`, `Pd`, `Pe`, `Pf`, `Pi`, `Po`, or `Ps`.

## Tabs

Tabs in lines are not expanded to [spaces].  However,
in contexts where whitespace helps to define block structure,
tabs behave as if they were replaced by spaces with a tab stop
of 4 characters.

Thus, for example, a tab can be used instead of four spaces
in an indented code block.  (Note, however, that internal
tabs are passed through as literal tabs, not expanded to
spaces.)

```````````````````````````````` example
→foo→baz→→bim
.
<pre><code>foo→baz→→bim
</code></pre>
````````````````````````````````

```````````````````````````````` example
  →foo→baz→→bim
.
<pre><code>foo→baz→→bim
</code></pre>
````````````````````````````````

```````````````````````````````` example
    a→a
    ὐ→a
.
<pre><code>a→a
ὐ→a
</code></pre>
````````````````````````````````

In the following example, a continuation paragraph of a list
item is indented with a tab; this has exactly the same effect
as indentation with four spaces would:

```````````````````````````````` example
  - foo

→bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
````````````````````````````````

```````````````````````````````` example
- foo

→→bar
.
<ul>
<li>
<p>foo</p>
<pre><code>  bar
</code></pre>
</li>
</ul>
````````````````````````````````

Normally the `>` that begins a block quote may be followed
optionally by a space, which is not considered part of the
content.  In the following case `>` is followed by a tab,
which is treated as if it were expanded into three spaces.
Since one of these spaces is considered part of the
delimiter, `foo` is considered to be indented six spaces
inside the block quote context, so we get an indented
code block starting with two spaces.

```````````````````````````````` example
>→→foo
.
<blockquote>
<pre><code>  foo
</code></pre>
</blockquote>
````````````````````````````````

```````````````````````````````` example
-→→foo
.
<ul>
<li>
<pre><code>  foo
</code></pre>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
    foo
→bar
.
<pre><code>foo
bar
</code></pre>
````````````````````````````````

```````````````````````````````` example
 - foo
   - bar
→ - baz
.
<ul>
<li>foo
<ul>
<li>bar
<ul>
<li>baz</li>
</ul>
</li>
</ul>
</li>
</ul>
````````````````````````````````

```````````````````````````````` example
#→Foo
.
<h1>Foo</h1>
````````````````````````````````

```````````````````````````````` example
*→*→*→
.
<hr />
````````````````````````````````


## Insecure characters

For security reasons, the Unicode character `U+0000` must be replaced
with the REPLACEMENT CHARACTER (`U+FFFD`).

# Blocks and inlines

We can think of a document as a sequence of
[blocks](@)---structural elements like paragraphs, block
quotations, lists, headings, rules, and code blocks.  Some blocks (like
block quotes and list items) contain other blocks; others (like
headings and paragraphs) contain [inline](@) content---text,
links, emphasized text, images, code spans, and so on.

## Precedence

Indicators of block structure always take precedence over indicators
of inline structure.  So, for example, the following is a list with
two items, not a list with one item containing a code span:

```````````````````````````````` example
- `one
- two`
.
<ul>
<li>`one</li>
<li>two`</li>
</ul>
````````````````````````````````


This means that parsing can proceed in two steps:  first, the block
structure of the document can be discerned; second, text lines inside
paragraphs, headings, and other block constructs can be parsed for inline
structure.  The second step requires information about link reference
definitions that will be available only at the end of the first
step.  Note that the first step requires processing lines in sequence,
but the second can be parallelized, since the inline parsing of
one block element does not affect the inline parsing of any other.

## Container blocks and leaf blocks

We can divide blocks into two types:
[container blocks](@),
which can contain other blocks, and [leaf blocks](@),
which cannot.

# Leaf blocks

This section describes the different kinds of leaf block that make up a
Markdown document.

## Thematic breaks

A line consisting of 0-3 spaces of indentation, followed by a sequence
of three or more matching `-`, `_`, or `*` characters, each followed
optionally by any number of spaces or tabs, forms a
[thematic break](@).

```````````````````````````````` example
***
---
___
.
<hr />
<hr />
<hr />
````````````````````````````````


Wrong characters:

```````````````````````````````` example
+++
.
<p>+++</p>
````````````````````````````````


```````````````````````````````` example
===
.
<p>===</p>
````````````````````````````````


Not enough characters:

```````````````````````````````` example
--
**
__
.
<p>--
**
__</p>
````````````````````````````````


One to three spaces indent are allowed:

```````````````````````````````` example
 ***
  ***
   ***
.
<hr />
<hr />
<hr />
````````````````````````````````


Four spaces is too many:

```````````````````````````````` example
    ***
.
<pre><code>***
</code></pre>
````````````````````````````````


```````````````````````````````` example
Foo
    ***
.
<p>Foo
***</p>
````````````````````````````````


More than three characters may be used:

```````````````````````````````` example
_____________________________________
.
<hr />
````````````````````````````````


Spaces are allowed between the characters:

```````````````````````````````` example
 - - -
.
<hr />
````````````````````````````````


```````````````````````````````` example
 **  * ** * ** * **
.
<hr />
````````````````````````````````


```````````````````````````````` example
-     -      -      -
.
<hr />
````````````````````````````````


Spaces are allowed at the end:

```````````````````````````````` example
- - - -    
.
<hr />
````````````````````````````````


However, no other characters may occur in the line:

```````````````````````````````` example
_ _ _ _ a

a------

---a---
.
<p>_ _ _ _ a</p>
<p>a------</p>
<p>---a---</p>
````````````````````````````````


It is required that all of the [non-whitespace characters] be the same.
So, this is not a thematic break:

```````````````````````````````` example
 *-*
.
<p><em>-</em></p>
````````````````````````````````


Thematic breaks do not need blank lines before or after:

```````````````````````````````` example
- foo
***
- bar
.
<ul>
<li>foo</li>
</ul>
<hr />
<ul>
<li>bar</li>
</ul>
````````````````````````````````


Thematic breaks can interrupt a paragraph:

```````````````````````````````` example
Foo
***
bar
.
<p>Foo</p>
<hr />
<p>bar</p>
````````````````````````````````


If a line of dashes that meets the above conditions for being a
thematic break could also be interpreted as the underline of a [setext
heading], the interpretation as a
[setext heading] takes precedence. Thus, for example,
this is a setext heading, not a paragraph followed by a thematic break:

```````````````````````````````` example
Foo
---
bar
.
<h2>Foo</h2>
<p>bar</p>
````````````````````````````````


When both a thematic break and a list item are possible
interpretations of a line, the thematic break takes precedence:

```````````````````````````````` example
* Foo
* * *
* Bar
.
<ul>
<li>Foo</li>
</ul>
<hr />
<ul>
<li>Bar</li>
</ul>
````````````````````````````````


If you want a thematic break in a list item, use a different bullet:

```````````````````````````````` example
- Foo
- * * *
.
<ul>
<li>Foo</li>
<li>
<hr />
</li>
</ul>
````````````````````````````````


## ATX headings

An [ATX heading](@)
consists of a string of characters, parsed as inline content, between an
opening sequence of 1--6 unescaped `#` characters and an optional
closing sequence of any number of unescaped `#` characters.
The opening sequence of `#` characters must be followed by a
[space] or by the end of line. The optional closing sequence of `#`s must be
preceded by a [space] and may be followed by spaces only.  The opening
`#` character may be indented 0-3 spaces.  The raw contents of the
heading are stripped of leading and trailing spaces before being parsed
as inline content.  The heading level is equal to the number of `#`
characters in the opening sequence.

Simple headings:

```````````````````````````````` example
# foo
## foo
### foo
#### foo
##### foo
###### foo
.
<h1>foo</h1>
<h2>foo</h2>
<h3>foo</h3>
<h4>foo</h4>
<h5>foo</h5>
<h6>foo</h6>
````````````````````````````````


More than six `#` characters is not a heading:

```````````````````````````````` example
####### foo
.
<p>####### foo</p>
````````````````````````````````


At least one space is required between the `#` characters and the
heading's contents, unless the heading is empty.  Note that many
implementations currently do not require the space.  However, the
space was required by the
[original ATX implementation](http://www.aaronsw.com/2002/atx/atx.py),
and it helps prevent things like the following from being parsed as
headings:

```````````````````````````````` example
#5 bolt

#hashtag
.
<p>#5 bolt</p>
<p>#hashtag</p>
````````````````````````````````


This is not a heading, because the first `#` is escaped:

```````````````````````````````` example
\## foo
.
<p>## foo</p>
````````````````````````````````


Contents are parsed as inlines:

```````````````````````````````` example
# foo *bar* \*baz\*
.
<h1>foo <em>bar</em> *baz*</h1>
````````````````````````````````


Leading and trailing [whitespace] is ignored in parsing inline content:

```````````````````````````````` example
#                  foo                     
.
<h1>foo</h1>
````````````````````````````````


One to three spaces indentation are allowed:

```````````````````````````````` example
 ### foo
  ## foo
   # foo
.
<h3>foo</h3>
<h2>foo</h2>
<h1>foo</h1>
````````````````````````````````


Four spaces are too much:

```````````````````````````````` example
    # foo
.
<pre><code># foo
</code></pre>
````````````````````````````````


```````````````````````````````` example
foo
    # bar
.
<p>foo
# bar</p>
````````````````````````````````


A closing sequence of `#` characters is optional:

```````````````````````````````` example
## foo ##
  ###   bar    ###
.
<h2>foo</h2>
<h3>bar</h3>
````````````````````````````````


It need not be the same length as the opening sequence:

```````````````````````````````` example
# foo ##################################
##### foo ##
.
<h1>foo</h1>
<h5>foo</h5>
````````````````````````````````


Spaces are allowed after the closing sequence:

```````````````````````````````` example
### foo ###     
.
<h3>foo</h3>
````````````````````````````````


A sequence of `#` characters with anything but [spaces] following it
is not a closing sequence, but counts as part of the contents of the
heading:

```````````````````````````````` example
### foo ### b
.
<h3>foo ### b</h3>
````````````````````````````````


The closing sequence must be preceded by a space:

```````````````````````````````` example
# foo#
.
<h1>foo#</h1>
````````````````````````````````


Backslash-escaped `#` characters do not count as part
of the closing sequence:

```````````````````````````````` example
### foo \###
## foo #\##
# foo \#
.
<h3>foo ###</h3>
<h2>foo ###</h2>
<h1>foo #</h1>
````````````````````````````````


ATX headings need not be separated from surrounding content by blank
lines, and they can interrupt paragraphs:

```````````````````````````````` example
****
## foo
****
.
<hr />
<h2>foo</h2>
<hr />
````````````````````````````````


```````````````````````````````` example
Foo bar
# baz
Bar foo
.
<p>Foo bar</p>
<h1>baz</h1>
<p>Bar foo</p>
````````````````````````````````


ATX headings can be empty:

```````````````````````````````` example
## 
#
### ###
.
<h2></h2>
<h1></h1>
<h3></h3>
````````````````````````````````


## Setext headings

A [setext heading](@) consists of one or more
lines of text, each containing at least one [non-whitespace
character], with no more than 3 spaces indentation, followed by
a [setext heading underline].  The lines of text must be such
that, were they not followed by the setext heading underline,
they would be interpreted as a paragraph:  they cannot be
interpretable as a [code fence], [ATX heading][ATX headings],
[block quote][block quotes], [thematic break][thematic breaks],
[list item][list items], or [HTML block][HTML blocks].

A [setext heading underline](@) is a sequence of
`=` characters or a sequence of `-` characters, with no more than 3
spaces indentation and any number of trailing spaces.  If a line
containing a single `-` can be interpreted as an
empty [list items], it should be interpreted this way
and not as a [setext heading underline].

The heading is a level 1 heading if `=` characters are used in
the [setext heading underline], and a level 2 heading if `-`
characters are used.  The contents of the heading are the result
of parsing the preceding lines of text as CommonMark inline
content.

In general, a setext heading need not be preceded or followed by a
blank line.  However, it cannot interrupt a paragraph, so when a
setext heading comes after a paragraph, a blank line is needed between
them.

Simple examples:

```````````````````````````````` example
Foo *bar*
=========

Foo *bar*
---------
.
<h1>Foo <em>bar</em></h1>
<h2>Foo <em>bar</em></h2>
````````````````````````````````


The content of the header may span more than one line:

```````````````````````````````` example
Foo *bar
baz*
====
.
<h1>Foo <em>bar
baz</em></h1>
````````````````````````````````

The contents are the result of parsing the headings's raw
content as inlines.  The heading's raw content is formed by
concatenating the lines and removing initial and final
[whitespace].

```````````````````````````````` example
  Foo *bar
baz*→
====
.
<h1>Foo <em>bar
baz</em></h1>
````````````````````````````````


The underlining can be any length:

```````````````````````````````` example
Foo
-------------------------

Foo
=
.
<h2>Foo</h2>
<h1>Foo</h1>
````````````````````````````````


The heading content can be indented up to three spaces, and need
not line up with the underlining:

```````````````````````````````` example
   Foo
---

  Foo
-----

  Foo
  ===
.
<h2>Foo</h2>
<h2>Foo</h2>
<h1>Foo</h1>
````````````````````````````````


Four spaces indent is too much:

```````````````````````````````` example
    Foo
    ---

    Foo
---
.
<pre><code>Foo
---

Foo
</code></pre>
<hr />
````````````````````````````````


The setext heading underline can be indented up to three spaces, and
may have trailing spaces:

```````````````````````````````` example
Foo
   ----      
.
<h2>Foo</h2>
````````````````````````````````


Four spaces is too much:

```````````````````````````````` example
Foo
    ---
.
<p>Foo
---</p>
````````````````````````````````


The setext heading underline cannot contain internal spaces:

```````````````````````````````` example
Foo
= =

Foo
--- -
.
<p>Foo
= =</p>
<p>Foo</p>
<hr />
````````````````````````````````


Trailing spaces in the content line do not cause a line break:

```````````````````````````````` example
Foo  
-----
.
<h2>Foo</h2>
````````````````````````````````


Nor does a backslash at the end:

```````````````````````````````` example
Foo\
----
.
<h2>Foo\</h2>
````````````````````````````````


Since indicators of block structure take precedence over
indicators of inline structure, the following are setext headings:

```````````````````````````````` example
`Foo
----
`

<a title="a lot
---
of dashes"/>
.
<h2>`Foo</h2>
<p>`</p>
<h2>&lt;a title=&quot;a lot</h2>
<p>of dashes&quot;/&gt;</p>
````````````````````````````````


The setext heading underline cannot be a [lazy continuation
line] in a list item or block quote:

```````````````````````````````` example
> Foo
---
.
<blockquote>
<p>Foo</p>
</blockquote>
<hr />
````````````````````````````````


```````````````````````````````` example
> foo
bar
===
.
<blockquote>
<p>foo
bar
===</p>
</blockquote>
````````````````````````````````


```````````````````````````````` example
- Foo
---
.
<ul>
<li>Foo</li>
</ul>
<hr />
````````````````````````````````


A blank line is needed between a paragraph and a following
setext heading, since otherwise the paragraph becomes part
of the heading's content:

```````````````````````````````` example
Foo
Bar
---
.
<h2>Foo
Bar</h2>
````````````````````````````````


But in general a blank line is not required before or after
setext headings:

```````````````````````````````` example
---
Foo
---
Bar
---
Baz
.
<hr />
<h2>Foo</h2>
<h2>Bar</h2>
<p>Baz</p>
````````````````````````````````


Setext headings cannot be empty:

```````````````````````````````` example

====
.
<p>====</p>
````````````````````````````````


Setext heading text lines must not be interpretable as block
constructs other than paragraphs.  So, the line of dashes
in these examples gets interpreted as a thematic break:

```````````````````````````````` example
---
---
.
<hr />
<hr />
````````````````````````````````


```````````````````````````````` example
- foo
-----
.
<ul>
<li>foo</li>
</ul>
<hr />
````````````````````````````````


```````````````````````````````` example
    foo
---
.
<pre><code>foo
</code></pre>
<hr />
````````````````````````````````


```````````````````````````````` example
> foo
-----
.
<blockquote>
<p>foo</p>
</blockquote>
<hr />
````````````````````````````````


If you want a heading with `> foo` as its literal text, you can
use backslash escapes:

```````````````````````````````` example
\> foo
------
.
<h2>&gt; foo</h2>
````````````````````````````````


**Compatibility note:**  Most existing Markdown implementations
do not allow the text of setext headings to span multiple lines.
But there is no consensus about how to interpret

``` markdown
Foo
bar
---
baz
```

One can find four different interpretations:

1. paragraph "Foo", heading "bar", paragraph "baz"
2. paragraph "Foo bar", thematic break, paragraph "baz"
3. paragraph "Foo bar --- baz"
4. heading "Foo bar", paragraph "baz"

We find interpretation 4 most natural, and interpretation 4
increases the expressive power of CommonMark, by allowing
multiline headings.  Authors who want interpretation 1 can
put a blank line after the first paragraph:

```````````````````````````````` example
Foo

bar
---
baz
.
<p>Foo</p>
<h2>bar</h2>
<p>baz</p>
````````````````````````````````


Authors who want interpretation 2 can put blank lines around
the thematic break,

```````````````````````````````` example
Foo
bar

---

baz
.
<p>Foo
bar</p>
<hr />
<p>baz</p>
````````````````````````````````


or use a thematic break that cannot count as a [setext heading
underline], such as

```````````````````````````````` example
Foo
bar
* * *
baz
.
<p>Foo
bar</p>
<hr />
<p>baz</p>
````````````````````````````````


Authors who want interpretation 3 can use backslash escapes:

```````````````````````````````` example
Foo
bar
\---
baz
.
<p>Foo
bar
---
baz</p>
````````````````````````````````


## Indented code blocks

An [indented code block](@) is composed of one or more
[indented chunks] separated by blank lines.
An [indented chunk](@) is a sequence of non-blank lines,
each indented four or more spaces. The contents of the code block are
the literal contents of the lines, including trailing
[line endings], minus four spaces of indentation.
An indented code block has no [info string].

An indented code block cannot interrupt a paragraph, so there must be
a blank line between a paragraph and a following indented code block.
(A blank line is not needed, however, between a code block and a following
paragraph.)

```````````````````````````````` example
    a simple
      indented code block
.
<pre><code>a simple
  indented code block
</code></pre>
````````````````````````````````


If there is any ambiguity between an interpretation of indentation
as a code block and as indicating that material belongs to a [list
item][list items], the list item interpretation takes precedence:

```````````````````````````````` example
  - foo

    bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
1.  foo

    - bar
.
<ol>
<li>
<p>foo</p>
<ul>
<li>bar</li>
</ul>
</li>
</ol>
````````````````````````````````



The contents of a code block are literal text, and do not get parsed
as Markdown:

```````````````````````````````` example
    <a/>
    *hi*

    - one
.
<pre><code>&lt;a/&gt;
*hi*

- one
</code></pre>
````````````````````````````````


Here we have three chunks separated by blank lines:

```````````````````````````````` example
    chunk1

    chunk2
  
 
 
    chunk3
.
<pre><code>chunk1

chunk2



chunk3
</code></pre>
````````````````````````````````


Any initial spaces beyond four will be included in the content, even
in interior blank lines:

```````````````````````````````` example
    chunk1
      
      chunk2
.
<pre><code>chunk1
  
  chunk2
</code></pre>
````````````````````````````````


An indented code block cannot interrupt a paragraph.  (This
allows hanging indents and the like.)

```````````````````````````````` example
Foo
    bar

.
<p>Foo
bar</p>
````````````````````````````````


However, any non-blank line with fewer than four leading spaces ends
the code block immediately.  So a paragraph may occur immediately
after indented code:

```````````````````````````````` example
    foo
bar
.
<pre><code>foo
</code></pre>
<p>bar</p>
````````````````````````````````


And indented code can occur immediately before and after other kinds of
blocks:

```````````````````````````````` example
# Heading
    foo
Heading
------
    foo
----
.
<h1>Heading</h1>
<pre><code>foo
</code></pre>
<h2>Heading</h2>
<pre><code>foo
</code></pre>
<hr />
````````````````````````````````


The first line can be indented more than four spaces:

```````````````````````````````` example
        foo
    bar
.
<pre><code>    foo
bar
</code></pre>
````````````````````````````````


Blank lines preceding or following an indented code block
are not included in it:

```````````````````````````````` example

    
    foo
    

.
<pre><code>foo
</code></pre>
````````````````````````````````


Trailing spaces are included in the code block's content:

```````````````````````````````` example
    foo  
.
<pre><code>foo  
</code></pre>
````````````````````````````````



## Fenced code blocks

A [code fence](@) is a sequence
of at least three consecutive backtick characters (`` ` ``) or
tildes (`~`).  (Tildes and backticks cannot be mixed.)
A [fenced code block](@)
begins with a code fence, indented no more than three spaces.

The line with the opening code fence may optionally contain some text
following the code fence; this is trimmed of leading and trailing
whitespace and called the [info string](@). If the [info string] comes
after a backtick fence, it may not contain any backtick
characters.  (The reason for this restriction is that otherwise
some inline code would be incorrectly interpreted as the
beginning of a fenced code block.)

The content of the code block consists of all subsequent lines, until
a closing [code fence] of the same type as the code block
began with (backticks or tildes), and with at least as many backticks
or tildes as the opening code fence.  If the leading code fence is
indented N spaces, then up to N spaces of indentation are removed from
each line of the content (if present).  (If a content line is not
indented, it is preserved unchanged.  If it is indented less than N
spaces, all of the indentation is removed.)

The closing code fence may be indented up to three spaces, and may be
followed only by spaces, which are ignored.  If the end of the
containing block (or document) is reached and no closing code fence
has been found, the code block contains all of the lines after the
opening code fence until the end of the containing block (or
document).  (An alternative spec would require backtracking in the
event that a closing code fence is not found.  But this makes parsing
much less efficient, and there seems to be no real down side to the
behavior described here.)

A fenced code block may interrupt a paragraph, and does not require
a blank line either before or after.

The content of a code fence is treated as literal text, not parsed
as inlines.  The first word of the [info string] is typically used to
specify the language of the code sample, and rendered in the `class`
attribute of the `code` tag.  However, this spec does not mandate any
particular treatment of the [info string].

Here is a simple example with backticks:

```````````````````````````````` example
```
<
 >
```
.
<pre><code>&lt;
 &gt;
</code></pre>
````````````````````````````````


With tildes:

```````````````````````````````` example
~~~
<
 >
~~~
.
<pre><code>&lt;
 &gt;
</code></pre>
````````````````````````````````

Fewer than three backticks is not enough:

```````````````````````````````` example
``
foo
``
.
<p><code>foo</code></p>
````````````````````````````````

The closing code fence must use the same character as the opening
fence:

```````````````````````````````` example
```
aaa
~~~
```
.
<pre><code>aaa
~~~
</code></pre>
````````````````````````````````


```````````````````````````````` example
~~~
aaa
```
~~~
.
<pre><code>aaa
```
</code></pre>
````````````````````````````````


The closing code fence must be at least as long as the opening fence:

```````````````````````````````` example
````
aaa
```
``````
.
<pre><code>aaa
```
</code></pre>
````````````````````````````````


```````````````````````````````` example
~~~~
aaa
~~~
~~~~
.
<pre><code>aaa
~~~
</code></pre>
````````````````````````````````


Unclosed code blocks are closed by the end of the document
(or the enclosing [block quote][block quotes] or [list item][list items]):

```````````````````````````````` example
```
.
<pre><code></code></pre>
````````````````````````````````


```````````````````````````````` example
`````

```
aaa
.
<pre><code>
```
aaa
</code></pre>
````````````````````````````````


```````````````````````````````` example
> ```
> aaa

bbb
.
<blockquote>
<pre><code>aaa
</code></pre>
</blockquote>
<p>bbb</p>
````````````````````````````````


A code block can have all empty lines as its content:

```````````````````````````````` example
```

  
```
.
<pre><code>
  
</code></pre>
````````````````````````````````


A code block can be empty:

```````````````````````````````` example
```
```
.
<pre><code></code></pre>
````````````````````````````````


Fences can be indented.  If the opening fence is indented,
content lines will have equivalent opening indentation removed,
if present:

```````````````````````````````` example
 ```
 aaa
aaa
```
.
<pre><code>aaa
aaa
</code></pre>
````````````````````````````````


```````````````````````````````` example
  ```
aaa
  aaa
aaa
  ```
.
<pre><code>aaa
aaa
aaa
</code></pre>
````````````````````````````````


```````````````````````````````` example
   ```
   aaa
    aaa
  aaa
   ```
.
<pre><code>aaa
 aaa
aaa
</code></pre>
````````````````````````````````


Four spaces indentation produces an indented code block:

```````````````````````````````` example
    ```
    aaa
    ```
.
<pre><code>```
aaa
```
</code></pre>
````````````````````````````````


Closing fences may be indented by 0-3 spaces, and their indentation
need not match that of the opening fence:

```````````````````````````````` example
```
aaa
  ```
.
<pre><code>aaa
</code></pre>
````````````````````````````````


```````````````````````````````` example
   ```
aaa
  ```
.
<pre><code>aaa
</code></pre>
````````````````````````````````


This is not a closing fence, because it is indented 4 spaces:

```````````````````````````````` example
```
aaa
    ```
.
<pre><code>aaa
    ```
</code></pre>
````````````````````````````````



Code fences (opening and closing) cannot contain internal spaces:

```````````````````````````````` example
``` ```
aaa
.
<p><code> </code>
aaa</p>
````````````````````````````````


```````````````````````````````` example
~~~~~~
aaa
~~~ ~~
.
<pre><code>aaa
~~~ ~~
</code></pre>
````````````````````````````````


Fenced code blocks can interrupt paragraphs, and can be followed
directly by paragraphs, without a blank line between:

```````````````````````````````` example
foo
```
bar
```
baz
.
<p>foo</p>
<pre><code>bar
</code></pre>
<p>baz</p>
````````````````````````````````


Other blocks can also occur before and after fenced code blocks
without an intervening blank line:

```````````````````````````````` example
foo
---
~~~
bar
~~~
# baz
.
<h2>foo</h2>
<pre><code>bar
</code></pre>
<h1>baz</h1>
````````````````````````````````


An [info string] can be provided after the opening code fence.
Although this spec doesn't mandate any particular treatment of
the info string, the first word is typically used to specify
the language of the code block. In HTML output, the language is
normally indicated by adding a class to the `code` element consisting
of `language-` followed by the language name.

```````````````````````````````` example
```ruby
def foo(x)
  return 3
end
```
.
<pre><code class="language-ruby">def foo(x)
  return 3
end
</code></pre>
````````````````````````````````


```````````````````````````````` example
~~~~    ruby startline=3 $%@#$
def foo(x)
  return 3
end
~~~~~~~
.
<pre><code class="language-ruby">def foo(x)
  return 3
end
</code></pre>
````````````````````````````````


```````````````````````````````` example
````;
````
.
<pre><code class="language-;"></code></pre>
````````````````````````````````


[Info strings] for backtick code blocks cannot contain backticks:

```````````````````````````````` example
``` aa ```
foo
.
<p><code>aa</code>
foo</p>
````````````````````````````````


[Info strings] for tilde code blocks can contain backticks and tildes:

```````````````````````````````` example
~~~ aa ``` ~~~
foo
~~~
.
<pre><code class="language-aa">foo
</code></pre>
````````````````````````````````


Closing code fences cannot have [info strings]:

```````````````````````````````` example
```
``` aaa
```
.
<pre><code>``` aaa
</code></pre>
````````````````````````````````



## HTML blocks

An [HTML block](@) is a group of lines that is treated
as raw HTML (and will not be escaped in HTML output).

There are seven kinds of [HTML block], which can be defined by their
start and end conditions.  The block begins with a line that meets a
[start condition](@) (after up to three spaces optional indentation).
It ends with the first subsequent line that meets a matching [end
condition](@), or the last line of the document, or the last line of
the [container block](#container-blocks) containing the current HTML
block, if no line is encountered that meets the [end condition].  If
the first line meets both the [start condition] and the [end
condition], the block will contain just that line.

1.  **Start condition:**  line begins with the string `<script`,
`<pre`, or `<style` (case-insensitive), followed by whitespace,
the string `>`, or the end of the line.\
**End condition:**  line contains an end tag
`</script>`, `</pre>`, or `</style>` (case-insensitive; it
need not match the start tag).

2.  **Start condition:** line begins with the string `<!--`.\
**End condition:**  line contains the string `-->`.

3.  **Start condition:** line begins with the string `<?`.\
**End condition:** line contains the string `?>`.

4.  **Start condition:** line begins with the string `<!`
followed by an uppercase ASCII letter.\
**End condition:** line contains the character `>`.

5.  **Start condition:**  line begins with the string
`<![CDATA[`.\
**End condition:** line contains the string `]]>`.

6.  **Start condition:** line begins the string `<` or `</`
followed by one of the strings (case-insensitive) `address`,
`article`, `aside`, `base`, `basefont`, `blockquote`, `body`,
`caption`, `center`, `col`, `colgroup`, `dd`, `details`, `dialog`,
`dir`, `div`, `dl`, `dt`, `fieldset`, `figcaption`, `figure`,
`footer`, `form`, `frame`, `frameset`,
`h1`, `h2`, `h3`, `h4`, `h5`, `h6`, `head`, `header`, `hr`,
`html`, `iframe`, `legend`, `li`, `link`, `main`, `menu`, `menuitem`,
`nav`, `noframes`, `ol`, `optgroup`, `option`, `p`, `param`,
`section`, `source`, `summary`, `table`, `tbody`, `td`,
`tfoot`, `th`, `thead`, `title`, `tr`, `track`, `ul`, followed
by [whitespace], the end of the line, the string `>`, or
the string `/>`.\
**End condition:** line is followed by a [blank line].

7.  **Start condition:**  line begins with a complete [open tag]
(with any [tag name] other than `script`,
`style`, or `pre`) or a complete [closing tag],
followed only by [whitespace] or the end of the line.\
**End condition:** line is followed by a [blank line].

HTML blocks continue until they are closed by their appropriate
[end condition], or the last line of the document or other [container
block](#container-blocks).  This means any HTML **within an HTML
block** that might otherwise be recognised as a start condition will
be ignored by the parser and passed through as-is, without changing
the parser's state.

For instance, `<pre>` within a HTML block started by `<table>` will not affect
the parser state; as the HTML block was started in by start condition 6, it
will end at any blank line. This can be surprising:

```````````````````````````````` example
<table><tr><td>
<pre>
**Hello**,

_world_.
</pre>
</td></tr></table>
.
<table><tr><td>
<pre>
**Hello**,
<p><em>world</em>.
</pre></p>
</td></tr></table>
````````````````````````````````

In this case, the HTML block is terminated by the newline — the `**Hello**`
text remains verbatim — and regular parsing resumes, with a paragraph,
emphasised `world` and inline and block HTML following.

All types of [HTML blocks] except type 7 may interrupt
a paragraph.  Blocks of type 7 may not interrupt a paragraph.
(This restriction is intended to prevent unwanted interpretation
of long tags inside a wrapped paragraph as starting HTML blocks.)

Some simple examples follow.  Here are some basic HTML blocks
of type 6:

```````````````````````````````` example
<table>
  <tr>
    <td>
           hi
    </td>
  </tr>
</table>

okay.
.
<table>
  <tr>
    <td>
           hi
    </td>
  </tr>
</table>
<p>okay.</p>
````````````````````````````````


```````````````````````````````` example
 <div>
  *hello*
         <foo><a>
.
 <div>
  *hello*
         <foo><a>
````````````````````````````````


A block can also start with a closing tag:

```````````````````````````````` example
</div>
*foo*
.
</div>
*foo*
````````````````````````````````


Here we have two HTML blocks with a Markdown paragraph between them:

```````````````````````````````` example
<DIV CLASS="foo">

*Markdown*

</DIV>
.
<DIV CLASS="foo">
<p><em>Markdown</em></p>
</DIV>
````````````````````````````````


The tag on the first line can be partial, as long
as it is split where there would be whitespace:

```````````````````````````````` example
<div id="foo"
  class="bar">
</div>
.
<div id="foo"
  class="bar">
</div>
````````````````````````````````


```````````````````````````````` example
<div id="foo" class="bar
  baz">
</div>
.
<div id="foo" class="bar
  baz">
</div>
````````````````````````````````


An open tag need not be closed:
```````````````````````````````` example
<div>
*foo*

*bar*
.
<div>
*foo*
<p><em>bar</em></p>
````````````````````````````````



A partial tag need not even be completed (garbage
in, garbage out):

```````````````````````````````` example
<div id="foo"
*hi*
.
<div id="foo"
*hi*
````````````````````````````````


```````````````````````````````` example
<div class
foo
.
<div class
foo
````````````````````````````````


The initial tag doesn't even need to be a valid
tag, as long as it starts like one:

```````````````````````````````` example
<div *???-&&&-<---
*foo*
.
<div *???-&&&-<---
*foo*
````````````````````````````````


In type 6 blocks, the initial tag need not be on a line by
itself:

```````````````````````````````` example
<div><a href="bar">*foo*</a></div>
.
<div><a href="bar">*foo*</a></div>
````````````````````````````````


```````````````````````````````` example
<table><tr><td>
foo
</td></tr></table>
.
<table><tr><td>
foo
</td></tr></table>
````````````````````````````````


Everything until the next blank line or end of document
gets included in the HTML block.  So, in the following
example, what looks like a Markdown code block
is actually part of the HTML block, which continues until a blank
line or the end of the document is reached:

```````````````````````````````` example
<div></div>
``` c
int x = 33;
```
.
<div></div>
``` c
int x = 33;
```
````````````````````````````````


To start an [HTML block] with a tag that is *not* in the
list of block-level tags in (6), you must put the tag by
itself on the first line (and it must be complete):

```````````````````````````````` example
<a href="foo">
*bar*
</a>
.
<a href="foo">
*bar*
</a>
````````````````````````````````


In type 7 blocks, the [tag name] can be anything:

```````````````````````````````` example
<Warning>
*bar*
</Warning>
.
<Warning>
*bar*
</Warning>
````````````````````````````````


```````````````````````````````` example
<i class="foo">
*bar*
</i>
.
<i class="foo">
*bar*
</i>
````````````````````````````````


```````````````````````````````` example
</ins>
*bar*
.
</ins>
*bar*
````````````````````````````````


These rules are designed to allow us to work with tags that
can function as either block-level or inline-level tags.
The `<del>` tag is a nice example.  We can surround content with
`<del>` tags in three different ways.  In this case, we get a raw
HTML block, because the `<del>` tag is on a line by itself:

```````````````````````````````` example
<del>
*foo*
</del>
.
<del>
*foo*
</del>
````````````````````````````````


In this case, we get a raw HTML block that just includes
the `<del>` tag (because it ends with the following blank
line).  So the contents get interpreted as CommonMark:

```````````````````````````````` example
<del>

*foo*

</del>
.
<del>
<p><em>foo</em></p>
</del>
````````````````````````````````


Finally, in this case, the `<del>` tags are interpreted
as [raw HTML] *inside* the CommonMark paragraph.  (Because
the tag is not on a line by itself, we get inline HTML
rather than an [HTML block].)

```````````````````````````````` example
<del>*foo*</del>
.
<p><del><em>foo</em></del></p>
````````````````````````````````


HTML tags designed to contain literal content
(`script`, `style`, `pre`), comments, processing instructions,
and declarations are treated somewhat differently.
Instead of ending at the first blank line, these blocks
end at the first line containing a corresponding end tag.
As a result, these blocks can contain blank lines:

A pre tag (type 1):

```````````````````````````````` example
<pre language="haskell"><code>
import Text.HTML.TagSoup

main :: IO ()
main = print $ parseTags tags
</code></pre>
okay
.
<pre language="haskell"><code>
import Text.HTML.TagSoup

main :: IO ()
main = print $ parseTags tags
</code></pre>
<p>okay</p>
````````````````````````````````


A script tag (type 1):

```````````````````````````````` example
<script type="text/javascript">
// JavaScript example

document.getElementById("demo").innerHTML = "Hello JavaScript!";
</script>
okay
.
<script type="text/javascript">
// JavaScript example

document.getElementById("demo").innerHTML = "Hello JavaScript!";
</script>
<p>okay</p>
````````````````````````````````


A style tag (type 1):

```````````````````````````````` example
<style
  type="text/css">
h1 {color:red;}

p {color:blue;}
</style>
okay
.
<style
  type="text/css">
h1 {color:red;}

p {color:blue;}
</style>
<p>okay</p>
````````````````````````````````


If there is no matching end tag, the block will end at the
end of the document (or the enclosing [block quote][block quotes]
or [list item][list items]):

```````````````````````````````` example
<style
  type="text/css">

foo
.
<style
  type="text/css">

foo
````````````````````````````````


```````````````````````````````` example
> <div>
> foo

bar
.
<blockquote>
<div>
foo
</blockquote>
<p>bar</p>
````````````````````````````````


```````````````````````````````` example
- <div>
- foo
.
<ul>
<li>
<div>
</li>
<li>foo</li>
</ul>
````````````````````````````````


The end tag can occur on the same line as the start tag:

```````````````````````````````` example
<style>p{color:red;}</style>
*foo*
.
<style>p{color:red;}</style>
<p><em>foo</em></p>
````````````````````````````````


```````````````````````````````` example
<!-- foo -->*bar*
*baz*
.
<!-- foo -->*bar*
<p><em>baz</em></p>
````````````````````````````````


Note that anything on the last line after the
end tag will be included in the [HTML block]:

```````````````````````````````` example
<script>
foo
</script>1. *bar*
.
<script>
foo
</script>1. *bar*
````````````````````````````````


A comment (type 2):

```````````````````````````````` example
<!-- Foo

bar
   baz -->
okay
.
<!-- Foo

bar
   baz -->
<p>okay</p>
````````````````````````````````



A processing instruction (type 3):

```````````````````````````````` example
<?php

  echo '>';

?>
okay
.
<?php

  echo '>';

?>
<p>okay</p>
````````````````````````````````


A declaration (type 4):

```````````````````````````````` example
<!DOCTYPE html>
.
<!DOCTYPE html>
````````````````````````````````


CDATA (type 5):

```````````````````````````````` example
<![CDATA[
function matchwo(a,b)
{
  if (a < b && a < 0) then {
    return 1;

  } else {

    return 0;
  }
}
]]>
okay
.
<![CDATA[
function matchwo(a,b)
{
  if (a < b && a < 0) then {
    return 1;

  } else {

    return 0;
  }
}
]]>
<p>okay</p>
````````````````````````````````


The opening tag can be indented 1-3 spaces, but not 4:

```````````````````````````````` example
  <!-- foo -->

    <!-- foo -->
.
  <!-- foo -->
<pre><code>&lt;!-- foo --&gt;
</code></pre>
````````````````````````````````


```````````````````````````````` example
  <div>

    <div>
.
  <div>
<pre><code>&lt;div&gt;
</code></pre>
````````````````````````````````


An HTML block of types 1--6 can interrupt a paragraph, and need not be
preceded by a blank line.

```````````````````````````````` example
Foo
<div>
bar
</div>
.
<p>Foo</p>
<div>
bar
</div>
````````````````````````````````


However, a following blank line is needed, except at the end of
a document, and except for blocks of types 1--5, [above][HTML
block]:

```````````````````````````````` example
<div>
bar
</div>
*foo*
.
<div>
bar
</div>
*foo*
````````````````````````````````


HTML blocks of type 7 cannot interrupt a paragraph:

```````````````````````````````` example
Foo
<a href="bar">
baz
.
<p>Foo
<a href="bar">
baz</p>
````````````````````````````````


This rule differs from John Gruber's original Markdown syntax
specification, which says:

> The only restrictions are that block-level HTML elements —
> e.g. `<div>`, `<table>`, `<pre>`, `<p>`, etc. — must be separated from
> surrounding content by blank lines, and the start and end tags of the
> block should not be indented with tabs or spaces.

In some ways Gruber's rule is more restrictive than the one given
here:

- It requires that an HTML block be preceded by a blank line.
- It does not allow the start tag to be indented.
- It requires a matching end tag, which it also does not allow to
  be indented.

Most Markdown implementations (including some of Gruber's own) do not
respect all of these restrictions.

There is one respect, however, in which Gruber's rule is more liberal
than the one given here, since it allows blank lines to occur inside
an HTML block.  There are two reasons for disallowing them here.
First, it removes the need to parse balanced tags, which is
expensive and can require backtracking from the end of the document
if no matching end tag is found. Second, it provides a very simple
and flexible way of including Markdown content inside HTML tags:
simply separate the Markdown from the HTML using blank lines:

Compare:

```````````````````````````````` example
<div>

*Emphasized* text.

</div>
.
<div>
<p><em>Emphasized</em> text.</p>
</div>
````````````````````````````````


```````````````````````````````` example
<div>
*Emphasized* text.
</div>
.
<div>
*Emphasized* text.
</div>
````````````````````````````````


Some Markdown implementations have adopted a convention of
interpreting content inside tags as text if the open tag has
the attribute `markdown=1`.  The rule given above seems a simpler and
more elegant way of achieving the same expressive power, which is also
much simpler to parse.

The main potential drawback is that one can no longer paste HTML
blocks into Markdown documents with 100% reliability.  However,
*in most cases* this will work fine, because the blank lines in
HTML are usually followed by HTML block tags.  For example:

```````````````````````````````` example
<table>

<tr>

<td>
Hi
</td>

</tr>

</table>
.
<table>
<tr>
<td>
Hi
</td>
</tr>
</table>
````````````````````````````````


There are problems, however, if the inner tags are indented
*and* separated by spaces, as then they will be interpreted as
an indented code block:

```````````````````````````````` example
<table>

  <tr>

    <td>
      Hi
    </td>

  </tr>

</table>
.
<table>
  <tr>
<pre><code>&lt;td&gt;
  Hi
&lt;/td&gt;
</code></pre>
  </tr>
</table>
````````````````````````````````


Fortunately, blank lines are usually not necessary and can be
deleted.  The exception is inside `<pre>` tags, but as described
[above][HTML blocks], raw HTML blocks starting with `<pre>`
*can* contain blank lines.

## Link reference definitions

A [link reference definition](@)
consists of a [link label], indented up to three spaces, followed
by a colon (`:`), optional [whitespace] (including up to one
[line ending]), a [link destination],
optional [whitespace] (including up to one
[line ending]), and an optional [link
title], which if it is present must be separated
from the [link destination] by [whitespace].
No further [non-whitespace characters] may occur on the line.

A [link reference definition]
does not correspond to a structural element of a document.  Instead, it
defines a label which can be used in [reference links]
and reference-style [images] elsewhere in the document.  [Link
reference definitions] can come either before or after the links that use
them.

```````````````````````````````` example
[foo]: /url "title"

[foo]
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


```````````````````````````````` example
   [foo]: 
      /url  
           'the title'  

[foo]
.
<p><a href="/url" title="the title">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[Foo*bar\]]:my_(url) 'title (with parens)'

[Foo*bar\]]
.
<p><a href="my_(url)" title="title (with parens)">Foo*bar]</a></p>
````````````````````````````````


```````````````````````````````` example
[Foo bar]:
<my url>
'title'

[Foo bar]
.
<p><a href="my%20url" title="title">Foo bar</a></p>
````````````````````````````````


The title may extend over multiple lines:

```````````````````````````````` example
[foo]: /url '
title
line1
line2
'

[foo]
.
<p><a href="/url" title="
title
line1
line2
">foo</a></p>
````````````````````````````````


However, it may not contain a [blank line]:

```````````````````````````````` example
[foo]: /url 'title

with blank line'

[foo]
.
<p>[foo]: /url 'title</p>
<p>with blank line'</p>
<p>[foo]</p>
````````````````````````````````


The title may be omitted:

```````````````````````````````` example
[foo]:
/url

[foo]
.
<p><a href="/url">foo</a></p>
````````````````````````````````


The link destination may not be omitted:

```````````````````````````````` example
[foo]:

[foo]
.
<p>[foo]:</p>
<p>[foo]</p>
````````````````````````````````

 However, an empty link destination may be specified using
 angle brackets:

```````````````````````````````` example
[foo]: <>

[foo]
.
<p><a href="">foo</a></p>
````````````````````````````````

The title must be separated from the link destination by
whitespace:

```````````````````````````````` example
[foo]: <bar>(baz)

[foo]
.
<p>[foo]: <bar>(baz)</p>
<p>[foo]</p>
````````````````````````````````


Both title and destination can contain backslash escapes
and literal backslashes:

```````````````````````````````` example
[foo]: /url\bar\*baz "foo\"bar\baz"

[foo]
.
<p><a href="/url%5Cbar*baz" title="foo&quot;bar\baz">foo</a></p>
````````````````````````````````


A link can come before its corresponding definition:

```````````````````````````````` example
[foo]

[foo]: url
.
<p><a href="url">foo</a></p>
````````````````````````````````


If there are several matching definitions, the first one takes
precedence:

```````````````````````````````` example
[foo]

[foo]: first
[foo]: second
.
<p><a href="first">foo</a></p>
````````````````````````````````


As noted in the section on [Links], matching of labels is
case-insensitive (see [matches]).

```````````````````````````````` example
[FOO]: /url

[Foo]
.
<p><a href="/url">Foo</a></p>
````````````````````````````````


```````````````````````````````` example
[ΑΓΩ]: /φου

[αγω]
.
<p><a href="/%CF%86%CE%BF%CF%85">αγω</a></p>
````````````````````````````````


Here is a link reference definition with no corresponding link.
It contributes nothing to the document.

```````````````````````````````` example
[foo]: /url
.
````````````````````````````````


Here is another one:

```````````````````````````````` example
[
foo
]: /url
bar
.
<p>bar</p>
````````````````````````````````


This is not a link reference definition, because there are
[non-whitespace characters] after the title:

```````````````````````````````` example
[foo]: /url "title" ok
.
<p>[foo]: /url &quot;title&quot; ok</p>
````````````````````````````````


This is a link reference definition, but it has no title:

```````````````````````````````` example
[foo]: /url
"title" ok
.
<p>&quot;title&quot; ok</p>
````````````````````````````````


This is not a link reference definition, because it is indented
four spaces:

```````````````````````````````` example
    [foo]: /url "title"

[foo]
.
<pre><code>[foo]: /url &quot;title&quot;
</code></pre>
<p>[foo]</p>
````````````````````````````````


This is not a link reference definition, because it occurs inside
a code block:

```````````````````````````````` example
```
[foo]: /url
```

[foo]
.
<pre><code>[foo]: /url
</code></pre>
<p>[foo]</p>
````````````````````````````````


A [link reference definition] cannot interrupt a paragraph.

```````````````````````````````` example
Foo
[bar]: /baz

[bar]
.
<p>Foo
[bar]: /baz</p>
<p>[bar]</p>
````````````````````````````````


However, it can directly follow other block elements, such as headings
and thematic breaks, and it need not be followed by a blank line.

```````````````````````````````` example
# [Foo]
[foo]: /url
> bar
.
<h1><a href="/url">Foo</a></h1>
<blockquote>
<p>bar</p>
</blockquote>
````````````````````````````````

```````````````````````````````` example
[foo]: /url
bar
===
[foo]
.
<h1>bar</h1>
<p><a href="/url">foo</a></p>
````````````````````````````````

```````````````````````````````` example
[foo]: /url
===
[foo]
.
<p>===
<a href="/url">foo</a></p>
````````````````````````````````


Several [link reference definitions]
can occur one after another, without intervening blank lines.

```````````````````````````````` example
[foo]: /foo-url "foo"
[bar]: /bar-url
  "bar"
[baz]: /baz-url

[foo],
[bar],
[baz]
.
<p><a href="/foo-url" title="foo">foo</a>,
<a href="/bar-url" title="bar">bar</a>,
<a href="/baz-url">baz</a></p>
````````````````````````````````


[Link reference definitions] can occur
inside block containers, like lists and block quotations.  They
affect the entire document, not just the container in which they
are defined:

```````````````````````````````` example
[foo]

> [foo]: /url
.
<p><a href="/url">foo</a></p>
<blockquote>
</blockquote>
````````````````````````````````


Whether something is a [link reference definition] is
independent of whether the link reference it defines is
used in the document.  Thus, for example, the following
document contains just a link reference definition, and
no visible content:

```````````````````````````````` example
[foo]: /url
.
````````````````````````````````


## Paragraphs

A sequence of non-blank lines that cannot be interpreted as other
kinds of blocks forms a [paragraph](@).
The contents of the paragraph are the result of parsing the
paragraph's raw content as inlines.  The paragraph's raw content
is formed by concatenating the lines and removing initial and final
[whitespace].

A simple example with two paragraphs:

```````````````````````````````` example
aaa

bbb
.
<p>aaa</p>
<p>bbb</p>
````````````````````````````````


Paragraphs can contain multiple lines, but no blank lines:

```````````````````````````````` example
aaa
bbb

ccc
ddd
.
<p>aaa
bbb</p>
<p>ccc
ddd</p>
````````````````````````````````


Multiple blank lines between paragraph have no effect:

```````````````````````````````` example
aaa


bbb
.
<p>aaa</p>
<p>bbb</p>
````````````````````````````````


Leading spaces are skipped:

```````````````````````````````` example
  aaa
 bbb
.
<p>aaa
bbb</p>
````````````````````````````````


Lines after the first may be indented any amount, since indented
code blocks cannot interrupt paragraphs.

```````````````````````````````` example
aaa
             bbb
                                       ccc
.
<p>aaa
bbb
ccc</p>
````````````````````````````````


However, the first line may be indented at most three spaces,
or an indented code block will be triggered:

```````````````````````````````` example
   aaa
bbb
.
<p>aaa
bbb</p>
````````````````````````````````


```````````````````````````````` example
    aaa
bbb
.
<pre><code>aaa
</code></pre>
<p>bbb</p>
````````````````````````````````


Final spaces are stripped before inline parsing, so a paragraph
that ends with two or more spaces will not end with a [hard line
break]:

```````````````````````````````` example
aaa     
bbb     
.
<p>aaa<br />
bbb</p>
````````````````````````````````


## Blank lines

[Blank lines] between block-level elements are ignored,
except for the role they play in determining whether a [list]
is [tight] or [loose].

Blank lines at the beginning and end of the document are also ignored.

```````````````````````````````` example
  

aaa
  

# aaa

  
.
<p>aaa</p>
<h1>aaa</h1>
````````````````````````````````



# Container blocks

A [container block](#container-blocks) is a block that has other
blocks as its contents.  There are two basic kinds of container blocks:
[block quotes] and [list items].
[Lists] are meta-containers for [list items].

We define the syntax for container blocks recursively.  The general
form of the definition is:

> If X is a sequence of blocks, then the result of
> transforming X in such-and-such a way is a container of type Y
> with these blocks as its content.

So, we explain what counts as a block quote or list item by explaining
how these can be *generated* from their contents. This should suffice
to define the syntax, although it does not give a recipe for *parsing*
these constructions.  (A recipe is provided below in the section entitled
[A parsing strategy](#appendix-a-parsing-strategy).)

## Block quotes

A [block quote marker](@)
consists of 0-3 spaces of initial indent, plus (a) the character `>` together
with a following space, or (b) a single character `>` not followed by a space.

The following rules define [block quotes]:

1.  **Basic case.**  If a string of lines *Ls* constitute a sequence
    of blocks *Bs*, then the result of prepending a [block quote
    marker] to the beginning of each line in *Ls*
    is a [block quote](#block-quotes) containing *Bs*.

2.  **Laziness.**  If a string of lines *Ls* constitute a [block
    quote](#block-quotes) with contents *Bs*, then the result of deleting
    the initial [block quote marker] from one or
    more lines in which the next [non-whitespace character] after the [block
    quote marker] is [paragraph continuation
    text] is a block quote with *Bs* as its content.
    [Paragraph continuation text](@) is text
    that will be parsed as part of the content of a paragraph, but does
    not occur at the beginning of the paragraph.

3.  **Consecutiveness.**  A document cannot contain two [block
    quotes] in a row unless there is a [blank line] between them.

Nothing else counts as a [block quote](#block-quotes).

Here is a simple example:

```````````````````````````````` example
> # Foo
> bar
> baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


The spaces after the `>` characters can be omitted:

```````````````````````````````` example
># Foo
>bar
> baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


The `>` characters can be indented 1-3 spaces:

```````````````````````````````` example
   > # Foo
   > bar
 > baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


Four spaces gives us a code block:

```````````````````````````````` example
    > # Foo
    > bar
    > baz
.
<pre><code>&gt; # Foo
&gt; bar
&gt; baz
</code></pre>
````````````````````````````````


The Laziness clause allows us to omit the `>` before
[paragraph continuation text]:

```````````````````````````````` example
> # Foo
> bar
baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


A block quote can contain some lazy and some non-lazy
continuation lines:

```````````````````````````````` example
> bar
baz
> foo
.
<blockquote>
<p>bar
baz
foo</p>
</blockquote>
````````````````````````````````


Laziness only applies to lines that would have been continuations of
paragraphs had they been prepended with [block quote markers].
For example, the `> ` cannot be omitted in the second line of

``` markdown
> foo
> ---
```

without changing the meaning:

```````````````````````````````` example
> foo
---
.
<blockquote>
<p>foo</p>
</blockquote>
<hr />
````````````````````````````````


Similarly, if we omit the `> ` in the second line of

``` markdown
> - foo
> - bar
```

then the block quote ends after the first line:

```````````````````````````````` example
> - foo
- bar
.
<blockquote>
<ul>
<li>foo</li>
</ul>
</blockquote>
<ul>
<li>bar</li>
</ul>
````````````````````````````````


For the same reason, we can't omit the `> ` in front of
subsequent lines of an indented or fenced code block:

```````````````````````````````` example
>     foo
    bar
.
<blockquote>
<pre><code>foo
</code></pre>
</blockquote>
<pre><code>bar
</code></pre>
````````````````````````````````


```````````````````````````````` example
> ```
foo
```
.
<blockquote>
<pre><code></code></pre>
</blockquote>
<p>foo</p>
<pre><code></code></pre>
````````````````````````````````


Note that in the following case, we have a [lazy
continuation line]:

```````````````````````````````` example
> foo
    - bar
.
<blockquote>
<p>foo
- bar</p>
</blockquote>
````````````````````````````````


To see why, note that in

```markdown
> foo
>     - bar
```

the `- bar` is indented too far to start a list, and can't
be an indented code block because indented code blocks cannot
interrupt paragraphs, so it is [paragraph continuation text].

A block quote can be empty:

```````````````````````````````` example
>
.
<blockquote>
</blockquote>
````````````````````````````````


```````````````````````````````` example
>
>  
> 
.
<blockquote>
</blockquote>
````````````````````````````````


A block quote can have initial or final blank lines:

```````````````````````````````` example
>
> foo
>  
.
<blockquote>
<p>foo</p>
</blockquote>
````````````````````````````````


A blank line always separates block quotes:

```````````````````````````````` example
> foo

> bar
.
<blockquote>
<p>foo</p>
</blockquote>
<blockquote>
<p>bar</p>
</blockquote>
````````````````````````````````


(Most current Markdown implementations, including John Gruber's
original `Markdown.pl`, will parse this example as a single block quote
with two paragraphs.  But it seems better to allow the author to decide
whether two block quotes or one are wanted.)

Consecutiveness means that if we put these block quotes together,
we get a single block quote:

```````````````````````````````` example
> foo
> bar
.
<blockquote>
<p>foo
bar</p>
</blockquote>
````````````````````````````````


To get a block quote with two paragraphs, use:

```````````````````````````````` example
> foo
>
> bar
.
<blockquote>
<p>foo</p>
<p>bar</p>
</blockquote>
````````````````````````````````


Block quotes can interrupt paragraphs:

```````````````````````````````` example
foo
> bar
.
<p>foo</p>
<blockquote>
<p>bar</p>
</blockquote>
````````````````````````````````


In general, blank lines are not needed before or after block
quotes:

```````````````````````````````` example
> aaa
***
> bbb
.
<blockquote>
<p>aaa</p>
</blockquote>
<hr />
<blockquote>
<p>bbb</p>
</blockquote>
````````````````````````````````


However, because of laziness, a blank line is needed between
a block quote and a following paragraph:

```````````````````````````````` example
> bar
baz
.
<blockquote>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


```````````````````````````````` example
> bar

baz
.
<blockquote>
<p>bar</p>
</blockquote>
<p>baz</p>
````````````````````````````````


```````````````````````````````` example
> bar
>
baz
.
<blockquote>
<p>bar</p>
</blockquote>
<p>baz</p>
````````````````````````````````


It is a consequence of the Laziness rule that any number
of initial `>`s may be omitted on a continuation line of a
nested block quote:

```````````````````````````````` example
> > > foo
bar
.
<blockquote>
<blockquote>
<blockquote>
<p>foo
bar</p>
</blockquote>
</blockquote>
</blockquote>
````````````````````````````````


```````````````````````````````` example
>>> foo
> bar
>>baz
.
<blockquote>
<blockquote>
<blockquote>
<p>foo
bar
baz</p>
</blockquote>
</blockquote>
</blockquote>
````````````````````````````````


When including an indented code block in a block quote,
remember that the [block quote marker] includes
both the `>` and a following space.  So *five spaces* are needed after
the `>`:

```````````````````````````````` example
>     code

>    not code
.
<blockquote>
<pre><code>code
</code></pre>
</blockquote>
<blockquote>
<p>not code</p>
</blockquote>
````````````````````````````````



## List items

A [list marker](@) is a
[bullet list marker] or an [ordered list marker].

A [bullet list marker](@)
is a `-`, `+`, or `*` character.

An [ordered list marker](@)
is a sequence of 1--9 arabic digits (`0-9`), followed by either a
`.` character or a `)` character.  (The reason for the length
limit is that with 10 digits we start seeing integer overflows
in some browsers.)

The following rules define [list items]:

1.  **Basic case.**  If a sequence of lines *Ls* constitute a sequence of
    blocks *Bs* starting with a [non-whitespace character], and *M* is a
    list marker of width *W* followed by 1 ≤ *N* ≤ 4 spaces, then the result
    of prepending *M* and the following spaces to the first line of
    *Ls*, and indenting subsequent lines of *Ls* by *W + N* spaces, is a
    list item with *Bs* as its contents.  The type of the list item
    (bullet or ordered) is determined by the type of its list marker.
    If the list item is ordered, then it is also assigned a start
    number, based on the ordered list marker.

    Exceptions:

    1. When the first list item in a [list] interrupts
       a paragraph---that is, when it starts on a line that would
       otherwise count as [paragraph continuation text]---then (a)
       the lines *Ls* must not begin with a blank line, and (b) if
       the list item is ordered, the start number must be 1.
    2. If any line is a [thematic break][thematic breaks] then
       that line is not a list item.

For example, let *Ls* be the lines

```````````````````````````````` example
A paragraph
with two lines.

    indented code

> A block quote.
.
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
````````````````````````````````


And let *M* be the marker `1.`, and *N* = 2.  Then rule #1 says
that the following is an ordered list item with start number 1,
and the same contents as *Ls*:

```````````````````````````````` example
1.  A paragraph
    with two lines.

        indented code

    > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


The most important thing to notice is that the position of
the text after the list marker determines how much indentation
is needed in subsequent blocks in the list item.  If the list
marker takes up two spaces, and there are three spaces between
the list marker and the next [non-whitespace character], then blocks
must be indented five spaces in order to fall under the list
item.

Here are some examples showing how far content must be indented to be
put under the list item:

```````````````````````````````` example
- one

 two
.
<ul>
<li>one</li>
</ul>
<p>two</p>
````````````````````````````````


```````````````````````````````` example
- one

  two
.
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
 -    one

     two
.
<ul>
<li>one</li>
</ul>
<pre><code> two
</code></pre>
````````````````````````````````


```````````````````````````````` example
 -    one

      two
.
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
````````````````````````````````


It is tempting to think of this in terms of columns:  the continuation
blocks must be indented at least to the column of the first
[non-whitespace character] after the list marker. However, that is not quite right.
The spaces after the list marker determine how much relative indentation
is needed.  Which column this indentation reaches will depend on
how the list item is embedded in other constructions, as shown by
this example:

```````````````````````````````` example
   > > 1.  one
>>
>>     two
.
<blockquote>
<blockquote>
<ol>
<li>
<p>one</p>
<p>two</p>
</li>
</ol>
</blockquote>
</blockquote>
````````````````````````````````


Here `two` occurs in the same column as the list marker `1.`,
but is actually contained in the list item, because there is
sufficient indentation after the last containing blockquote marker.

The converse is also possible.  In the following example, the word `two`
occurs far to the right of the initial text of the list item, `one`, but
it is not considered part of the list item, because it is not indented
far enough past the blockquote marker:

```````````````````````````````` example
>>- one
>>
  >  > two
.
<blockquote>
<blockquote>
<ul>
<li>one</li>
</ul>
<p>two</p>
</blockquote>
</blockquote>
````````````````````````````````


Note that at least one space is needed between the list marker and
any following content, so these are not list items:

```````````````````````````````` example
-one

2.two
.
<p>-one</p>
<p>2.two</p>
````````````````````````````````


A list item may contain blocks that are separated by more than
one blank line.

```````````````````````````````` example
- foo


  bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
````````````````````````````````


A list item may contain any kind of block:

```````````````````````````````` example
1.  foo

    ```
    bar
    ```

    baz

    > bam
.
<ol>
<li>
<p>foo</p>
<pre><code>bar
</code></pre>
<p>baz</p>
<blockquote>
<p>bam</p>
</blockquote>
</li>
</ol>
````````````````````````````````


A list item that contains an indented code block will preserve
empty lines within the code block verbatim.

```````````````````````````````` example
- Foo

      bar


      baz
.
<ul>
<li>
<p>Foo</p>
<pre><code>bar


baz
</code></pre>
</li>
</ul>
````````````````````````````````

Note that ordered list start numbers must be nine digits or less:

```````````````````````````````` example
123456789. ok
.
<ol start="123456789">
<li>ok</li>
</ol>
````````````````````````````````


```````````````````````````````` example
1234567890. not ok
.
<p>1234567890. not ok</p>
````````````````````````````````


A start number may begin with 0s:

```````````````````````````````` example
0. ok
.
<ol start="0">
<li>ok</li>
</ol>
````````````````````````````````


```````````````````````````````` example
003. ok
.
<ol start="3">
<li>ok</li>
</ol>
````````````````````````````````


A start number may not be negative:

```````````````````````````````` example
-1. not ok
.
<p>-1. not ok</p>
````````````````````````````````



2.  **Item starting with indented code.**  If a sequence of lines *Ls*
    constitute a sequence of blocks *Bs* starting with an indented code
    block, and *M* is a list marker of width *W* followed by
    one space, then the result of prepending *M* and the following
    space to the first line of *Ls*, and indenting subsequent lines of
    *Ls* by *W + 1* spaces, is a list item with *Bs* as its contents.
    If a line is empty, then it need not be indented.  The type of the
    list item (bullet or ordered) is determined by the type of its list
    marker.  If the list item is ordered, then it is also assigned a
    start number, based on the ordered list marker.

An indented code block will have to be indented four spaces beyond
the edge of the region where text will be included in the list item.
In the following case that is 6 spaces:

```````````````````````````````` example
- foo

      bar
.
<ul>
<li>
<p>foo</p>
<pre><code>bar
</code></pre>
</li>
</ul>
````````````````````````````````


And in this case it is 11 spaces:

```````````````````````````````` example
  10.  foo

           bar
.
<ol start="10">
<li>
<p>foo</p>
<pre><code>bar
</code></pre>
</li>
</ol>
````````````````````````````````


If the *first* block in the list item is an indented code block,
then by rule #2, the contents must be indented *one* space after the
list marker:

```````````````````````````````` example
    indented code

paragraph

    more code
.
<pre><code>indented code
</code></pre>
<p>paragraph</p>
<pre><code>more code
</code></pre>
````````````````````````````````


```````````````````````````````` example
1.     indented code

   paragraph

       more code
.
<ol>
<li>
<pre><code>indented code
</code></pre>
<p>paragraph</p>
<pre><code>more code
</code></pre>
</li>
</ol>
````````````````````````````````


Note that an additional space indent is interpreted as space
inside the code block:

```````````````````````````````` example
1.      indented code

   paragraph

       more code
.
<ol>
<li>
<pre><code> indented code
</code></pre>
<p>paragraph</p>
<pre><code>more code
</code></pre>
</li>
</ol>
````````````````````````````````


Note that rules #1 and #2 only apply to two cases:  (a) cases
in which the lines to be included in a list item begin with a
[non-whitespace character], and (b) cases in which
they begin with an indented code
block.  In a case like the following, where the first block begins with
a three-space indent, the rules do not allow us to form a list item by
indenting the whole thing and prepending a list marker:

```````````````````````````````` example
   foo

bar
.
<p>foo</p>
<p>bar</p>
````````````````````````````````


```````````````````````````````` example
-    foo

  bar
.
<ul>
<li>foo</li>
</ul>
<p>bar</p>
````````````````````````````````


This is not a significant restriction, because when a block begins
with 1-3 spaces indent, the indentation can always be removed without
a change in interpretation, allowing rule #1 to be applied.  So, in
the above case:

```````````````````````````````` example
-  foo

   bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
````````````````````````````````


3.  **Item starting with a blank line.**  If a sequence of lines *Ls*
    starting with a single [blank line] constitute a (possibly empty)
    sequence of blocks *Bs*, not separated from each other by more than
    one blank line, and *M* is a list marker of width *W*,
    then the result of prepending *M* to the first line of *Ls*, and
    indenting subsequent lines of *Ls* by *W + 1* spaces, is a list
    item with *Bs* as its contents.
    If a line is empty, then it need not be indented.  The type of the
    list item (bullet or ordered) is determined by the type of its list
    marker.  If the list item is ordered, then it is also assigned a
    start number, based on the ordered list marker.

Here are some list items that start with a blank line but are not empty:

```````````````````````````````` example
-
  foo
-
  ```
  bar
  ```
-
      baz
.
<ul>
<li>foo</li>
<li>
<pre><code>bar
</code></pre>
</li>
<li>
<pre><code>baz
</code></pre>
</li>
</ul>
````````````````````````````````

When the list item starts with a blank line, the number of spaces
following the list marker doesn't change the required indentation:

```````````````````````````````` example
-   
  foo
.
<ul>
<li>foo</li>
</ul>
````````````````````````````````


A list item can begin with at most one blank line.
In the following example, `foo` is not part of the list
item:

```````````````````````````````` example
-

  foo
.
<ul>
<li></li>
</ul>
<p>foo</p>
````````````````````````````````


Here is an empty bullet list item:

```````````````````````````````` example
- foo
-
- bar
.
<ul>
<li>foo</li>
<li></li>
<li>bar</li>
</ul>
````````````````````````````````


It does not matter whether there are spaces following the [list marker]:

```````````````````````````````` example
- foo
-   
- bar
.
<ul>
<li>foo</li>
<li></li>
<li>bar</li>
</ul>
````````````````````````````````


Here is an empty ordered list item:

```````````````````````````````` example
1. foo
2.
3. bar
.
<ol>
<li>foo</li>
<li></li>
<li>bar</li>
</ol>
````````````````````````````````


A list may start or end with an empty list item:

```````````````````````````````` example
*
.
<ul>
<li></li>
</ul>
````````````````````````````````

However, an empty list item cannot interrupt a paragraph:

```````````````````````````````` example
foo
*

foo
1.
.
<p>foo
*</p>
<p>foo
1.</p>
````````````````````````````````


4.  **Indentation.**  If a sequence of lines *Ls* constitutes a list item
    according to rule #1, #2, or #3, then the result of indenting each line
    of *Ls* by 1-3 spaces (the same for each line) also constitutes a
    list item with the same contents and attributes.  If a line is
    empty, then it need not be indented.

Indented one space:

```````````````````````````````` example
 1.  A paragraph
     with two lines.

         indented code

     > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


Indented two spaces:

```````````````````````````````` example
  1.  A paragraph
      with two lines.

          indented code

      > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


Indented three spaces:

```````````````````````````````` example
   1.  A paragraph
       with two lines.

           indented code

       > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


Four spaces indent gives a code block:

```````````````````````````````` example
    1.  A paragraph
        with two lines.

            indented code

        > A block quote.
.
<pre><code>1.  A paragraph
    with two lines.

        indented code

    &gt; A block quote.
</code></pre>
````````````````````````````````



5.  **Laziness.**  If a string of lines *Ls* constitute a [list
    item](#list-items) with contents *Bs*, then the result of deleting
    some or all of the indentation from one or more lines in which the
    next [non-whitespace character] after the indentation is
    [paragraph continuation text] is a
    list item with the same contents and attributes.  The unindented
    lines are called
    [lazy continuation line](@)s.

Here is an example with [lazy continuation lines]:

```````````````````````````````` example
  1.  A paragraph
with two lines.

          indented code

      > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


Indentation can be partially deleted:

```````````````````````````````` example
  1.  A paragraph
    with two lines.
.
<ol>
<li>A paragraph
with two lines.</li>
</ol>
````````````````````````````````


These examples show how laziness can work in nested structures:

```````````````````````````````` example
> 1. > Blockquote
continued here.
.
<blockquote>
<ol>
<li>
<blockquote>
<p>Blockquote
continued here.</p>
</blockquote>
</li>
</ol>
</blockquote>
````````````````````````````````


```````````````````````````````` example
> 1. > Blockquote
> continued here.
.
<blockquote>
<ol>
<li>
<blockquote>
<p>Blockquote
continued here.</p>
</blockquote>
</li>
</ol>
</blockquote>
````````````````````````````````



6.  **That's all.** Nothing that is not counted as a list item by rules
    #1--5 counts as a [list item](#list-items).

The rules for sublists follow from the general rules
[above][List items].  A sublist must be indented the same number
of spaces a paragraph would need to be in order to be included
in the list item.

So, in this case we need two spaces indent:

```````````````````````````````` example
- foo
  - bar
    - baz
      - boo
.
<ul>
<li>foo
<ul>
<li>bar
<ul>
<li>baz
<ul>
<li>boo</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
````````````````````````````````


One is not enough:

```````````````````````````````` example
- foo
 - bar
  - baz
   - boo
.
<ul>
<li>foo</li>
<li>bar</li>
<li>baz</li>
<li>boo</li>
</ul>
````````````````````````````````


Here we need four, because the list marker is wider:

```````````````````````````````` example
10) foo
    - bar
.
<ol start="10">
<li>foo
<ul>
<li>bar</li>
</ul>
</li>
</ol>
````````````````````````````````


Three is not enough:

```````````````````````````````` example
10) foo
   - bar
.
<ol start="10">
<li>foo</li>
</ol>
<ul>
<li>bar</li>
</ul>
````````````````````````````````


A list may be the first block in a list item:

```````````````````````````````` example
- - foo
.
<ul>
<li>
<ul>
<li>foo</li>
</ul>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
1. - 2. foo
.
<ol>
<li>
<ul>
<li>
<ol start="2">
<li>foo</li>
</ol>
</li>
</ul>
</li>
</ol>
````````````````````````````````


A list item can contain a heading:

```````````````````````````````` example
- # Foo
- Bar
  ---
  baz
.
<ul>
<li>
<h1>Foo</h1>
</li>
<li>
<h2>Bar</h2>
baz</li>
</ul>
````````````````````````````````


### Motivation

John Gruber's Markdown spec says the following about list items:

1. "List markers typically start at the left margin, but may be indented
   by up to three spaces. List markers must be followed by one or more
   spaces or a tab."

2. "To make lists look nice, you can wrap items with hanging indents....
   But if you don't want to, you don't have to."

3. "List items may consist of multiple paragraphs. Each subsequent
   paragraph in a list item must be indented by either 4 spaces or one
   tab."

4. "It looks nice if you indent every line of the subsequent paragraphs,
   but here again, Markdown will allow you to be lazy."

5. "To put a blockquote within a list item, the blockquote's `>`
   delimiters need to be indented."

6. "To put a code block within a list item, the code block needs to be
   indented twice — 8 spaces or two tabs."

These rules specify that a paragraph under a list item must be indented
four spaces (presumably, from the left margin, rather than the start of
the list marker, but this is not said), and that code under a list item
must be indented eight spaces instead of the usual four.  They also say
that a block quote must be indented, but not by how much; however, the
example given has four spaces indentation.  Although nothing is said
about other kinds of block-level content, it is certainly reasonable to
infer that *all* block elements under a list item, including other
lists, must be indented four spaces.  This principle has been called the
*four-space rule*.

The four-space rule is clear and principled, and if the reference
implementation `Markdown.pl` had followed it, it probably would have
become the standard.  However, `Markdown.pl` allowed paragraphs and
sublists to start with only two spaces indentation, at least on the
outer level.  Worse, its behavior was inconsistent: a sublist of an
outer-level list needed two spaces indentation, but a sublist of this
sublist needed three spaces.  It is not surprising, then, that different
implementations of Markdown have developed very different rules for
determining what comes under a list item.  (Pandoc and python-Markdown,
for example, stuck with Gruber's syntax description and the four-space
rule, while discount, redcarpet, marked, PHP Markdown, and others
followed `Markdown.pl`'s behavior more closely.)

Unfortunately, given the divergences between implementations, there
is no way to give a spec for list items that will be guaranteed not
to break any existing documents.  However, the spec given here should
correctly handle lists formatted with either the four-space rule or
the more forgiving `Markdown.pl` behavior, provided they are laid out
in a way that is natural for a human to read.

The strategy here is to let the width and indentation of the list marker
determine the indentation necessary for blocks to fall under the list
item, rather than having a fixed and arbitrary number.  The writer can
think of the body of the list item as a unit which gets indented to the
right enough to fit the list marker (and any indentation on the list
marker).  (The laziness rule, #5, then allows continuation lines to be
unindented if needed.)

This rule is superior, we claim, to any rule requiring a fixed level of
indentation from the margin.  The four-space rule is clear but
unnatural. It is quite unintuitive that

``` markdown
- foo

  bar

  - baz
```

should be parsed as two lists with an intervening paragraph,

``` html
<ul>
<li>foo</li>
</ul>
<p>bar</p>
<ul>
<li>baz</li>
</ul>
```

as the four-space rule demands, rather than a single list,

``` html
<ul>
<li>
<p>foo</p>
<p>bar</p>
<ul>
<li>baz</li>
</ul>
</li>
</ul>
```

The choice of four spaces is arbitrary.  It can be learned, but it is
not likely to be guessed, and it trips up beginners regularly.

Would it help to adopt a two-space rule?  The problem is that such
a rule, together with the rule allowing 1--3 spaces indentation of the
initial list marker, allows text that is indented *less than* the
original list marker to be included in the list item. For example,
`Markdown.pl` parses

``` markdown
   - one

  two
```

as a single list item, with `two` a continuation paragraph:

``` html
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
```

and similarly

``` markdown
>   - one
>
>  two
```

as

``` html
<blockquote>
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
</blockquote>
```

This is extremely unintuitive.

Rather than requiring a fixed indent from the margin, we could require
a fixed indent (say, two spaces, or even one space) from the list marker (which
may itself be indented).  This proposal would remove the last anomaly
discussed.  Unlike the spec presented above, it would count the following
as a list item with a subparagraph, even though the paragraph `bar`
is not indented as far as the first paragraph `foo`:

``` markdown
 10. foo

   bar  
```

Arguably this text does read like a list item with `bar` as a subparagraph,
which may count in favor of the proposal.  However, on this proposal indented
code would have to be indented six spaces after the list marker.  And this
would break a lot of existing Markdown, which has the pattern:

``` markdown
1.  foo

        indented code
```

where the code is indented eight spaces.  The spec above, by contrast, will
parse this text as expected, since the code block's indentation is measured
from the beginning of `foo`.

The one case that needs special treatment is a list item that *starts*
with indented code.  How much indentation is required in that case, since
we don't have a "first paragraph" to measure from?  Rule #2 simply stipulates
that in such cases, we require one space indentation from the list marker
(and then the normal four spaces for the indented code).  This will match the
four-space rule in cases where the list marker plus its initial indentation
takes four spaces (a common case), but diverge in other cases.

## Lists

A [list](@) is a sequence of one or more
list items [of the same type].  The list items
may be separated by any number of blank lines.

Two list items are [of the same type](@)
if they begin with a [list marker] of the same type.
Two list markers are of the
same type if (a) they are bullet list markers using the same character
(`-`, `+`, or `*`) or (b) they are ordered list numbers with the same
delimiter (either `.` or `)`).

A list is an [ordered list](@)
if its constituent list items begin with
[ordered list markers], and a
[bullet list](@) if its constituent list
items begin with [bullet list markers].

The [start number](@)
of an [ordered list] is determined by the list number of
its initial list item.  The numbers of subsequent list items are
disregarded.

A list is [loose](@) if any of its constituent
list items are separated by blank lines, or if any of its constituent
list items directly contain two block-level elements with a blank line
between them.  Otherwise a list is [tight](@).
(The difference in HTML output is that paragraphs in a loose list are
wrapped in `<p>` tags, while paragraphs in a tight list are not.)

Changing the bullet or ordered list delimiter starts a new list:

```````````````````````````````` example
- foo
- bar
+ baz
.
<ul>
<li>foo</li>
<li>bar</li>
</ul>
<ul>
<li>baz</li>
</ul>
````````````````````````````````


```````````````````````````````` example
1. foo
2. bar
3) baz
.
<ol>
<li>foo</li>
<li>bar</li>
</ol>
<ol start="3">
<li>baz</li>
</ol>
````````````````````````````````


In CommonMark, a list can interrupt a paragraph. That is,
no blank line is needed to separate a paragraph from a following
list:

```````````````````````````````` example
Foo
- bar
- baz
.
<p>Foo</p>
<ul>
<li>bar</li>
<li>baz</li>
</ul>
````````````````````````````````

`Markdown.pl` does not allow this, through fear of triggering a list
via a numeral in a hard-wrapped line:

``` markdown
The number of windows in my house is
14.  The number of doors is 6.
```

Oddly, though, `Markdown.pl` *does* allow a blockquote to
interrupt a paragraph, even though the same considerations might
apply.

In CommonMark, we do allow lists to interrupt paragraphs, for
two reasons.  First, it is natural and not uncommon for people
to start lists without blank lines:

``` markdown
I need to buy
- new shoes
- a coat
- a plane ticket
```

Second, we are attracted to a

> [principle of uniformity](@):
> if a chunk of text has a certain
> meaning, it will continue to have the same meaning when put into a
> container block (such as a list item or blockquote).

(Indeed, the spec for [list items] and [block quotes] presupposes
this principle.) This principle implies that if

``` markdown
  * I need to buy
    - new shoes
    - a coat
    - a plane ticket
```

is a list item containing a paragraph followed by a nested sublist,
as all Markdown implementations agree it is (though the paragraph
may be rendered without `<p>` tags, since the list is "tight"),
then

``` markdown
I need to buy
- new shoes
- a coat
- a plane ticket
```

by itself should be a paragraph followed by a nested sublist.

Since it is well established Markdown practice to allow lists to
interrupt paragraphs inside list items, the [principle of
uniformity] requires us to allow this outside list items as
well.  ([reStructuredText](http://docutils.sourceforge.net/rst.html)
takes a different approach, requiring blank lines before lists
even inside other list items.)

In order to solve of unwanted lists in paragraphs with
hard-wrapped numerals, we allow only lists starting with `1` to
interrupt paragraphs.  Thus,

```````````````````````````````` example
The number of windows in my house is
14.  The number of doors is 6.
.
<p>The number of windows in my house is
14.  The number of doors is 6.</p>
````````````````````````````````

We may still get an unintended result in cases like

```````````````````````````````` example
The number of windows in my house is
1.  The number of doors is 6.
.
<p>The number of windows in my house is</p>
<ol>
<li>The number of doors is 6.</li>
</ol>
````````````````````````````````

but this rule should prevent most spurious list captures.

There can be any number of blank lines between items:

```````````````````````````````` example
- foo

- bar


- baz
.
<ul>
<li>
<p>foo</p>
</li>
<li>
<p>bar</p>
</li>
<li>
<p>baz</p>
</li>
</ul>
````````````````````````````````

```````````````````````````````` example
- foo
  - bar
    - baz


      bim
.
<ul>
<li>foo
<ul>
<li>bar
<ul>
<li>
<p>baz</p>
<p>bim</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
````````````````````````````````


To separate consecutive lists of the same type, or to separate a
list from an indented code block that would otherwise be parsed
as a subparagraph of the final list item, you can insert a blank HTML
comment:

```````````````````````````````` example
- foo
- bar

<!-- -->

- baz
- bim
.
<ul>
<li>foo</li>
<li>bar</li>
</ul>
<!-- -->
<ul>
<li>baz</li>
<li>bim</li>
</ul>
````````````````````````````````


```````````````````````````````` example
-   foo

    notcode

-   foo

<!-- -->

    code
.
<ul>
<li>
<p>foo</p>
<p>notcode</p>
</li>
<li>
<p>foo</p>
</li>
</ul>
<!-- -->
<pre><code>code
</code></pre>
````````````````````````````````


List items need not be indented to the same level.  The following
list items will be treated as items at the same list level,
since none is indented enough to belong to the previous list
item:

```````````````````````````````` example
- a
 - b
  - c
   - d
  - e
 - f
- g
.
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
<li>d</li>
<li>e</li>
<li>f</li>
<li>g</li>
</ul>
````````````````````````````````


```````````````````````````````` example
1. a

  2. b

   3. c
.
<ol>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
<li>
<p>c</p>
</li>
</ol>
````````````````````````````````

Note, however, that list items may not be indented more than
three spaces.  Here `- e` is treated as a paragraph continuation
line, because it is indented more than three spaces:

```````````````````````````````` example
- a
 - b
  - c
   - d
    - e
.
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
<li>d
- e</li>
</ul>
````````````````````````````````

And here, `3. c` is treated as in indented code block,
because it is indented four spaces and preceded by a
blank line.

```````````````````````````````` example
1. a

  2. b

    3. c
.
<ol>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
</ol>
<pre><code>3. c
</code></pre>
````````````````````````````````


This is a loose list, because there is a blank line between
two of the list items:

```````````````````````````````` example
- a
- b

- c
.
<ul>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
<li>
<p>c</p>
</li>
</ul>
````````````````````````````````


So is this, with a empty second item:

```````````````````````````````` example
* a
*

* c
.
<ul>
<li>
<p>a</p>
</li>
<li></li>
<li>
<p>c</p>
</li>
</ul>
````````````````````````````````


These are loose lists, even though there is no space between the items,
because one of the items directly contains two block-level elements
with a blank line between them:

```````````````````````````````` example
- a
- b

  c
- d
.
<ul>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
<p>c</p>
</li>
<li>
<p>d</p>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
- a
- b

  [ref]: /url
- d
.
<ul>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
<li>
<p>d</p>
</li>
</ul>
````````````````````````````````


This is a tight list, because the blank lines are in a code block:

```````````````````````````````` example
- a
- ```
  b


  ```
- c
.
<ul>
<li>a</li>
<li>
<pre><code>b


</code></pre>
</li>
<li>c</li>
</ul>
````````````````````````````````


This is a tight list, because the blank line is between two
paragraphs of a sublist.  So the sublist is loose while
the outer list is tight:

```````````````````````````````` example
- a
  - b

    c
- d
.
<ul>
<li>a
<ul>
<li>
<p>b</p>
<p>c</p>
</li>
</ul>
</li>
<li>d</li>
</ul>
````````````````````````````````


This is a tight list, because the blank line is inside the
block quote:

```````````````````````````````` example
* a
  > b
  >
* c
.
<ul>
<li>a
<blockquote>
<p>b</p>
</blockquote>
</li>
<li>c</li>
</ul>
````````````````````````````````


This list is tight, because the consecutive block elements
are not separated by blank lines:

```````````````````````````````` example
- a
  > b
  ```
  c
  ```
- d
.
<ul>
<li>a
<blockquote>
<p>b</p>
</blockquote>
<pre><code>c
</code></pre>
</li>
<li>d</li>
</ul>
````````````````````````````````


A single-paragraph list is tight:

```````````````````````````````` example
- a
.
<ul>
<li>a</li>
</ul>
````````````````````````````````


```````````````````````````````` example
- a
  - b
.
<ul>
<li>a
<ul>
<li>b</li>
</ul>
</li>
</ul>
````````````````````````````````


This list is loose, because of the blank line between the
two block elements in the list item:

```````````````````````````````` example
1. ```
   foo
   ```

   bar
.
<ol>
<li>
<pre><code>foo
</code></pre>
<p>bar</p>
</li>
</ol>
````````````````````````````````


Here the outer list is loose, the inner list tight:

```````````````````````````````` example
* foo
  * bar

  baz
.
<ul>
<li>
<p>foo</p>
<ul>
<li>bar</li>
</ul>
<p>baz</p>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
- a
  - b
  - c

- d
  - e
  - f
.
<ul>
<li>
<p>a</p>
<ul>
<li>b</li>
<li>c</li>
</ul>
</li>
<li>
<p>d</p>
<ul>
<li>e</li>
<li>f</li>
</ul>
</li>
</ul>
````````````````````````````````


# Inlines

Inlines are parsed sequentially from the beginning of the character
stream to the end (left to right, in left-to-right languages).
Thus, for example, in

```````````````````````````````` example
`hi`lo`
.
<p><code>hi</code>lo`</p>
````````````````````````````````

`hi` is parsed as code, leaving the backtick at the end as a literal
backtick.


## Backslash escapes

Any ASCII punctuation character may be backslash-escaped:

```````````````````````````````` example
\!\"\#\$\%\&\'\(\)\*\+\,\-\.\/\:\;\<\=\>\?\@\[\\\]\^\_\`\{\|\}\~
.
<p>!&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~</p>
````````````````````````````````


Backslashes before other characters are treated as literal
backslashes:

```````````````````````````````` example
\→\A\a\ \3\φ\«
.
<p>\→\A\a\ \3\φ\«</p>
````````````````````````````````


Escaped characters are treated as regular characters and do
not have their usual Markdown meanings:

```````````````````````````````` example
\*not emphasized*
\<br/> not a tag
\[not a link](/foo)
\`not code`
1\. not a list
\* not a list
\# not a heading
\[foo]: /url "not a reference"
\&ouml; not a character entity
.
<p>*not emphasized*
&lt;br/&gt; not a tag
[not a link](/foo)
`not code`
1. not a list
* not a list
# not a heading
[foo]: /url &quot;not a reference&quot;
&amp;ouml; not a character entity</p>
````````````````````````````````


If a backslash is itself escaped, the following character is not:

```````````````````````````````` example
\\*emphasis*
.
<p>\<em>emphasis</em></p>
````````````````````````````````


A backslash at the end of the line is a [hard line break]:

```````````````````````````````` example
foo\
bar
.
<p>foo<br />
bar</p>
````````````````````````````````


Backslash escapes do not work in code blocks, code spans, autolinks, or
raw HTML:

```````````````````````````````` example
`` \[\` ``
.
<p><code>\[\`</code></p>
````````````````````````````````


```````````````````````````````` example
    \[\]
.
<pre><code>\[\]
</code></pre>
````````````````````````````````


```````````````````````````````` example
~~~
\[\]
~~~
.
<pre><code>\[\]
</code></pre>
````````````````````````````````


```````````````````````````````` example
<http://example.com?find=\*>
.
<p><a href="http://example.com?find=%5C*">http://example.com?find=\*</a></p>
````````````````````````````````


```````````````````````````````` example
<a href="/bar\/)">
.
<a href="/bar\/)">
````````````````````````````````


But they work in all other contexts, including URLs and link titles,
link references, and [info strings] in [fenced code blocks]:

```````````````````````````````` example
[foo](/bar\* "ti\*tle")
.
<p><a href="/bar*" title="ti*tle">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[foo]

[foo]: /bar\* "ti\*tle"
.
<p><a href="/bar*" title="ti*tle">foo</a></p>
````````````````````````````````


```````````````````````````````` example
``` foo\+bar
foo
```
.
<pre><code class="language-foo+bar">foo
</code></pre>
````````````````````````````````



## Entity and numeric character references

Valid HTML entity references and numeric character references
can be used in place of the corresponding Unicode character,
with the following exceptions:

- Entity and character references are not recognized in code
  blocks and code spans.

- Entity and character references cannot stand in place of
  special characters that define structural elements in
  CommonMark.  For example, although `&#42;` can be used
  in place of a literal `*` character, `&#42;` cannot replace
  `*` in emphasis delimiters, bullet list markers, or thematic
  breaks.

Conforming CommonMark parsers need not store information about
whether a particular character was represented in the source
using a Unicode character or an entity reference.

[Entity references](@) consist of `&` + any of the valid
HTML5 entity names + `;`. The
document <https://html.spec.whatwg.org/multipage/entities.json>
is used as an authoritative source for the valid entity
references and their corresponding code points.

```````````````````````````````` example
&nbsp; &amp; &copy; &AElig; &Dcaron;
&frac34; &HilbertSpace; &DifferentialD;
&ClockwiseContourIntegral; &ngE;
.
<p>  &amp; © Æ Ď
¾ ℋ ⅆ
∲ ≧̸</p>
````````````````````````````````


[Decimal numeric character
references](@)
consist of `&#` + a string of 1--7 arabic digits + `;`. A
numeric character reference is parsed as the corresponding
Unicode character. Invalid Unicode code points will be replaced by
the REPLACEMENT CHARACTER (`U+FFFD`).  For security reasons,
the code point `U+0000` will also be replaced by `U+FFFD`.

```````````````````````````````` example
&#35; &#1234; &#992; &#0;
.
<p># Ӓ Ϡ �</p>
````````````````````````````````


[Hexadecimal numeric character
references](@) consist of `&#` +
either `X` or `x` + a string of 1-6 hexadecimal digits + `;`.
They too are parsed as the corresponding Unicode character (this
time specified with a hexadecimal numeral instead of decimal).

```````````````````````````````` example
&#X22; &#XD06; &#xcab;
.
<p>&quot; ആ ಫ</p>
````````````````````````````````


Here are some nonentities:

```````````````````````````````` example
&nbsp &x; &#; &#x;
&#87654321;
&#abcdef0;
&ThisIsNotDefined; &hi?;
.
<p>&amp;nbsp &amp;x; &amp;#; &amp;#x;
&amp;#87654321;
&amp;#abcdef0;
&amp;ThisIsNotDefined; &amp;hi?;</p>
````````````````````````````````


Although HTML5 does accept some entity references
without a trailing semicolon (such as `&copy`), these are not
recognized here, because it makes the grammar too ambiguous:

```````````````````````````````` example
&copy
.
<p>&amp;copy</p>
````````````````````````````````


Strings that are not on the list of HTML5 named entities are not
recognized as entity references either:

```````````````````````````````` example
&MadeUpEntity;
.
<p>&amp;MadeUpEntity;</p>
````````````````````````````````


Entity and numeric character references are recognized in any
context besides code spans or code blocks, including
URLs, [link titles], and [fenced code block][] [info strings]:

```````````````````````````````` example
<a href="&ouml;&ouml;.html">
.
<a href="&ouml;&ouml;.html">
````````````````````````````````


```````````````````````````````` example
[foo](/f&ouml;&ouml; "f&ouml;&ouml;")
.
<p><a href="/f%C3%B6%C3%B6" title="föö">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[foo]

[foo]: /f&ouml;&ouml; "f&ouml;&ouml;"
.
<p><a href="/f%C3%B6%C3%B6" title="föö">foo</a></p>
````````````````````````````````


```````````````````````````````` example
``` f&ouml;&ouml;
foo
```
.
<pre><code class="language-föö">foo
</code></pre>
````````````````````````````````


Entity and numeric character references are treated as literal
text in code spans and code blocks:

```````````````````````````````` example
`f&ouml;&ouml;`
.
<p><code>f&amp;ouml;&amp;ouml;</code></p>
````````````````````````````````


```````````````````````````````` example
    f&ouml;f&ouml;
.
<pre><code>f&amp;ouml;f&amp;ouml;
</code></pre>
````````````````````````````````


Entity and numeric character references cannot be used
in place of symbols indicating structure in CommonMark
documents.

```````````````````````````````` example
&#42;foo&#42;
*foo*
.
<p>*foo*
<em>foo</em></p>
````````````````````````````````

```````````````````````````````` example
&#42; foo

* foo
.
<p>* foo</p>
<ul>
<li>foo</li>
</ul>
````````````````````````````````

```````````````````````````````` example
foo&#10;&#10;bar
.
<p>foo

bar</p>
````````````````````````````````

```````````````````````````````` example
&#9;foo
.
<p>→foo</p>
````````````````````````````````


```````````````````````````````` example
[a](url &quot;tit&quot;)
.
<p>[a](url &quot;tit&quot;)</p>
````````````````````````````````


## Code spans

A [backtick string](@)
is a string of one or more backtick characters (`` ` ``) that is neither
preceded nor followed by a backtick.

A [code span](@) begins with a backtick string and ends with
a backtick string of equal length.  The contents of the code span are
the characters between the two backtick strings, normalized in the
following ways:

- First, [line endings] are converted to [spaces].
- If the resulting string both begins *and* ends with a [space]
  character, but does not consist entirely of [space]
  characters, a single [space] character is removed from the
  front and back.  This allows you to include code that begins
  or ends with backtick characters, which must be separated by
  whitespace from the opening or closing backtick strings.

This is a simple code span:

```````````````````````````````` example
`foo`
.
<p><code>foo</code></p>
````````````````````````````````


Here two backticks are used, because the code contains a backtick.
This example also illustrates stripping of a single leading and
trailing space:

```````````````````````````````` example
`` foo ` bar ``
.
<p><code>foo ` bar</code></p>
````````````````````````````````


This example shows the motivation for stripping leading and trailing
spaces:

```````````````````````````````` example
` `` `
.
<p><code>``</code></p>
````````````````````````````````

Note that only *one* space is stripped:

```````````````````````````````` example
`  ``  `
.
<p><code> `` </code></p>
````````````````````````````````

The stripping only happens if the space is on both
sides of the string:

```````````````````````````````` example
` a`
.
<p><code> a</code></p>
````````````````````````````````

Only [spaces], and not [unicode whitespace] in general, are
stripped in this way:

```````````````````````````````` example
` b `
.
<p><code> b </code></p>
````````````````````````````````

No stripping occurs if the code span contains only spaces:

```````````````````````````````` example
` `
`  `
.
<p><code> </code>
<code>  </code></p>
````````````````````````````````


[Line endings] are treated like spaces:

```````````````````````````````` example
``
foo
bar  
baz
``
.
<p><code>foo bar   baz</code></p>
````````````````````````````````

```````````````````````````````` example
``
foo 
``
.
<p><code>foo </code></p>
````````````````````````````````


Interior spaces are not collapsed:

```````````````````````````````` example
`foo   bar 
baz`
.
<p><code>foo   bar  baz</code></p>
````````````````````````````````

Note that browsers will typically collapse consecutive spaces
when rendering `<code>` elements, so it is recommended that
the following CSS be used:

    code{white-space: pre-wrap;}


Note that backslash escapes do not work in code spans. All backslashes
are treated literally:

```````````````````````````````` example
`foo\`bar`
.
<p><code>foo\</code>bar`</p>
````````````````````````````````


Backslash escapes are never needed, because one can always choose a
string of *n* backtick characters as delimiters, where the code does
not contain any strings of exactly *n* backtick characters.

```````````````````````````````` example
``foo`bar``
.
<p><code>foo`bar</code></p>
````````````````````````````````

```````````````````````````````` example
` foo `` bar `
.
<p><code>foo `` bar</code></p>
````````````````````````````````


Code span backticks have higher precedence than any other inline
constructs except HTML tags and autolinks.  Thus, for example, this is
not parsed as emphasized text, since the second `*` is part of a code
span:

```````````````````````````````` example
*foo`*`
.
<p>*foo<code>*</code></p>
````````````````````````````````


And this is not parsed as a link:

```````````````````````````````` example
[not a `link](/foo`)
.
<p>[not a <code>link](/foo</code>)</p>
````````````````````````````````


Code spans, HTML tags, and autolinks have the same precedence.
Thus, this is code:

```````````````````````````````` example
`<a href="`">`
.
<p><code>&lt;a href=&quot;</code>&quot;&gt;`</p>
````````````````````````````````


But this is an HTML tag:

```````````````````````````````` example
<a href="`">`
.
<p><a href="`">`</p>
````````````````````````````````


And this is code:

```````````````````````````````` example
`<http://foo.bar.`baz>`
.
<p><code>&lt;http://foo.bar.</code>baz&gt;`</p>
````````````````````````````````


But this is an autolink:

```````````````````````````````` example
<http://foo.bar.`baz>`
.
<p><a href="http://foo.bar.%60baz">http://foo.bar.`baz</a>`</p>
````````````````````````````````


When a backtick string is not closed by a matching backtick string,
we just have literal backticks:

```````````````````````````````` example
```foo``
.
<p>```foo``</p>
````````````````````````````````


```````````````````````````````` example
`foo
.
<p>`foo</p>
````````````````````````````````

The following case also illustrates the need for opening and
closing backtick strings to be equal in length:

```````````````````````````````` example
`foo``bar``
.
<p>`foo<code>bar</code></p>
````````````````````````````````


## Emphasis and strong emphasis

John Gruber's original [Markdown syntax
description](http://daringfireball.net/projects/markdown/syntax#em) says:

> Markdown treats asterisks (`*`) and underscores (`_`) as indicators of
> emphasis. Text wrapped with one `*` or `_` will be wrapped with an HTML
> `<em>` tag; double `*`'s or `_`'s will be wrapped with an HTML `<strong>`
> tag.

This is enough for most users, but these rules leave much undecided,
especially when it comes to nested emphasis.  The original
`Markdown.pl` test suite makes it clear that triple `***` and
`___` delimiters can be used for strong emphasis, and most
implementations have also allowed the following patterns:

``` markdown
***strong emph***
***strong** in emph*
***emph* in strong**
**in strong *emph***
*in emph **strong***
```

The following patterns are less widely supported, but the intent
is clear and they are useful (especially in contexts like bibliography
entries):

``` markdown
*emph *with emph* in it*
**strong **with strong** in it**
```

Many implementations have also restricted intraword emphasis to
the `*` forms, to avoid unwanted emphasis in words containing
internal underscores.  (It is best practice to put these in code
spans, but users often do not.)

``` markdown
internal emphasis: foo*bar*baz
no emphasis: foo_bar_baz
```

The rules given below capture all of these patterns, while allowing
for efficient parsing strategies that do not backtrack.

First, some definitions.  A [delimiter run](@) is either
a sequence of one or more `*` characters that is not preceded or
followed by a non-backslash-escaped `*` character, or a sequence
of one or more `_` characters that is not preceded or followed by
a non-backslash-escaped `_` character.

A [left-flanking delimiter run](@) is
a [delimiter run] that is (1) not followed by [Unicode whitespace],
and either (2a) not followed by a [punctuation character], or
(2b) followed by a [punctuation character] and
preceded by [Unicode whitespace] or a [punctuation character].
For purposes of this definition, the beginning and the end of
the line count as Unicode whitespace.

A [right-flanking delimiter run](@) is
a [delimiter run] that is (1) not preceded by [Unicode whitespace],
and either (2a) not preceded by a [punctuation character], or
(2b) preceded by a [punctuation character] and
followed by [Unicode whitespace] or a [punctuation character].
For purposes of this definition, the beginning and the end of
the line count as Unicode whitespace.

Here are some examples of delimiter runs.

  - left-flanking but not right-flanking:

    ```
    ***abc
      _abc
    **"abc"
     _"abc"
    ```

  - right-flanking but not left-flanking:

    ```
     abc***
     abc_
    "abc"**
    "abc"_
    ```

  - Both left and right-flanking:

    ```
     abc***def
    "abc"_"def"
    ```

  - Neither left nor right-flanking:

    ```
    abc *** def
    a _ b
    ```

(The idea of distinguishing left-flanking and right-flanking
delimiter runs based on the character before and the character
after comes from Roopesh Chander's
[vfmd](http://www.vfmd.org/vfmd-spec/specification/#procedure-for-identifying-emphasis-tags).
vfmd uses the terminology "emphasis indicator string" instead of "delimiter
run," and its rules for distinguishing left- and right-flanking runs
are a bit more complex than the ones given here.)

The following rules define emphasis and strong emphasis:

1.  A single `*` character [can open emphasis](@)
    iff (if and only if) it is part of a [left-flanking delimiter run].

2.  A single `_` character [can open emphasis] iff
    it is part of a [left-flanking delimiter run]
    and either (a) not part of a [right-flanking delimiter run]
    or (b) part of a [right-flanking delimiter run]
    preceded by punctuation.

3.  A single `*` character [can close emphasis](@)
    iff it is part of a [right-flanking delimiter run].

4.  A single `_` character [can close emphasis] iff
    it is part of a [right-flanking delimiter run]
    and either (a) not part of a [left-flanking delimiter run]
    or (b) part of a [left-flanking delimiter run]
    followed by punctuation.

5.  A double `**` [can open strong emphasis](@)
    iff it is part of a [left-flanking delimiter run].

6.  A double `__` [can open strong emphasis] iff
    it is part of a [left-flanking delimiter run]
    and either (a) not part of a [right-flanking delimiter run]
    or (b) part of a [right-flanking delimiter run]
    preceded by punctuation.

7.  A double `**` [can close strong emphasis](@)
    iff it is part of a [right-flanking delimiter run].

8.  A double `__` [can close strong emphasis] iff
    it is part of a [right-flanking delimiter run]
    and either (a) not part of a [left-flanking delimiter run]
    or (b) part of a [left-flanking delimiter run]
    followed by punctuation.

9.  Emphasis begins with a delimiter that [can open emphasis] and ends
    with a delimiter that [can close emphasis], and that uses the same
    character (`_` or `*`) as the opening delimiter.  The
    opening and closing delimiters must belong to separate
    [delimiter runs].  If one of the delimiters can both
    open and close emphasis, then the sum of the lengths of the
    delimiter runs containing the opening and closing delimiters
    must not be a multiple of 3 unless both lengths are
    multiples of 3.

10. Strong emphasis begins with a delimiter that
    [can open strong emphasis] and ends with a delimiter that
    [can close strong emphasis], and that uses the same character
    (`_` or `*`) as the opening delimiter.  The
    opening and closing delimiters must belong to separate
    [delimiter runs].  If one of the delimiters can both open
    and close strong emphasis, then the sum of the lengths of
    the delimiter runs containing the opening and closing
    delimiters must not be a multiple of 3 unless both lengths
    are multiples of 3.

11. A literal `*` character cannot occur at the beginning or end of
    `*`-delimited emphasis or `**`-delimited strong emphasis, unless it
    is backslash-escaped.

12. A literal `_` character cannot occur at the beginning or end of
    `_`-delimited emphasis or `__`-delimited strong emphasis, unless it
    is backslash-escaped.

Where rules 1--12 above are compatible with multiple parsings,
the following principles resolve ambiguity:

13. The number of nestings should be minimized. Thus, for example,
    an interpretation `<strong>...</strong>` is always preferred to
    `<em><em>...</em></em>`.

14. An interpretation `<em><strong>...</strong></em>` is always
    preferred to `<strong><em>...</em></strong>`.

15. When two potential emphasis or strong emphasis spans overlap,
    so that the second begins before the first ends and ends after
    the first ends, the first takes precedence. Thus, for example,
    `*foo _bar* baz_` is parsed as `<em>foo _bar</em> baz_` rather
    than `*foo <em>bar* baz</em>`.

16. When there are two potential emphasis or strong emphasis spans
    with the same closing delimiter, the shorter one (the one that
    opens later) takes precedence. Thus, for example,
    `**foo **bar baz**` is parsed as `**foo <strong>bar baz</strong>`
    rather than `<strong>foo **bar baz</strong>`.

17. Inline code spans, links, images, and HTML tags group more tightly
    than emphasis.  So, when there is a choice between an interpretation
    that contains one of these elements and one that does not, the
    former always wins.  Thus, for example, `*[foo*](bar)` is
    parsed as `*<a href="bar">foo*</a>` rather than as
    `<em>[foo</em>](bar)`.

These rules can be illustrated through a series of examples.

Rule 1:

```````````````````````````````` example
*foo bar*
.
<p><em>foo bar</em></p>
````````````````````````````````


This is not emphasis, because the opening `*` is followed by
whitespace, and hence not part of a [left-flanking delimiter run]:

```````````````````````````````` example
a * foo bar*
.
<p>a * foo bar*</p>
````````````````````````````````


This is not emphasis, because the opening `*` is preceded
by an alphanumeric and followed by punctuation, and hence
not part of a [left-flanking delimiter run]:

```````````````````````````````` example
a*"foo"*
.
<p>a*&quot;foo&quot;*</p>
````````````````````````````````


Unicode nonbreaking spaces count as whitespace, too:

```````````````````````````````` example
* a *
.
<p>* a *</p>
````````````````````````````````


Intraword emphasis with `*` is permitted:

```````````````````````````````` example
foo*bar*
.
<p>foo<em>bar</em></p>
````````````````````````````````


```````````````````````````````` example
5*6*78
.
<p>5<em>6</em>78</p>
````````````````````````````````


Rule 2:

```````````````````````````````` example
_foo bar_
.
<p><em>foo bar</em></p>
````````````````````````````````


This is not emphasis, because the opening `_` is followed by
whitespace:

```````````````````````````````` example
_ foo bar_
.
<p>_ foo bar_</p>
````````````````````````````````


This is not emphasis, because the opening `_` is preceded
by an alphanumeric and followed by punctuation:

```````````````````````````````` example
a_"foo"_
.
<p>a_&quot;foo&quot;_</p>
````````````````````````````````


Emphasis with `_` is not allowed inside words:

```````````````````````````````` example
foo_bar_
.
<p>foo_bar_</p>
````````````````````````````````


```````````````````````````````` example
5_6_78
.
<p>5_6_78</p>
````````````````````````````````


```````````````````````````````` example
пристаням_стремятся_
.
<p>пристаням_стремятся_</p>
````````````````````````````````


Here `_` does not generate emphasis, because the first delimiter run
is right-flanking and the second left-flanking:

```````````````````````````````` example
aa_"bb"_cc
.
<p>aa_&quot;bb&quot;_cc</p>
````````````````````````````````


This is emphasis, even though the opening delimiter is
both left- and right-flanking, because it is preceded by
punctuation:

```````````````````````````````` example
foo-_(bar)_
.
<p>foo-<em>(bar)</em></p>
````````````````````````````````


Rule 3:

This is not emphasis, because the closing delimiter does
not match the opening delimiter:

```````````````````````````````` example
_foo*
.
<p>_foo*</p>
````````````````````````````````


This is not emphasis, because the closing `*` is preceded by
whitespace:

```````````````````````````````` example
*foo bar *
.
<p>*foo bar *</p>
````````````````````````````````


A newline also counts as whitespace:

```````````````````````````````` example
*foo bar
*
.
<p>*foo bar
*</p>
````````````````````````````````


This is not emphasis, because the second `*` is
preceded by punctuation and followed by an alphanumeric
(hence it is not part of a [right-flanking delimiter run]:

```````````````````````````````` example
*(*foo)
.
<p>*(*foo)</p>
````````````````````````````````


The point of this restriction is more easily appreciated
with this example:

```````````````````````````````` example
*(*foo*)*
.
<p><em>(<em>foo</em>)</em></p>
````````````````````````````````


Intraword emphasis with `*` is allowed:

```````````````````````````````` example
*foo*bar
.
<p><em>foo</em>bar</p>
````````````````````````````````



Rule 4:

This is not emphasis, because the closing `_` is preceded by
whitespace:

```````````````````````````````` example
_foo bar _
.
<p>_foo bar _</p>
````````````````````````````````


This is not emphasis, because the second `_` is
preceded by punctuation and followed by an alphanumeric:

```````````````````````````````` example
_(_foo)
.
<p>_(_foo)</p>
````````````````````````````````


This is emphasis within emphasis:

```````````````````````````````` example
_(_foo_)_
.
<p><em>(<em>foo</em>)</em></p>
````````````````````````````````


Intraword emphasis is disallowed for `_`:

```````````````````````````````` example
_foo_bar
.
<p>_foo_bar</p>
````````````````````````````````


```````````````````````````````` example
_пристаням_стремятся
.
<p>_пристаням_стремятся</p>
````````````````````````````````


```````````````````````````````` example
_foo_bar_baz_
.
<p><em>foo_bar_baz</em></p>
````````````````````````````````


This is emphasis, even though the closing delimiter is
both left- and right-flanking, because it is followed by
punctuation:

```````````````````````````````` example
_(bar)_.
.
<p><em>(bar)</em>.</p>
````````````````````````````````


Rule 5:

```````````````````````````````` example
**foo bar**
.
<p><strong>foo bar</strong></p>
````````````````````````````````


This is not strong emphasis, because the opening delimiter is
followed by whitespace:

```````````````````````````````` example
** foo bar**
.
<p>** foo bar**</p>
````````````````````````````````


This is not strong emphasis, because the opening `**` is preceded
by an alphanumeric and followed by punctuation, and hence
not part of a [left-flanking delimiter run]:

```````````````````````````````` example
a**"foo"**
.
<p>a**&quot;foo&quot;**</p>
````````````````````````````````


Intraword strong emphasis with `**` is permitted:

```````````````````````````````` example
foo**bar**
.
<p>foo<strong>bar</strong></p>
````````````````````````````````


Rule 6:

```````````````````````````````` example
__foo bar__
.
<p><strong>foo bar</strong></p>
````````````````````````````````


This is not strong emphasis, because the opening delimiter is
followed by whitespace:

```````````````````````````````` example
__ foo bar__
.
<p>__ foo bar__</p>
````````````````````````````````


A newline counts as whitespace:
```````````````````````````````` example
__
foo bar__
.
<p>__
foo bar__</p>
````````````````````````````````


This is not strong emphasis, because the opening `__` is preceded
by an alphanumeric and followed by punctuation:

```````````````````````````````` example
a__"foo"__
.
<p>a__&quot;foo&quot;__</p>
````````````````````````````````


Intraword strong emphasis is forbidden with `__`:

```````````````````````````````` example
foo__bar__
.
<p>foo__bar__</p>
````````````````````````````````


```````````````````````````````` example
5__6__78
.
<p>5__6__78</p>
````````````````````````````````


```````````````````````````````` example
пристаням__стремятся__
.
<p>пристаням__стремятся__</p>
````````````````````````````````


```````````````````````````````` example
__foo, __bar__, baz__
.
<p><strong>foo, <strong>bar</strong>, baz</strong></p>
````````````````````````````````


This is strong emphasis, even though the opening delimiter is
both left- and right-flanking, because it is preceded by
punctuation:

```````````````````````````````` example
foo-__(bar)__
.
<p>foo-<strong>(bar)</strong></p>
````````````````````````````````



Rule 7:

This is not strong emphasis, because the closing delimiter is preceded
by whitespace:

```````````````````````````````` example
**foo bar **
.
<p>**foo bar **</p>
````````````````````````````````


(Nor can it be interpreted as an emphasized `*foo bar *`, because of
Rule 11.)

This is not strong emphasis, because the second `**` is
preceded by punctuation and followed by an alphanumeric:

```````````````````````````````` example
**(**foo)
.
<p>**(**foo)</p>
````````````````````````````````


The point of this restriction is more easily appreciated
with these examples:

```````````````````````````````` example
*(**foo**)*
.
<p><em>(<strong>foo</strong>)</em></p>
````````````````````````````````


```````````````````````````````` example
**Gomphocarpus (*Gomphocarpus physocarpus*, syn.
*Asclepias physocarpa*)**
.
<p><strong>Gomphocarpus (<em>Gomphocarpus physocarpus</em>, syn.
<em>Asclepias physocarpa</em>)</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo "*bar*" foo**
.
<p><strong>foo &quot;<em>bar</em>&quot; foo</strong></p>
````````````````````````````````


Intraword emphasis:

```````````````````````````````` example
**foo**bar
.
<p><strong>foo</strong>bar</p>
````````````````````````````````


Rule 8:

This is not strong emphasis, because the closing delimiter is
preceded by whitespace:

```````````````````````````````` example
__foo bar __
.
<p>__foo bar __</p>
````````````````````````````````


This is not strong emphasis, because the second `__` is
preceded by punctuation and followed by an alphanumeric:

```````````````````````````````` example
__(__foo)
.
<p>__(__foo)</p>
````````````````````````````````


The point of this restriction is more easily appreciated
with this example:

```````````````````````````````` example
_(__foo__)_
.
<p><em>(<strong>foo</strong>)</em></p>
````````````````````````````````


Intraword strong emphasis is forbidden with `__`:

```````````````````````````````` example
__foo__bar
.
<p>__foo__bar</p>
````````````````````````````````


```````````````````````````````` example
__пристаням__стремятся
.
<p>__пристаням__стремятся</p>
````````````````````````````````


```````````````````````````````` example
__foo__bar__baz__
.
<p><strong>foo__bar__baz</strong></p>
````````````````````````````````


This is strong emphasis, even though the closing delimiter is
both left- and right-flanking, because it is followed by
punctuation:

```````````````````````````````` example
__(bar)__.
.
<p><strong>(bar)</strong>.</p>
````````````````````````````````


Rule 9:

Any nonempty sequence of inline elements can be the contents of an
emphasized span.

```````````````````````````````` example
*foo [bar](/url)*
.
<p><em>foo <a href="/url">bar</a></em></p>
````````````````````````````````


```````````````````````````````` example
*foo
bar*
.
<p><em>foo
bar</em></p>
````````````````````````````````


In particular, emphasis and strong emphasis can be nested
inside emphasis:

```````````````````````````````` example
_foo __bar__ baz_
.
<p><em>foo <strong>bar</strong> baz</em></p>
````````````````````````````````


```````````````````````````````` example
_foo _bar_ baz_
.
<p><em>foo <em>bar</em> baz</em></p>
````````````````````````````````


```````````````````````````````` example
__foo_ bar_
.
<p><em><em>foo</em> bar</em></p>
````````````````````````````````


```````````````````````````````` example
*foo *bar**
.
<p><em>foo <em>bar</em></em></p>
````````````````````````````````


```````````````````````````````` example
*foo **bar** baz*
.
<p><em>foo <strong>bar</strong> baz</em></p>
````````````````````````````````

```````````````````````````````` example
*foo**bar**baz*
.
<p><em>foo<strong>bar</strong>baz</em></p>
````````````````````````````````

Note that in the preceding case, the interpretation

``` markdown
<p><em>foo</em><em>bar<em></em>baz</em></p>
```


is precluded by the condition that a delimiter that
can both open and close (like the `*` after `foo`)
cannot form emphasis if the sum of the lengths of
the delimiter runs containing the opening and
closing delimiters is a multiple of 3 unless
both lengths are multiples of 3.


For the same reason, we don't get two consecutive
emphasis sections in this example:

```````````````````````````````` example
*foo**bar*
.
<p><em>foo**bar</em></p>
````````````````````````````````


The same condition ensures that the following
cases are all strong emphasis nested inside
emphasis, even when the interior spaces are
omitted:


```````````````````````````````` example
***foo** bar*
.
<p><em><strong>foo</strong> bar</em></p>
````````````````````````````````


```````````````````````````````` example
*foo **bar***
.
<p><em>foo <strong>bar</strong></em></p>
````````````````````````````````


```````````````````````````````` example
*foo**bar***
.
<p><em>foo<strong>bar</strong></em></p>
````````````````````````````````


When the lengths of the interior closing and opening
delimiter runs are *both* multiples of 3, though,
they can match to create emphasis:

```````````````````````````````` example
foo***bar***baz
.
<p>foo<em><strong>bar</strong></em>baz</p>
````````````````````````````````

```````````````````````````````` example
foo******bar*********baz
.
<p>foo<strong><strong><strong>bar</strong></strong></strong>***baz</p>
````````````````````````````````


Indefinite levels of nesting are possible:

```````````````````````````````` example
*foo **bar *baz* bim** bop*
.
<p><em>foo <strong>bar <em>baz</em> bim</strong> bop</em></p>
````````````````````````````````


```````````````````````````````` example
*foo [*bar*](/url)*
.
<p><em>foo <a href="/url"><em>bar</em></a></em></p>
````````````````````````````````


There can be no empty emphasis or strong emphasis:

```````````````````````````````` example
** is not an empty emphasis
.
<p>** is not an empty emphasis</p>
````````````````````````````````


```````````````````````````````` example
**** is not an empty strong emphasis
.
<p>**** is not an empty strong emphasis</p>
````````````````````````````````



Rule 10:

Any nonempty sequence of inline elements can be the contents of an
strongly emphasized span.

```````````````````````````````` example
**foo [bar](/url)**
.
<p><strong>foo <a href="/url">bar</a></strong></p>
````````````````````````````````


```````````````````````````````` example
**foo
bar**
.
<p><strong>foo
bar</strong></p>
````````````````````````````````


In particular, emphasis and strong emphasis can be nested
inside strong emphasis:

```````````````````````````````` example
__foo _bar_ baz__
.
<p><strong>foo <em>bar</em> baz</strong></p>
````````````````````````````````


```````````````````````````````` example
__foo __bar__ baz__
.
<p><strong>foo <strong>bar</strong> baz</strong></p>
````````````````````````````````


```````````````````````````````` example
____foo__ bar__
.
<p><strong><strong>foo</strong> bar</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo **bar****
.
<p><strong>foo <strong>bar</strong></strong></p>
````````````````````````````````


```````````````````````````````` example
**foo *bar* baz**
.
<p><strong>foo <em>bar</em> baz</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo*bar*baz**
.
<p><strong>foo<em>bar</em>baz</strong></p>
````````````````````````````````


```````````````````````````````` example
***foo* bar**
.
<p><strong><em>foo</em> bar</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo *bar***
.
<p><strong>foo <em>bar</em></strong></p>
````````````````````````````````


Indefinite levels of nesting are possible:

```````````````````````````````` example
**foo *bar **baz**
bim* bop**
.
<p><strong>foo <em>bar <strong>baz</strong>
bim</em> bop</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo [*bar*](/url)**
.
<p><strong>foo <a href="/url"><em>bar</em></a></strong></p>
````````````````````````````````


There can be no empty emphasis or strong emphasis:

```````````````````````````````` example
__ is not an empty emphasis
.
<p>__ is not an empty emphasis</p>
````````````````````````````````


```````````````````````````````` example
____ is not an empty strong emphasis
.
<p>____ is not an empty strong emphasis</p>
````````````````````````````````



Rule 11:

```````````````````````````````` example
foo ***
.
<p>foo ***</p>
````````````````````````````````


```````````````````````````````` example
foo *\**
.
<p>foo <em>*</em></p>
````````````````````````````````


```````````````````````````````` example
foo *_*
.
<p>foo <em>_</em></p>
````````````````````````````````


```````````````````````````````` example
foo *****
.
<p>foo *****</p>
````````````````````````````````


```````````````````````````````` example
foo **\***
.
<p>foo <strong>*</strong></p>
````````````````````````````````


```````````````````````````````` example
foo **_**
.
<p>foo <strong>_</strong></p>
````````````````````````````````


Note that when delimiters do not match evenly, Rule 11 determines
that the excess literal `*` characters will appear outside of the
emphasis, rather than inside it:

```````````````````````````````` example
**foo*
.
<p>*<em>foo</em></p>
````````````````````````````````


```````````````````````````````` example
*foo**
.
<p><em>foo</em>*</p>
````````````````````````````````


```````````````````````````````` example
***foo**
.
<p>*<strong>foo</strong></p>
````````````````````````````````


```````````````````````````````` example
****foo*
.
<p>***<em>foo</em></p>
````````````````````````````````


```````````````````````````````` example
**foo***
.
<p><strong>foo</strong>*</p>
````````````````````````````````


```````````````````````````````` example
*foo****
.
<p><em>foo</em>***</p>
````````````````````````````````



Rule 12:

```````````````````````````````` example
foo ___
.
<p>foo ___</p>
````````````````````````````````


```````````````````````````````` example
foo _\__
.
<p>foo <em>_</em></p>
````````````````````````````````


```````````````````````````````` example
foo _*_
.
<p>foo <em>*</em></p>
````````````````````````````````


```````````````````````````````` example
foo _____
.
<p>foo _____</p>
````````````````````````````````


```````````````````````````````` example
foo __\___
.
<p>foo <strong>_</strong></p>
````````````````````````````````


```````````````````````````````` example
foo __*__
.
<p>foo <strong>*</strong></p>
````````````````````````````````


```````````````````````````````` example
__foo_
.
<p>_<em>foo</em></p>
````````````````````````````````


Note that when delimiters do not match evenly, Rule 12 determines
that the excess literal `_` characters will appear outside of the
emphasis, rather than inside it:

```````````````````````````````` example
_foo__
.
<p><em>foo</em>_</p>
````````````````````````````````


```````````````````````````````` example
___foo__
.
<p>_<strong>foo</strong></p>
````````````````````````````````


```````````````````````````````` example
____foo_
.
<p>___<em>foo</em></p>
````````````````````````````````


```````````````````````````````` example
__foo___
.
<p><strong>foo</strong>_</p>
````````````````````````````````


```````````````````````````````` example
_foo____
.
<p><em>foo</em>___</p>
````````````````````````````````


Rule 13 implies that if you want emphasis nested directly inside
emphasis, you must use different delimiters:

```````````````````````````````` example
**foo**
.
<p><strong>foo</strong></p>
````````````````````````````````


```````````````````````````````` example
*_foo_*
.
<p><em><em>foo</em></em></p>
````````````````````````````````


```````````````````````````````` example
__foo__
.
<p><strong>foo</strong></p>
````````````````````````````````


```````````````````````````````` example
_*foo*_
.
<p><em><em>foo</em></em></p>
````````````````````````````````


However, strong emphasis within strong emphasis is possible without
switching delimiters:

```````````````````````````````` example
****foo****
.
<p><strong><strong>foo</strong></strong></p>
````````````````````````````````


```````````````````````````````` example
____foo____
.
<p><strong><strong>foo</strong></strong></p>
````````````````````````````````



Rule 13 can be applied to arbitrarily long sequences of
delimiters:

```````````````````````````````` example
******foo******
.
<p><strong><strong><strong>foo</strong></strong></strong></p>
````````````````````````````````


Rule 14:

```````````````````````````````` example
***foo***
.
<p><em><strong>foo</strong></em></p>
````````````````````````````````


```````````````````````````````` example
_____foo_____
.
<p><em><strong><strong>foo</strong></strong></em></p>
````````````````````````````````


Rule 15:

```````````````````````````````` example
*foo _bar* baz_
.
<p><em>foo _bar</em> baz_</p>
````````````````````````````````


```````````````````````````````` example
*foo __bar *baz bim__ bam*
.
<p><em>foo <strong>bar *baz bim</strong> bam</em></p>
````````````````````````````````


Rule 16:

```````````````````````````````` example
**foo **bar baz**
.
<p>**foo <strong>bar baz</strong></p>
````````````````````````````````


```````````````````````````````` example
*foo *bar baz*
.
<p>*foo <em>bar baz</em></p>
````````````````````````````````


Rule 17:

```````````````````````````````` example
*[bar*](/url)
.
<p>*<a href="/url">bar*</a></p>
````````````````````````````````


```````````````````````````````` example
_foo [bar_](/url)
.
<p>_foo <a href="/url">bar_</a></p>
````````````````````````````````


```````````````````````````````` example
*<img src="foo" title="*"/>
.
<p>*<img src="foo" title="*"/></p>
````````````````````````````````


```````````````````````````````` example
**<a href="**">
.
<p>**<a href="**"></p>
````````````````````````````````


```````````````````````````````` example
__<a href="__">
.
<p>__<a href="__"></p>
````````````````````````````````


```````````````````````````````` example
*a `*`*
.
<p><em>a <code>*</code></em></p>
````````````````````````````````


```````````````````````````````` example
_a `_`_
.
<p><em>a <code>_</code></em></p>
````````````````````````````````


```````````````````````````````` example
**a<http://foo.bar/?q=**>
.
<p>**a<a href="http://foo.bar/?q=**">http://foo.bar/?q=**</a></p>
````````````````````````````````


```````````````````````````````` example
__a<http://foo.bar/?q=__>
.
<p>__a<a href="http://foo.bar/?q=__">http://foo.bar/?q=__</a></p>
````````````````````````````````



## Links

A link contains [link text] (the visible text), a [link destination]
(the URI that is the link destination), and optionally a [link title].
There are two basic kinds of links in Markdown.  In [inline links] the
destination and title are given immediately after the link text.  In
[reference links] the destination and title are defined elsewhere in
the document.

A [link text](@) consists of a sequence of zero or more
inline elements enclosed by square brackets (`[` and `]`).  The
following rules apply:

- Links may not contain other links, at any level of nesting. If
  multiple otherwise valid link definitions appear nested inside each
  other, the inner-most definition is used.

- Brackets are allowed in the [link text] only if (a) they
  are backslash-escaped or (b) they appear as a matched pair of brackets,
  with an open bracket `[`, a sequence of zero or more inlines, and
  a close bracket `]`.

- Backtick [code spans], [autolinks], and raw [HTML tags] bind more tightly
  than the brackets in link text.  Thus, for example,
  `` [foo`]` `` could not be a link text, since the second `]`
  is part of a code span.

- The brackets in link text bind more tightly than markers for
  [emphasis and strong emphasis]. Thus, for example, `*[foo*](url)` is a link.

A [link destination](@) consists of either

- a sequence of zero or more characters between an opening `<` and a
  closing `>` that contains no line breaks or unescaped
  `<` or `>` characters, or

- a nonempty sequence of characters that does not start with
  `<`, does not include ASCII space or control characters, and
  includes parentheses only if (a) they are backslash-escaped or
  (b) they are part of a balanced pair of unescaped parentheses.
  (Implementations may impose limits on parentheses nesting to
  avoid performance issues, but at least three levels of nesting
  should be supported.)

A [link title](@)  consists of either

- a sequence of zero or more characters between straight double-quote
  characters (`"`), including a `"` character only if it is
  backslash-escaped, or

- a sequence of zero or more characters between straight single-quote
  characters (`'`), including a `'` character only if it is
  backslash-escaped, or

- a sequence of zero or more characters between matching parentheses
  (`(...)`), including a `(` or `)` character only if it is
  backslash-escaped.

Although [link titles] may span multiple lines, they may not contain
a [blank line].

An [inline link](@) consists of a [link text] followed immediately
by a left parenthesis `(`, optional [whitespace], an optional
[link destination], an optional [link title] separated from the link
destination by [whitespace], optional [whitespace], and a right
parenthesis `)`. The link's text consists of the inlines contained
in the [link text] (excluding the enclosing square brackets).
The link's URI consists of the link destination, excluding enclosing
`<...>` if present, with backslash-escapes in effect as described
above.  The link's title consists of the link title, excluding its
enclosing delimiters, with backslash-escapes in effect as described
above.

Here is a simple inline link:

```````````````````````````````` example
[link](/uri "title")
.
<p><a href="/uri" title="title">link</a></p>
````````````````````````````````


The title may be omitted:

```````````````````````````````` example
[link](/uri)
.
<p><a href="/uri">link</a></p>
````````````````````````````````


Both the title and the destination may be omitted:

```````````````````````````````` example
[link]()
.
<p><a href="">link</a></p>
````````````````````````````````


```````````````````````````````` example
[link](<>)
.
<p><a href="">link</a></p>
````````````````````````````````

The destination can only contain spaces if it is
enclosed in pointy brackets:

```````````````````````````````` example
[link](/my uri)
.
<p>[link](/my uri)</p>
````````````````````````````````

```````````````````````````````` example
[link](</my uri>)
.
<p><a href="/my%20uri">link</a></p>
````````````````````````````````

The destination cannot contain line breaks,
even if enclosed in pointy brackets:

```````````````````````````````` example
[link](foo
bar)
.
<p>[link](foo
bar)</p>
````````````````````````````````

```````````````````````````````` example
[link](<foo
bar>)
.
<p>[link](<foo
bar>)</p>
````````````````````````````````

The destination can contain `)` if it is enclosed
in pointy brackets:

```````````````````````````````` example
[a](<b)c>)
.
<p><a href="b)c">a</a></p>
````````````````````````````````

Pointy brackets that enclose links must be unescaped:

```````````````````````````````` example
[link](<foo\>)
.
<p>[link](&lt;foo&gt;)</p>
````````````````````````````````

These are not links, because the opening pointy bracket
is not matched properly:

```````````````````````````````` example
[a](<b)c
[a](<b)c>
[a](<b>c)
.
<p>[a](&lt;b)c
[a](&lt;b)c&gt;
[a](<b>c)</p>
````````````````````````````````

Parentheses inside the link destination may be escaped:

```````````````````````````````` example
[link](\(foo\))
.
<p><a href="(foo)">link</a></p>
````````````````````````````````

Any number of parentheses are allowed without escaping, as long as they are
balanced:

```````````````````````````````` example
[link](foo(and(bar)))
.
<p><a href="foo(and(bar))">link</a></p>
````````````````````````````````

However, if you have unbalanced parentheses, you need to escape or use the
`<...>` form:

```````````````````````````````` example
[link](foo\(and\(bar\))
.
<p><a href="foo(and(bar)">link</a></p>
````````````````````````````````


```````````````````````````````` example
[link](<foo(and(bar)>)
.
<p><a href="foo(and(bar)">link</a></p>
````````````````````````````````


Parentheses and other symbols can also be escaped, as usual
in Markdown:

```````````````````````````````` example
[link](foo\)\:)
.
<p><a href="foo):">link</a></p>
````````````````````````````````


A link can contain fragment identifiers and queries:

```````````````````````````````` example
[link](#fragment)

[link](http://example.com#fragment)

[link](http://example.com?foo=3#frag)
.
<p><a href="#fragment">link</a></p>
<p><a href="http://example.com#fragment">link</a></p>
<p><a href="http://example.com?foo=3#frag">link</a></p>
````````````````````````````````


Note that a backslash before a non-escapable character is
just a backslash:

```````````````````````````````` example
[link](foo\bar)
.
<p><a href="foo%5Cbar">link</a></p>
````````````````````````````````


URL-escaping should be left alone inside the destination, as all
URL-escaped characters are also valid URL characters. Entity and
numerical character references in the destination will be parsed
into the corresponding Unicode code points, as usual.  These may
be optionally URL-escaped when written as HTML, but this spec
does not enforce any particular policy for rendering URLs in
HTML or other formats.  Renderers may make different decisions
about how to escape or normalize URLs in the output.

```````````````````````````````` example
[link](foo%20b&auml;)
.
<p><a href="foo%20b%C3%A4">link</a></p>
````````````````````````````````


Note that, because titles can often be parsed as destinations,
if you try to omit the destination and keep the title, you'll
get unexpected results:

```````````````````````````````` example
[link]("title")
.
<p><a href="%22title%22">link</a></p>
````````````````````````````````


Titles may be in single quotes, double quotes, or parentheses:

```````````````````````````````` example
[link](/url "title")
[link](/url 'title')
[link](/url (title))
.
<p><a href="/url" title="title">link</a>
<a href="/url" title="title">link</a>
<a href="/url" title="title">link</a></p>
````````````````````````````````


Backslash escapes and entity and numeric character references
may be used in titles:

```````````````````````````````` example
[link](/url "title \"&quot;")
.
<p><a href="/url" title="title &quot;&quot;">link</a></p>
````````````````````````````````


Titles must be separated from the link using a [whitespace].
Other [Unicode whitespace] like non-breaking space doesn't work.

```````````````````````````````` example
[link](/url "title")
.
<p><a href="/url%C2%A0%22title%22">link</a></p>
````````````````````````````````


Nested balanced quotes are not allowed without escaping:

```````````````````````````````` example
[link](/url "title "and" title")
.
<p>[link](/url &quot;title &quot;and&quot; title&quot;)</p>
````````````````````````````````


But it is easy to work around this by using a different quote type:

```````````````````````````````` example
[link](/url 'title "and" title')
.
<p><a href="/url" title="title &quot;and&quot; title">link</a></p>
````````````````````````````````


(Note:  `Markdown.pl` did allow double quotes inside a double-quoted
title, and its test suite included a test demonstrating this.
But it is hard to see a good rationale for the extra complexity this
brings, since there are already many ways---backslash escaping,
entity and numeric character references, or using a different
quote type for the enclosing title---to write titles containing
double quotes.  `Markdown.pl`'s handling of titles has a number
of other strange features.  For example, it allows single-quoted
titles in inline links, but not reference links.  And, in
reference links but not inline links, it allows a title to begin
with `"` and end with `)`.  `Markdown.pl` 1.0.1 even allows
titles with no closing quotation mark, though 1.0.2b8 does not.
It seems preferable to adopt a simple, rational rule that works
the same way in inline links and link reference definitions.)

[Whitespace] is allowed around the destination and title:

```````````````````````````````` example
[link](   /uri
  "title"  )
.
<p><a href="/uri" title="title">link</a></p>
````````````````````````````````


But it is not allowed between the link text and the
following parenthesis:

```````````````````````````````` example
[link] (/uri)
.
<p>[link] (/uri)</p>
````````````````````````````````


The link text may contain balanced brackets, but not unbalanced ones,
unless they are escaped:

```````````````````````````````` example
[link [foo [bar]]](/uri)
.
<p><a href="/uri">link [foo [bar]]</a></p>
````````````````````````````````


```````````````````````````````` example
[link] bar](/uri)
.
<p>[link] bar](/uri)</p>
````````````````````````````````


```````````````````````````````` example
[link [bar](/uri)
.
<p>[link <a href="/uri">bar</a></p>
````````````````````````````````


```````````````````````````````` example
[link \[bar](/uri)
.
<p><a href="/uri">link [bar</a></p>
````````````````````````````````


The link text may contain inline content:

```````````````````````````````` example
[link *foo **bar** `#`*](/uri)
.
<p><a href="/uri">link <em>foo <strong>bar</strong> <code>#</code></em></a></p>
````````````````````````````````


```````````````````````````````` example
[![moon](moon.jpg)](/uri)
.
<p><a href="/uri"><img src="moon.jpg" alt="moon" /></a></p>
````````````````````````````````


However, links may not contain other links, at any level of nesting.

```````````````````````````````` example
[foo [bar](/uri)](/uri)
.
<p>[foo <a href="/uri">bar</a>](/uri)</p>
````````````````````````````````


```````````````````````````````` example
[foo *[bar [baz](/uri)](/uri)*](/uri)
.
<p>[foo <em>[bar <a href="/uri">baz</a>](/uri)</em>](/uri)</p>
````````````````````````````````


```````````````````````````````` example
![[[foo](uri1)](uri2)](uri3)
.
<p><img src="uri3" alt="[foo](uri2)" /></p>
````````````````````````````````


These cases illustrate the precedence of link text grouping over
emphasis grouping:

```````````````````````````````` example
*[foo*](/uri)
.
<p>*<a href="/uri">foo*</a></p>
````````````````````````````````


```````````````````````````````` example
[foo *bar](baz*)
.
<p><a href="baz*">foo *bar</a></p>
````````````````````````````````


Note that brackets that *aren't* part of links do not take
precedence:

```````````````````````````````` example
*foo [bar* baz]
.
<p><em>foo [bar</em> baz]</p>
````````````````````````````````


These cases illustrate the precedence of HTML tags, code spans,
and autolinks over link grouping:

```````````````````````````````` example
[foo <bar attr="](baz)">
.
<p>[foo <bar attr="](baz)"></p>
````````````````````````````````


```````````````````````````````` example
[foo`](/uri)`
.
<p>[foo<code>](/uri)</code></p>
````````````````````````````````


```````````````````````````````` example
[foo<http://example.com/?search=](uri)>
.
<p>[foo<a href="http://example.com/?search=%5D(uri)">http://example.com/?search=](uri)</a></p>
````````````````````````````````


There are three kinds of [reference link](@)s:
[full](#full-reference-link), [collapsed](#collapsed-reference-link),
and [shortcut](#shortcut-reference-link).

A [full reference link](@)
consists of a [link text] immediately followed by a [link label]
that [matches] a [link reference definition] elsewhere in the document.

A [link label](@)  begins with a left bracket (`[`) and ends
with the first right bracket (`]`) that is not backslash-escaped.
Between these brackets there must be at least one [non-whitespace character].
Unescaped square bracket characters are not allowed inside the
opening and closing square brackets of [link labels].  A link
label can have at most 999 characters inside the square
brackets.

One label [matches](@)
another just in case their normalized forms are equal.  To normalize a
label, strip off the opening and closing brackets,
perform the *Unicode case fold*, strip leading and trailing
[whitespace] and collapse consecutive internal
[whitespace] to a single space.  If there are multiple
matching reference link definitions, the one that comes first in the
document is used.  (It is desirable in such cases to emit a warning.)

The contents of the first link label are parsed as inlines, which are
used as the link's text.  The link's URI and title are provided by the
matching [link reference definition].

Here is a simple example:

```````````````````````````````` example
[foo][bar]

[bar]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


The rules for the [link text] are the same as with
[inline links].  Thus:

The link text may contain balanced brackets, but not unbalanced ones,
unless they are escaped:

```````````````````````````````` example
[link [foo [bar]]][ref]

[ref]: /uri
.
<p><a href="/uri">link [foo [bar]]</a></p>
````````````````````````````````


```````````````````````````````` example
[link \[bar][ref]

[ref]: /uri
.
<p><a href="/uri">link [bar</a></p>
````````````````````````````````


The link text may contain inline content:

```````````````````````````````` example
[link *foo **bar** `#`*][ref]

[ref]: /uri
.
<p><a href="/uri">link <em>foo <strong>bar</strong> <code>#</code></em></a></p>
````````````````````````````````


```````````````````````````````` example
[![moon](moon.jpg)][ref]

[ref]: /uri
.
<p><a href="/uri"><img src="moon.jpg" alt="moon" /></a></p>
````````````````````````````````


However, links may not contain other links, at any level of nesting.

```````````````````````````````` example
[foo [bar](/uri)][ref]

[ref]: /uri
.
<p>[foo <a href="/uri">bar</a>]<a href="/uri">ref</a></p>
````````````````````````````````


```````````````````````````````` example
[foo *bar [baz][ref]*][ref]

[ref]: /uri
.
<p>[foo <em>bar <a href="/uri">baz</a></em>]<a href="/uri">ref</a></p>
````````````````````````````````


(In the examples above, we have two [shortcut reference links]
instead of one [full reference link].)

The following cases illustrate the precedence of link text grouping over
emphasis grouping:

```````````````````````````````` example
*[foo*][ref]

[ref]: /uri
.
<p>*<a href="/uri">foo*</a></p>
````````````````````````````````


```````````````````````````````` example
[foo *bar][ref]

[ref]: /uri
.
<p><a href="/uri">foo *bar</a></p>
````````````````````````````````


These cases illustrate the precedence of HTML tags, code spans,
and autolinks over link grouping:

```````````````````````````````` example
[foo <bar attr="][ref]">

[ref]: /uri
.
<p>[foo <bar attr="][ref]"></p>
````````````````````````````````


```````````````````````````````` example
[foo`][ref]`

[ref]: /uri
.
<p>[foo<code>][ref]</code></p>
````````````````````````````````


```````````````````````````````` example
[foo<http://example.com/?search=][ref]>

[ref]: /uri
.
<p>[foo<a href="http://example.com/?search=%5D%5Bref%5D">http://example.com/?search=][ref]</a></p>
````````````````````````````````


Matching is case-insensitive:

```````````````````````````````` example
[foo][BaR]

[bar]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


Unicode case fold is used:

```````````````````````````````` example
[Толпой][Толпой] is a Russian word.

[ТОЛПОЙ]: /url
.
<p><a href="/url">Толпой</a> is a Russian word.</p>
````````````````````````````````


Consecutive internal [whitespace] is treated as one space for
purposes of determining matching:

```````````````````````````````` example
[Foo
  bar]: /url

[Baz][Foo bar]
.
<p><a href="/url">Baz</a></p>
````````````````````````````````


No [whitespace] is allowed between the [link text] and the
[link label]:

```````````````````````````````` example
[foo] [bar]

[bar]: /url "title"
.
<p>[foo] <a href="/url" title="title">bar</a></p>
````````````````````````````````


```````````````````````````````` example
[foo]
[bar]

[bar]: /url "title"
.
<p>[foo]
<a href="/url" title="title">bar</a></p>
````````````````````````````````


This is a departure from John Gruber's original Markdown syntax
description, which explicitly allows whitespace between the link
text and the link label.  It brings reference links in line with
[inline links], which (according to both original Markdown and
this spec) cannot have whitespace after the link text.  More
importantly, it prevents inadvertent capture of consecutive
[shortcut reference links]. If whitespace is allowed between the
link text and the link label, then in the following we will have
a single reference link, not two shortcut reference links, as
intended:

``` markdown
[foo]
[bar]

[foo]: /url1
[bar]: /url2
```

(Note that [shortcut reference links] were introduced by Gruber
himself in a beta version of `Markdown.pl`, but never included
in the official syntax description.  Without shortcut reference
links, it is harmless to allow space between the link text and
link label; but once shortcut references are introduced, it is
too dangerous to allow this, as it frequently leads to
unintended results.)

When there are multiple matching [link reference definitions],
the first is used:

```````````````````````````````` example
[foo]: /url1

[foo]: /url2

[bar][foo]
.
<p><a href="/url1">bar</a></p>
````````````````````````````````


Note that matching is performed on normalized strings, not parsed
inline content.  So the following does not match, even though the
labels define equivalent inline content:

```````````````````````````````` example
[bar][foo\!]

[foo!]: /url
.
<p>[bar][foo!]</p>
````````````````````````````````


[Link labels] cannot contain brackets, unless they are
backslash-escaped:

```````````````````````````````` example
[foo][ref[]

[ref[]: /uri
.
<p>[foo][ref[]</p>
<p>[ref[]: /uri</p>
````````````````````````````````


```````````````````````````````` example
[foo][ref[bar]]

[ref[bar]]: /uri
.
<p>[foo][ref[bar]]</p>
<p>[ref[bar]]: /uri</p>
````````````````````````````````


```````````````````````````````` example
[[[foo]]]

[[[foo]]]: /url
.
<p>[[[foo]]]</p>
<p>[[[foo]]]: /url</p>
````````````````````````````````


```````````````````````````````` example
[foo][ref\[]

[ref\[]: /uri
.
<p><a href="/uri">foo</a></p>
````````````````````````````````


Note that in this example `]` is not backslash-escaped:

```````````````````````````````` example
[bar\\]: /uri

[bar\\]
.
<p><a href="/uri">bar\</a></p>
````````````````````````````````


A [link label] must contain at least one [non-whitespace character]:

```````````````````````````````` example
[]

[]: /uri
.
<p>[]</p>
<p>[]: /uri</p>
````````````````````````````````


```````````````````````````````` example
[
 ]

[
 ]: /uri
.
<p>[
]</p>
<p>[
]: /uri</p>
````````````````````````````````


A [collapsed reference link](@)
consists of a [link label] that [matches] a
[link reference definition] elsewhere in the
document, followed by the string `[]`.
The contents of the first link label are parsed as inlines,
which are used as the link's text.  The link's URI and title are
provided by the matching reference link definition.  Thus,
`[foo][]` is equivalent to `[foo][foo]`.

```````````````````````````````` example
[foo][]

[foo]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[*foo* bar][]

[*foo* bar]: /url "title"
.
<p><a href="/url" title="title"><em>foo</em> bar</a></p>
````````````````````````````````


The link labels are case-insensitive:

```````````````````````````````` example
[Foo][]

[foo]: /url "title"
.
<p><a href="/url" title="title">Foo</a></p>
````````````````````````````````



As with full reference links, [whitespace] is not
allowed between the two sets of brackets:

```````````````````````````````` example
[foo] 
[]

[foo]: /url "title"
.
<p><a href="/url" title="title">foo</a>
[]</p>
````````````````````````````````


A [shortcut reference link](@)
consists of a [link label] that [matches] a
[link reference definition] elsewhere in the
document and is not followed by `[]` or a link label.
The contents of the first link label are parsed as inlines,
which are used as the link's text.  The link's URI and title
are provided by the matching link reference definition.
Thus, `[foo]` is equivalent to `[foo][]`.

```````````````````````````````` example
[foo]

[foo]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[*foo* bar]

[*foo* bar]: /url "title"
.
<p><a href="/url" title="title"><em>foo</em> bar</a></p>
````````````````````````````````


```````````````````````````````` example
[[*foo* bar]]

[*foo* bar]: /url "title"
.
<p>[<a href="/url" title="title"><em>foo</em> bar</a>]</p>
````````````````````````````````


```````````````````````````````` example
[[bar [foo]

[foo]: /url
.
<p>[[bar <a href="/url">foo</a></p>
````````````````````````````````


The link labels are case-insensitive:

```````````````````````````````` example
[Foo]

[foo]: /url "title"
.
<p><a href="/url" title="title">Foo</a></p>
````````````````````````````````


A space after the link text should be preserved:

```````````````````````````````` example
[foo] bar

[foo]: /url
.
<p><a href="/url">foo</a> bar</p>
````````````````````````````````


If you just want bracketed text, you can backslash-escape the
opening bracket to avoid links:

```````````````````````````````` example
\[foo]

[foo]: /url "title"
.
<p>[foo]</p>
````````````````````````````````


Note that this is a link, because a link label ends with the first
following closing bracket:

```````````````````````````````` example
[foo*]: /url

*[foo*]
.
<p>*<a href="/url">foo*</a></p>
````````````````````````````````


Full and compact references take precedence over shortcut
references:

```````````````````````````````` example
[foo][bar]

[foo]: /url1
[bar]: /url2
.
<p><a href="/url2">foo</a></p>
````````````````````````````````

```````````````````````````````` example
[foo][]

[foo]: /url1
.
<p><a href="/url1">foo</a></p>
````````````````````````````````

Inline links also take precedence:

```````````````````````````````` example
[foo]()

[foo]: /url1
.
<p><a href="">foo</a></p>
````````````````````````````````

```````````````````````````````` example
[foo](not a link)

[foo]: /url1
.
<p><a href="/url1">foo</a>(not a link)</p>
````````````````````````````````

In the following case `[bar][baz]` is parsed as a reference,
`[foo]` as normal text:

```````````````````````````````` example
[foo][bar][baz]

[baz]: /url
.
<p>[foo]<a href="/url">bar</a></p>
````````````````````````````````


Here, though, `[foo][bar]` is parsed as a reference, since
`[bar]` is defined:

```````````````````````````````` example
[foo][bar][baz]

[baz]: /url1
[bar]: /url2
.
<p><a href="/url2">foo</a><a href="/url1">baz</a></p>
````````````````````````````````


Here `[foo]` is not parsed as a shortcut reference, because it
is followed by a link label (even though `[bar]` is not defined):

```````````````````````````````` example
[foo][bar][baz]

[baz]: /url1
[foo]: /url2
.
<p>[foo]<a href="/url1">bar</a></p>
````````````````````````````````



## Images

Syntax for images is like the syntax for links, with one
difference. Instead of [link text], we have an
[image description](@).  The rules for this are the
same as for [link text], except that (a) an
image description starts with `![` rather than `[`, and
(b) an image description may contain links.
An image description has inline elements
as its contents.  When an image is rendered to HTML,
this is standardly used as the image's `alt` attribute.

```````````````````````````````` example
![foo](/url "title")
.
<p><img src="/url" alt="foo" title="title" /></p>
````````````````````````````````


```````````````````````````````` example
![foo *bar*]

[foo *bar*]: train.jpg "train & tracks"
.
<p><img src="train.jpg" alt="foo bar" title="train &amp; tracks" /></p>
````````````````````````````````


```````````````````````````````` example
![foo ![bar](/url)](/url2)
.
<p><img src="/url2" alt="foo bar" /></p>
````````````````````````````````


```````````````````````````````` example
![foo [bar](/url)](/url2)
.
<p><img src="/url2" alt="foo bar" /></p>
````````````````````````````````


Though this spec is concerned with parsing, not rendering, it is
recommended that in rendering to HTML, only the plain string content
of the [image description] be used.  Note that in
the above example, the alt attribute's value is `foo bar`, not `foo
[bar](/url)` or `foo <a href="/url">bar</a>`.  Only the plain string
content is rendered, without formatting.

```````````````````````````````` example
![foo *bar*][]

[foo *bar*]: train.jpg "train & tracks"
.
<p><img src="train.jpg" alt="foo bar" title="train &amp; tracks" /></p>
````````````````````````````````


```````````````````````````````` example
![foo *bar*][foobar]

[FOOBAR]: train.jpg "train & tracks"
.
<p><img src="train.jpg" alt="foo bar" title="train &amp; tracks" /></p>
````````````````````````````````


```````````````````````````````` example
![foo](train.jpg)
.
<p><img src="train.jpg" alt="foo" /></p>
````````````````````````````````


```````````````````````````````` example
My ![foo bar](/path/to/train.jpg  "title"   )
.
<p>My <img src="/path/to/train.jpg" alt="foo bar" title="title" /></p>
````````````````````````````````


```````````````````````````````` example
![foo](<url>)
.
<p><img src="url" alt="foo" /></p>
````````````````````````````````


```````````````````````````````` example
![](/url)
.
<p><img src="/url" alt="" /></p>
````````````````````````````````


Reference-style:

```````````````````````````````` example
![foo][bar]

[bar]: /url
.
<p><img src="/url" alt="foo" /></p>
````````````````````````````````


```````````````````````````````` example
![foo][bar]

[BAR]: /url
.
<p><img src="/url" alt="foo" /></p>
````````````````````````````````


Collapsed:

```````````````````````````````` example
![foo][]

[foo]: /url "title"
.
<p><img src="/url" alt="foo" title="title" /></p>
````````````````````````````````


```````````````````````````````` example
![*foo* bar][]

[*foo* bar]: /url "title"
.
<p><img src="/url" alt="foo bar" title="title" /></p>
````````````````````````````````


The labels are case-insensitive:

```````````````````````````````` example
![Foo][]

[foo]: /url "title"
.
<p><img src="/url" alt="Foo" title="title" /></p>
````````````````````````````````


As with reference links, [whitespace] is not allowed
between the two sets of brackets:

```````````````````````````````` example
![foo] 
[]

[foo]: /url "title"
.
<p><img src="/url" alt="foo" title="title" />
[]</p>
````````````````````````````````


Shortcut:

```````````````````````````````` example
![foo]

[foo]: /url "title"
.
<p><img src="/url" alt="foo" title="title" /></p>
````````````````````````````````


```````````````````````````````` example
![*foo* bar]

[*foo* bar]: /url "title"
.
<p><img src="/url" alt="foo bar" title="title" /></p>
````````````````````````````````


Note that link labels cannot contain unescaped brackets:

```````````````````````````````` example
![[foo]]

[[foo]]: /url "title"
.
<p>![[foo]]</p>
<p>[[foo]]: /url &quot;title&quot;</p>
````````````````````````````````


The link labels are case-insensitive:

```````````````````````````````` example
![Foo]

[foo]: /url "title"
.
<p><img src="/url" alt="Foo" title="title" /></p>
````````````````````````````````


If you just want a literal `!` followed by bracketed text, you can
backslash-escape the opening `[`:

```````````````````````````````` example
!\[foo]

[foo]: /url "title"
.
<p>![foo]</p>
````````````````````````````````


If you want a link after a literal `!`, backslash-escape the
`!`:

```````````````````````````````` example
\![foo]

[foo]: /url "title"
.
<p>!<a href="/url" title="title">foo</a></p>
````````````````````````````````


## Autolinks

[Autolink](@)s are absolute URIs and email addresses inside
`<` and `>`. They are parsed as links, with the URL or email address
as the link label.

A [URI autolink](@) consists of `<`, followed by an
[absolute URI] followed by `>`.  It is parsed as
a link to the URI, with the URI as the link's label.

An [absolute URI](@),
for these purposes, consists of a [scheme] followed by a colon (`:`)
followed by zero or more characters other than ASCII
[whitespace] and control characters, `<`, and `>`.  If
the URI includes these characters, they must be percent-encoded
(e.g. `%20` for a space).

For purposes of this spec, a [scheme](@) is any sequence
of 2--32 characters beginning with an ASCII letter and followed
by any combination of ASCII letters, digits, or the symbols plus
("+"), period ("."), or hyphen ("-").

Here are some valid autolinks:

```````````````````````````````` example
<http://foo.bar.baz>
.
<p><a href="http://foo.bar.baz">http://foo.bar.baz</a></p>
````````````````````````````````


```````````````````````````````` example
<http://foo.bar.baz/test?q=hello&id=22&boolean>
.
<p><a href="http://foo.bar.baz/test?q=hello&amp;id=22&amp;boolean">http://foo.bar.baz/test?q=hello&amp;id=22&amp;boolean</a></p>
````````````````````````````````


```````````````````````````````` example
<irc://foo.bar:2233/baz>
.
<p><a href="irc://foo.bar:2233/baz">irc://foo.bar:2233/baz</a></p>
````````````````````````````````


Uppercase is also fine:

```````````````````````````````` example
<MAILTO:FOO@BAR.BAZ>
.
<p><a href="MAILTO:FOO@BAR.BAZ">MAILTO:FOO@BAR.BAZ</a></p>
````````````````````````````````


Note that many strings that count as [absolute URIs] for
purposes of this spec are not valid URIs, because their
schemes are not registered or because of other problems
with their syntax:

```````````````````````````````` example
<a+b+c:d>
.
<p><a href="a+b+c:d">a+b+c:d</a></p>
````````````````````````````````


```````````````````````````````` example
<made-up-scheme://foo,bar>
.
<p><a href="made-up-scheme://foo,bar">made-up-scheme://foo,bar</a></p>
````````````````````````````````


```````````````````````````````` example
<http://../>
.
<p><a href="http://../">http://../</a></p>
````````````````````````````````


```````````````````````````````` example
<localhost:5001/foo>
.
<p><a href="localhost:5001/foo">localhost:5001/foo</a></p>
````````````````````````````````


Spaces are not allowed in autolinks:

```````````````````````````````` example
<http://foo.bar/baz bim>
.
<p>&lt;http://foo.bar/baz bim&gt;</p>
````````````````````````````````


Backslash-escapes do not work inside autolinks:

```````````````````````````````` example
<http://example.com/\[\>
.
<p><a href="http://example.com/%5C%5B%5C">http://example.com/\[\</a></p>
````````````````````````````````


An [email autolink](@)
consists of `<`, followed by an [email address],
followed by `>`.  The link's label is the email address,
and the URL is `mailto:` followed by the email address.

An [email address](@),
for these purposes, is anything that matches
the [non-normative regex from the HTML5
spec](https://html.spec.whatwg.org/multipage/forms.html#e-mail-state-(type=email)):

    /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?
    (?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/

Examples of email autolinks:

```````````````````````````````` example
<foo@bar.example.com>
.
<p><a href="mailto:foo@bar.example.com">foo@bar.example.com</a></p>
````````````````````````````````


```````````````````````````````` example
<foo+special@Bar.baz-bar0.com>
.
<p><a href="mailto:foo+special@Bar.baz-bar0.com">foo+special@Bar.baz-bar0.com</a></p>
````````````````````````````````


Backslash-escapes do not work inside email autolinks:

```````````````````````````````` example
<foo\+@bar.example.com>
.
<p>&lt;foo+@bar.example.com&gt;</p>
````````````````````````````````


These are not autolinks:

```````````````````````````````` example
<>
.
<p>&lt;&gt;</p>
````````````````````````````````


```````````````````````````````` example
< http://foo.bar >
.
<p>&lt; http://foo.bar &gt;</p>
````````````````````````````````


```````````````````````````````` example
<m:abc>
.
<p>&lt;m:abc&gt;</p>
````````````````````````````````


```````````````````````````````` example
<foo.bar.baz>
.
<p>&lt;foo.bar.baz&gt;</p>
````````````````````````````````


```````````````````````````````` example
http://example.com
.
<p>http://example.com</p>
````````````````````````````````


```````````````````````````````` example
foo@bar.example.com
.
<p>foo@bar.example.com</p>
````````````````````````````````


## Raw HTML

Text between `<` and `>` that looks like an HTML tag is parsed as a
raw HTML tag and will be rendered in HTML without escaping.
Tag and attribute names are not limited to current HTML tags,
so custom tags (and even, say, DocBook tags) may be used.

Here is the grammar for tags:

A [tag name](@) consists of an ASCII letter
followed by zero or more ASCII letters, digits, or
hyphens (`-`).

An [attribute](@) consists of [whitespace],
an [attribute name], and an optional
[attribute value specification].

An [attribute name](@)
consists of an ASCII letter, `_`, or `:`, followed by zero or more ASCII
letters, digits, `_`, `.`, `:`, or `-`.  (Note:  This is the XML
specification restricted to ASCII.  HTML5 is laxer.)

An [attribute value specification](@)
consists of optional [whitespace],
a `=` character, optional [whitespace], and an [attribute
value].

An [attribute value](@)
consists of an [unquoted attribute value],
a [single-quoted attribute value], or a [double-quoted attribute value].

An [unquoted attribute value](@)
is a nonempty string of characters not
including [whitespace], `"`, `'`, `=`, `<`, `>`, or `` ` ``.

A [single-quoted attribute value](@)
consists of `'`, zero or more
characters not including `'`, and a final `'`.

A [double-quoted attribute value](@)
consists of `"`, zero or more
characters not including `"`, and a final `"`.

An [open tag](@) consists of a `<` character, a [tag name],
zero or more [attributes], optional [whitespace], an optional `/`
character, and a `>` character.

A [closing tag](@) consists of the string `</`, a
[tag name], optional [whitespace], and the character `>`.

An [HTML comment](@) consists of `<!--` + *text* + `-->`,
where *text* does not start with `>` or `->`, does not end with `-`,
and does not contain `--`.  (See the
[HTML5 spec](http://www.w3.org/TR/html5/syntax.html#comments).)

A [processing instruction](@)
consists of the string `<?`, a string
of characters not including the string `?>`, and the string
`?>`.

A [declaration](@) consists of the
string `<!`, a name consisting of one or more uppercase ASCII letters,
[whitespace], a string of characters not including the
character `>`, and the character `>`.

A [CDATA section](@) consists of
the string `<![CDATA[`, a string of characters not including the string
`]]>`, and the string `]]>`.

An [HTML tag](@) consists of an [open tag], a [closing tag],
an [HTML comment], a [processing instruction], a [declaration],
or a [CDATA section].

Here are some simple open tags:

```````````````````````````````` example
<a><bab><c2c>
.
<p><a><bab><c2c></p>
````````````````````````````````


Empty elements:

```````````````````````````````` example
<a/><b2/>
.
<p><a/><b2/></p>
````````````````````````````````


[Whitespace] is allowed:

```````````````````````````````` example
<a  /><b2
data="foo" >
.
<p><a  /><b2
data="foo" ></p>
````````````````````````````````


With attributes:

```````````````````````````````` example
<a foo="bar" bam = 'baz <em>"</em>'
_boolean zoop:33=zoop:33 />
.
<p><a foo="bar" bam = 'baz <em>"</em>'
_boolean zoop:33=zoop:33 /></p>
````````````````````````````````


Custom tag names can be used:

```````````````````````````````` example
Foo <responsive-image src="foo.jpg" />
.
<p>Foo <responsive-image src="foo.jpg" /></p>
````````````````````````````````


Illegal tag names, not parsed as HTML:

```````````````````````````````` example
<33> <__>
.
<p>&lt;33&gt; &lt;__&gt;</p>
````````````````````````````````


Illegal attribute names:

```````````````````````````````` example
<a h*#ref="hi">
.
<p>&lt;a h*#ref=&quot;hi&quot;&gt;</p>
````````````````````````````````


Illegal attribute values:

```````````````````````````````` example
<a href="hi'> <a href=hi'>
.
<p>&lt;a href=&quot;hi'&gt; &lt;a href=hi'&gt;</p>
````````````````````````````````


Illegal [whitespace]:

```````````````````````````````` example
< a><
foo><bar/ >
<foo bar=baz
bim!bop />
.
<p>&lt; a&gt;&lt;
foo&gt;&lt;bar/ &gt;
&lt;foo bar=baz
bim!bop /&gt;</p>
````````````````````````````````


Missing [whitespace]:

```````````````````````````````` example
<a href='bar'title=title>
.
<p>&lt;a href='bar'title=title&gt;</p>
````````````````````````````````


Closing tags:

```````````````````````````````` example
</a></foo >
.
<p></a></foo ></p>
````````````````````````````````


Illegal attributes in closing tag:

```````````````````````````````` example
</a href="foo">
.
<p>&lt;/a href=&quot;foo&quot;&gt;</p>
````````````````````````````````


Comments:

```````````````````````````````` example
foo <!-- this is a
comment - with hyphen -->
.
<p>foo <!-- this is a
comment - with hyphen --></p>
````````````````````````````````


```````````````````````````````` example
foo <!-- not a comment -- two hyphens -->
.
<p>foo &lt;!-- not a comment -- two hyphens --&gt;</p>
````````````````````````````````


Not comments:

```````````````````````````````` example
foo <!--> foo -->

foo <!-- foo--->
.
<p>foo &lt;!--&gt; foo --&gt;</p>
<p>foo &lt;!-- foo---&gt;</p>
````````````````````````````````


Processing instructions:

```````````````````````````````` example
foo <?php echo $a; ?>
.
<p>foo <?php echo $a; ?></p>
````````````````````````````````


Declarations:

```````````````````````````````` example
foo <!ELEMENT br EMPTY>
.
<p>foo <!ELEMENT br EMPTY></p>
````````````````````````````````


CDATA sections:

```````````````````````````````` example
foo <![CDATA[>&<]]>
.
<p>foo <![CDATA[>&<]]></p>
````````````````````````````````


Entity and numeric character references are preserved in HTML
attributes:

```````````````````````````````` example
foo <a href="&ouml;">
.
<p>foo <a href="&ouml;"></p>
````````````````````````````````


Backslash escapes do not work in HTML attributes:

```````````````````````````````` example
foo <a href="\*">
.
<p>foo <a href="\*"></p>
````````````````````````````````


```````````````````````````````` example
<a href="\"">
.
<p>&lt;a href=&quot;&quot;&quot;&gt;</p>
````````````````````````````````


## Hard line breaks

A line break (not in a code span or HTML tag) that is preceded
by two or more spaces and does not occur at the end of a block
is parsed as a [hard line break](@) (rendered
in HTML as a `<br />` tag):

```````````````````````````````` example
foo  
baz
.
<p>foo<br />
baz</p>
````````````````````````````````


For a more visible alternative, a backslash before the
[line ending] may be used instead of two spaces:

```````````````````````````````` example
foo\
baz
.
<p>foo<br />
baz</p>
````````````````````````````````


More than two spaces can be used:

```````````````````````````````` example
foo       
baz
.
<p>foo<br />
baz</p>
````````````````````````````````


Leading spaces at the beginning of the next line are ignored:

```````````````````````````````` example
foo  
     bar
.
<p>foo<br />
bar</p>
````````````````````````````````


```````````````````````````````` example
foo\
     bar
.
<p>foo<br />
bar</p>
````````````````````````````````


Line breaks can occur inside emphasis, links, and other constructs
that allow inline content:

```````````````````````````````` example
*foo  
bar*
.
<p><em>foo<br />
bar</em></p>
````````````````````````````````


```````````````````````````````` example
*foo\
bar*
.
<p><em>foo<br />
bar</em></p>
````````````````````````````````


Line breaks do not occur inside code spans

```````````````````````````````` example
`code 
span`
.
<p><code>code  span</code></p>
````````````````````````````````


```````````````````````````````` example
`code\
span`
.
<p><code>code\ span</code></p>
````````````````````````````````


or HTML tags:

```````````````````````````````` example
<a href="foo  
bar">
.
<p><a href="foo  
bar"></p>
````````````````````````````````


```````````````````````````````` example
<a href="foo\
bar">
.
<p><a href="foo\
bar"></p>
````````````````````````````````


Hard line breaks are for separating inline content within a block.
Neither syntax for hard line breaks works at the end of a paragraph or
other block element:

```````````````````````````````` example
foo\
.
<p>foo\</p>
````````````````````````````````


```````````````````````````````` example
foo  
.
<p>foo</p>
````````````````````````````````


```````````````````````````````` example
### foo\
.
<h3>foo\</h3>
````````````````````````````````


```````````````````````````````` example
### foo  
.
<h3>foo</h3>
````````````````````````````````


## Soft line breaks

A regular line break (not in a code span or HTML tag) that is not
preceded by two or more spaces or a backslash is parsed as a
[softbreak](@).  (A softbreak may be rendered in HTML either as a
[line ending] or as a space. The result will be the same in
browsers. In the examples here, a [line ending] will be used.)

```````````````````````````````` example
foo
baz
.
<p>foo
baz</p>
````````````````````````````````


Spaces at the end of the line and beginning of the next line are
removed:

```````````````````````````````` example
foo 
 baz
.
<p>foo
baz</p>
````````````````````````````````


A conforming parser may render a soft line break in HTML either as a
line break or as a space.

A renderer may also provide an option to render soft line breaks
as hard line breaks.

## Textual content

Any characters not given an interpretation by the above rules will
be parsed as plain textual content.

```````````````````````````````` example
hello $.;'there
.
<p>hello $.;'there</p>
````````````````````````````````


```````````````````````````````` example
Foo χρῆν
.
<p>Foo χρῆν</p>
````````````````````````````````


Internal spaces are preserved verbatim:

```````````````````````````````` example
Multiple     spaces
.
<p>Multiple     spaces</p>
````````````````````````````````


<!-- END TESTS -->

# Appendix: A parsing strategy

In this appendix we describe some features of the parsing strategy
used in the CommonMark reference implementations.

## Overview

Parsing has two phases:

1. In the first phase, lines of input are consumed and the block
structure of the document---its division into paragraphs, block quotes,
list items, and so on---is constructed.  Text is assigned to these
blocks but not parsed. Link reference definitions are parsed and a
map of links is constructed.

2. In the second phase, the raw text contents of paragraphs and headings
are parsed into sequences of Markdown inline elements (strings,
code spans, links, emphasis, and so on), using the map of link
references constructed in phase 1.

At each point in processing, the document is represented as a tree of
**blocks**.  The root of the tree is a `document` block.  The `document`
may have any number of other blocks as **children**.  These children
may, in turn, have other blocks as children.  The last child of a block
is normally considered **open**, meaning that subsequent lines of input
can alter its contents.  (Blocks that are not open are **closed**.)
Here, for example, is a possible document tree, with the open blocks
marked by arrows:

``` tree
-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             "Qui *quodsi iracundia*"
      -> list_item
        -> paragraph
             "aliquando id"
```

## Phase 1: block structure

Each line that is processed has an effect on this tree.  The line is
analyzed and, depending on its contents, the document may be altered
in one or more of the following ways:

1. One or more open blocks may be closed.
2. One or more new blocks may be created as children of the
   last open block.
3. Text may be added to the last (deepest) open block remaining
   on the tree.

Once a line has been incorporated into the tree in this way,
it can be discarded, so input can be read in a stream.

For each line, we follow this procedure:

1. First we iterate through the open blocks, starting with the
root document, and descending through last children down to the last
open block.  Each block imposes a condition that the line must satisfy
if the block is to remain open.  For example, a block quote requires a
`>` character.  A paragraph requires a non-blank line.
In this phase we may match all or just some of the open
blocks.  But we cannot close unmatched blocks yet, because we may have a
[lazy continuation line].

2.  Next, after consuming the continuation markers for existing
blocks, we look for new block starts (e.g. `>` for a block quote).
If we encounter a new block start, we close any blocks unmatched
in step 1 before creating the new block as a child of the last
matched block.

3.  Finally, we look at the remainder of the line (after block
markers like `>`, list markers, and indentation have been consumed).
This is text that can be incorporated into the last open
block (a paragraph, code block, heading, or raw HTML).

Setext headings are formed when we see a line of a paragraph
that is a [setext heading underline].

Reference link definitions are detected when a paragraph is closed;
the accumulated text lines are parsed to see if they begin with
one or more reference link definitions.  Any remainder becomes a
normal paragraph.

We can see how this works by considering how the tree above is
generated by four lines of Markdown:

``` markdown
> Lorem ipsum dolor
sit amet.
> - Qui *quodsi iracundia*
> - aliquando id
```

At the outset, our document model is just

``` tree
-> document
```

The first line of our text,

``` markdown
> Lorem ipsum dolor
```

causes a `block_quote` block to be created as a child of our
open `document` block, and a `paragraph` block as a child of
the `block_quote`.  Then the text is added to the last open
block, the `paragraph`:

``` tree
-> document
  -> block_quote
    -> paragraph
         "Lorem ipsum dolor"
```

The next line,

``` markdown
sit amet.
```

is a "lazy continuation" of the open `paragraph`, so it gets added
to the paragraph's text:

``` tree
-> document
  -> block_quote
    -> paragraph
         "Lorem ipsum dolor\nsit amet."
```

The third line,

``` markdown
> - Qui *quodsi iracundia*
```

causes the `paragraph` block to be closed, and a new `list` block
opened as a child of the `block_quote`.  A `list_item` is also
added as a child of the `list`, and a `paragraph` as a child of
the `list_item`.  The text is then added to the new `paragraph`:

``` tree
-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
      -> list_item
        -> paragraph
             "Qui *quodsi iracundia*"
```

The fourth line,

``` markdown
> - aliquando id
```

causes the `list_item` (and its child the `paragraph`) to be closed,
and a new `list_item` opened up as child of the `list`.  A `paragraph`
is added as a child of the new `list_item`, to contain the text.
We thus obtain the final tree:

``` tree
-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             "Qui *quodsi iracundia*"
      -> list_item
        -> paragraph
             "aliquando id"
```

## Phase 2: inline structure

Once all of the input has been parsed, all open blocks are closed.

We then "walk the tree," visiting every node, and parse raw
string contents of paragraphs and headings as inlines.  At this
point we have seen all the link reference definitions, so we can
resolve reference links as we go.

``` tree
document
  block_quote
    paragraph
      str "Lorem ipsum dolor"
      softbreak
      str "sit amet."
    list (type=bullet tight=true bullet_char=-)
      list_item
        paragraph
          str "Qui "
          emph
            str "quodsi iracundia"
      list_item
        paragraph
          str "aliquando id"
```

Notice how the [line ending] in the first paragraph has
been parsed as a `softbreak`, and the asterisks in the first list item
have become an `emph`.

### An algorithm for parsing nested emphasis and links

By far the trickiest part of inline parsing is handling emphasis,
strong emphasis, links, and images.  This is done using the following
algorithm.

When we're parsing inlines and we hit either

- a run of `*` or `_` characters, or
- a `[` or `![`

we insert a text node with these symbols as its literal content, and we
add a pointer to this text node to the [delimiter stack](@).

The [delimiter stack] is a doubly linked list.  Each
element contains a pointer to a text node, plus information about

- the type of delimiter (`[`, `![`, `*`, `_`)
- the number of delimiters,
- whether the delimiter is "active" (all are active to start), and
- whether the delimiter is a potential opener, a potential closer,
  or both (which depends on what sort of characters precede
  and follow the delimiters).

When we hit a `]` character, we call the *look for link or image*
procedure (see below).

When we hit the end of the input, we call the *process emphasis*
procedure (see below), with `stack_bottom` = NULL.

#### *look for link or image*

Starting at the top of the delimiter stack, we look backwards
through the stack for an opening `[` or `![` delimiter.

- If we don't find one, we return a literal text node `]`.

- If we do find one, but it's not *active*, we remove the inactive
  delimiter from the stack, and return a literal text node `]`.

- If we find one and it's active, then we parse ahead to see if
  we have an inline link/image, reference link/image, compact reference
  link/image, or shortcut reference link/image.

  + If we don't, then we remove the opening delimiter from the
    delimiter stack and return a literal text node `]`.

  + If we do, then

    * We return a link or image node whose children are the inlines
      after the text node pointed to by the opening delimiter.

    * We run *process emphasis* on these inlines, with the `[` opener
      as `stack_bottom`.

    * We remove the opening delimiter.

    * If we have a link (and not an image), we also set all
      `[` delimiters before the opening delimiter to *inactive*.  (This
      will prevent us from getting links within links.)

#### *process emphasis*

Parameter `stack_bottom` sets a lower bound to how far we
descend in the [delimiter stack].  If it is NULL, we can
go all the way to the bottom.  Otherwise, we stop before
visiting `stack_bottom`.

Let `current_position` point to the element on the [delimiter stack]
just above `stack_bottom` (or the first element if `stack_bottom`
is NULL).

We keep track of the `openers_bottom` for each delimiter
type (`*`, `_`) and each length of the closing delimiter run
(modulo 3).  Initialize this to `stack_bottom`.

Then we repeat the following until we run out of potential
closers:

- Move `current_position` forward in the delimiter stack (if needed)
  until we find the first potential closer with delimiter `*` or `_`.
  (This will be the potential closer closest
  to the beginning of the input -- the first one in parse order.)

- Now, look back in the stack (staying above `stack_bottom` and
  the `openers_bottom` for this delimiter type) for the
  first matching potential opener ("matching" means same delimiter).

- If one is found:

  + Figure out whether we have emphasis or strong emphasis:
    if both closer and opener spans have length >= 2, we have
    strong, otherwise regular.

  + Insert an emph or strong emph node accordingly, after
    the text node corresponding to the opener.

  + Remove any delimiters between the opener and closer from
    the delimiter stack.

  + Remove 1 (for regular emph) or 2 (for strong emph) delimiters
    from the opening and closing text nodes.  If they become empty
    as a result, remove them and remove the corresponding element
    of the delimiter stack.  If the closing node is removed, reset
    `current_position` to the next element in the stack.

- If none is found:

  + Set `openers_bottom` to the element before `current_position`.
    (We know that there are no openers for this kind of closer up to and
    including this point, so this puts a lower bound on future searches.)

  + If the closer at `current_position` is not a potential opener,
    remove it from the delimiter stack (since we know it can't
    be a closer either).

  + Advance `current_position` to the next element in the stack.

After we're done, we remove all delimiters above `stack_bottom` from the
delimiter stack.
</file>

<file path="_benchmark/cmark/.gitignore">
cmark-master
cmark_benchmark
</file>

<file path="_benchmark/cmark/cmark_benchmark.c">
#include <stdio.h>
#include <stdlib.h>
#ifdef WIN32
#  include <windows.h>
#else
#  include <sys/time.h>
#  include <sys/resource.h>
#endif
#include "cmark.h"


#ifdef WIN32

double get_time()
{
    LARGE_INTEGER t, f;
    QueryPerformanceCounter(&t);
    QueryPerformanceFrequency(&f);
    return (double)t.QuadPart/(double)f.QuadPart;
}

#else


double get_time()
{
    struct timeval t;
    struct timezone tzp;
    gettimeofday(&t, &tzp);
    return t.tv_sec + t.tv_usec*1e-6;
}

#endif

int main(int argc, char **argv) {
    char *markdown_file;
    FILE *fp;
    size_t size;
    char *buf;
    char *html;
    double start, sum;
    int i, n;

    n = argc > 1 ? atoi(argv[1]) : 50;
    markdown_file = argc > 2 ? argv[2] : "_data.md";

    fp = fopen(markdown_file,"r");
    if(fp == NULL){
      fprintf(stderr, "can not open %s", markdown_file);
      exit(1);
    }

    if(fseek(fp, 0, SEEK_END) != 0) {
      fprintf(stderr, "can not seek %s", markdown_file);
      exit(1);
    }
    if((size = ftell(fp)) < 0) {
      fprintf(stderr, "can not get size of %s", markdown_file);
      exit(1);
    }
    if(fseek(fp, 0, SEEK_SET) != 0) {
      fprintf(stderr, "can not seek %s", markdown_file);
      exit(1);
    }
    buf = malloc(sizeof(char) * size);
    if(buf == NULL) {
      fprintf(stderr, "can not allocate memory for %s", markdown_file);
      exit(1);
    }

    if(fread(buf, 1, size, fp) < size) {
      fprintf(stderr, "failed to read for %s", markdown_file);
      exit(1);
    }

    fclose(fp);

    for(i = 0; i < n; i++) {
      start = get_time();
      html = cmark_markdown_to_html(buf, size, CMARK_OPT_UNSAFE);
      free(html);
      sum += get_time() - start;
    }
    printf("----------- cmark -----------\n");
    printf("file: %s\n", markdown_file);
    printf("iteration: %d\n", n);
    printf("average: %.10f sec\n", sum / (double)n);

    free(buf);
    return 0;
}
</file>

<file path="_benchmark/cmark/goldmark_benchmark.go">
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"time"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
)

func main() {
	n := 50
	file := "_data.md"
	if len(os.Args) > 1 {
		n, _ = strconv.Atoi(os.Args[1])
	}
	if len(os.Args) > 2 {
		file = os.Args[2]
	}
	source, err := ioutil.ReadFile(file)
	if err != nil {
		panic(err)
	}
	markdown := goldmark.New(goldmark.WithRendererOptions(html.WithXHTML(), html.WithUnsafe()))
	var out bytes.Buffer
	markdown.Convert([]byte(""), &out)

	sum := time.Duration(0)
	for i := 0; i < n; i++ {
		start := time.Now()
		out.Reset()
		if err := markdown.Convert(source, &out); err != nil {
			panic(err)
		}
		sum += time.Since(start)
	}
	fmt.Printf("------- goldmark -------\n")
	fmt.Printf("file: %s\n", file)
	fmt.Printf("iteration: %d\n", n)
	fmt.Printf("average: %.10f sec\n", float64((int64(sum)/int64(n)))/1000000000.0)
}
</file>

<file path="_benchmark/go/_data.md">
# Introduction

## What is Markdown?

Markdown is a plain text format for writing structured documents,
based on conventions for indicating formatting in email
and usenet posts.  It was developed by John Gruber (with
help from Aaron Swartz) and released in 2004 in the form of a
[syntax description](http://daringfireball.net/projects/markdown/syntax)
and a Perl script (`Markdown.pl`) for converting Markdown to
HTML.  In the next decade, dozens of implementations were
developed in many languages.  Some extended the original
Markdown syntax with conventions for footnotes, tables, and
other document elements.  Some allowed Markdown documents to be
rendered in formats other than HTML.  Websites like Reddit,
StackOverflow, and GitHub had millions of people using Markdown.
And Markdown started to be used beyond the web, to author books,
articles, slide shows, letters, and lecture notes.

What distinguishes Markdown from many other lightweight markup
syntaxes, which are often easier to write, is its readability.
As Gruber writes:

> The overriding design goal for Markdown's formatting syntax is
> to make it as readable as possible. The idea is that a
> Markdown-formatted document should be publishable as-is, as
> plain text, without looking like it's been marked up with tags
> or formatting instructions.
> (<http://daringfireball.net/projects/markdown/>)

The point can be illustrated by comparing a sample of
[AsciiDoc](http://www.methods.co.nz/asciidoc/) with
an equivalent sample of Markdown.  Here is a sample of
AsciiDoc from the AsciiDoc manual:

```
1. List item one.
+
List item one continued with a second paragraph followed by an
Indented block.
+
.................
$ ls *.sh
$ mv *.sh ~/tmp
.................
+
List item continued with a third paragraph.

2. List item two continued with an open block.
+
--
This paragraph is part of the preceding list item.

a. This list is nested and does not require explicit item
continuation.
+
This paragraph is part of the preceding list item.

b. List item b.

This paragraph belongs to item two of the outer list.
--
```

And here is the equivalent in Markdown:
```
1.  List item one.

    List item one continued with a second paragraph followed by an
    Indented block.

        $ ls *.sh
        $ mv *.sh ~/tmp

    List item continued with a third paragraph.

2.  List item two continued with an open block.

    This paragraph is part of the preceding list item.

    1. This list is nested and does not require explicit item continuation.

       This paragraph is part of the preceding list item.

    2. List item b.

    This paragraph belongs to item two of the outer list.
```

The AsciiDoc version is, arguably, easier to write. You don't need
to worry about indentation.  But the Markdown version is much easier
to read.  The nesting of list items is apparent to the eye in the
source, not just in the processed document.

## Why is a spec needed?

John Gruber's [canonical description of Markdown's
syntax](http://daringfireball.net/projects/markdown/syntax)
does not specify the syntax unambiguously.  Here are some examples of
questions it does not answer:

1.  How much indentation is needed for a sublist?  The spec says that
    continuation paragraphs need to be indented four spaces, but is
    not fully explicit about sublists.  It is natural to think that
    they, too, must be indented four spaces, but `Markdown.pl` does
    not require that.  This is hardly a "corner case," and divergences
    between implementations on this issue often lead to surprises for
    users in real documents. (See [this comment by John
    Gruber](http://article.gmane.org/gmane.text.markdown.general/1997).)

2.  Is a blank line needed before a block quote or heading?
    Most implementations do not require the blank line.  However,
    this can lead to unexpected results in hard-wrapped text, and
    also to ambiguities in parsing (note that some implementations
    put the heading inside the blockquote, while others do not).
    (John Gruber has also spoken [in favor of requiring the blank
    lines](http://article.gmane.org/gmane.text.markdown.general/2146).)

3.  Is a blank line needed before an indented code block?
    (`Markdown.pl` requires it, but this is not mentioned in the
    documentation, and some implementations do not require it.)

    ``` markdown
    paragraph
        code?
    ```

4.  What is the exact rule for determining when list items get
    wrapped in `<p>` tags?  Can a list be partially "loose" and partially
    "tight"?  What should we do with a list like this?

    ``` markdown
    1. one

    2. two
    3. three
    ```

    Or this?

    ``` markdown
    1.  one
        - a

        - b
    2.  two
    ```

    (There are some relevant comments by John Gruber
    [here](http://article.gmane.org/gmane.text.markdown.general/2554).)

5.  Can list markers be indented?  Can ordered list markers be right-aligned?

    ``` markdown
     8. item 1
     9. item 2
    10. item 2a
    ```

6.  Is this one list with a thematic break in its second item,
    or two lists separated by a thematic break?

    ``` markdown
    * a
    * * * * *
    * b
    ```

7.  When list markers change from numbers to bullets, do we have
    two lists or one?  (The Markdown syntax description suggests two,
    but the perl scripts and many other implementations produce one.)

    ``` markdown
    1. fee
    2. fie
    -  foe
    -  fum
    ```

8.  What are the precedence rules for the markers of inline structure?
    For example, is the following a valid link, or does the code span
    take precedence ?

    ``` markdown
    [a backtick (`)](/url) and [another backtick (`)](/url).
    ```

9.  What are the precedence rules for markers of emphasis and strong
    emphasis?  For example, how should the following be parsed?

    ``` markdown
    *foo *bar* baz*
    ```

10. What are the precedence rules between block-level and inline-level
    structure?  For example, how should the following be parsed?

    ``` markdown
    - `a long code span can contain a hyphen like this
      - and it can screw things up`
    ```

11. Can list items include section headings?  (`Markdown.pl` does not
    allow this, but does allow blockquotes to include headings.)

    ``` markdown
    - # Heading
    ```

12. Can list items be empty?

    ``` markdown
    * a
    *
    * b
    ```

13. Can link references be defined inside block quotes or list items?

    ``` markdown
    > Blockquote [foo].
    >
    > [foo]: /url
    ```

14. If there are multiple definitions for the same reference, which takes
    precedence?

    ``` markdown
    [foo]: /url1
    [foo]: /url2

    [foo][]
    ```

In the absence of a spec, early implementers consulted `Markdown.pl`
to resolve these ambiguities.  But `Markdown.pl` was quite buggy, and
gave manifestly bad results in many cases, so it was not a
satisfactory replacement for a spec.

Because there is no unambiguous spec, implementations have diverged
considerably.  As a result, users are often surprised to find that
a document that renders one way on one system (say, a GitHub wiki)
renders differently on another (say, converting to docbook using
pandoc).  To make matters worse, because nothing in Markdown counts
as a "syntax error," the divergence often isn't discovered right away.

## About this document

This document attempts to specify Markdown syntax unambiguously.
It contains many examples with side-by-side Markdown and
HTML.  These are intended to double as conformance tests.  An
accompanying script `spec_tests.py` can be used to run the tests
against any Markdown program:

    python test/spec_tests.py --spec spec.txt --program PROGRAM

Since this document describes how Markdown is to be parsed into
an abstract syntax tree, it would have made sense to use an abstract
representation of the syntax tree instead of HTML.  But HTML is capable
of representing the structural distinctions we need to make, and the
choice of HTML for the tests makes it possible to run the tests against
an implementation without writing an abstract syntax tree renderer.

This document is generated from a text file, `spec.txt`, written
in Markdown with a small extension for the side-by-side tests.
The script `tools/makespec.py` can be used to convert `spec.txt` into
HTML or CommonMark (which can then be converted into other formats).

In the examples, the `→` character is used to represent tabs.

# Preliminaries

## Characters and lines

Any sequence of [characters] is a valid CommonMark
document.

A [character](@) is a Unicode code point.  Although some
code points (for example, combining accents) do not correspond to
characters in an intuitive sense, all code points count as characters
for purposes of this spec.

This spec does not specify an encoding; it thinks of lines as composed
of [characters] rather than bytes.  A conforming parser may be limited
to a certain encoding.

A [line](@) is a sequence of zero or more [characters]
other than newline (`U+000A`) or carriage return (`U+000D`),
followed by a [line ending] or by the end of file.

A [line ending](@) is a newline (`U+000A`), a carriage return
(`U+000D`) not followed by a newline, or a carriage return and a
following newline.

A line containing no characters, or a line containing only spaces
(`U+0020`) or tabs (`U+0009`), is called a [blank line](@).

The following definitions of character classes will be used in this spec:

A [whitespace character](@) is a space
(`U+0020`), tab (`U+0009`), newline (`U+000A`), line tabulation (`U+000B`),
form feed (`U+000C`), or carriage return (`U+000D`).

[Whitespace](@) is a sequence of one or more [whitespace
characters].

A [Unicode whitespace character](@) is
any code point in the Unicode `Zs` general category, or a tab (`U+0009`),
carriage return (`U+000D`), newline (`U+000A`), or form feed
(`U+000C`).

[Unicode whitespace](@) is a sequence of one
or more [Unicode whitespace characters].

A [space](@) is `U+0020`.

A [non-whitespace character](@) is any character
that is not a [whitespace character].

An [ASCII punctuation character](@)
is `!`, `"`, `#`, `$`, `%`, `&`, `'`, `(`, `)`,
`*`, `+`, `,`, `-`, `.`, `/` (U+0021–2F), 
`:`, `;`, `<`, `=`, `>`, `?`, `@` (U+003A–0040),
`[`, `\`, `]`, `^`, `_`, `` ` `` (U+005B–0060), 
`{`, `|`, `}`, or `~` (U+007B–007E).

A [punctuation character](@) is an [ASCII
punctuation character] or anything in
the general Unicode categories  `Pc`, `Pd`, `Pe`, `Pf`, `Pi`, `Po`, or `Ps`.

## Tabs

Tabs in lines are not expanded to [spaces].  However,
in contexts where whitespace helps to define block structure,
tabs behave as if they were replaced by spaces with a tab stop
of 4 characters.

Thus, for example, a tab can be used instead of four spaces
in an indented code block.  (Note, however, that internal
tabs are passed through as literal tabs, not expanded to
spaces.)

```````````````````````````````` example
→foo→baz→→bim
.
<pre><code>foo→baz→→bim
</code></pre>
````````````````````````````````

```````````````````````````````` example
  →foo→baz→→bim
.
<pre><code>foo→baz→→bim
</code></pre>
````````````````````````````````

```````````````````````````````` example
    a→a
    ὐ→a
.
<pre><code>a→a
ὐ→a
</code></pre>
````````````````````````````````

In the following example, a continuation paragraph of a list
item is indented with a tab; this has exactly the same effect
as indentation with four spaces would:

```````````````````````````````` example
  - foo

→bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
````````````````````````````````

```````````````````````````````` example
- foo

→→bar
.
<ul>
<li>
<p>foo</p>
<pre><code>  bar
</code></pre>
</li>
</ul>
````````````````````````````````

Normally the `>` that begins a block quote may be followed
optionally by a space, which is not considered part of the
content.  In the following case `>` is followed by a tab,
which is treated as if it were expanded into three spaces.
Since one of these spaces is considered part of the
delimiter, `foo` is considered to be indented six spaces
inside the block quote context, so we get an indented
code block starting with two spaces.

```````````````````````````````` example
>→→foo
.
<blockquote>
<pre><code>  foo
</code></pre>
</blockquote>
````````````````````````````````

```````````````````````````````` example
-→→foo
.
<ul>
<li>
<pre><code>  foo
</code></pre>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
    foo
→bar
.
<pre><code>foo
bar
</code></pre>
````````````````````````````````

```````````````````````````````` example
 - foo
   - bar
→ - baz
.
<ul>
<li>foo
<ul>
<li>bar
<ul>
<li>baz</li>
</ul>
</li>
</ul>
</li>
</ul>
````````````````````````````````

```````````````````````````````` example
#→Foo
.
<h1>Foo</h1>
````````````````````````````````

```````````````````````````````` example
*→*→*→
.
<hr />
````````````````````````````````


## Insecure characters

For security reasons, the Unicode character `U+0000` must be replaced
with the REPLACEMENT CHARACTER (`U+FFFD`).

# Blocks and inlines

We can think of a document as a sequence of
[blocks](@)---structural elements like paragraphs, block
quotations, lists, headings, rules, and code blocks.  Some blocks (like
block quotes and list items) contain other blocks; others (like
headings and paragraphs) contain [inline](@) content---text,
links, emphasized text, images, code spans, and so on.

## Precedence

Indicators of block structure always take precedence over indicators
of inline structure.  So, for example, the following is a list with
two items, not a list with one item containing a code span:

```````````````````````````````` example
- `one
- two`
.
<ul>
<li>`one</li>
<li>two`</li>
</ul>
````````````````````````````````


This means that parsing can proceed in two steps:  first, the block
structure of the document can be discerned; second, text lines inside
paragraphs, headings, and other block constructs can be parsed for inline
structure.  The second step requires information about link reference
definitions that will be available only at the end of the first
step.  Note that the first step requires processing lines in sequence,
but the second can be parallelized, since the inline parsing of
one block element does not affect the inline parsing of any other.

## Container blocks and leaf blocks

We can divide blocks into two types:
[container blocks](@),
which can contain other blocks, and [leaf blocks](@),
which cannot.

# Leaf blocks

This section describes the different kinds of leaf block that make up a
Markdown document.

## Thematic breaks

A line consisting of 0-3 spaces of indentation, followed by a sequence
of three or more matching `-`, `_`, or `*` characters, each followed
optionally by any number of spaces or tabs, forms a
[thematic break](@).

```````````````````````````````` example
***
---
___
.
<hr />
<hr />
<hr />
````````````````````````````````


Wrong characters:

```````````````````````````````` example
+++
.
<p>+++</p>
````````````````````````````````


```````````````````````````````` example
===
.
<p>===</p>
````````````````````````````````


Not enough characters:

```````````````````````````````` example
--
**
__
.
<p>--
**
__</p>
````````````````````````````````


One to three spaces indent are allowed:

```````````````````````````````` example
 ***
  ***
   ***
.
<hr />
<hr />
<hr />
````````````````````````````````


Four spaces is too many:

```````````````````````````````` example
    ***
.
<pre><code>***
</code></pre>
````````````````````````````````


```````````````````````````````` example
Foo
    ***
.
<p>Foo
***</p>
````````````````````````````````


More than three characters may be used:

```````````````````````````````` example
_____________________________________
.
<hr />
````````````````````````````````


Spaces are allowed between the characters:

```````````````````````````````` example
 - - -
.
<hr />
````````````````````````````````


```````````````````````````````` example
 **  * ** * ** * **
.
<hr />
````````````````````````````````


```````````````````````````````` example
-     -      -      -
.
<hr />
````````````````````````````````


Spaces are allowed at the end:

```````````````````````````````` example
- - - -    
.
<hr />
````````````````````````````````


However, no other characters may occur in the line:

```````````````````````````````` example
_ _ _ _ a

a------

---a---
.
<p>_ _ _ _ a</p>
<p>a------</p>
<p>---a---</p>
````````````````````````````````


It is required that all of the [non-whitespace characters] be the same.
So, this is not a thematic break:

```````````````````````````````` example
 *-*
.
<p><em>-</em></p>
````````````````````````````````


Thematic breaks do not need blank lines before or after:

```````````````````````````````` example
- foo
***
- bar
.
<ul>
<li>foo</li>
</ul>
<hr />
<ul>
<li>bar</li>
</ul>
````````````````````````````````


Thematic breaks can interrupt a paragraph:

```````````````````````````````` example
Foo
***
bar
.
<p>Foo</p>
<hr />
<p>bar</p>
````````````````````````````````


If a line of dashes that meets the above conditions for being a
thematic break could also be interpreted as the underline of a [setext
heading], the interpretation as a
[setext heading] takes precedence. Thus, for example,
this is a setext heading, not a paragraph followed by a thematic break:

```````````````````````````````` example
Foo
---
bar
.
<h2>Foo</h2>
<p>bar</p>
````````````````````````````````


When both a thematic break and a list item are possible
interpretations of a line, the thematic break takes precedence:

```````````````````````````````` example
* Foo
* * *
* Bar
.
<ul>
<li>Foo</li>
</ul>
<hr />
<ul>
<li>Bar</li>
</ul>
````````````````````````````````


If you want a thematic break in a list item, use a different bullet:

```````````````````````````````` example
- Foo
- * * *
.
<ul>
<li>Foo</li>
<li>
<hr />
</li>
</ul>
````````````````````````````````


## ATX headings

An [ATX heading](@)
consists of a string of characters, parsed as inline content, between an
opening sequence of 1--6 unescaped `#` characters and an optional
closing sequence of any number of unescaped `#` characters.
The opening sequence of `#` characters must be followed by a
[space] or by the end of line. The optional closing sequence of `#`s must be
preceded by a [space] and may be followed by spaces only.  The opening
`#` character may be indented 0-3 spaces.  The raw contents of the
heading are stripped of leading and trailing spaces before being parsed
as inline content.  The heading level is equal to the number of `#`
characters in the opening sequence.

Simple headings:

```````````````````````````````` example
# foo
## foo
### foo
#### foo
##### foo
###### foo
.
<h1>foo</h1>
<h2>foo</h2>
<h3>foo</h3>
<h4>foo</h4>
<h5>foo</h5>
<h6>foo</h6>
````````````````````````````````


More than six `#` characters is not a heading:

```````````````````````````````` example
####### foo
.
<p>####### foo</p>
````````````````````````````````


At least one space is required between the `#` characters and the
heading's contents, unless the heading is empty.  Note that many
implementations currently do not require the space.  However, the
space was required by the
[original ATX implementation](http://www.aaronsw.com/2002/atx/atx.py),
and it helps prevent things like the following from being parsed as
headings:

```````````````````````````````` example
#5 bolt

#hashtag
.
<p>#5 bolt</p>
<p>#hashtag</p>
````````````````````````````````


This is not a heading, because the first `#` is escaped:

```````````````````````````````` example
\## foo
.
<p>## foo</p>
````````````````````````````````


Contents are parsed as inlines:

```````````````````````````````` example
# foo *bar* \*baz\*
.
<h1>foo <em>bar</em> *baz*</h1>
````````````````````````````````


Leading and trailing [whitespace] is ignored in parsing inline content:

```````````````````````````````` example
#                  foo                     
.
<h1>foo</h1>
````````````````````````````````


One to three spaces indentation are allowed:

```````````````````````````````` example
 ### foo
  ## foo
   # foo
.
<h3>foo</h3>
<h2>foo</h2>
<h1>foo</h1>
````````````````````````````````


Four spaces are too much:

```````````````````````````````` example
    # foo
.
<pre><code># foo
</code></pre>
````````````````````````````````


```````````````````````````````` example
foo
    # bar
.
<p>foo
# bar</p>
````````````````````````````````


A closing sequence of `#` characters is optional:

```````````````````````````````` example
## foo ##
  ###   bar    ###
.
<h2>foo</h2>
<h3>bar</h3>
````````````````````````````````


It need not be the same length as the opening sequence:

```````````````````````````````` example
# foo ##################################
##### foo ##
.
<h1>foo</h1>
<h5>foo</h5>
````````````````````````````````


Spaces are allowed after the closing sequence:

```````````````````````````````` example
### foo ###     
.
<h3>foo</h3>
````````````````````````````````


A sequence of `#` characters with anything but [spaces] following it
is not a closing sequence, but counts as part of the contents of the
heading:

```````````````````````````````` example
### foo ### b
.
<h3>foo ### b</h3>
````````````````````````````````


The closing sequence must be preceded by a space:

```````````````````````````````` example
# foo#
.
<h1>foo#</h1>
````````````````````````````````


Backslash-escaped `#` characters do not count as part
of the closing sequence:

```````````````````````````````` example
### foo \###
## foo #\##
# foo \#
.
<h3>foo ###</h3>
<h2>foo ###</h2>
<h1>foo #</h1>
````````````````````````````````


ATX headings need not be separated from surrounding content by blank
lines, and they can interrupt paragraphs:

```````````````````````````````` example
****
## foo
****
.
<hr />
<h2>foo</h2>
<hr />
````````````````````````````````


```````````````````````````````` example
Foo bar
# baz
Bar foo
.
<p>Foo bar</p>
<h1>baz</h1>
<p>Bar foo</p>
````````````````````````````````


ATX headings can be empty:

```````````````````````````````` example
## 
#
### ###
.
<h2></h2>
<h1></h1>
<h3></h3>
````````````````````````````````


## Setext headings

A [setext heading](@) consists of one or more
lines of text, each containing at least one [non-whitespace
character], with no more than 3 spaces indentation, followed by
a [setext heading underline].  The lines of text must be such
that, were they not followed by the setext heading underline,
they would be interpreted as a paragraph:  they cannot be
interpretable as a [code fence], [ATX heading][ATX headings],
[block quote][block quotes], [thematic break][thematic breaks],
[list item][list items], or [HTML block][HTML blocks].

A [setext heading underline](@) is a sequence of
`=` characters or a sequence of `-` characters, with no more than 3
spaces indentation and any number of trailing spaces.  If a line
containing a single `-` can be interpreted as an
empty [list items], it should be interpreted this way
and not as a [setext heading underline].

The heading is a level 1 heading if `=` characters are used in
the [setext heading underline], and a level 2 heading if `-`
characters are used.  The contents of the heading are the result
of parsing the preceding lines of text as CommonMark inline
content.

In general, a setext heading need not be preceded or followed by a
blank line.  However, it cannot interrupt a paragraph, so when a
setext heading comes after a paragraph, a blank line is needed between
them.

Simple examples:

```````````````````````````````` example
Foo *bar*
=========

Foo *bar*
---------
.
<h1>Foo <em>bar</em></h1>
<h2>Foo <em>bar</em></h2>
````````````````````````````````


The content of the header may span more than one line:

```````````````````````````````` example
Foo *bar
baz*
====
.
<h1>Foo <em>bar
baz</em></h1>
````````````````````````````````

The contents are the result of parsing the headings's raw
content as inlines.  The heading's raw content is formed by
concatenating the lines and removing initial and final
[whitespace].

```````````````````````````````` example
  Foo *bar
baz*→
====
.
<h1>Foo <em>bar
baz</em></h1>
````````````````````````````````


The underlining can be any length:

```````````````````````````````` example
Foo
-------------------------

Foo
=
.
<h2>Foo</h2>
<h1>Foo</h1>
````````````````````````````````


The heading content can be indented up to three spaces, and need
not line up with the underlining:

```````````````````````````````` example
   Foo
---

  Foo
-----

  Foo
  ===
.
<h2>Foo</h2>
<h2>Foo</h2>
<h1>Foo</h1>
````````````````````````````````


Four spaces indent is too much:

```````````````````````````````` example
    Foo
    ---

    Foo
---
.
<pre><code>Foo
---

Foo
</code></pre>
<hr />
````````````````````````````````


The setext heading underline can be indented up to three spaces, and
may have trailing spaces:

```````````````````````````````` example
Foo
   ----      
.
<h2>Foo</h2>
````````````````````````````````


Four spaces is too much:

```````````````````````````````` example
Foo
    ---
.
<p>Foo
---</p>
````````````````````````````````


The setext heading underline cannot contain internal spaces:

```````````````````````````````` example
Foo
= =

Foo
--- -
.
<p>Foo
= =</p>
<p>Foo</p>
<hr />
````````````````````````````````


Trailing spaces in the content line do not cause a line break:

```````````````````````````````` example
Foo  
-----
.
<h2>Foo</h2>
````````````````````````````````


Nor does a backslash at the end:

```````````````````````````````` example
Foo\
----
.
<h2>Foo\</h2>
````````````````````````````````


Since indicators of block structure take precedence over
indicators of inline structure, the following are setext headings:

```````````````````````````````` example
`Foo
----
`

<a title="a lot
---
of dashes"/>
.
<h2>`Foo</h2>
<p>`</p>
<h2>&lt;a title=&quot;a lot</h2>
<p>of dashes&quot;/&gt;</p>
````````````````````````````````


The setext heading underline cannot be a [lazy continuation
line] in a list item or block quote:

```````````````````````````````` example
> Foo
---
.
<blockquote>
<p>Foo</p>
</blockquote>
<hr />
````````````````````````````````


```````````````````````````````` example
> foo
bar
===
.
<blockquote>
<p>foo
bar
===</p>
</blockquote>
````````````````````````````````


```````````````````````````````` example
- Foo
---
.
<ul>
<li>Foo</li>
</ul>
<hr />
````````````````````````````````


A blank line is needed between a paragraph and a following
setext heading, since otherwise the paragraph becomes part
of the heading's content:

```````````````````````````````` example
Foo
Bar
---
.
<h2>Foo
Bar</h2>
````````````````````````````````


But in general a blank line is not required before or after
setext headings:

```````````````````````````````` example
---
Foo
---
Bar
---
Baz
.
<hr />
<h2>Foo</h2>
<h2>Bar</h2>
<p>Baz</p>
````````````````````````````````


Setext headings cannot be empty:

```````````````````````````````` example

====
.
<p>====</p>
````````````````````````````````


Setext heading text lines must not be interpretable as block
constructs other than paragraphs.  So, the line of dashes
in these examples gets interpreted as a thematic break:

```````````````````````````````` example
---
---
.
<hr />
<hr />
````````````````````````````````


```````````````````````````````` example
- foo
-----
.
<ul>
<li>foo</li>
</ul>
<hr />
````````````````````````````````


```````````````````````````````` example
    foo
---
.
<pre><code>foo
</code></pre>
<hr />
````````````````````````````````


```````````````````````````````` example
> foo
-----
.
<blockquote>
<p>foo</p>
</blockquote>
<hr />
````````````````````````````````


If you want a heading with `> foo` as its literal text, you can
use backslash escapes:

```````````````````````````````` example
\> foo
------
.
<h2>&gt; foo</h2>
````````````````````````````````


**Compatibility note:**  Most existing Markdown implementations
do not allow the text of setext headings to span multiple lines.
But there is no consensus about how to interpret

``` markdown
Foo
bar
---
baz
```

One can find four different interpretations:

1. paragraph "Foo", heading "bar", paragraph "baz"
2. paragraph "Foo bar", thematic break, paragraph "baz"
3. paragraph "Foo bar --- baz"
4. heading "Foo bar", paragraph "baz"

We find interpretation 4 most natural, and interpretation 4
increases the expressive power of CommonMark, by allowing
multiline headings.  Authors who want interpretation 1 can
put a blank line after the first paragraph:

```````````````````````````````` example
Foo

bar
---
baz
.
<p>Foo</p>
<h2>bar</h2>
<p>baz</p>
````````````````````````````````


Authors who want interpretation 2 can put blank lines around
the thematic break,

```````````````````````````````` example
Foo
bar

---

baz
.
<p>Foo
bar</p>
<hr />
<p>baz</p>
````````````````````````````````


or use a thematic break that cannot count as a [setext heading
underline], such as

```````````````````````````````` example
Foo
bar
* * *
baz
.
<p>Foo
bar</p>
<hr />
<p>baz</p>
````````````````````````````````


Authors who want interpretation 3 can use backslash escapes:

```````````````````````````````` example
Foo
bar
\---
baz
.
<p>Foo
bar
---
baz</p>
````````````````````````````````


## Indented code blocks

An [indented code block](@) is composed of one or more
[indented chunks] separated by blank lines.
An [indented chunk](@) is a sequence of non-blank lines,
each indented four or more spaces. The contents of the code block are
the literal contents of the lines, including trailing
[line endings], minus four spaces of indentation.
An indented code block has no [info string].

An indented code block cannot interrupt a paragraph, so there must be
a blank line between a paragraph and a following indented code block.
(A blank line is not needed, however, between a code block and a following
paragraph.)

```````````````````````````````` example
    a simple
      indented code block
.
<pre><code>a simple
  indented code block
</code></pre>
````````````````````````````````


If there is any ambiguity between an interpretation of indentation
as a code block and as indicating that material belongs to a [list
item][list items], the list item interpretation takes precedence:

```````````````````````````````` example
  - foo

    bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
1.  foo

    - bar
.
<ol>
<li>
<p>foo</p>
<ul>
<li>bar</li>
</ul>
</li>
</ol>
````````````````````````````````



The contents of a code block are literal text, and do not get parsed
as Markdown:

```````````````````````````````` example
    <a/>
    *hi*

    - one
.
<pre><code>&lt;a/&gt;
*hi*

- one
</code></pre>
````````````````````````````````


Here we have three chunks separated by blank lines:

```````````````````````````````` example
    chunk1

    chunk2
  
 
 
    chunk3
.
<pre><code>chunk1

chunk2



chunk3
</code></pre>
````````````````````````````````


Any initial spaces beyond four will be included in the content, even
in interior blank lines:

```````````````````````````````` example
    chunk1
      
      chunk2
.
<pre><code>chunk1
  
  chunk2
</code></pre>
````````````````````````````````


An indented code block cannot interrupt a paragraph.  (This
allows hanging indents and the like.)

```````````````````````````````` example
Foo
    bar

.
<p>Foo
bar</p>
````````````````````````````````


However, any non-blank line with fewer than four leading spaces ends
the code block immediately.  So a paragraph may occur immediately
after indented code:

```````````````````````````````` example
    foo
bar
.
<pre><code>foo
</code></pre>
<p>bar</p>
````````````````````````````````


And indented code can occur immediately before and after other kinds of
blocks:

```````````````````````````````` example
# Heading
    foo
Heading
------
    foo
----
.
<h1>Heading</h1>
<pre><code>foo
</code></pre>
<h2>Heading</h2>
<pre><code>foo
</code></pre>
<hr />
````````````````````````````````


The first line can be indented more than four spaces:

```````````````````````````````` example
        foo
    bar
.
<pre><code>    foo
bar
</code></pre>
````````````````````````````````


Blank lines preceding or following an indented code block
are not included in it:

```````````````````````````````` example

    
    foo
    

.
<pre><code>foo
</code></pre>
````````````````````````````````


Trailing spaces are included in the code block's content:

```````````````````````````````` example
    foo  
.
<pre><code>foo  
</code></pre>
````````````````````````````````



## Fenced code blocks

A [code fence](@) is a sequence
of at least three consecutive backtick characters (`` ` ``) or
tildes (`~`).  (Tildes and backticks cannot be mixed.)
A [fenced code block](@)
begins with a code fence, indented no more than three spaces.

The line with the opening code fence may optionally contain some text
following the code fence; this is trimmed of leading and trailing
whitespace and called the [info string](@). If the [info string] comes
after a backtick fence, it may not contain any backtick
characters.  (The reason for this restriction is that otherwise
some inline code would be incorrectly interpreted as the
beginning of a fenced code block.)

The content of the code block consists of all subsequent lines, until
a closing [code fence] of the same type as the code block
began with (backticks or tildes), and with at least as many backticks
or tildes as the opening code fence.  If the leading code fence is
indented N spaces, then up to N spaces of indentation are removed from
each line of the content (if present).  (If a content line is not
indented, it is preserved unchanged.  If it is indented less than N
spaces, all of the indentation is removed.)

The closing code fence may be indented up to three spaces, and may be
followed only by spaces, which are ignored.  If the end of the
containing block (or document) is reached and no closing code fence
has been found, the code block contains all of the lines after the
opening code fence until the end of the containing block (or
document).  (An alternative spec would require backtracking in the
event that a closing code fence is not found.  But this makes parsing
much less efficient, and there seems to be no real down side to the
behavior described here.)

A fenced code block may interrupt a paragraph, and does not require
a blank line either before or after.

The content of a code fence is treated as literal text, not parsed
as inlines.  The first word of the [info string] is typically used to
specify the language of the code sample, and rendered in the `class`
attribute of the `code` tag.  However, this spec does not mandate any
particular treatment of the [info string].

Here is a simple example with backticks:

```````````````````````````````` example
```
<
 >
```
.
<pre><code>&lt;
 &gt;
</code></pre>
````````````````````````````````


With tildes:

```````````````````````````````` example
~~~
<
 >
~~~
.
<pre><code>&lt;
 &gt;
</code></pre>
````````````````````````````````

Fewer than three backticks is not enough:

```````````````````````````````` example
``
foo
``
.
<p><code>foo</code></p>
````````````````````````````````

The closing code fence must use the same character as the opening
fence:

```````````````````````````````` example
```
aaa
~~~
```
.
<pre><code>aaa
~~~
</code></pre>
````````````````````````````````


```````````````````````````````` example
~~~
aaa
```
~~~
.
<pre><code>aaa
```
</code></pre>
````````````````````````````````


The closing code fence must be at least as long as the opening fence:

```````````````````````````````` example
````
aaa
```
``````
.
<pre><code>aaa
```
</code></pre>
````````````````````````````````


```````````````````````````````` example
~~~~
aaa
~~~
~~~~
.
<pre><code>aaa
~~~
</code></pre>
````````````````````````````````


Unclosed code blocks are closed by the end of the document
(or the enclosing [block quote][block quotes] or [list item][list items]):

```````````````````````````````` example
```
.
<pre><code></code></pre>
````````````````````````````````


```````````````````````````````` example
`````

```
aaa
.
<pre><code>
```
aaa
</code></pre>
````````````````````````````````


```````````````````````````````` example
> ```
> aaa

bbb
.
<blockquote>
<pre><code>aaa
</code></pre>
</blockquote>
<p>bbb</p>
````````````````````````````````


A code block can have all empty lines as its content:

```````````````````````````````` example
```

  
```
.
<pre><code>
  
</code></pre>
````````````````````````````````


A code block can be empty:

```````````````````````````````` example
```
```
.
<pre><code></code></pre>
````````````````````````````````


Fences can be indented.  If the opening fence is indented,
content lines will have equivalent opening indentation removed,
if present:

```````````````````````````````` example
 ```
 aaa
aaa
```
.
<pre><code>aaa
aaa
</code></pre>
````````````````````````````````


```````````````````````````````` example
  ```
aaa
  aaa
aaa
  ```
.
<pre><code>aaa
aaa
aaa
</code></pre>
````````````````````````````````


```````````````````````````````` example
   ```
   aaa
    aaa
  aaa
   ```
.
<pre><code>aaa
 aaa
aaa
</code></pre>
````````````````````````````````


Four spaces indentation produces an indented code block:

```````````````````````````````` example
    ```
    aaa
    ```
.
<pre><code>```
aaa
```
</code></pre>
````````````````````````````````


Closing fences may be indented by 0-3 spaces, and their indentation
need not match that of the opening fence:

```````````````````````````````` example
```
aaa
  ```
.
<pre><code>aaa
</code></pre>
````````````````````````````````


```````````````````````````````` example
   ```
aaa
  ```
.
<pre><code>aaa
</code></pre>
````````````````````````````````


This is not a closing fence, because it is indented 4 spaces:

```````````````````````````````` example
```
aaa
    ```
.
<pre><code>aaa
    ```
</code></pre>
````````````````````````````````



Code fences (opening and closing) cannot contain internal spaces:

```````````````````````````````` example
``` ```
aaa
.
<p><code> </code>
aaa</p>
````````````````````````````````


```````````````````````````````` example
~~~~~~
aaa
~~~ ~~
.
<pre><code>aaa
~~~ ~~
</code></pre>
````````````````````````````````


Fenced code blocks can interrupt paragraphs, and can be followed
directly by paragraphs, without a blank line between:

```````````````````````````````` example
foo
```
bar
```
baz
.
<p>foo</p>
<pre><code>bar
</code></pre>
<p>baz</p>
````````````````````````````````


Other blocks can also occur before and after fenced code blocks
without an intervening blank line:

```````````````````````````````` example
foo
---
~~~
bar
~~~
# baz
.
<h2>foo</h2>
<pre><code>bar
</code></pre>
<h1>baz</h1>
````````````````````````````````


An [info string] can be provided after the opening code fence.
Although this spec doesn't mandate any particular treatment of
the info string, the first word is typically used to specify
the language of the code block. In HTML output, the language is
normally indicated by adding a class to the `code` element consisting
of `language-` followed by the language name.

```````````````````````````````` example
```ruby
def foo(x)
  return 3
end
```
.
<pre><code class="language-ruby">def foo(x)
  return 3
end
</code></pre>
````````````````````````````````


```````````````````````````````` example
~~~~    ruby startline=3 $%@#$
def foo(x)
  return 3
end
~~~~~~~
.
<pre><code class="language-ruby">def foo(x)
  return 3
end
</code></pre>
````````````````````````````````


```````````````````````````````` example
````;
````
.
<pre><code class="language-;"></code></pre>
````````````````````````````````


[Info strings] for backtick code blocks cannot contain backticks:

```````````````````````````````` example
``` aa ```
foo
.
<p><code>aa</code>
foo</p>
````````````````````````````````


[Info strings] for tilde code blocks can contain backticks and tildes:

```````````````````````````````` example
~~~ aa ``` ~~~
foo
~~~
.
<pre><code class="language-aa">foo
</code></pre>
````````````````````````````````


Closing code fences cannot have [info strings]:

```````````````````````````````` example
```
``` aaa
```
.
<pre><code>``` aaa
</code></pre>
````````````````````````````````



## HTML blocks

An [HTML block](@) is a group of lines that is treated
as raw HTML (and will not be escaped in HTML output).

There are seven kinds of [HTML block], which can be defined by their
start and end conditions.  The block begins with a line that meets a
[start condition](@) (after up to three spaces optional indentation).
It ends with the first subsequent line that meets a matching [end
condition](@), or the last line of the document, or the last line of
the [container block](#container-blocks) containing the current HTML
block, if no line is encountered that meets the [end condition].  If
the first line meets both the [start condition] and the [end
condition], the block will contain just that line.

1.  **Start condition:**  line begins with the string `<script`,
`<pre`, or `<style` (case-insensitive), followed by whitespace,
the string `>`, or the end of the line.\
**End condition:**  line contains an end tag
`</script>`, `</pre>`, or `</style>` (case-insensitive; it
need not match the start tag).

2.  **Start condition:** line begins with the string `<!--`.\
**End condition:**  line contains the string `-->`.

3.  **Start condition:** line begins with the string `<?`.\
**End condition:** line contains the string `?>`.

4.  **Start condition:** line begins with the string `<!`
followed by an uppercase ASCII letter.\
**End condition:** line contains the character `>`.

5.  **Start condition:**  line begins with the string
`<![CDATA[`.\
**End condition:** line contains the string `]]>`.

6.  **Start condition:** line begins the string `<` or `</`
followed by one of the strings (case-insensitive) `address`,
`article`, `aside`, `base`, `basefont`, `blockquote`, `body`,
`caption`, `center`, `col`, `colgroup`, `dd`, `details`, `dialog`,
`dir`, `div`, `dl`, `dt`, `fieldset`, `figcaption`, `figure`,
`footer`, `form`, `frame`, `frameset`,
`h1`, `h2`, `h3`, `h4`, `h5`, `h6`, `head`, `header`, `hr`,
`html`, `iframe`, `legend`, `li`, `link`, `main`, `menu`, `menuitem`,
`nav`, `noframes`, `ol`, `optgroup`, `option`, `p`, `param`,
`section`, `source`, `summary`, `table`, `tbody`, `td`,
`tfoot`, `th`, `thead`, `title`, `tr`, `track`, `ul`, followed
by [whitespace], the end of the line, the string `>`, or
the string `/>`.\
**End condition:** line is followed by a [blank line].

7.  **Start condition:**  line begins with a complete [open tag]
(with any [tag name] other than `script`,
`style`, or `pre`) or a complete [closing tag],
followed only by [whitespace] or the end of the line.\
**End condition:** line is followed by a [blank line].

HTML blocks continue until they are closed by their appropriate
[end condition], or the last line of the document or other [container
block](#container-blocks).  This means any HTML **within an HTML
block** that might otherwise be recognised as a start condition will
be ignored by the parser and passed through as-is, without changing
the parser's state.

For instance, `<pre>` within a HTML block started by `<table>` will not affect
the parser state; as the HTML block was started in by start condition 6, it
will end at any blank line. This can be surprising:

```````````````````````````````` example
<table><tr><td>
<pre>
**Hello**,

_world_.
</pre>
</td></tr></table>
.
<table><tr><td>
<pre>
**Hello**,
<p><em>world</em>.
</pre></p>
</td></tr></table>
````````````````````````````````

In this case, the HTML block is terminated by the newline — the `**Hello**`
text remains verbatim — and regular parsing resumes, with a paragraph,
emphasised `world` and inline and block HTML following.

All types of [HTML blocks] except type 7 may interrupt
a paragraph.  Blocks of type 7 may not interrupt a paragraph.
(This restriction is intended to prevent unwanted interpretation
of long tags inside a wrapped paragraph as starting HTML blocks.)

Some simple examples follow.  Here are some basic HTML blocks
of type 6:

```````````````````````````````` example
<table>
  <tr>
    <td>
           hi
    </td>
  </tr>
</table>

okay.
.
<table>
  <tr>
    <td>
           hi
    </td>
  </tr>
</table>
<p>okay.</p>
````````````````````````````````


```````````````````````````````` example
 <div>
  *hello*
         <foo><a>
.
 <div>
  *hello*
         <foo><a>
````````````````````````````````


A block can also start with a closing tag:

```````````````````````````````` example
</div>
*foo*
.
</div>
*foo*
````````````````````````````````


Here we have two HTML blocks with a Markdown paragraph between them:

```````````````````````````````` example
<DIV CLASS="foo">

*Markdown*

</DIV>
.
<DIV CLASS="foo">
<p><em>Markdown</em></p>
</DIV>
````````````````````````````````


The tag on the first line can be partial, as long
as it is split where there would be whitespace:

```````````````````````````````` example
<div id="foo"
  class="bar">
</div>
.
<div id="foo"
  class="bar">
</div>
````````````````````````````````


```````````````````````````````` example
<div id="foo" class="bar
  baz">
</div>
.
<div id="foo" class="bar
  baz">
</div>
````````````````````````````````


An open tag need not be closed:
```````````````````````````````` example
<div>
*foo*

*bar*
.
<div>
*foo*
<p><em>bar</em></p>
````````````````````````````````



A partial tag need not even be completed (garbage
in, garbage out):

```````````````````````````````` example
<div id="foo"
*hi*
.
<div id="foo"
*hi*
````````````````````````````````


```````````````````````````````` example
<div class
foo
.
<div class
foo
````````````````````````````````


The initial tag doesn't even need to be a valid
tag, as long as it starts like one:

```````````````````````````````` example
<div *???-&&&-<---
*foo*
.
<div *???-&&&-<---
*foo*
````````````````````````````````


In type 6 blocks, the initial tag need not be on a line by
itself:

```````````````````````````````` example
<div><a href="bar">*foo*</a></div>
.
<div><a href="bar">*foo*</a></div>
````````````````````````````````


```````````````````````````````` example
<table><tr><td>
foo
</td></tr></table>
.
<table><tr><td>
foo
</td></tr></table>
````````````````````````````````


Everything until the next blank line or end of document
gets included in the HTML block.  So, in the following
example, what looks like a Markdown code block
is actually part of the HTML block, which continues until a blank
line or the end of the document is reached:

```````````````````````````````` example
<div></div>
``` c
int x = 33;
```
.
<div></div>
``` c
int x = 33;
```
````````````````````````````````


To start an [HTML block] with a tag that is *not* in the
list of block-level tags in (6), you must put the tag by
itself on the first line (and it must be complete):

```````````````````````````````` example
<a href="foo">
*bar*
</a>
.
<a href="foo">
*bar*
</a>
````````````````````````````````


In type 7 blocks, the [tag name] can be anything:

```````````````````````````````` example
<Warning>
*bar*
</Warning>
.
<Warning>
*bar*
</Warning>
````````````````````````````````


```````````````````````````````` example
<i class="foo">
*bar*
</i>
.
<i class="foo">
*bar*
</i>
````````````````````````````````


```````````````````````````````` example
</ins>
*bar*
.
</ins>
*bar*
````````````````````````````````


These rules are designed to allow us to work with tags that
can function as either block-level or inline-level tags.
The `<del>` tag is a nice example.  We can surround content with
`<del>` tags in three different ways.  In this case, we get a raw
HTML block, because the `<del>` tag is on a line by itself:

```````````````````````````````` example
<del>
*foo*
</del>
.
<del>
*foo*
</del>
````````````````````````````````


In this case, we get a raw HTML block that just includes
the `<del>` tag (because it ends with the following blank
line).  So the contents get interpreted as CommonMark:

```````````````````````````````` example
<del>

*foo*

</del>
.
<del>
<p><em>foo</em></p>
</del>
````````````````````````````````


Finally, in this case, the `<del>` tags are interpreted
as [raw HTML] *inside* the CommonMark paragraph.  (Because
the tag is not on a line by itself, we get inline HTML
rather than an [HTML block].)

```````````````````````````````` example
<del>*foo*</del>
.
<p><del><em>foo</em></del></p>
````````````````````````````````


HTML tags designed to contain literal content
(`script`, `style`, `pre`), comments, processing instructions,
and declarations are treated somewhat differently.
Instead of ending at the first blank line, these blocks
end at the first line containing a corresponding end tag.
As a result, these blocks can contain blank lines:

A pre tag (type 1):

```````````````````````````````` example
<pre language="haskell"><code>
import Text.HTML.TagSoup

main :: IO ()
main = print $ parseTags tags
</code></pre>
okay
.
<pre language="haskell"><code>
import Text.HTML.TagSoup

main :: IO ()
main = print $ parseTags tags
</code></pre>
<p>okay</p>
````````````````````````````````


A script tag (type 1):

```````````````````````````````` example
<script type="text/javascript">
// JavaScript example

document.getElementById("demo").innerHTML = "Hello JavaScript!";
</script>
okay
.
<script type="text/javascript">
// JavaScript example

document.getElementById("demo").innerHTML = "Hello JavaScript!";
</script>
<p>okay</p>
````````````````````````````````


A style tag (type 1):

```````````````````````````````` example
<style
  type="text/css">
h1 {color:red;}

p {color:blue;}
</style>
okay
.
<style
  type="text/css">
h1 {color:red;}

p {color:blue;}
</style>
<p>okay</p>
````````````````````````````````


If there is no matching end tag, the block will end at the
end of the document (or the enclosing [block quote][block quotes]
or [list item][list items]):

```````````````````````````````` example
<style
  type="text/css">

foo
.
<style
  type="text/css">

foo
````````````````````````````````


```````````````````````````````` example
> <div>
> foo

bar
.
<blockquote>
<div>
foo
</blockquote>
<p>bar</p>
````````````````````````````````


```````````````````````````````` example
- <div>
- foo
.
<ul>
<li>
<div>
</li>
<li>foo</li>
</ul>
````````````````````````````````


The end tag can occur on the same line as the start tag:

```````````````````````````````` example
<style>p{color:red;}</style>
*foo*
.
<style>p{color:red;}</style>
<p><em>foo</em></p>
````````````````````````````````


```````````````````````````````` example
<!-- foo -->*bar*
*baz*
.
<!-- foo -->*bar*
<p><em>baz</em></p>
````````````````````````````````


Note that anything on the last line after the
end tag will be included in the [HTML block]:

```````````````````````````````` example
<script>
foo
</script>1. *bar*
.
<script>
foo
</script>1. *bar*
````````````````````````````````


A comment (type 2):

```````````````````````````````` example
<!-- Foo

bar
   baz -->
okay
.
<!-- Foo

bar
   baz -->
<p>okay</p>
````````````````````````````````



A processing instruction (type 3):

```````````````````````````````` example
<?php

  echo '>';

?>
okay
.
<?php

  echo '>';

?>
<p>okay</p>
````````````````````````````````


A declaration (type 4):

```````````````````````````````` example
<!DOCTYPE html>
.
<!DOCTYPE html>
````````````````````````````````


CDATA (type 5):

```````````````````````````````` example
<![CDATA[
function matchwo(a,b)
{
  if (a < b && a < 0) then {
    return 1;

  } else {

    return 0;
  }
}
]]>
okay
.
<![CDATA[
function matchwo(a,b)
{
  if (a < b && a < 0) then {
    return 1;

  } else {

    return 0;
  }
}
]]>
<p>okay</p>
````````````````````````````````


The opening tag can be indented 1-3 spaces, but not 4:

```````````````````````````````` example
  <!-- foo -->

    <!-- foo -->
.
  <!-- foo -->
<pre><code>&lt;!-- foo --&gt;
</code></pre>
````````````````````````````````


```````````````````````````````` example
  <div>

    <div>
.
  <div>
<pre><code>&lt;div&gt;
</code></pre>
````````````````````````````````


An HTML block of types 1--6 can interrupt a paragraph, and need not be
preceded by a blank line.

```````````````````````````````` example
Foo
<div>
bar
</div>
.
<p>Foo</p>
<div>
bar
</div>
````````````````````````````````


However, a following blank line is needed, except at the end of
a document, and except for blocks of types 1--5, [above][HTML
block]:

```````````````````````````````` example
<div>
bar
</div>
*foo*
.
<div>
bar
</div>
*foo*
````````````````````````````````


HTML blocks of type 7 cannot interrupt a paragraph:

```````````````````````````````` example
Foo
<a href="bar">
baz
.
<p>Foo
<a href="bar">
baz</p>
````````````````````````````````


This rule differs from John Gruber's original Markdown syntax
specification, which says:

> The only restrictions are that block-level HTML elements —
> e.g. `<div>`, `<table>`, `<pre>`, `<p>`, etc. — must be separated from
> surrounding content by blank lines, and the start and end tags of the
> block should not be indented with tabs or spaces.

In some ways Gruber's rule is more restrictive than the one given
here:

- It requires that an HTML block be preceded by a blank line.
- It does not allow the start tag to be indented.
- It requires a matching end tag, which it also does not allow to
  be indented.

Most Markdown implementations (including some of Gruber's own) do not
respect all of these restrictions.

There is one respect, however, in which Gruber's rule is more liberal
than the one given here, since it allows blank lines to occur inside
an HTML block.  There are two reasons for disallowing them here.
First, it removes the need to parse balanced tags, which is
expensive and can require backtracking from the end of the document
if no matching end tag is found. Second, it provides a very simple
and flexible way of including Markdown content inside HTML tags:
simply separate the Markdown from the HTML using blank lines:

Compare:

```````````````````````````````` example
<div>

*Emphasized* text.

</div>
.
<div>
<p><em>Emphasized</em> text.</p>
</div>
````````````````````````````````


```````````````````````````````` example
<div>
*Emphasized* text.
</div>
.
<div>
*Emphasized* text.
</div>
````````````````````````````````


Some Markdown implementations have adopted a convention of
interpreting content inside tags as text if the open tag has
the attribute `markdown=1`.  The rule given above seems a simpler and
more elegant way of achieving the same expressive power, which is also
much simpler to parse.

The main potential drawback is that one can no longer paste HTML
blocks into Markdown documents with 100% reliability.  However,
*in most cases* this will work fine, because the blank lines in
HTML are usually followed by HTML block tags.  For example:

```````````````````````````````` example
<table>

<tr>

<td>
Hi
</td>

</tr>

</table>
.
<table>
<tr>
<td>
Hi
</td>
</tr>
</table>
````````````````````````````````


There are problems, however, if the inner tags are indented
*and* separated by spaces, as then they will be interpreted as
an indented code block:

```````````````````````````````` example
<table>

  <tr>

    <td>
      Hi
    </td>

  </tr>

</table>
.
<table>
  <tr>
<pre><code>&lt;td&gt;
  Hi
&lt;/td&gt;
</code></pre>
  </tr>
</table>
````````````````````````````````


Fortunately, blank lines are usually not necessary and can be
deleted.  The exception is inside `<pre>` tags, but as described
[above][HTML blocks], raw HTML blocks starting with `<pre>`
*can* contain blank lines.

## Link reference definitions

A [link reference definition](@)
consists of a [link label], indented up to three spaces, followed
by a colon (`:`), optional [whitespace] (including up to one
[line ending]), a [link destination],
optional [whitespace] (including up to one
[line ending]), and an optional [link
title], which if it is present must be separated
from the [link destination] by [whitespace].
No further [non-whitespace characters] may occur on the line.

A [link reference definition]
does not correspond to a structural element of a document.  Instead, it
defines a label which can be used in [reference links]
and reference-style [images] elsewhere in the document.  [Link
reference definitions] can come either before or after the links that use
them.

```````````````````````````````` example
[foo]: /url "title"

[foo]
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


```````````````````````````````` example
   [foo]: 
      /url  
           'the title'  

[foo]
.
<p><a href="/url" title="the title">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[Foo*bar\]]:my_(url) 'title (with parens)'

[Foo*bar\]]
.
<p><a href="my_(url)" title="title (with parens)">Foo*bar]</a></p>
````````````````````````````````


```````````````````````````````` example
[Foo bar]:
<my url>
'title'

[Foo bar]
.
<p><a href="my%20url" title="title">Foo bar</a></p>
````````````````````````````````


The title may extend over multiple lines:

```````````````````````````````` example
[foo]: /url '
title
line1
line2
'

[foo]
.
<p><a href="/url" title="
title
line1
line2
">foo</a></p>
````````````````````````````````


However, it may not contain a [blank line]:

```````````````````````````````` example
[foo]: /url 'title

with blank line'

[foo]
.
<p>[foo]: /url 'title</p>
<p>with blank line'</p>
<p>[foo]</p>
````````````````````````````````


The title may be omitted:

```````````````````````````````` example
[foo]:
/url

[foo]
.
<p><a href="/url">foo</a></p>
````````````````````````````````


The link destination may not be omitted:

```````````````````````````````` example
[foo]:

[foo]
.
<p>[foo]:</p>
<p>[foo]</p>
````````````````````````````````

 However, an empty link destination may be specified using
 angle brackets:

```````````````````````````````` example
[foo]: <>

[foo]
.
<p><a href="">foo</a></p>
````````````````````````````````

The title must be separated from the link destination by
whitespace:

```````````````````````````````` example
[foo]: <bar>(baz)

[foo]
.
<p>[foo]: <bar>(baz)</p>
<p>[foo]</p>
````````````````````````````````


Both title and destination can contain backslash escapes
and literal backslashes:

```````````````````````````````` example
[foo]: /url\bar\*baz "foo\"bar\baz"

[foo]
.
<p><a href="/url%5Cbar*baz" title="foo&quot;bar\baz">foo</a></p>
````````````````````````````````


A link can come before its corresponding definition:

```````````````````````````````` example
[foo]

[foo]: url
.
<p><a href="url">foo</a></p>
````````````````````````````````


If there are several matching definitions, the first one takes
precedence:

```````````````````````````````` example
[foo]

[foo]: first
[foo]: second
.
<p><a href="first">foo</a></p>
````````````````````````````````


As noted in the section on [Links], matching of labels is
case-insensitive (see [matches]).

```````````````````````````````` example
[FOO]: /url

[Foo]
.
<p><a href="/url">Foo</a></p>
````````````````````````````````


```````````````````````````````` example
[ΑΓΩ]: /φου

[αγω]
.
<p><a href="/%CF%86%CE%BF%CF%85">αγω</a></p>
````````````````````````````````


Here is a link reference definition with no corresponding link.
It contributes nothing to the document.

```````````````````````````````` example
[foo]: /url
.
````````````````````````````````


Here is another one:

```````````````````````````````` example
[
foo
]: /url
bar
.
<p>bar</p>
````````````````````````````````


This is not a link reference definition, because there are
[non-whitespace characters] after the title:

```````````````````````````````` example
[foo]: /url "title" ok
.
<p>[foo]: /url &quot;title&quot; ok</p>
````````````````````````````````


This is a link reference definition, but it has no title:

```````````````````````````````` example
[foo]: /url
"title" ok
.
<p>&quot;title&quot; ok</p>
````````````````````````````````


This is not a link reference definition, because it is indented
four spaces:

```````````````````````````````` example
    [foo]: /url "title"

[foo]
.
<pre><code>[foo]: /url &quot;title&quot;
</code></pre>
<p>[foo]</p>
````````````````````````````````


This is not a link reference definition, because it occurs inside
a code block:

```````````````````````````````` example
```
[foo]: /url
```

[foo]
.
<pre><code>[foo]: /url
</code></pre>
<p>[foo]</p>
````````````````````````````````


A [link reference definition] cannot interrupt a paragraph.

```````````````````````````````` example
Foo
[bar]: /baz

[bar]
.
<p>Foo
[bar]: /baz</p>
<p>[bar]</p>
````````````````````````````````


However, it can directly follow other block elements, such as headings
and thematic breaks, and it need not be followed by a blank line.

```````````````````````````````` example
# [Foo]
[foo]: /url
> bar
.
<h1><a href="/url">Foo</a></h1>
<blockquote>
<p>bar</p>
</blockquote>
````````````````````````````````

```````````````````````````````` example
[foo]: /url
bar
===
[foo]
.
<h1>bar</h1>
<p><a href="/url">foo</a></p>
````````````````````````````````

```````````````````````````````` example
[foo]: /url
===
[foo]
.
<p>===
<a href="/url">foo</a></p>
````````````````````````````````


Several [link reference definitions]
can occur one after another, without intervening blank lines.

```````````````````````````````` example
[foo]: /foo-url "foo"
[bar]: /bar-url
  "bar"
[baz]: /baz-url

[foo],
[bar],
[baz]
.
<p><a href="/foo-url" title="foo">foo</a>,
<a href="/bar-url" title="bar">bar</a>,
<a href="/baz-url">baz</a></p>
````````````````````````````````


[Link reference definitions] can occur
inside block containers, like lists and block quotations.  They
affect the entire document, not just the container in which they
are defined:

```````````````````````````````` example
[foo]

> [foo]: /url
.
<p><a href="/url">foo</a></p>
<blockquote>
</blockquote>
````````````````````````````````


Whether something is a [link reference definition] is
independent of whether the link reference it defines is
used in the document.  Thus, for example, the following
document contains just a link reference definition, and
no visible content:

```````````````````````````````` example
[foo]: /url
.
````````````````````````````````


## Paragraphs

A sequence of non-blank lines that cannot be interpreted as other
kinds of blocks forms a [paragraph](@).
The contents of the paragraph are the result of parsing the
paragraph's raw content as inlines.  The paragraph's raw content
is formed by concatenating the lines and removing initial and final
[whitespace].

A simple example with two paragraphs:

```````````````````````````````` example
aaa

bbb
.
<p>aaa</p>
<p>bbb</p>
````````````````````````````````


Paragraphs can contain multiple lines, but no blank lines:

```````````````````````````````` example
aaa
bbb

ccc
ddd
.
<p>aaa
bbb</p>
<p>ccc
ddd</p>
````````````````````````````````


Multiple blank lines between paragraph have no effect:

```````````````````````````````` example
aaa


bbb
.
<p>aaa</p>
<p>bbb</p>
````````````````````````````````


Leading spaces are skipped:

```````````````````````````````` example
  aaa
 bbb
.
<p>aaa
bbb</p>
````````````````````````````````


Lines after the first may be indented any amount, since indented
code blocks cannot interrupt paragraphs.

```````````````````````````````` example
aaa
             bbb
                                       ccc
.
<p>aaa
bbb
ccc</p>
````````````````````````````````


However, the first line may be indented at most three spaces,
or an indented code block will be triggered:

```````````````````````````````` example
   aaa
bbb
.
<p>aaa
bbb</p>
````````````````````````````````


```````````````````````````````` example
    aaa
bbb
.
<pre><code>aaa
</code></pre>
<p>bbb</p>
````````````````````````````````


Final spaces are stripped before inline parsing, so a paragraph
that ends with two or more spaces will not end with a [hard line
break]:

```````````````````````````````` example
aaa     
bbb     
.
<p>aaa<br />
bbb</p>
````````````````````````````````


## Blank lines

[Blank lines] between block-level elements are ignored,
except for the role they play in determining whether a [list]
is [tight] or [loose].

Blank lines at the beginning and end of the document are also ignored.

```````````````````````````````` example
  

aaa
  

# aaa

  
.
<p>aaa</p>
<h1>aaa</h1>
````````````````````````````````



# Container blocks

A [container block](#container-blocks) is a block that has other
blocks as its contents.  There are two basic kinds of container blocks:
[block quotes] and [list items].
[Lists] are meta-containers for [list items].

We define the syntax for container blocks recursively.  The general
form of the definition is:

> If X is a sequence of blocks, then the result of
> transforming X in such-and-such a way is a container of type Y
> with these blocks as its content.

So, we explain what counts as a block quote or list item by explaining
how these can be *generated* from their contents. This should suffice
to define the syntax, although it does not give a recipe for *parsing*
these constructions.  (A recipe is provided below in the section entitled
[A parsing strategy](#appendix-a-parsing-strategy).)

## Block quotes

A [block quote marker](@)
consists of 0-3 spaces of initial indent, plus (a) the character `>` together
with a following space, or (b) a single character `>` not followed by a space.

The following rules define [block quotes]:

1.  **Basic case.**  If a string of lines *Ls* constitute a sequence
    of blocks *Bs*, then the result of prepending a [block quote
    marker] to the beginning of each line in *Ls*
    is a [block quote](#block-quotes) containing *Bs*.

2.  **Laziness.**  If a string of lines *Ls* constitute a [block
    quote](#block-quotes) with contents *Bs*, then the result of deleting
    the initial [block quote marker] from one or
    more lines in which the next [non-whitespace character] after the [block
    quote marker] is [paragraph continuation
    text] is a block quote with *Bs* as its content.
    [Paragraph continuation text](@) is text
    that will be parsed as part of the content of a paragraph, but does
    not occur at the beginning of the paragraph.

3.  **Consecutiveness.**  A document cannot contain two [block
    quotes] in a row unless there is a [blank line] between them.

Nothing else counts as a [block quote](#block-quotes).

Here is a simple example:

```````````````````````````````` example
> # Foo
> bar
> baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


The spaces after the `>` characters can be omitted:

```````````````````````````````` example
># Foo
>bar
> baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


The `>` characters can be indented 1-3 spaces:

```````````````````````````````` example
   > # Foo
   > bar
 > baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


Four spaces gives us a code block:

```````````````````````````````` example
    > # Foo
    > bar
    > baz
.
<pre><code>&gt; # Foo
&gt; bar
&gt; baz
</code></pre>
````````````````````````````````


The Laziness clause allows us to omit the `>` before
[paragraph continuation text]:

```````````````````````````````` example
> # Foo
> bar
baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


A block quote can contain some lazy and some non-lazy
continuation lines:

```````````````````````````````` example
> bar
baz
> foo
.
<blockquote>
<p>bar
baz
foo</p>
</blockquote>
````````````````````````````````


Laziness only applies to lines that would have been continuations of
paragraphs had they been prepended with [block quote markers].
For example, the `> ` cannot be omitted in the second line of

``` markdown
> foo
> ---
```

without changing the meaning:

```````````````````````````````` example
> foo
---
.
<blockquote>
<p>foo</p>
</blockquote>
<hr />
````````````````````````````````


Similarly, if we omit the `> ` in the second line of

``` markdown
> - foo
> - bar
```

then the block quote ends after the first line:

```````````````````````````````` example
> - foo
- bar
.
<blockquote>
<ul>
<li>foo</li>
</ul>
</blockquote>
<ul>
<li>bar</li>
</ul>
````````````````````````````````


For the same reason, we can't omit the `> ` in front of
subsequent lines of an indented or fenced code block:

```````````````````````````````` example
>     foo
    bar
.
<blockquote>
<pre><code>foo
</code></pre>
</blockquote>
<pre><code>bar
</code></pre>
````````````````````````````````


```````````````````````````````` example
> ```
foo
```
.
<blockquote>
<pre><code></code></pre>
</blockquote>
<p>foo</p>
<pre><code></code></pre>
````````````````````````````````


Note that in the following case, we have a [lazy
continuation line]:

```````````````````````````````` example
> foo
    - bar
.
<blockquote>
<p>foo
- bar</p>
</blockquote>
````````````````````````````````


To see why, note that in

```markdown
> foo
>     - bar
```

the `- bar` is indented too far to start a list, and can't
be an indented code block because indented code blocks cannot
interrupt paragraphs, so it is [paragraph continuation text].

A block quote can be empty:

```````````````````````````````` example
>
.
<blockquote>
</blockquote>
````````````````````````````````


```````````````````````````````` example
>
>  
> 
.
<blockquote>
</blockquote>
````````````````````````````````


A block quote can have initial or final blank lines:

```````````````````````````````` example
>
> foo
>  
.
<blockquote>
<p>foo</p>
</blockquote>
````````````````````````````````


A blank line always separates block quotes:

```````````````````````````````` example
> foo

> bar
.
<blockquote>
<p>foo</p>
</blockquote>
<blockquote>
<p>bar</p>
</blockquote>
````````````````````````````````


(Most current Markdown implementations, including John Gruber's
original `Markdown.pl`, will parse this example as a single block quote
with two paragraphs.  But it seems better to allow the author to decide
whether two block quotes or one are wanted.)

Consecutiveness means that if we put these block quotes together,
we get a single block quote:

```````````````````````````````` example
> foo
> bar
.
<blockquote>
<p>foo
bar</p>
</blockquote>
````````````````````````````````


To get a block quote with two paragraphs, use:

```````````````````````````````` example
> foo
>
> bar
.
<blockquote>
<p>foo</p>
<p>bar</p>
</blockquote>
````````````````````````````````


Block quotes can interrupt paragraphs:

```````````````````````````````` example
foo
> bar
.
<p>foo</p>
<blockquote>
<p>bar</p>
</blockquote>
````````````````````````````````


In general, blank lines are not needed before or after block
quotes:

```````````````````````````````` example
> aaa
***
> bbb
.
<blockquote>
<p>aaa</p>
</blockquote>
<hr />
<blockquote>
<p>bbb</p>
</blockquote>
````````````````````````````````


However, because of laziness, a blank line is needed between
a block quote and a following paragraph:

```````````````````````````````` example
> bar
baz
.
<blockquote>
<p>bar
baz</p>
</blockquote>
````````````````````````````````


```````````````````````````````` example
> bar

baz
.
<blockquote>
<p>bar</p>
</blockquote>
<p>baz</p>
````````````````````````````````


```````````````````````````````` example
> bar
>
baz
.
<blockquote>
<p>bar</p>
</blockquote>
<p>baz</p>
````````````````````````````````


It is a consequence of the Laziness rule that any number
of initial `>`s may be omitted on a continuation line of a
nested block quote:

```````````````````````````````` example
> > > foo
bar
.
<blockquote>
<blockquote>
<blockquote>
<p>foo
bar</p>
</blockquote>
</blockquote>
</blockquote>
````````````````````````````````


```````````````````````````````` example
>>> foo
> bar
>>baz
.
<blockquote>
<blockquote>
<blockquote>
<p>foo
bar
baz</p>
</blockquote>
</blockquote>
</blockquote>
````````````````````````````````


When including an indented code block in a block quote,
remember that the [block quote marker] includes
both the `>` and a following space.  So *five spaces* are needed after
the `>`:

```````````````````````````````` example
>     code

>    not code
.
<blockquote>
<pre><code>code
</code></pre>
</blockquote>
<blockquote>
<p>not code</p>
</blockquote>
````````````````````````````````



## List items

A [list marker](@) is a
[bullet list marker] or an [ordered list marker].

A [bullet list marker](@)
is a `-`, `+`, or `*` character.

An [ordered list marker](@)
is a sequence of 1--9 arabic digits (`0-9`), followed by either a
`.` character or a `)` character.  (The reason for the length
limit is that with 10 digits we start seeing integer overflows
in some browsers.)

The following rules define [list items]:

1.  **Basic case.**  If a sequence of lines *Ls* constitute a sequence of
    blocks *Bs* starting with a [non-whitespace character], and *M* is a
    list marker of width *W* followed by 1 ≤ *N* ≤ 4 spaces, then the result
    of prepending *M* and the following spaces to the first line of
    *Ls*, and indenting subsequent lines of *Ls* by *W + N* spaces, is a
    list item with *Bs* as its contents.  The type of the list item
    (bullet or ordered) is determined by the type of its list marker.
    If the list item is ordered, then it is also assigned a start
    number, based on the ordered list marker.

    Exceptions:

    1. When the first list item in a [list] interrupts
       a paragraph---that is, when it starts on a line that would
       otherwise count as [paragraph continuation text]---then (a)
       the lines *Ls* must not begin with a blank line, and (b) if
       the list item is ordered, the start number must be 1.
    2. If any line is a [thematic break][thematic breaks] then
       that line is not a list item.

For example, let *Ls* be the lines

```````````````````````````````` example
A paragraph
with two lines.

    indented code

> A block quote.
.
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
````````````````````````````````


And let *M* be the marker `1.`, and *N* = 2.  Then rule #1 says
that the following is an ordered list item with start number 1,
and the same contents as *Ls*:

```````````````````````````````` example
1.  A paragraph
    with two lines.

        indented code

    > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


The most important thing to notice is that the position of
the text after the list marker determines how much indentation
is needed in subsequent blocks in the list item.  If the list
marker takes up two spaces, and there are three spaces between
the list marker and the next [non-whitespace character], then blocks
must be indented five spaces in order to fall under the list
item.

Here are some examples showing how far content must be indented to be
put under the list item:

```````````````````````````````` example
- one

 two
.
<ul>
<li>one</li>
</ul>
<p>two</p>
````````````````````````````````


```````````````````````````````` example
- one

  two
.
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
 -    one

     two
.
<ul>
<li>one</li>
</ul>
<pre><code> two
</code></pre>
````````````````````````````````


```````````````````````````````` example
 -    one

      two
.
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
````````````````````````````````


It is tempting to think of this in terms of columns:  the continuation
blocks must be indented at least to the column of the first
[non-whitespace character] after the list marker. However, that is not quite right.
The spaces after the list marker determine how much relative indentation
is needed.  Which column this indentation reaches will depend on
how the list item is embedded in other constructions, as shown by
this example:

```````````````````````````````` example
   > > 1.  one
>>
>>     two
.
<blockquote>
<blockquote>
<ol>
<li>
<p>one</p>
<p>two</p>
</li>
</ol>
</blockquote>
</blockquote>
````````````````````````````````


Here `two` occurs in the same column as the list marker `1.`,
but is actually contained in the list item, because there is
sufficient indentation after the last containing blockquote marker.

The converse is also possible.  In the following example, the word `two`
occurs far to the right of the initial text of the list item, `one`, but
it is not considered part of the list item, because it is not indented
far enough past the blockquote marker:

```````````````````````````````` example
>>- one
>>
  >  > two
.
<blockquote>
<blockquote>
<ul>
<li>one</li>
</ul>
<p>two</p>
</blockquote>
</blockquote>
````````````````````````````````


Note that at least one space is needed between the list marker and
any following content, so these are not list items:

```````````````````````````````` example
-one

2.two
.
<p>-one</p>
<p>2.two</p>
````````````````````````````````


A list item may contain blocks that are separated by more than
one blank line.

```````````````````````````````` example
- foo


  bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
````````````````````````````````


A list item may contain any kind of block:

```````````````````````````````` example
1.  foo

    ```
    bar
    ```

    baz

    > bam
.
<ol>
<li>
<p>foo</p>
<pre><code>bar
</code></pre>
<p>baz</p>
<blockquote>
<p>bam</p>
</blockquote>
</li>
</ol>
````````````````````````````````


A list item that contains an indented code block will preserve
empty lines within the code block verbatim.

```````````````````````````````` example
- Foo

      bar


      baz
.
<ul>
<li>
<p>Foo</p>
<pre><code>bar


baz
</code></pre>
</li>
</ul>
````````````````````````````````

Note that ordered list start numbers must be nine digits or less:

```````````````````````````````` example
123456789. ok
.
<ol start="123456789">
<li>ok</li>
</ol>
````````````````````````````````


```````````````````````````````` example
1234567890. not ok
.
<p>1234567890. not ok</p>
````````````````````````````````


A start number may begin with 0s:

```````````````````````````````` example
0. ok
.
<ol start="0">
<li>ok</li>
</ol>
````````````````````````````````


```````````````````````````````` example
003. ok
.
<ol start="3">
<li>ok</li>
</ol>
````````````````````````````````


A start number may not be negative:

```````````````````````````````` example
-1. not ok
.
<p>-1. not ok</p>
````````````````````````````````



2.  **Item starting with indented code.**  If a sequence of lines *Ls*
    constitute a sequence of blocks *Bs* starting with an indented code
    block, and *M* is a list marker of width *W* followed by
    one space, then the result of prepending *M* and the following
    space to the first line of *Ls*, and indenting subsequent lines of
    *Ls* by *W + 1* spaces, is a list item with *Bs* as its contents.
    If a line is empty, then it need not be indented.  The type of the
    list item (bullet or ordered) is determined by the type of its list
    marker.  If the list item is ordered, then it is also assigned a
    start number, based on the ordered list marker.

An indented code block will have to be indented four spaces beyond
the edge of the region where text will be included in the list item.
In the following case that is 6 spaces:

```````````````````````````````` example
- foo

      bar
.
<ul>
<li>
<p>foo</p>
<pre><code>bar
</code></pre>
</li>
</ul>
````````````````````````````````


And in this case it is 11 spaces:

```````````````````````````````` example
  10.  foo

           bar
.
<ol start="10">
<li>
<p>foo</p>
<pre><code>bar
</code></pre>
</li>
</ol>
````````````````````````````````


If the *first* block in the list item is an indented code block,
then by rule #2, the contents must be indented *one* space after the
list marker:

```````````````````````````````` example
    indented code

paragraph

    more code
.
<pre><code>indented code
</code></pre>
<p>paragraph</p>
<pre><code>more code
</code></pre>
````````````````````````````````


```````````````````````````````` example
1.     indented code

   paragraph

       more code
.
<ol>
<li>
<pre><code>indented code
</code></pre>
<p>paragraph</p>
<pre><code>more code
</code></pre>
</li>
</ol>
````````````````````````````````


Note that an additional space indent is interpreted as space
inside the code block:

```````````````````````````````` example
1.      indented code

   paragraph

       more code
.
<ol>
<li>
<pre><code> indented code
</code></pre>
<p>paragraph</p>
<pre><code>more code
</code></pre>
</li>
</ol>
````````````````````````````````


Note that rules #1 and #2 only apply to two cases:  (a) cases
in which the lines to be included in a list item begin with a
[non-whitespace character], and (b) cases in which
they begin with an indented code
block.  In a case like the following, where the first block begins with
a three-space indent, the rules do not allow us to form a list item by
indenting the whole thing and prepending a list marker:

```````````````````````````````` example
   foo

bar
.
<p>foo</p>
<p>bar</p>
````````````````````````````````


```````````````````````````````` example
-    foo

  bar
.
<ul>
<li>foo</li>
</ul>
<p>bar</p>
````````````````````````````````


This is not a significant restriction, because when a block begins
with 1-3 spaces indent, the indentation can always be removed without
a change in interpretation, allowing rule #1 to be applied.  So, in
the above case:

```````````````````````````````` example
-  foo

   bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
````````````````````````````````


3.  **Item starting with a blank line.**  If a sequence of lines *Ls*
    starting with a single [blank line] constitute a (possibly empty)
    sequence of blocks *Bs*, not separated from each other by more than
    one blank line, and *M* is a list marker of width *W*,
    then the result of prepending *M* to the first line of *Ls*, and
    indenting subsequent lines of *Ls* by *W + 1* spaces, is a list
    item with *Bs* as its contents.
    If a line is empty, then it need not be indented.  The type of the
    list item (bullet or ordered) is determined by the type of its list
    marker.  If the list item is ordered, then it is also assigned a
    start number, based on the ordered list marker.

Here are some list items that start with a blank line but are not empty:

```````````````````````````````` example
-
  foo
-
  ```
  bar
  ```
-
      baz
.
<ul>
<li>foo</li>
<li>
<pre><code>bar
</code></pre>
</li>
<li>
<pre><code>baz
</code></pre>
</li>
</ul>
````````````````````````````````

When the list item starts with a blank line, the number of spaces
following the list marker doesn't change the required indentation:

```````````````````````````````` example
-   
  foo
.
<ul>
<li>foo</li>
</ul>
````````````````````````````````


A list item can begin with at most one blank line.
In the following example, `foo` is not part of the list
item:

```````````````````````````````` example
-

  foo
.
<ul>
<li></li>
</ul>
<p>foo</p>
````````````````````````````````


Here is an empty bullet list item:

```````````````````````````````` example
- foo
-
- bar
.
<ul>
<li>foo</li>
<li></li>
<li>bar</li>
</ul>
````````````````````````````````


It does not matter whether there are spaces following the [list marker]:

```````````````````````````````` example
- foo
-   
- bar
.
<ul>
<li>foo</li>
<li></li>
<li>bar</li>
</ul>
````````````````````````````````


Here is an empty ordered list item:

```````````````````````````````` example
1. foo
2.
3. bar
.
<ol>
<li>foo</li>
<li></li>
<li>bar</li>
</ol>
````````````````````````````````


A list may start or end with an empty list item:

```````````````````````````````` example
*
.
<ul>
<li></li>
</ul>
````````````````````````````````

However, an empty list item cannot interrupt a paragraph:

```````````````````````````````` example
foo
*

foo
1.
.
<p>foo
*</p>
<p>foo
1.</p>
````````````````````````````````


4.  **Indentation.**  If a sequence of lines *Ls* constitutes a list item
    according to rule #1, #2, or #3, then the result of indenting each line
    of *Ls* by 1-3 spaces (the same for each line) also constitutes a
    list item with the same contents and attributes.  If a line is
    empty, then it need not be indented.

Indented one space:

```````````````````````````````` example
 1.  A paragraph
     with two lines.

         indented code

     > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


Indented two spaces:

```````````````````````````````` example
  1.  A paragraph
      with two lines.

          indented code

      > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


Indented three spaces:

```````````````````````````````` example
   1.  A paragraph
       with two lines.

           indented code

       > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


Four spaces indent gives a code block:

```````````````````````````````` example
    1.  A paragraph
        with two lines.

            indented code

        > A block quote.
.
<pre><code>1.  A paragraph
    with two lines.

        indented code

    &gt; A block quote.
</code></pre>
````````````````````````````````



5.  **Laziness.**  If a string of lines *Ls* constitute a [list
    item](#list-items) with contents *Bs*, then the result of deleting
    some or all of the indentation from one or more lines in which the
    next [non-whitespace character] after the indentation is
    [paragraph continuation text] is a
    list item with the same contents and attributes.  The unindented
    lines are called
    [lazy continuation line](@)s.

Here is an example with [lazy continuation lines]:

```````````````````````````````` example
  1.  A paragraph
with two lines.

          indented code

      > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
````````````````````````````````


Indentation can be partially deleted:

```````````````````````````````` example
  1.  A paragraph
    with two lines.
.
<ol>
<li>A paragraph
with two lines.</li>
</ol>
````````````````````````````````


These examples show how laziness can work in nested structures:

```````````````````````````````` example
> 1. > Blockquote
continued here.
.
<blockquote>
<ol>
<li>
<blockquote>
<p>Blockquote
continued here.</p>
</blockquote>
</li>
</ol>
</blockquote>
````````````````````````````````


```````````````````````````````` example
> 1. > Blockquote
> continued here.
.
<blockquote>
<ol>
<li>
<blockquote>
<p>Blockquote
continued here.</p>
</blockquote>
</li>
</ol>
</blockquote>
````````````````````````````````



6.  **That's all.** Nothing that is not counted as a list item by rules
    #1--5 counts as a [list item](#list-items).

The rules for sublists follow from the general rules
[above][List items].  A sublist must be indented the same number
of spaces a paragraph would need to be in order to be included
in the list item.

So, in this case we need two spaces indent:

```````````````````````````````` example
- foo
  - bar
    - baz
      - boo
.
<ul>
<li>foo
<ul>
<li>bar
<ul>
<li>baz
<ul>
<li>boo</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
````````````````````````````````


One is not enough:

```````````````````````````````` example
- foo
 - bar
  - baz
   - boo
.
<ul>
<li>foo</li>
<li>bar</li>
<li>baz</li>
<li>boo</li>
</ul>
````````````````````````````````


Here we need four, because the list marker is wider:

```````````````````````````````` example
10) foo
    - bar
.
<ol start="10">
<li>foo
<ul>
<li>bar</li>
</ul>
</li>
</ol>
````````````````````````````````


Three is not enough:

```````````````````````````````` example
10) foo
   - bar
.
<ol start="10">
<li>foo</li>
</ol>
<ul>
<li>bar</li>
</ul>
````````````````````````````````


A list may be the first block in a list item:

```````````````````````````````` example
- - foo
.
<ul>
<li>
<ul>
<li>foo</li>
</ul>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
1. - 2. foo
.
<ol>
<li>
<ul>
<li>
<ol start="2">
<li>foo</li>
</ol>
</li>
</ul>
</li>
</ol>
````````````````````````````````


A list item can contain a heading:

```````````````````````````````` example
- # Foo
- Bar
  ---
  baz
.
<ul>
<li>
<h1>Foo</h1>
</li>
<li>
<h2>Bar</h2>
baz</li>
</ul>
````````````````````````````````


### Motivation

John Gruber's Markdown spec says the following about list items:

1. "List markers typically start at the left margin, but may be indented
   by up to three spaces. List markers must be followed by one or more
   spaces or a tab."

2. "To make lists look nice, you can wrap items with hanging indents....
   But if you don't want to, you don't have to."

3. "List items may consist of multiple paragraphs. Each subsequent
   paragraph in a list item must be indented by either 4 spaces or one
   tab."

4. "It looks nice if you indent every line of the subsequent paragraphs,
   but here again, Markdown will allow you to be lazy."

5. "To put a blockquote within a list item, the blockquote's `>`
   delimiters need to be indented."

6. "To put a code block within a list item, the code block needs to be
   indented twice — 8 spaces or two tabs."

These rules specify that a paragraph under a list item must be indented
four spaces (presumably, from the left margin, rather than the start of
the list marker, but this is not said), and that code under a list item
must be indented eight spaces instead of the usual four.  They also say
that a block quote must be indented, but not by how much; however, the
example given has four spaces indentation.  Although nothing is said
about other kinds of block-level content, it is certainly reasonable to
infer that *all* block elements under a list item, including other
lists, must be indented four spaces.  This principle has been called the
*four-space rule*.

The four-space rule is clear and principled, and if the reference
implementation `Markdown.pl` had followed it, it probably would have
become the standard.  However, `Markdown.pl` allowed paragraphs and
sublists to start with only two spaces indentation, at least on the
outer level.  Worse, its behavior was inconsistent: a sublist of an
outer-level list needed two spaces indentation, but a sublist of this
sublist needed three spaces.  It is not surprising, then, that different
implementations of Markdown have developed very different rules for
determining what comes under a list item.  (Pandoc and python-Markdown,
for example, stuck with Gruber's syntax description and the four-space
rule, while discount, redcarpet, marked, PHP Markdown, and others
followed `Markdown.pl`'s behavior more closely.)

Unfortunately, given the divergences between implementations, there
is no way to give a spec for list items that will be guaranteed not
to break any existing documents.  However, the spec given here should
correctly handle lists formatted with either the four-space rule or
the more forgiving `Markdown.pl` behavior, provided they are laid out
in a way that is natural for a human to read.

The strategy here is to let the width and indentation of the list marker
determine the indentation necessary for blocks to fall under the list
item, rather than having a fixed and arbitrary number.  The writer can
think of the body of the list item as a unit which gets indented to the
right enough to fit the list marker (and any indentation on the list
marker).  (The laziness rule, #5, then allows continuation lines to be
unindented if needed.)

This rule is superior, we claim, to any rule requiring a fixed level of
indentation from the margin.  The four-space rule is clear but
unnatural. It is quite unintuitive that

``` markdown
- foo

  bar

  - baz
```

should be parsed as two lists with an intervening paragraph,

``` html
<ul>
<li>foo</li>
</ul>
<p>bar</p>
<ul>
<li>baz</li>
</ul>
```

as the four-space rule demands, rather than a single list,

``` html
<ul>
<li>
<p>foo</p>
<p>bar</p>
<ul>
<li>baz</li>
</ul>
</li>
</ul>
```

The choice of four spaces is arbitrary.  It can be learned, but it is
not likely to be guessed, and it trips up beginners regularly.

Would it help to adopt a two-space rule?  The problem is that such
a rule, together with the rule allowing 1--3 spaces indentation of the
initial list marker, allows text that is indented *less than* the
original list marker to be included in the list item. For example,
`Markdown.pl` parses

``` markdown
   - one

  two
```

as a single list item, with `two` a continuation paragraph:

``` html
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
```

and similarly

``` markdown
>   - one
>
>  two
```

as

``` html
<blockquote>
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
</blockquote>
```

This is extremely unintuitive.

Rather than requiring a fixed indent from the margin, we could require
a fixed indent (say, two spaces, or even one space) from the list marker (which
may itself be indented).  This proposal would remove the last anomaly
discussed.  Unlike the spec presented above, it would count the following
as a list item with a subparagraph, even though the paragraph `bar`
is not indented as far as the first paragraph `foo`:

``` markdown
 10. foo

   bar  
```

Arguably this text does read like a list item with `bar` as a subparagraph,
which may count in favor of the proposal.  However, on this proposal indented
code would have to be indented six spaces after the list marker.  And this
would break a lot of existing Markdown, which has the pattern:

``` markdown
1.  foo

        indented code
```

where the code is indented eight spaces.  The spec above, by contrast, will
parse this text as expected, since the code block's indentation is measured
from the beginning of `foo`.

The one case that needs special treatment is a list item that *starts*
with indented code.  How much indentation is required in that case, since
we don't have a "first paragraph" to measure from?  Rule #2 simply stipulates
that in such cases, we require one space indentation from the list marker
(and then the normal four spaces for the indented code).  This will match the
four-space rule in cases where the list marker plus its initial indentation
takes four spaces (a common case), but diverge in other cases.

## Lists

A [list](@) is a sequence of one or more
list items [of the same type].  The list items
may be separated by any number of blank lines.

Two list items are [of the same type](@)
if they begin with a [list marker] of the same type.
Two list markers are of the
same type if (a) they are bullet list markers using the same character
(`-`, `+`, or `*`) or (b) they are ordered list numbers with the same
delimiter (either `.` or `)`).

A list is an [ordered list](@)
if its constituent list items begin with
[ordered list markers], and a
[bullet list](@) if its constituent list
items begin with [bullet list markers].

The [start number](@)
of an [ordered list] is determined by the list number of
its initial list item.  The numbers of subsequent list items are
disregarded.

A list is [loose](@) if any of its constituent
list items are separated by blank lines, or if any of its constituent
list items directly contain two block-level elements with a blank line
between them.  Otherwise a list is [tight](@).
(The difference in HTML output is that paragraphs in a loose list are
wrapped in `<p>` tags, while paragraphs in a tight list are not.)

Changing the bullet or ordered list delimiter starts a new list:

```````````````````````````````` example
- foo
- bar
+ baz
.
<ul>
<li>foo</li>
<li>bar</li>
</ul>
<ul>
<li>baz</li>
</ul>
````````````````````````````````


```````````````````````````````` example
1. foo
2. bar
3) baz
.
<ol>
<li>foo</li>
<li>bar</li>
</ol>
<ol start="3">
<li>baz</li>
</ol>
````````````````````````````````


In CommonMark, a list can interrupt a paragraph. That is,
no blank line is needed to separate a paragraph from a following
list:

```````````````````````````````` example
Foo
- bar
- baz
.
<p>Foo</p>
<ul>
<li>bar</li>
<li>baz</li>
</ul>
````````````````````````````````

`Markdown.pl` does not allow this, through fear of triggering a list
via a numeral in a hard-wrapped line:

``` markdown
The number of windows in my house is
14.  The number of doors is 6.
```

Oddly, though, `Markdown.pl` *does* allow a blockquote to
interrupt a paragraph, even though the same considerations might
apply.

In CommonMark, we do allow lists to interrupt paragraphs, for
two reasons.  First, it is natural and not uncommon for people
to start lists without blank lines:

``` markdown
I need to buy
- new shoes
- a coat
- a plane ticket
```

Second, we are attracted to a

> [principle of uniformity](@):
> if a chunk of text has a certain
> meaning, it will continue to have the same meaning when put into a
> container block (such as a list item or blockquote).

(Indeed, the spec for [list items] and [block quotes] presupposes
this principle.) This principle implies that if

``` markdown
  * I need to buy
    - new shoes
    - a coat
    - a plane ticket
```

is a list item containing a paragraph followed by a nested sublist,
as all Markdown implementations agree it is (though the paragraph
may be rendered without `<p>` tags, since the list is "tight"),
then

``` markdown
I need to buy
- new shoes
- a coat
- a plane ticket
```

by itself should be a paragraph followed by a nested sublist.

Since it is well established Markdown practice to allow lists to
interrupt paragraphs inside list items, the [principle of
uniformity] requires us to allow this outside list items as
well.  ([reStructuredText](http://docutils.sourceforge.net/rst.html)
takes a different approach, requiring blank lines before lists
even inside other list items.)

In order to solve of unwanted lists in paragraphs with
hard-wrapped numerals, we allow only lists starting with `1` to
interrupt paragraphs.  Thus,

```````````````````````````````` example
The number of windows in my house is
14.  The number of doors is 6.
.
<p>The number of windows in my house is
14.  The number of doors is 6.</p>
````````````````````````````````

We may still get an unintended result in cases like

```````````````````````````````` example
The number of windows in my house is
1.  The number of doors is 6.
.
<p>The number of windows in my house is</p>
<ol>
<li>The number of doors is 6.</li>
</ol>
````````````````````````````````

but this rule should prevent most spurious list captures.

There can be any number of blank lines between items:

```````````````````````````````` example
- foo

- bar


- baz
.
<ul>
<li>
<p>foo</p>
</li>
<li>
<p>bar</p>
</li>
<li>
<p>baz</p>
</li>
</ul>
````````````````````````````````

```````````````````````````````` example
- foo
  - bar
    - baz


      bim
.
<ul>
<li>foo
<ul>
<li>bar
<ul>
<li>
<p>baz</p>
<p>bim</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
````````````````````````````````


To separate consecutive lists of the same type, or to separate a
list from an indented code block that would otherwise be parsed
as a subparagraph of the final list item, you can insert a blank HTML
comment:

```````````````````````````````` example
- foo
- bar

<!-- -->

- baz
- bim
.
<ul>
<li>foo</li>
<li>bar</li>
</ul>
<!-- -->
<ul>
<li>baz</li>
<li>bim</li>
</ul>
````````````````````````````````


```````````````````````````````` example
-   foo

    notcode

-   foo

<!-- -->

    code
.
<ul>
<li>
<p>foo</p>
<p>notcode</p>
</li>
<li>
<p>foo</p>
</li>
</ul>
<!-- -->
<pre><code>code
</code></pre>
````````````````````````````````


List items need not be indented to the same level.  The following
list items will be treated as items at the same list level,
since none is indented enough to belong to the previous list
item:

```````````````````````````````` example
- a
 - b
  - c
   - d
  - e
 - f
- g
.
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
<li>d</li>
<li>e</li>
<li>f</li>
<li>g</li>
</ul>
````````````````````````````````


```````````````````````````````` example
1. a

  2. b

   3. c
.
<ol>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
<li>
<p>c</p>
</li>
</ol>
````````````````````````````````

Note, however, that list items may not be indented more than
three spaces.  Here `- e` is treated as a paragraph continuation
line, because it is indented more than three spaces:

```````````````````````````````` example
- a
 - b
  - c
   - d
    - e
.
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
<li>d
- e</li>
</ul>
````````````````````````````````

And here, `3. c` is treated as in indented code block,
because it is indented four spaces and preceded by a
blank line.

```````````````````````````````` example
1. a

  2. b

    3. c
.
<ol>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
</ol>
<pre><code>3. c
</code></pre>
````````````````````````````````


This is a loose list, because there is a blank line between
two of the list items:

```````````````````````````````` example
- a
- b

- c
.
<ul>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
<li>
<p>c</p>
</li>
</ul>
````````````````````````````````


So is this, with a empty second item:

```````````````````````````````` example
* a
*

* c
.
<ul>
<li>
<p>a</p>
</li>
<li></li>
<li>
<p>c</p>
</li>
</ul>
````````````````````````````````


These are loose lists, even though there is no space between the items,
because one of the items directly contains two block-level elements
with a blank line between them:

```````````````````````````````` example
- a
- b

  c
- d
.
<ul>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
<p>c</p>
</li>
<li>
<p>d</p>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
- a
- b

  [ref]: /url
- d
.
<ul>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
<li>
<p>d</p>
</li>
</ul>
````````````````````````````````


This is a tight list, because the blank lines are in a code block:

```````````````````````````````` example
- a
- ```
  b


  ```
- c
.
<ul>
<li>a</li>
<li>
<pre><code>b


</code></pre>
</li>
<li>c</li>
</ul>
````````````````````````````````


This is a tight list, because the blank line is between two
paragraphs of a sublist.  So the sublist is loose while
the outer list is tight:

```````````````````````````````` example
- a
  - b

    c
- d
.
<ul>
<li>a
<ul>
<li>
<p>b</p>
<p>c</p>
</li>
</ul>
</li>
<li>d</li>
</ul>
````````````````````````````````


This is a tight list, because the blank line is inside the
block quote:

```````````````````````````````` example
* a
  > b
  >
* c
.
<ul>
<li>a
<blockquote>
<p>b</p>
</blockquote>
</li>
<li>c</li>
</ul>
````````````````````````````````


This list is tight, because the consecutive block elements
are not separated by blank lines:

```````````````````````````````` example
- a
  > b
  ```
  c
  ```
- d
.
<ul>
<li>a
<blockquote>
<p>b</p>
</blockquote>
<pre><code>c
</code></pre>
</li>
<li>d</li>
</ul>
````````````````````````````````


A single-paragraph list is tight:

```````````````````````````````` example
- a
.
<ul>
<li>a</li>
</ul>
````````````````````````````````


```````````````````````````````` example
- a
  - b
.
<ul>
<li>a
<ul>
<li>b</li>
</ul>
</li>
</ul>
````````````````````````````````


This list is loose, because of the blank line between the
two block elements in the list item:

```````````````````````````````` example
1. ```
   foo
   ```

   bar
.
<ol>
<li>
<pre><code>foo
</code></pre>
<p>bar</p>
</li>
</ol>
````````````````````````````````


Here the outer list is loose, the inner list tight:

```````````````````````````````` example
* foo
  * bar

  baz
.
<ul>
<li>
<p>foo</p>
<ul>
<li>bar</li>
</ul>
<p>baz</p>
</li>
</ul>
````````````````````````````````


```````````````````````````````` example
- a
  - b
  - c

- d
  - e
  - f
.
<ul>
<li>
<p>a</p>
<ul>
<li>b</li>
<li>c</li>
</ul>
</li>
<li>
<p>d</p>
<ul>
<li>e</li>
<li>f</li>
</ul>
</li>
</ul>
````````````````````````````````


# Inlines

Inlines are parsed sequentially from the beginning of the character
stream to the end (left to right, in left-to-right languages).
Thus, for example, in

```````````````````````````````` example
`hi`lo`
.
<p><code>hi</code>lo`</p>
````````````````````````````````

`hi` is parsed as code, leaving the backtick at the end as a literal
backtick.


## Backslash escapes

Any ASCII punctuation character may be backslash-escaped:

```````````````````````````````` example
\!\"\#\$\%\&\'\(\)\*\+\,\-\.\/\:\;\<\=\>\?\@\[\\\]\^\_\`\{\|\}\~
.
<p>!&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~</p>
````````````````````````````````


Backslashes before other characters are treated as literal
backslashes:

```````````````````````````````` example
\→\A\a\ \3\φ\«
.
<p>\→\A\a\ \3\φ\«</p>
````````````````````````````````


Escaped characters are treated as regular characters and do
not have their usual Markdown meanings:

```````````````````````````````` example
\*not emphasized*
\<br/> not a tag
\[not a link](/foo)
\`not code`
1\. not a list
\* not a list
\# not a heading
\[foo]: /url "not a reference"
\&ouml; not a character entity
.
<p>*not emphasized*
&lt;br/&gt; not a tag
[not a link](/foo)
`not code`
1. not a list
* not a list
# not a heading
[foo]: /url &quot;not a reference&quot;
&amp;ouml; not a character entity</p>
````````````````````````````````


If a backslash is itself escaped, the following character is not:

```````````````````````````````` example
\\*emphasis*
.
<p>\<em>emphasis</em></p>
````````````````````````````````


A backslash at the end of the line is a [hard line break]:

```````````````````````````````` example
foo\
bar
.
<p>foo<br />
bar</p>
````````````````````````````````


Backslash escapes do not work in code blocks, code spans, autolinks, or
raw HTML:

```````````````````````````````` example
`` \[\` ``
.
<p><code>\[\`</code></p>
````````````````````````````````


```````````````````````````````` example
    \[\]
.
<pre><code>\[\]
</code></pre>
````````````````````````````````


```````````````````````````````` example
~~~
\[\]
~~~
.
<pre><code>\[\]
</code></pre>
````````````````````````````````


```````````````````````````````` example
<http://example.com?find=\*>
.
<p><a href="http://example.com?find=%5C*">http://example.com?find=\*</a></p>
````````````````````````````````


```````````````````````````````` example
<a href="/bar\/)">
.
<a href="/bar\/)">
````````````````````````````````


But they work in all other contexts, including URLs and link titles,
link references, and [info strings] in [fenced code blocks]:

```````````````````````````````` example
[foo](/bar\* "ti\*tle")
.
<p><a href="/bar*" title="ti*tle">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[foo]

[foo]: /bar\* "ti\*tle"
.
<p><a href="/bar*" title="ti*tle">foo</a></p>
````````````````````````````````


```````````````````````````````` example
``` foo\+bar
foo
```
.
<pre><code class="language-foo+bar">foo
</code></pre>
````````````````````````````````



## Entity and numeric character references

Valid HTML entity references and numeric character references
can be used in place of the corresponding Unicode character,
with the following exceptions:

- Entity and character references are not recognized in code
  blocks and code spans.

- Entity and character references cannot stand in place of
  special characters that define structural elements in
  CommonMark.  For example, although `&#42;` can be used
  in place of a literal `*` character, `&#42;` cannot replace
  `*` in emphasis delimiters, bullet list markers, or thematic
  breaks.

Conforming CommonMark parsers need not store information about
whether a particular character was represented in the source
using a Unicode character or an entity reference.

[Entity references](@) consist of `&` + any of the valid
HTML5 entity names + `;`. The
document <https://html.spec.whatwg.org/multipage/entities.json>
is used as an authoritative source for the valid entity
references and their corresponding code points.

```````````````````````````````` example
&nbsp; &amp; &copy; &AElig; &Dcaron;
&frac34; &HilbertSpace; &DifferentialD;
&ClockwiseContourIntegral; &ngE;
.
<p>  &amp; © Æ Ď
¾ ℋ ⅆ
∲ ≧̸</p>
````````````````````````````````


[Decimal numeric character
references](@)
consist of `&#` + a string of 1--7 arabic digits + `;`. A
numeric character reference is parsed as the corresponding
Unicode character. Invalid Unicode code points will be replaced by
the REPLACEMENT CHARACTER (`U+FFFD`).  For security reasons,
the code point `U+0000` will also be replaced by `U+FFFD`.

```````````````````````````````` example
&#35; &#1234; &#992; &#0;
.
<p># Ӓ Ϡ �</p>
````````````````````````````````


[Hexadecimal numeric character
references](@) consist of `&#` +
either `X` or `x` + a string of 1-6 hexadecimal digits + `;`.
They too are parsed as the corresponding Unicode character (this
time specified with a hexadecimal numeral instead of decimal).

```````````````````````````````` example
&#X22; &#XD06; &#xcab;
.
<p>&quot; ആ ಫ</p>
````````````````````````````````


Here are some nonentities:

```````````````````````````````` example
&nbsp &x; &#; &#x;
&#87654321;
&#abcdef0;
&ThisIsNotDefined; &hi?;
.
<p>&amp;nbsp &amp;x; &amp;#; &amp;#x;
&amp;#87654321;
&amp;#abcdef0;
&amp;ThisIsNotDefined; &amp;hi?;</p>
````````````````````````````````


Although HTML5 does accept some entity references
without a trailing semicolon (such as `&copy`), these are not
recognized here, because it makes the grammar too ambiguous:

```````````````````````````````` example
&copy
.
<p>&amp;copy</p>
````````````````````````````````


Strings that are not on the list of HTML5 named entities are not
recognized as entity references either:

```````````````````````````````` example
&MadeUpEntity;
.
<p>&amp;MadeUpEntity;</p>
````````````````````````````````


Entity and numeric character references are recognized in any
context besides code spans or code blocks, including
URLs, [link titles], and [fenced code block][] [info strings]:

```````````````````````````````` example
<a href="&ouml;&ouml;.html">
.
<a href="&ouml;&ouml;.html">
````````````````````````````````


```````````````````````````````` example
[foo](/f&ouml;&ouml; "f&ouml;&ouml;")
.
<p><a href="/f%C3%B6%C3%B6" title="föö">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[foo]

[foo]: /f&ouml;&ouml; "f&ouml;&ouml;"
.
<p><a href="/f%C3%B6%C3%B6" title="föö">foo</a></p>
````````````````````````````````


```````````````````````````````` example
``` f&ouml;&ouml;
foo
```
.
<pre><code class="language-föö">foo
</code></pre>
````````````````````````````````


Entity and numeric character references are treated as literal
text in code spans and code blocks:

```````````````````````````````` example
`f&ouml;&ouml;`
.
<p><code>f&amp;ouml;&amp;ouml;</code></p>
````````````````````````````````


```````````````````````````````` example
    f&ouml;f&ouml;
.
<pre><code>f&amp;ouml;f&amp;ouml;
</code></pre>
````````````````````````````````


Entity and numeric character references cannot be used
in place of symbols indicating structure in CommonMark
documents.

```````````````````````````````` example
&#42;foo&#42;
*foo*
.
<p>*foo*
<em>foo</em></p>
````````````````````````````````

```````````````````````````````` example
&#42; foo

* foo
.
<p>* foo</p>
<ul>
<li>foo</li>
</ul>
````````````````````````````````

```````````````````````````````` example
foo&#10;&#10;bar
.
<p>foo

bar</p>
````````````````````````````````

```````````````````````````````` example
&#9;foo
.
<p>→foo</p>
````````````````````````````````


```````````````````````````````` example
[a](url &quot;tit&quot;)
.
<p>[a](url &quot;tit&quot;)</p>
````````````````````````````````


## Code spans

A [backtick string](@)
is a string of one or more backtick characters (`` ` ``) that is neither
preceded nor followed by a backtick.

A [code span](@) begins with a backtick string and ends with
a backtick string of equal length.  The contents of the code span are
the characters between the two backtick strings, normalized in the
following ways:

- First, [line endings] are converted to [spaces].
- If the resulting string both begins *and* ends with a [space]
  character, but does not consist entirely of [space]
  characters, a single [space] character is removed from the
  front and back.  This allows you to include code that begins
  or ends with backtick characters, which must be separated by
  whitespace from the opening or closing backtick strings.

This is a simple code span:

```````````````````````````````` example
`foo`
.
<p><code>foo</code></p>
````````````````````````````````


Here two backticks are used, because the code contains a backtick.
This example also illustrates stripping of a single leading and
trailing space:

```````````````````````````````` example
`` foo ` bar ``
.
<p><code>foo ` bar</code></p>
````````````````````````````````


This example shows the motivation for stripping leading and trailing
spaces:

```````````````````````````````` example
` `` `
.
<p><code>``</code></p>
````````````````````````````````

Note that only *one* space is stripped:

```````````````````````````````` example
`  ``  `
.
<p><code> `` </code></p>
````````````````````````````````

The stripping only happens if the space is on both
sides of the string:

```````````````````````````````` example
` a`
.
<p><code> a</code></p>
````````````````````````````````

Only [spaces], and not [unicode whitespace] in general, are
stripped in this way:

```````````````````````````````` example
` b `
.
<p><code> b </code></p>
````````````````````````````````

No stripping occurs if the code span contains only spaces:

```````````````````````````````` example
` `
`  `
.
<p><code> </code>
<code>  </code></p>
````````````````````````````````


[Line endings] are treated like spaces:

```````````````````````````````` example
``
foo
bar  
baz
``
.
<p><code>foo bar   baz</code></p>
````````````````````````````````

```````````````````````````````` example
``
foo 
``
.
<p><code>foo </code></p>
````````````````````````````````


Interior spaces are not collapsed:

```````````````````````````````` example
`foo   bar 
baz`
.
<p><code>foo   bar  baz</code></p>
````````````````````````````````

Note that browsers will typically collapse consecutive spaces
when rendering `<code>` elements, so it is recommended that
the following CSS be used:

    code{white-space: pre-wrap;}


Note that backslash escapes do not work in code spans. All backslashes
are treated literally:

```````````````````````````````` example
`foo\`bar`
.
<p><code>foo\</code>bar`</p>
````````````````````````````````


Backslash escapes are never needed, because one can always choose a
string of *n* backtick characters as delimiters, where the code does
not contain any strings of exactly *n* backtick characters.

```````````````````````````````` example
``foo`bar``
.
<p><code>foo`bar</code></p>
````````````````````````````````

```````````````````````````````` example
` foo `` bar `
.
<p><code>foo `` bar</code></p>
````````````````````````````````


Code span backticks have higher precedence than any other inline
constructs except HTML tags and autolinks.  Thus, for example, this is
not parsed as emphasized text, since the second `*` is part of a code
span:

```````````````````````````````` example
*foo`*`
.
<p>*foo<code>*</code></p>
````````````````````````````````


And this is not parsed as a link:

```````````````````````````````` example
[not a `link](/foo`)
.
<p>[not a <code>link](/foo</code>)</p>
````````````````````````````````


Code spans, HTML tags, and autolinks have the same precedence.
Thus, this is code:

```````````````````````````````` example
`<a href="`">`
.
<p><code>&lt;a href=&quot;</code>&quot;&gt;`</p>
````````````````````````````````


But this is an HTML tag:

```````````````````````````````` example
<a href="`">`
.
<p><a href="`">`</p>
````````````````````````````````


And this is code:

```````````````````````````````` example
`<http://foo.bar.`baz>`
.
<p><code>&lt;http://foo.bar.</code>baz&gt;`</p>
````````````````````````````````


But this is an autolink:

```````````````````````````````` example
<http://foo.bar.`baz>`
.
<p><a href="http://foo.bar.%60baz">http://foo.bar.`baz</a>`</p>
````````````````````````````````


When a backtick string is not closed by a matching backtick string,
we just have literal backticks:

```````````````````````````````` example
```foo``
.
<p>```foo``</p>
````````````````````````````````


```````````````````````````````` example
`foo
.
<p>`foo</p>
````````````````````````````````

The following case also illustrates the need for opening and
closing backtick strings to be equal in length:

```````````````````````````````` example
`foo``bar``
.
<p>`foo<code>bar</code></p>
````````````````````````````````


## Emphasis and strong emphasis

John Gruber's original [Markdown syntax
description](http://daringfireball.net/projects/markdown/syntax#em) says:

> Markdown treats asterisks (`*`) and underscores (`_`) as indicators of
> emphasis. Text wrapped with one `*` or `_` will be wrapped with an HTML
> `<em>` tag; double `*`'s or `_`'s will be wrapped with an HTML `<strong>`
> tag.

This is enough for most users, but these rules leave much undecided,
especially when it comes to nested emphasis.  The original
`Markdown.pl` test suite makes it clear that triple `***` and
`___` delimiters can be used for strong emphasis, and most
implementations have also allowed the following patterns:

``` markdown
***strong emph***
***strong** in emph*
***emph* in strong**
**in strong *emph***
*in emph **strong***
```

The following patterns are less widely supported, but the intent
is clear and they are useful (especially in contexts like bibliography
entries):

``` markdown
*emph *with emph* in it*
**strong **with strong** in it**
```

Many implementations have also restricted intraword emphasis to
the `*` forms, to avoid unwanted emphasis in words containing
internal underscores.  (It is best practice to put these in code
spans, but users often do not.)

``` markdown
internal emphasis: foo*bar*baz
no emphasis: foo_bar_baz
```

The rules given below capture all of these patterns, while allowing
for efficient parsing strategies that do not backtrack.

First, some definitions.  A [delimiter run](@) is either
a sequence of one or more `*` characters that is not preceded or
followed by a non-backslash-escaped `*` character, or a sequence
of one or more `_` characters that is not preceded or followed by
a non-backslash-escaped `_` character.

A [left-flanking delimiter run](@) is
a [delimiter run] that is (1) not followed by [Unicode whitespace],
and either (2a) not followed by a [punctuation character], or
(2b) followed by a [punctuation character] and
preceded by [Unicode whitespace] or a [punctuation character].
For purposes of this definition, the beginning and the end of
the line count as Unicode whitespace.

A [right-flanking delimiter run](@) is
a [delimiter run] that is (1) not preceded by [Unicode whitespace],
and either (2a) not preceded by a [punctuation character], or
(2b) preceded by a [punctuation character] and
followed by [Unicode whitespace] or a [punctuation character].
For purposes of this definition, the beginning and the end of
the line count as Unicode whitespace.

Here are some examples of delimiter runs.

  - left-flanking but not right-flanking:

    ```
    ***abc
      _abc
    **"abc"
     _"abc"
    ```

  - right-flanking but not left-flanking:

    ```
     abc***
     abc_
    "abc"**
    "abc"_
    ```

  - Both left and right-flanking:

    ```
     abc***def
    "abc"_"def"
    ```

  - Neither left nor right-flanking:

    ```
    abc *** def
    a _ b
    ```

(The idea of distinguishing left-flanking and right-flanking
delimiter runs based on the character before and the character
after comes from Roopesh Chander's
[vfmd](http://www.vfmd.org/vfmd-spec/specification/#procedure-for-identifying-emphasis-tags).
vfmd uses the terminology "emphasis indicator string" instead of "delimiter
run," and its rules for distinguishing left- and right-flanking runs
are a bit more complex than the ones given here.)

The following rules define emphasis and strong emphasis:

1.  A single `*` character [can open emphasis](@)
    iff (if and only if) it is part of a [left-flanking delimiter run].

2.  A single `_` character [can open emphasis] iff
    it is part of a [left-flanking delimiter run]
    and either (a) not part of a [right-flanking delimiter run]
    or (b) part of a [right-flanking delimiter run]
    preceded by punctuation.

3.  A single `*` character [can close emphasis](@)
    iff it is part of a [right-flanking delimiter run].

4.  A single `_` character [can close emphasis] iff
    it is part of a [right-flanking delimiter run]
    and either (a) not part of a [left-flanking delimiter run]
    or (b) part of a [left-flanking delimiter run]
    followed by punctuation.

5.  A double `**` [can open strong emphasis](@)
    iff it is part of a [left-flanking delimiter run].

6.  A double `__` [can open strong emphasis] iff
    it is part of a [left-flanking delimiter run]
    and either (a) not part of a [right-flanking delimiter run]
    or (b) part of a [right-flanking delimiter run]
    preceded by punctuation.

7.  A double `**` [can close strong emphasis](@)
    iff it is part of a [right-flanking delimiter run].

8.  A double `__` [can close strong emphasis] iff
    it is part of a [right-flanking delimiter run]
    and either (a) not part of a [left-flanking delimiter run]
    or (b) part of a [left-flanking delimiter run]
    followed by punctuation.

9.  Emphasis begins with a delimiter that [can open emphasis] and ends
    with a delimiter that [can close emphasis], and that uses the same
    character (`_` or `*`) as the opening delimiter.  The
    opening and closing delimiters must belong to separate
    [delimiter runs].  If one of the delimiters can both
    open and close emphasis, then the sum of the lengths of the
    delimiter runs containing the opening and closing delimiters
    must not be a multiple of 3 unless both lengths are
    multiples of 3.

10. Strong emphasis begins with a delimiter that
    [can open strong emphasis] and ends with a delimiter that
    [can close strong emphasis], and that uses the same character
    (`_` or `*`) as the opening delimiter.  The
    opening and closing delimiters must belong to separate
    [delimiter runs].  If one of the delimiters can both open
    and close strong emphasis, then the sum of the lengths of
    the delimiter runs containing the opening and closing
    delimiters must not be a multiple of 3 unless both lengths
    are multiples of 3.

11. A literal `*` character cannot occur at the beginning or end of
    `*`-delimited emphasis or `**`-delimited strong emphasis, unless it
    is backslash-escaped.

12. A literal `_` character cannot occur at the beginning or end of
    `_`-delimited emphasis or `__`-delimited strong emphasis, unless it
    is backslash-escaped.

Where rules 1--12 above are compatible with multiple parsings,
the following principles resolve ambiguity:

13. The number of nestings should be minimized. Thus, for example,
    an interpretation `<strong>...</strong>` is always preferred to
    `<em><em>...</em></em>`.

14. An interpretation `<em><strong>...</strong></em>` is always
    preferred to `<strong><em>...</em></strong>`.

15. When two potential emphasis or strong emphasis spans overlap,
    so that the second begins before the first ends and ends after
    the first ends, the first takes precedence. Thus, for example,
    `*foo _bar* baz_` is parsed as `<em>foo _bar</em> baz_` rather
    than `*foo <em>bar* baz</em>`.

16. When there are two potential emphasis or strong emphasis spans
    with the same closing delimiter, the shorter one (the one that
    opens later) takes precedence. Thus, for example,
    `**foo **bar baz**` is parsed as `**foo <strong>bar baz</strong>`
    rather than `<strong>foo **bar baz</strong>`.

17. Inline code spans, links, images, and HTML tags group more tightly
    than emphasis.  So, when there is a choice between an interpretation
    that contains one of these elements and one that does not, the
    former always wins.  Thus, for example, `*[foo*](bar)` is
    parsed as `*<a href="bar">foo*</a>` rather than as
    `<em>[foo</em>](bar)`.

These rules can be illustrated through a series of examples.

Rule 1:

```````````````````````````````` example
*foo bar*
.
<p><em>foo bar</em></p>
````````````````````````````````


This is not emphasis, because the opening `*` is followed by
whitespace, and hence not part of a [left-flanking delimiter run]:

```````````````````````````````` example
a * foo bar*
.
<p>a * foo bar*</p>
````````````````````````````````


This is not emphasis, because the opening `*` is preceded
by an alphanumeric and followed by punctuation, and hence
not part of a [left-flanking delimiter run]:

```````````````````````````````` example
a*"foo"*
.
<p>a*&quot;foo&quot;*</p>
````````````````````````````````


Unicode nonbreaking spaces count as whitespace, too:

```````````````````````````````` example
* a *
.
<p>* a *</p>
````````````````````````````````


Intraword emphasis with `*` is permitted:

```````````````````````````````` example
foo*bar*
.
<p>foo<em>bar</em></p>
````````````````````````````````


```````````````````````````````` example
5*6*78
.
<p>5<em>6</em>78</p>
````````````````````````````````


Rule 2:

```````````````````````````````` example
_foo bar_
.
<p><em>foo bar</em></p>
````````````````````````````````


This is not emphasis, because the opening `_` is followed by
whitespace:

```````````````````````````````` example
_ foo bar_
.
<p>_ foo bar_</p>
````````````````````````````````


This is not emphasis, because the opening `_` is preceded
by an alphanumeric and followed by punctuation:

```````````````````````````````` example
a_"foo"_
.
<p>a_&quot;foo&quot;_</p>
````````````````````````````````


Emphasis with `_` is not allowed inside words:

```````````````````````````````` example
foo_bar_
.
<p>foo_bar_</p>
````````````````````````````````


```````````````````````````````` example
5_6_78
.
<p>5_6_78</p>
````````````````````````````````


```````````````````````````````` example
пристаням_стремятся_
.
<p>пристаням_стремятся_</p>
````````````````````````````````


Here `_` does not generate emphasis, because the first delimiter run
is right-flanking and the second left-flanking:

```````````````````````````````` example
aa_"bb"_cc
.
<p>aa_&quot;bb&quot;_cc</p>
````````````````````````````````


This is emphasis, even though the opening delimiter is
both left- and right-flanking, because it is preceded by
punctuation:

```````````````````````````````` example
foo-_(bar)_
.
<p>foo-<em>(bar)</em></p>
````````````````````````````````


Rule 3:

This is not emphasis, because the closing delimiter does
not match the opening delimiter:

```````````````````````````````` example
_foo*
.
<p>_foo*</p>
````````````````````````````````


This is not emphasis, because the closing `*` is preceded by
whitespace:

```````````````````````````````` example
*foo bar *
.
<p>*foo bar *</p>
````````````````````````````````


A newline also counts as whitespace:

```````````````````````````````` example
*foo bar
*
.
<p>*foo bar
*</p>
````````````````````````````````


This is not emphasis, because the second `*` is
preceded by punctuation and followed by an alphanumeric
(hence it is not part of a [right-flanking delimiter run]:

```````````````````````````````` example
*(*foo)
.
<p>*(*foo)</p>
````````````````````````````````


The point of this restriction is more easily appreciated
with this example:

```````````````````````````````` example
*(*foo*)*
.
<p><em>(<em>foo</em>)</em></p>
````````````````````````````````


Intraword emphasis with `*` is allowed:

```````````````````````````````` example
*foo*bar
.
<p><em>foo</em>bar</p>
````````````````````````````````



Rule 4:

This is not emphasis, because the closing `_` is preceded by
whitespace:

```````````````````````````````` example
_foo bar _
.
<p>_foo bar _</p>
````````````````````````````````


This is not emphasis, because the second `_` is
preceded by punctuation and followed by an alphanumeric:

```````````````````````````````` example
_(_foo)
.
<p>_(_foo)</p>
````````````````````````````````


This is emphasis within emphasis:

```````````````````````````````` example
_(_foo_)_
.
<p><em>(<em>foo</em>)</em></p>
````````````````````````````````


Intraword emphasis is disallowed for `_`:

```````````````````````````````` example
_foo_bar
.
<p>_foo_bar</p>
````````````````````````````````


```````````````````````````````` example
_пристаням_стремятся
.
<p>_пристаням_стремятся</p>
````````````````````````````````


```````````````````````````````` example
_foo_bar_baz_
.
<p><em>foo_bar_baz</em></p>
````````````````````````````````


This is emphasis, even though the closing delimiter is
both left- and right-flanking, because it is followed by
punctuation:

```````````````````````````````` example
_(bar)_.
.
<p><em>(bar)</em>.</p>
````````````````````````````````


Rule 5:

```````````````````````````````` example
**foo bar**
.
<p><strong>foo bar</strong></p>
````````````````````````````````


This is not strong emphasis, because the opening delimiter is
followed by whitespace:

```````````````````````````````` example
** foo bar**
.
<p>** foo bar**</p>
````````````````````````````````


This is not strong emphasis, because the opening `**` is preceded
by an alphanumeric and followed by punctuation, and hence
not part of a [left-flanking delimiter run]:

```````````````````````````````` example
a**"foo"**
.
<p>a**&quot;foo&quot;**</p>
````````````````````````````````


Intraword strong emphasis with `**` is permitted:

```````````````````````````````` example
foo**bar**
.
<p>foo<strong>bar</strong></p>
````````````````````````````````


Rule 6:

```````````````````````````````` example
__foo bar__
.
<p><strong>foo bar</strong></p>
````````````````````````````````


This is not strong emphasis, because the opening delimiter is
followed by whitespace:

```````````````````````````````` example
__ foo bar__
.
<p>__ foo bar__</p>
````````````````````````````````


A newline counts as whitespace:
```````````````````````````````` example
__
foo bar__
.
<p>__
foo bar__</p>
````````````````````````````````


This is not strong emphasis, because the opening `__` is preceded
by an alphanumeric and followed by punctuation:

```````````````````````````````` example
a__"foo"__
.
<p>a__&quot;foo&quot;__</p>
````````````````````````````````


Intraword strong emphasis is forbidden with `__`:

```````````````````````````````` example
foo__bar__
.
<p>foo__bar__</p>
````````````````````````````````


```````````````````````````````` example
5__6__78
.
<p>5__6__78</p>
````````````````````````````````


```````````````````````````````` example
пристаням__стремятся__
.
<p>пристаням__стремятся__</p>
````````````````````````````````


```````````````````````````````` example
__foo, __bar__, baz__
.
<p><strong>foo, <strong>bar</strong>, baz</strong></p>
````````````````````````````````


This is strong emphasis, even though the opening delimiter is
both left- and right-flanking, because it is preceded by
punctuation:

```````````````````````````````` example
foo-__(bar)__
.
<p>foo-<strong>(bar)</strong></p>
````````````````````````````````



Rule 7:

This is not strong emphasis, because the closing delimiter is preceded
by whitespace:

```````````````````````````````` example
**foo bar **
.
<p>**foo bar **</p>
````````````````````````````````


(Nor can it be interpreted as an emphasized `*foo bar *`, because of
Rule 11.)

This is not strong emphasis, because the second `**` is
preceded by punctuation and followed by an alphanumeric:

```````````````````````````````` example
**(**foo)
.
<p>**(**foo)</p>
````````````````````````````````


The point of this restriction is more easily appreciated
with these examples:

```````````````````````````````` example
*(**foo**)*
.
<p><em>(<strong>foo</strong>)</em></p>
````````````````````````````````


```````````````````````````````` example
**Gomphocarpus (*Gomphocarpus physocarpus*, syn.
*Asclepias physocarpa*)**
.
<p><strong>Gomphocarpus (<em>Gomphocarpus physocarpus</em>, syn.
<em>Asclepias physocarpa</em>)</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo "*bar*" foo**
.
<p><strong>foo &quot;<em>bar</em>&quot; foo</strong></p>
````````````````````````````````


Intraword emphasis:

```````````````````````````````` example
**foo**bar
.
<p><strong>foo</strong>bar</p>
````````````````````````````````


Rule 8:

This is not strong emphasis, because the closing delimiter is
preceded by whitespace:

```````````````````````````````` example
__foo bar __
.
<p>__foo bar __</p>
````````````````````````````````


This is not strong emphasis, because the second `__` is
preceded by punctuation and followed by an alphanumeric:

```````````````````````````````` example
__(__foo)
.
<p>__(__foo)</p>
````````````````````````````````


The point of this restriction is more easily appreciated
with this example:

```````````````````````````````` example
_(__foo__)_
.
<p><em>(<strong>foo</strong>)</em></p>
````````````````````````````````


Intraword strong emphasis is forbidden with `__`:

```````````````````````````````` example
__foo__bar
.
<p>__foo__bar</p>
````````````````````````````````


```````````````````````````````` example
__пристаням__стремятся
.
<p>__пристаням__стремятся</p>
````````````````````````````````


```````````````````````````````` example
__foo__bar__baz__
.
<p><strong>foo__bar__baz</strong></p>
````````````````````````````````


This is strong emphasis, even though the closing delimiter is
both left- and right-flanking, because it is followed by
punctuation:

```````````````````````````````` example
__(bar)__.
.
<p><strong>(bar)</strong>.</p>
````````````````````````````````


Rule 9:

Any nonempty sequence of inline elements can be the contents of an
emphasized span.

```````````````````````````````` example
*foo [bar](/url)*
.
<p><em>foo <a href="/url">bar</a></em></p>
````````````````````````````````


```````````````````````````````` example
*foo
bar*
.
<p><em>foo
bar</em></p>
````````````````````````````````


In particular, emphasis and strong emphasis can be nested
inside emphasis:

```````````````````````````````` example
_foo __bar__ baz_
.
<p><em>foo <strong>bar</strong> baz</em></p>
````````````````````````````````


```````````````````````````````` example
_foo _bar_ baz_
.
<p><em>foo <em>bar</em> baz</em></p>
````````````````````````````````


```````````````````````````````` example
__foo_ bar_
.
<p><em><em>foo</em> bar</em></p>
````````````````````````````````


```````````````````````````````` example
*foo *bar**
.
<p><em>foo <em>bar</em></em></p>
````````````````````````````````


```````````````````````````````` example
*foo **bar** baz*
.
<p><em>foo <strong>bar</strong> baz</em></p>
````````````````````````````````

```````````````````````````````` example
*foo**bar**baz*
.
<p><em>foo<strong>bar</strong>baz</em></p>
````````````````````````````````

Note that in the preceding case, the interpretation

``` markdown
<p><em>foo</em><em>bar<em></em>baz</em></p>
```


is precluded by the condition that a delimiter that
can both open and close (like the `*` after `foo`)
cannot form emphasis if the sum of the lengths of
the delimiter runs containing the opening and
closing delimiters is a multiple of 3 unless
both lengths are multiples of 3.


For the same reason, we don't get two consecutive
emphasis sections in this example:

```````````````````````````````` example
*foo**bar*
.
<p><em>foo**bar</em></p>
````````````````````````````````


The same condition ensures that the following
cases are all strong emphasis nested inside
emphasis, even when the interior spaces are
omitted:


```````````````````````````````` example
***foo** bar*
.
<p><em><strong>foo</strong> bar</em></p>
````````````````````````````````


```````````````````````````````` example
*foo **bar***
.
<p><em>foo <strong>bar</strong></em></p>
````````````````````````````````


```````````````````````````````` example
*foo**bar***
.
<p><em>foo<strong>bar</strong></em></p>
````````````````````````````````


When the lengths of the interior closing and opening
delimiter runs are *both* multiples of 3, though,
they can match to create emphasis:

```````````````````````````````` example
foo***bar***baz
.
<p>foo<em><strong>bar</strong></em>baz</p>
````````````````````````````````

```````````````````````````````` example
foo******bar*********baz
.
<p>foo<strong><strong><strong>bar</strong></strong></strong>***baz</p>
````````````````````````````````


Indefinite levels of nesting are possible:

```````````````````````````````` example
*foo **bar *baz* bim** bop*
.
<p><em>foo <strong>bar <em>baz</em> bim</strong> bop</em></p>
````````````````````````````````


```````````````````````````````` example
*foo [*bar*](/url)*
.
<p><em>foo <a href="/url"><em>bar</em></a></em></p>
````````````````````````````````


There can be no empty emphasis or strong emphasis:

```````````````````````````````` example
** is not an empty emphasis
.
<p>** is not an empty emphasis</p>
````````````````````````````````


```````````````````````````````` example
**** is not an empty strong emphasis
.
<p>**** is not an empty strong emphasis</p>
````````````````````````````````



Rule 10:

Any nonempty sequence of inline elements can be the contents of an
strongly emphasized span.

```````````````````````````````` example
**foo [bar](/url)**
.
<p><strong>foo <a href="/url">bar</a></strong></p>
````````````````````````````````


```````````````````````````````` example
**foo
bar**
.
<p><strong>foo
bar</strong></p>
````````````````````````````````


In particular, emphasis and strong emphasis can be nested
inside strong emphasis:

```````````````````````````````` example
__foo _bar_ baz__
.
<p><strong>foo <em>bar</em> baz</strong></p>
````````````````````````````````


```````````````````````````````` example
__foo __bar__ baz__
.
<p><strong>foo <strong>bar</strong> baz</strong></p>
````````````````````````````````


```````````````````````````````` example
____foo__ bar__
.
<p><strong><strong>foo</strong> bar</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo **bar****
.
<p><strong>foo <strong>bar</strong></strong></p>
````````````````````````````````


```````````````````````````````` example
**foo *bar* baz**
.
<p><strong>foo <em>bar</em> baz</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo*bar*baz**
.
<p><strong>foo<em>bar</em>baz</strong></p>
````````````````````````````````


```````````````````````````````` example
***foo* bar**
.
<p><strong><em>foo</em> bar</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo *bar***
.
<p><strong>foo <em>bar</em></strong></p>
````````````````````````````````


Indefinite levels of nesting are possible:

```````````````````````````````` example
**foo *bar **baz**
bim* bop**
.
<p><strong>foo <em>bar <strong>baz</strong>
bim</em> bop</strong></p>
````````````````````````````````


```````````````````````````````` example
**foo [*bar*](/url)**
.
<p><strong>foo <a href="/url"><em>bar</em></a></strong></p>
````````````````````````````````


There can be no empty emphasis or strong emphasis:

```````````````````````````````` example
__ is not an empty emphasis
.
<p>__ is not an empty emphasis</p>
````````````````````````````````


```````````````````````````````` example
____ is not an empty strong emphasis
.
<p>____ is not an empty strong emphasis</p>
````````````````````````````````



Rule 11:

```````````````````````````````` example
foo ***
.
<p>foo ***</p>
````````````````````````````````


```````````````````````````````` example
foo *\**
.
<p>foo <em>*</em></p>
````````````````````````````````


```````````````````````````````` example
foo *_*
.
<p>foo <em>_</em></p>
````````````````````````````````


```````````````````````````````` example
foo *****
.
<p>foo *****</p>
````````````````````````````````


```````````````````````````````` example
foo **\***
.
<p>foo <strong>*</strong></p>
````````````````````````````````


```````````````````````````````` example
foo **_**
.
<p>foo <strong>_</strong></p>
````````````````````````````````


Note that when delimiters do not match evenly, Rule 11 determines
that the excess literal `*` characters will appear outside of the
emphasis, rather than inside it:

```````````````````````````````` example
**foo*
.
<p>*<em>foo</em></p>
````````````````````````````````


```````````````````````````````` example
*foo**
.
<p><em>foo</em>*</p>
````````````````````````````````


```````````````````````````````` example
***foo**
.
<p>*<strong>foo</strong></p>
````````````````````````````````


```````````````````````````````` example
****foo*
.
<p>***<em>foo</em></p>
````````````````````````````````


```````````````````````````````` example
**foo***
.
<p><strong>foo</strong>*</p>
````````````````````````````````


```````````````````````````````` example
*foo****
.
<p><em>foo</em>***</p>
````````````````````````````````



Rule 12:

```````````````````````````````` example
foo ___
.
<p>foo ___</p>
````````````````````````````````


```````````````````````````````` example
foo _\__
.
<p>foo <em>_</em></p>
````````````````````````````````


```````````````````````````````` example
foo _*_
.
<p>foo <em>*</em></p>
````````````````````````````````


```````````````````````````````` example
foo _____
.
<p>foo _____</p>
````````````````````````````````


```````````````````````````````` example
foo __\___
.
<p>foo <strong>_</strong></p>
````````````````````````````````


```````````````````````````````` example
foo __*__
.
<p>foo <strong>*</strong></p>
````````````````````````````````


```````````````````````````````` example
__foo_
.
<p>_<em>foo</em></p>
````````````````````````````````


Note that when delimiters do not match evenly, Rule 12 determines
that the excess literal `_` characters will appear outside of the
emphasis, rather than inside it:

```````````````````````````````` example
_foo__
.
<p><em>foo</em>_</p>
````````````````````````````````


```````````````````````````````` example
___foo__
.
<p>_<strong>foo</strong></p>
````````````````````````````````


```````````````````````````````` example
____foo_
.
<p>___<em>foo</em></p>
````````````````````````````````


```````````````````````````````` example
__foo___
.
<p><strong>foo</strong>_</p>
````````````````````````````````


```````````````````````````````` example
_foo____
.
<p><em>foo</em>___</p>
````````````````````````````````


Rule 13 implies that if you want emphasis nested directly inside
emphasis, you must use different delimiters:

```````````````````````````````` example
**foo**
.
<p><strong>foo</strong></p>
````````````````````````````````


```````````````````````````````` example
*_foo_*
.
<p><em><em>foo</em></em></p>
````````````````````````````````


```````````````````````````````` example
__foo__
.
<p><strong>foo</strong></p>
````````````````````````````````


```````````````````````````````` example
_*foo*_
.
<p><em><em>foo</em></em></p>
````````````````````````````````


However, strong emphasis within strong emphasis is possible without
switching delimiters:

```````````````````````````````` example
****foo****
.
<p><strong><strong>foo</strong></strong></p>
````````````````````````````````


```````````````````````````````` example
____foo____
.
<p><strong><strong>foo</strong></strong></p>
````````````````````````````````



Rule 13 can be applied to arbitrarily long sequences of
delimiters:

```````````````````````````````` example
******foo******
.
<p><strong><strong><strong>foo</strong></strong></strong></p>
````````````````````````````````


Rule 14:

```````````````````````````````` example
***foo***
.
<p><em><strong>foo</strong></em></p>
````````````````````````````````


```````````````````````````````` example
_____foo_____
.
<p><em><strong><strong>foo</strong></strong></em></p>
````````````````````````````````


Rule 15:

```````````````````````````````` example
*foo _bar* baz_
.
<p><em>foo _bar</em> baz_</p>
````````````````````````````````


```````````````````````````````` example
*foo __bar *baz bim__ bam*
.
<p><em>foo <strong>bar *baz bim</strong> bam</em></p>
````````````````````````````````


Rule 16:

```````````````````````````````` example
**foo **bar baz**
.
<p>**foo <strong>bar baz</strong></p>
````````````````````````````````


```````````````````````````````` example
*foo *bar baz*
.
<p>*foo <em>bar baz</em></p>
````````````````````````````````


Rule 17:

```````````````````````````````` example
*[bar*](/url)
.
<p>*<a href="/url">bar*</a></p>
````````````````````````````````


```````````````````````````````` example
_foo [bar_](/url)
.
<p>_foo <a href="/url">bar_</a></p>
````````````````````````````````


```````````````````````````````` example
*<img src="foo" title="*"/>
.
<p>*<img src="foo" title="*"/></p>
````````````````````````````````


```````````````````````````````` example
**<a href="**">
.
<p>**<a href="**"></p>
````````````````````````````````


```````````````````````````````` example
__<a href="__">
.
<p>__<a href="__"></p>
````````````````````````````````


```````````````````````````````` example
*a `*`*
.
<p><em>a <code>*</code></em></p>
````````````````````````````````


```````````````````````````````` example
_a `_`_
.
<p><em>a <code>_</code></em></p>
````````````````````````````````


```````````````````````````````` example
**a<http://foo.bar/?q=**>
.
<p>**a<a href="http://foo.bar/?q=**">http://foo.bar/?q=**</a></p>
````````````````````````````````


```````````````````````````````` example
__a<http://foo.bar/?q=__>
.
<p>__a<a href="http://foo.bar/?q=__">http://foo.bar/?q=__</a></p>
````````````````````````````````



## Links

A link contains [link text] (the visible text), a [link destination]
(the URI that is the link destination), and optionally a [link title].
There are two basic kinds of links in Markdown.  In [inline links] the
destination and title are given immediately after the link text.  In
[reference links] the destination and title are defined elsewhere in
the document.

A [link text](@) consists of a sequence of zero or more
inline elements enclosed by square brackets (`[` and `]`).  The
following rules apply:

- Links may not contain other links, at any level of nesting. If
  multiple otherwise valid link definitions appear nested inside each
  other, the inner-most definition is used.

- Brackets are allowed in the [link text] only if (a) they
  are backslash-escaped or (b) they appear as a matched pair of brackets,
  with an open bracket `[`, a sequence of zero or more inlines, and
  a close bracket `]`.

- Backtick [code spans], [autolinks], and raw [HTML tags] bind more tightly
  than the brackets in link text.  Thus, for example,
  `` [foo`]` `` could not be a link text, since the second `]`
  is part of a code span.

- The brackets in link text bind more tightly than markers for
  [emphasis and strong emphasis]. Thus, for example, `*[foo*](url)` is a link.

A [link destination](@) consists of either

- a sequence of zero or more characters between an opening `<` and a
  closing `>` that contains no line breaks or unescaped
  `<` or `>` characters, or

- a nonempty sequence of characters that does not start with
  `<`, does not include ASCII space or control characters, and
  includes parentheses only if (a) they are backslash-escaped or
  (b) they are part of a balanced pair of unescaped parentheses.
  (Implementations may impose limits on parentheses nesting to
  avoid performance issues, but at least three levels of nesting
  should be supported.)

A [link title](@)  consists of either

- a sequence of zero or more characters between straight double-quote
  characters (`"`), including a `"` character only if it is
  backslash-escaped, or

- a sequence of zero or more characters between straight single-quote
  characters (`'`), including a `'` character only if it is
  backslash-escaped, or

- a sequence of zero or more characters between matching parentheses
  (`(...)`), including a `(` or `)` character only if it is
  backslash-escaped.

Although [link titles] may span multiple lines, they may not contain
a [blank line].

An [inline link](@) consists of a [link text] followed immediately
by a left parenthesis `(`, optional [whitespace], an optional
[link destination], an optional [link title] separated from the link
destination by [whitespace], optional [whitespace], and a right
parenthesis `)`. The link's text consists of the inlines contained
in the [link text] (excluding the enclosing square brackets).
The link's URI consists of the link destination, excluding enclosing
`<...>` if present, with backslash-escapes in effect as described
above.  The link's title consists of the link title, excluding its
enclosing delimiters, with backslash-escapes in effect as described
above.

Here is a simple inline link:

```````````````````````````````` example
[link](/uri "title")
.
<p><a href="/uri" title="title">link</a></p>
````````````````````````````````


The title may be omitted:

```````````````````````````````` example
[link](/uri)
.
<p><a href="/uri">link</a></p>
````````````````````````````````


Both the title and the destination may be omitted:

```````````````````````````````` example
[link]()
.
<p><a href="">link</a></p>
````````````````````````````````


```````````````````````````````` example
[link](<>)
.
<p><a href="">link</a></p>
````````````````````````````````

The destination can only contain spaces if it is
enclosed in pointy brackets:

```````````````````````````````` example
[link](/my uri)
.
<p>[link](/my uri)</p>
````````````````````````````````

```````````````````````````````` example
[link](</my uri>)
.
<p><a href="/my%20uri">link</a></p>
````````````````````````````````

The destination cannot contain line breaks,
even if enclosed in pointy brackets:

```````````````````````````````` example
[link](foo
bar)
.
<p>[link](foo
bar)</p>
````````````````````````````````

```````````````````````````````` example
[link](<foo
bar>)
.
<p>[link](<foo
bar>)</p>
````````````````````````````````

The destination can contain `)` if it is enclosed
in pointy brackets:

```````````````````````````````` example
[a](<b)c>)
.
<p><a href="b)c">a</a></p>
````````````````````````````````

Pointy brackets that enclose links must be unescaped:

```````````````````````````````` example
[link](<foo\>)
.
<p>[link](&lt;foo&gt;)</p>
````````````````````````````````

These are not links, because the opening pointy bracket
is not matched properly:

```````````````````````````````` example
[a](<b)c
[a](<b)c>
[a](<b>c)
.
<p>[a](&lt;b)c
[a](&lt;b)c&gt;
[a](<b>c)</p>
````````````````````````````````

Parentheses inside the link destination may be escaped:

```````````````````````````````` example
[link](\(foo\))
.
<p><a href="(foo)">link</a></p>
````````````````````````````````

Any number of parentheses are allowed without escaping, as long as they are
balanced:

```````````````````````````````` example
[link](foo(and(bar)))
.
<p><a href="foo(and(bar))">link</a></p>
````````````````````````````````

However, if you have unbalanced parentheses, you need to escape or use the
`<...>` form:

```````````````````````````````` example
[link](foo\(and\(bar\))
.
<p><a href="foo(and(bar)">link</a></p>
````````````````````````````````


```````````````````````````````` example
[link](<foo(and(bar)>)
.
<p><a href="foo(and(bar)">link</a></p>
````````````````````````````````


Parentheses and other symbols can also be escaped, as usual
in Markdown:

```````````````````````````````` example
[link](foo\)\:)
.
<p><a href="foo):">link</a></p>
````````````````````````````````


A link can contain fragment identifiers and queries:

```````````````````````````````` example
[link](#fragment)

[link](http://example.com#fragment)

[link](http://example.com?foo=3#frag)
.
<p><a href="#fragment">link</a></p>
<p><a href="http://example.com#fragment">link</a></p>
<p><a href="http://example.com?foo=3#frag">link</a></p>
````````````````````````````````


Note that a backslash before a non-escapable character is
just a backslash:

```````````````````````````````` example
[link](foo\bar)
.
<p><a href="foo%5Cbar">link</a></p>
````````````````````````````````


URL-escaping should be left alone inside the destination, as all
URL-escaped characters are also valid URL characters. Entity and
numerical character references in the destination will be parsed
into the corresponding Unicode code points, as usual.  These may
be optionally URL-escaped when written as HTML, but this spec
does not enforce any particular policy for rendering URLs in
HTML or other formats.  Renderers may make different decisions
about how to escape or normalize URLs in the output.

```````````````````````````````` example
[link](foo%20b&auml;)
.
<p><a href="foo%20b%C3%A4">link</a></p>
````````````````````````````````


Note that, because titles can often be parsed as destinations,
if you try to omit the destination and keep the title, you'll
get unexpected results:

```````````````````````````````` example
[link]("title")
.
<p><a href="%22title%22">link</a></p>
````````````````````````````````


Titles may be in single quotes, double quotes, or parentheses:

```````````````````````````````` example
[link](/url "title")
[link](/url 'title')
[link](/url (title))
.
<p><a href="/url" title="title">link</a>
<a href="/url" title="title">link</a>
<a href="/url" title="title">link</a></p>
````````````````````````````````


Backslash escapes and entity and numeric character references
may be used in titles:

```````````````````````````````` example
[link](/url "title \"&quot;")
.
<p><a href="/url" title="title &quot;&quot;">link</a></p>
````````````````````````````````


Titles must be separated from the link using a [whitespace].
Other [Unicode whitespace] like non-breaking space doesn't work.

```````````````````````````````` example
[link](/url "title")
.
<p><a href="/url%C2%A0%22title%22">link</a></p>
````````````````````````````````


Nested balanced quotes are not allowed without escaping:

```````````````````````````````` example
[link](/url "title "and" title")
.
<p>[link](/url &quot;title &quot;and&quot; title&quot;)</p>
````````````````````````````````


But it is easy to work around this by using a different quote type:

```````````````````````````````` example
[link](/url 'title "and" title')
.
<p><a href="/url" title="title &quot;and&quot; title">link</a></p>
````````````````````````````````


(Note:  `Markdown.pl` did allow double quotes inside a double-quoted
title, and its test suite included a test demonstrating this.
But it is hard to see a good rationale for the extra complexity this
brings, since there are already many ways---backslash escaping,
entity and numeric character references, or using a different
quote type for the enclosing title---to write titles containing
double quotes.  `Markdown.pl`'s handling of titles has a number
of other strange features.  For example, it allows single-quoted
titles in inline links, but not reference links.  And, in
reference links but not inline links, it allows a title to begin
with `"` and end with `)`.  `Markdown.pl` 1.0.1 even allows
titles with no closing quotation mark, though 1.0.2b8 does not.
It seems preferable to adopt a simple, rational rule that works
the same way in inline links and link reference definitions.)

[Whitespace] is allowed around the destination and title:

```````````````````````````````` example
[link](   /uri
  "title"  )
.
<p><a href="/uri" title="title">link</a></p>
````````````````````````````````


But it is not allowed between the link text and the
following parenthesis:

```````````````````````````````` example
[link] (/uri)
.
<p>[link] (/uri)</p>
````````````````````````````````


The link text may contain balanced brackets, but not unbalanced ones,
unless they are escaped:

```````````````````````````````` example
[link [foo [bar]]](/uri)
.
<p><a href="/uri">link [foo [bar]]</a></p>
````````````````````````````````


```````````````````````````````` example
[link] bar](/uri)
.
<p>[link] bar](/uri)</p>
````````````````````````````````


```````````````````````````````` example
[link [bar](/uri)
.
<p>[link <a href="/uri">bar</a></p>
````````````````````````````````


```````````````````````````````` example
[link \[bar](/uri)
.
<p><a href="/uri">link [bar</a></p>
````````````````````````````````


The link text may contain inline content:

```````````````````````````````` example
[link *foo **bar** `#`*](/uri)
.
<p><a href="/uri">link <em>foo <strong>bar</strong> <code>#</code></em></a></p>
````````````````````````````````


```````````````````````````````` example
[![moon](moon.jpg)](/uri)
.
<p><a href="/uri"><img src="moon.jpg" alt="moon" /></a></p>
````````````````````````````````


However, links may not contain other links, at any level of nesting.

```````````````````````````````` example
[foo [bar](/uri)](/uri)
.
<p>[foo <a href="/uri">bar</a>](/uri)</p>
````````````````````````````````


```````````````````````````````` example
[foo *[bar [baz](/uri)](/uri)*](/uri)
.
<p>[foo <em>[bar <a href="/uri">baz</a>](/uri)</em>](/uri)</p>
````````````````````````````````


```````````````````````````````` example
![[[foo](uri1)](uri2)](uri3)
.
<p><img src="uri3" alt="[foo](uri2)" /></p>
````````````````````````````````


These cases illustrate the precedence of link text grouping over
emphasis grouping:

```````````````````````````````` example
*[foo*](/uri)
.
<p>*<a href="/uri">foo*</a></p>
````````````````````````````````


```````````````````````````````` example
[foo *bar](baz*)
.
<p><a href="baz*">foo *bar</a></p>
````````````````````````````````


Note that brackets that *aren't* part of links do not take
precedence:

```````````````````````````````` example
*foo [bar* baz]
.
<p><em>foo [bar</em> baz]</p>
````````````````````````````````


These cases illustrate the precedence of HTML tags, code spans,
and autolinks over link grouping:

```````````````````````````````` example
[foo <bar attr="](baz)">
.
<p>[foo <bar attr="](baz)"></p>
````````````````````````````````


```````````````````````````````` example
[foo`](/uri)`
.
<p>[foo<code>](/uri)</code></p>
````````````````````````````````


```````````````````````````````` example
[foo<http://example.com/?search=](uri)>
.
<p>[foo<a href="http://example.com/?search=%5D(uri)">http://example.com/?search=](uri)</a></p>
````````````````````````````````


There are three kinds of [reference link](@)s:
[full](#full-reference-link), [collapsed](#collapsed-reference-link),
and [shortcut](#shortcut-reference-link).

A [full reference link](@)
consists of a [link text] immediately followed by a [link label]
that [matches] a [link reference definition] elsewhere in the document.

A [link label](@)  begins with a left bracket (`[`) and ends
with the first right bracket (`]`) that is not backslash-escaped.
Between these brackets there must be at least one [non-whitespace character].
Unescaped square bracket characters are not allowed inside the
opening and closing square brackets of [link labels].  A link
label can have at most 999 characters inside the square
brackets.

One label [matches](@)
another just in case their normalized forms are equal.  To normalize a
label, strip off the opening and closing brackets,
perform the *Unicode case fold*, strip leading and trailing
[whitespace] and collapse consecutive internal
[whitespace] to a single space.  If there are multiple
matching reference link definitions, the one that comes first in the
document is used.  (It is desirable in such cases to emit a warning.)

The contents of the first link label are parsed as inlines, which are
used as the link's text.  The link's URI and title are provided by the
matching [link reference definition].

Here is a simple example:

```````````````````````````````` example
[foo][bar]

[bar]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


The rules for the [link text] are the same as with
[inline links].  Thus:

The link text may contain balanced brackets, but not unbalanced ones,
unless they are escaped:

```````````````````````````````` example
[link [foo [bar]]][ref]

[ref]: /uri
.
<p><a href="/uri">link [foo [bar]]</a></p>
````````````````````````````````


```````````````````````````````` example
[link \[bar][ref]

[ref]: /uri
.
<p><a href="/uri">link [bar</a></p>
````````````````````````````````


The link text may contain inline content:

```````````````````````````````` example
[link *foo **bar** `#`*][ref]

[ref]: /uri
.
<p><a href="/uri">link <em>foo <strong>bar</strong> <code>#</code></em></a></p>
````````````````````````````````


```````````````````````````````` example
[![moon](moon.jpg)][ref]

[ref]: /uri
.
<p><a href="/uri"><img src="moon.jpg" alt="moon" /></a></p>
````````````````````````````````


However, links may not contain other links, at any level of nesting.

```````````````````````````````` example
[foo [bar](/uri)][ref]

[ref]: /uri
.
<p>[foo <a href="/uri">bar</a>]<a href="/uri">ref</a></p>
````````````````````````````````


```````````````````````````````` example
[foo *bar [baz][ref]*][ref]

[ref]: /uri
.
<p>[foo <em>bar <a href="/uri">baz</a></em>]<a href="/uri">ref</a></p>
````````````````````````````````


(In the examples above, we have two [shortcut reference links]
instead of one [full reference link].)

The following cases illustrate the precedence of link text grouping over
emphasis grouping:

```````````````````````````````` example
*[foo*][ref]

[ref]: /uri
.
<p>*<a href="/uri">foo*</a></p>
````````````````````````````````


```````````````````````````````` example
[foo *bar][ref]

[ref]: /uri
.
<p><a href="/uri">foo *bar</a></p>
````````````````````````````````


These cases illustrate the precedence of HTML tags, code spans,
and autolinks over link grouping:

```````````````````````````````` example
[foo <bar attr="][ref]">

[ref]: /uri
.
<p>[foo <bar attr="][ref]"></p>
````````````````````````````````


```````````````````````````````` example
[foo`][ref]`

[ref]: /uri
.
<p>[foo<code>][ref]</code></p>
````````````````````````````````


```````````````````````````````` example
[foo<http://example.com/?search=][ref]>

[ref]: /uri
.
<p>[foo<a href="http://example.com/?search=%5D%5Bref%5D">http://example.com/?search=][ref]</a></p>
````````````````````````````````


Matching is case-insensitive:

```````````````````````````````` example
[foo][BaR]

[bar]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


Unicode case fold is used:

```````````````````````````````` example
[Толпой][Толпой] is a Russian word.

[ТОЛПОЙ]: /url
.
<p><a href="/url">Толпой</a> is a Russian word.</p>
````````````````````````````````


Consecutive internal [whitespace] is treated as one space for
purposes of determining matching:

```````````````````````````````` example
[Foo
  bar]: /url

[Baz][Foo bar]
.
<p><a href="/url">Baz</a></p>
````````````````````````````````


No [whitespace] is allowed between the [link text] and the
[link label]:

```````````````````````````````` example
[foo] [bar]

[bar]: /url "title"
.
<p>[foo] <a href="/url" title="title">bar</a></p>
````````````````````````````````


```````````````````````````````` example
[foo]
[bar]

[bar]: /url "title"
.
<p>[foo]
<a href="/url" title="title">bar</a></p>
````````````````````````````````


This is a departure from John Gruber's original Markdown syntax
description, which explicitly allows whitespace between the link
text and the link label.  It brings reference links in line with
[inline links], which (according to both original Markdown and
this spec) cannot have whitespace after the link text.  More
importantly, it prevents inadvertent capture of consecutive
[shortcut reference links]. If whitespace is allowed between the
link text and the link label, then in the following we will have
a single reference link, not two shortcut reference links, as
intended:

``` markdown
[foo]
[bar]

[foo]: /url1
[bar]: /url2
```

(Note that [shortcut reference links] were introduced by Gruber
himself in a beta version of `Markdown.pl`, but never included
in the official syntax description.  Without shortcut reference
links, it is harmless to allow space between the link text and
link label; but once shortcut references are introduced, it is
too dangerous to allow this, as it frequently leads to
unintended results.)

When there are multiple matching [link reference definitions],
the first is used:

```````````````````````````````` example
[foo]: /url1

[foo]: /url2

[bar][foo]
.
<p><a href="/url1">bar</a></p>
````````````````````````````````


Note that matching is performed on normalized strings, not parsed
inline content.  So the following does not match, even though the
labels define equivalent inline content:

```````````````````````````````` example
[bar][foo\!]

[foo!]: /url
.
<p>[bar][foo!]</p>
````````````````````````````````


[Link labels] cannot contain brackets, unless they are
backslash-escaped:

```````````````````````````````` example
[foo][ref[]

[ref[]: /uri
.
<p>[foo][ref[]</p>
<p>[ref[]: /uri</p>
````````````````````````````````


```````````````````````````````` example
[foo][ref[bar]]

[ref[bar]]: /uri
.
<p>[foo][ref[bar]]</p>
<p>[ref[bar]]: /uri</p>
````````````````````````````````


```````````````````````````````` example
[[[foo]]]

[[[foo]]]: /url
.
<p>[[[foo]]]</p>
<p>[[[foo]]]: /url</p>
````````````````````````````````


```````````````````````````````` example
[foo][ref\[]

[ref\[]: /uri
.
<p><a href="/uri">foo</a></p>
````````````````````````````````


Note that in this example `]` is not backslash-escaped:

```````````````````````````````` example
[bar\\]: /uri

[bar\\]
.
<p><a href="/uri">bar\</a></p>
````````````````````````````````


A [link label] must contain at least one [non-whitespace character]:

```````````````````````````````` example
[]

[]: /uri
.
<p>[]</p>
<p>[]: /uri</p>
````````````````````````````````


```````````````````````````````` example
[
 ]

[
 ]: /uri
.
<p>[
]</p>
<p>[
]: /uri</p>
````````````````````````````````


A [collapsed reference link](@)
consists of a [link label] that [matches] a
[link reference definition] elsewhere in the
document, followed by the string `[]`.
The contents of the first link label are parsed as inlines,
which are used as the link's text.  The link's URI and title are
provided by the matching reference link definition.  Thus,
`[foo][]` is equivalent to `[foo][foo]`.

```````````````````````````````` example
[foo][]

[foo]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[*foo* bar][]

[*foo* bar]: /url "title"
.
<p><a href="/url" title="title"><em>foo</em> bar</a></p>
````````````````````````````````


The link labels are case-insensitive:

```````````````````````````````` example
[Foo][]

[foo]: /url "title"
.
<p><a href="/url" title="title">Foo</a></p>
````````````````````````````````



As with full reference links, [whitespace] is not
allowed between the two sets of brackets:

```````````````````````````````` example
[foo] 
[]

[foo]: /url "title"
.
<p><a href="/url" title="title">foo</a>
[]</p>
````````````````````````````````


A [shortcut reference link](@)
consists of a [link label] that [matches] a
[link reference definition] elsewhere in the
document and is not followed by `[]` or a link label.
The contents of the first link label are parsed as inlines,
which are used as the link's text.  The link's URI and title
are provided by the matching link reference definition.
Thus, `[foo]` is equivalent to `[foo][]`.

```````````````````````````````` example
[foo]

[foo]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
````````````````````````````````


```````````````````````````````` example
[*foo* bar]

[*foo* bar]: /url "title"
.
<p><a href="/url" title="title"><em>foo</em> bar</a></p>
````````````````````````````````


```````````````````````````````` example
[[*foo* bar]]

[*foo* bar]: /url "title"
.
<p>[<a href="/url" title="title"><em>foo</em> bar</a>]</p>
````````````````````````````````


```````````````````````````````` example
[[bar [foo]

[foo]: /url
.
<p>[[bar <a href="/url">foo</a></p>
````````````````````````````````


The link labels are case-insensitive:

```````````````````````````````` example
[Foo]

[foo]: /url "title"
.
<p><a href="/url" title="title">Foo</a></p>
````````````````````````````````


A space after the link text should be preserved:

```````````````````````````````` example
[foo] bar

[foo]: /url
.
<p><a href="/url">foo</a> bar</p>
````````````````````````````````


If you just want bracketed text, you can backslash-escape the
opening bracket to avoid links:

```````````````````````````````` example
\[foo]

[foo]: /url "title"
.
<p>[foo]</p>
````````````````````````````````


Note that this is a link, because a link label ends with the first
following closing bracket:

```````````````````````````````` example
[foo*]: /url

*[foo*]
.
<p>*<a href="/url">foo*</a></p>
````````````````````````````````


Full and compact references take precedence over shortcut
references:

```````````````````````````````` example
[foo][bar]

[foo]: /url1
[bar]: /url2
.
<p><a href="/url2">foo</a></p>
````````````````````````````````

```````````````````````````````` example
[foo][]

[foo]: /url1
.
<p><a href="/url1">foo</a></p>
````````````````````````````````

Inline links also take precedence:

```````````````````````````````` example
[foo]()

[foo]: /url1
.
<p><a href="">foo</a></p>
````````````````````````````````

```````````````````````````````` example
[foo](not a link)

[foo]: /url1
.
<p><a href="/url1">foo</a>(not a link)</p>
````````````````````````````````

In the following case `[bar][baz]` is parsed as a reference,
`[foo]` as normal text:

```````````````````````````````` example
[foo][bar][baz]

[baz]: /url
.
<p>[foo]<a href="/url">bar</a></p>
````````````````````````````````


Here, though, `[foo][bar]` is parsed as a reference, since
`[bar]` is defined:

```````````````````````````````` example
[foo][bar][baz]

[baz]: /url1
[bar]: /url2
.
<p><a href="/url2">foo</a><a href="/url1">baz</a></p>
````````````````````````````````


Here `[foo]` is not parsed as a shortcut reference, because it
is followed by a link label (even though `[bar]` is not defined):

```````````````````````````````` example
[foo][bar][baz]

[baz]: /url1
[foo]: /url2
.
<p>[foo]<a href="/url1">bar</a></p>
````````````````````````````````



## Images

Syntax for images is like the syntax for links, with one
difference. Instead of [link text], we have an
[image description](@).  The rules for this are the
same as for [link text], except that (a) an
image description starts with `![` rather than `[`, and
(b) an image description may contain links.
An image description has inline elements
as its contents.  When an image is rendered to HTML,
this is standardly used as the image's `alt` attribute.

```````````````````````````````` example
![foo](/url "title")
.
<p><img src="/url" alt="foo" title="title" /></p>
````````````````````````````````


```````````````````````````````` example
![foo *bar*]

[foo *bar*]: train.jpg "train & tracks"
.
<p><img src="train.jpg" alt="foo bar" title="train &amp; tracks" /></p>
````````````````````````````````


```````````````````````````````` example
![foo ![bar](/url)](/url2)
.
<p><img src="/url2" alt="foo bar" /></p>
````````````````````````````````


```````````````````````````````` example
![foo [bar](/url)](/url2)
.
<p><img src="/url2" alt="foo bar" /></p>
````````````````````````````````


Though this spec is concerned with parsing, not rendering, it is
recommended that in rendering to HTML, only the plain string content
of the [image description] be used.  Note that in
the above example, the alt attribute's value is `foo bar`, not `foo
[bar](/url)` or `foo <a href="/url">bar</a>`.  Only the plain string
content is rendered, without formatting.

```````````````````````````````` example
![foo *bar*][]

[foo *bar*]: train.jpg "train & tracks"
.
<p><img src="train.jpg" alt="foo bar" title="train &amp; tracks" /></p>
````````````````````````````````


```````````````````````````````` example
![foo *bar*][foobar]

[FOOBAR]: train.jpg "train & tracks"
.
<p><img src="train.jpg" alt="foo bar" title="train &amp; tracks" /></p>
````````````````````````````````


```````````````````````````````` example
![foo](train.jpg)
.
<p><img src="train.jpg" alt="foo" /></p>
````````````````````````````````


```````````````````````````````` example
My ![foo bar](/path/to/train.jpg  "title"   )
.
<p>My <img src="/path/to/train.jpg" alt="foo bar" title="title" /></p>
````````````````````````````````


```````````````````````````````` example
![foo](<url>)
.
<p><img src="url" alt="foo" /></p>
````````````````````````````````


```````````````````````````````` example
![](/url)
.
<p><img src="/url" alt="" /></p>
````````````````````````````````


Reference-style:

```````````````````````````````` example
![foo][bar]

[bar]: /url
.
<p><img src="/url" alt="foo" /></p>
````````````````````````````````


```````````````````````````````` example
![foo][bar]

[BAR]: /url
.
<p><img src="/url" alt="foo" /></p>
````````````````````````````````


Collapsed:

```````````````````````````````` example
![foo][]

[foo]: /url "title"
.
<p><img src="/url" alt="foo" title="title" /></p>
````````````````````````````````


```````````````````````````````` example
![*foo* bar][]

[*foo* bar]: /url "title"
.
<p><img src="/url" alt="foo bar" title="title" /></p>
````````````````````````````````


The labels are case-insensitive:

```````````````````````````````` example
![Foo][]

[foo]: /url "title"
.
<p><img src="/url" alt="Foo" title="title" /></p>
````````````````````````````````


As with reference links, [whitespace] is not allowed
between the two sets of brackets:

```````````````````````````````` example
![foo] 
[]

[foo]: /url "title"
.
<p><img src="/url" alt="foo" title="title" />
[]</p>
````````````````````````````````


Shortcut:

```````````````````````````````` example
![foo]

[foo]: /url "title"
.
<p><img src="/url" alt="foo" title="title" /></p>
````````````````````````````````


```````````````````````````````` example
![*foo* bar]

[*foo* bar]: /url "title"
.
<p><img src="/url" alt="foo bar" title="title" /></p>
````````````````````````````````


Note that link labels cannot contain unescaped brackets:

```````````````````````````````` example
![[foo]]

[[foo]]: /url "title"
.
<p>![[foo]]</p>
<p>[[foo]]: /url &quot;title&quot;</p>
````````````````````````````````


The link labels are case-insensitive:

```````````````````````````````` example
![Foo]

[foo]: /url "title"
.
<p><img src="/url" alt="Foo" title="title" /></p>
````````````````````````````````


If you just want a literal `!` followed by bracketed text, you can
backslash-escape the opening `[`:

```````````````````````````````` example
!\[foo]

[foo]: /url "title"
.
<p>![foo]</p>
````````````````````````````````


If you want a link after a literal `!`, backslash-escape the
`!`:

```````````````````````````````` example
\![foo]

[foo]: /url "title"
.
<p>!<a href="/url" title="title">foo</a></p>
````````````````````````````````


## Autolinks

[Autolink](@)s are absolute URIs and email addresses inside
`<` and `>`. They are parsed as links, with the URL or email address
as the link label.

A [URI autolink](@) consists of `<`, followed by an
[absolute URI] followed by `>`.  It is parsed as
a link to the URI, with the URI as the link's label.

An [absolute URI](@),
for these purposes, consists of a [scheme] followed by a colon (`:`)
followed by zero or more characters other than ASCII
[whitespace] and control characters, `<`, and `>`.  If
the URI includes these characters, they must be percent-encoded
(e.g. `%20` for a space).

For purposes of this spec, a [scheme](@) is any sequence
of 2--32 characters beginning with an ASCII letter and followed
by any combination of ASCII letters, digits, or the symbols plus
("+"), period ("."), or hyphen ("-").

Here are some valid autolinks:

```````````````````````````````` example
<http://foo.bar.baz>
.
<p><a href="http://foo.bar.baz">http://foo.bar.baz</a></p>
````````````````````````````````


```````````````````````````````` example
<http://foo.bar.baz/test?q=hello&id=22&boolean>
.
<p><a href="http://foo.bar.baz/test?q=hello&amp;id=22&amp;boolean">http://foo.bar.baz/test?q=hello&amp;id=22&amp;boolean</a></p>
````````````````````````````````


```````````````````````````````` example
<irc://foo.bar:2233/baz>
.
<p><a href="irc://foo.bar:2233/baz">irc://foo.bar:2233/baz</a></p>
````````````````````````````````


Uppercase is also fine:

```````````````````````````````` example
<MAILTO:FOO@BAR.BAZ>
.
<p><a href="MAILTO:FOO@BAR.BAZ">MAILTO:FOO@BAR.BAZ</a></p>
````````````````````````````````


Note that many strings that count as [absolute URIs] for
purposes of this spec are not valid URIs, because their
schemes are not registered or because of other problems
with their syntax:

```````````````````````````````` example
<a+b+c:d>
.
<p><a href="a+b+c:d">a+b+c:d</a></p>
````````````````````````````````


```````````````````````````````` example
<made-up-scheme://foo,bar>
.
<p><a href="made-up-scheme://foo,bar">made-up-scheme://foo,bar</a></p>
````````````````````````````````


```````````````````````````````` example
<http://../>
.
<p><a href="http://../">http://../</a></p>
````````````````````````````````


```````````````````````````````` example
<localhost:5001/foo>
.
<p><a href="localhost:5001/foo">localhost:5001/foo</a></p>
````````````````````````````````


Spaces are not allowed in autolinks:

```````````````````````````````` example
<http://foo.bar/baz bim>
.
<p>&lt;http://foo.bar/baz bim&gt;</p>
````````````````````````````````


Backslash-escapes do not work inside autolinks:

```````````````````````````````` example
<http://example.com/\[\>
.
<p><a href="http://example.com/%5C%5B%5C">http://example.com/\[\</a></p>
````````````````````````````````


An [email autolink](@)
consists of `<`, followed by an [email address],
followed by `>`.  The link's label is the email address,
and the URL is `mailto:` followed by the email address.

An [email address](@),
for these purposes, is anything that matches
the [non-normative regex from the HTML5
spec](https://html.spec.whatwg.org/multipage/forms.html#e-mail-state-(type=email)):

    /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?
    (?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/

Examples of email autolinks:

```````````````````````````````` example
<foo@bar.example.com>
.
<p><a href="mailto:foo@bar.example.com">foo@bar.example.com</a></p>
````````````````````````````````


```````````````````````````````` example
<foo+special@Bar.baz-bar0.com>
.
<p><a href="mailto:foo+special@Bar.baz-bar0.com">foo+special@Bar.baz-bar0.com</a></p>
````````````````````````````````


Backslash-escapes do not work inside email autolinks:

```````````````````````````````` example
<foo\+@bar.example.com>
.
<p>&lt;foo+@bar.example.com&gt;</p>
````````````````````````````````


These are not autolinks:

```````````````````````````````` example
<>
.
<p>&lt;&gt;</p>
````````````````````````````````


```````````````````````````````` example
< http://foo.bar >
.
<p>&lt; http://foo.bar &gt;</p>
````````````````````````````````


```````````````````````````````` example
<m:abc>
.
<p>&lt;m:abc&gt;</p>
````````````````````````````````


```````````````````````````````` example
<foo.bar.baz>
.
<p>&lt;foo.bar.baz&gt;</p>
````````````````````````````````


```````````````````````````````` example
http://example.com
.
<p>http://example.com</p>
````````````````````````````````


```````````````````````````````` example
foo@bar.example.com
.
<p>foo@bar.example.com</p>
````````````````````````````````


## Raw HTML

Text between `<` and `>` that looks like an HTML tag is parsed as a
raw HTML tag and will be rendered in HTML without escaping.
Tag and attribute names are not limited to current HTML tags,
so custom tags (and even, say, DocBook tags) may be used.

Here is the grammar for tags:

A [tag name](@) consists of an ASCII letter
followed by zero or more ASCII letters, digits, or
hyphens (`-`).

An [attribute](@) consists of [whitespace],
an [attribute name], and an optional
[attribute value specification].

An [attribute name](@)
consists of an ASCII letter, `_`, or `:`, followed by zero or more ASCII
letters, digits, `_`, `.`, `:`, or `-`.  (Note:  This is the XML
specification restricted to ASCII.  HTML5 is laxer.)

An [attribute value specification](@)
consists of optional [whitespace],
a `=` character, optional [whitespace], and an [attribute
value].

An [attribute value](@)
consists of an [unquoted attribute value],
a [single-quoted attribute value], or a [double-quoted attribute value].

An [unquoted attribute value](@)
is a nonempty string of characters not
including [whitespace], `"`, `'`, `=`, `<`, `>`, or `` ` ``.

A [single-quoted attribute value](@)
consists of `'`, zero or more
characters not including `'`, and a final `'`.

A [double-quoted attribute value](@)
consists of `"`, zero or more
characters not including `"`, and a final `"`.

An [open tag](@) consists of a `<` character, a [tag name],
zero or more [attributes], optional [whitespace], an optional `/`
character, and a `>` character.

A [closing tag](@) consists of the string `</`, a
[tag name], optional [whitespace], and the character `>`.

An [HTML comment](@) consists of `<!--` + *text* + `-->`,
where *text* does not start with `>` or `->`, does not end with `-`,
and does not contain `--`.  (See the
[HTML5 spec](http://www.w3.org/TR/html5/syntax.html#comments).)

A [processing instruction](@)
consists of the string `<?`, a string
of characters not including the string `?>`, and the string
`?>`.

A [declaration](@) consists of the
string `<!`, a name consisting of one or more uppercase ASCII letters,
[whitespace], a string of characters not including the
character `>`, and the character `>`.

A [CDATA section](@) consists of
the string `<![CDATA[`, a string of characters not including the string
`]]>`, and the string `]]>`.

An [HTML tag](@) consists of an [open tag], a [closing tag],
an [HTML comment], a [processing instruction], a [declaration],
or a [CDATA section].

Here are some simple open tags:

```````````````````````````````` example
<a><bab><c2c>
.
<p><a><bab><c2c></p>
````````````````````````````````


Empty elements:

```````````````````````````````` example
<a/><b2/>
.
<p><a/><b2/></p>
````````````````````````````````


[Whitespace] is allowed:

```````````````````````````````` example
<a  /><b2
data="foo" >
.
<p><a  /><b2
data="foo" ></p>
````````````````````````````````


With attributes:

```````````````````````````````` example
<a foo="bar" bam = 'baz <em>"</em>'
_boolean zoop:33=zoop:33 />
.
<p><a foo="bar" bam = 'baz <em>"</em>'
_boolean zoop:33=zoop:33 /></p>
````````````````````````````````


Custom tag names can be used:

```````````````````````````````` example
Foo <responsive-image src="foo.jpg" />
.
<p>Foo <responsive-image src="foo.jpg" /></p>
````````````````````````````````


Illegal tag names, not parsed as HTML:

```````````````````````````````` example
<33> <__>
.
<p>&lt;33&gt; &lt;__&gt;</p>
````````````````````````````````


Illegal attribute names:

```````````````````````````````` example
<a h*#ref="hi">
.
<p>&lt;a h*#ref=&quot;hi&quot;&gt;</p>
````````````````````````````````


Illegal attribute values:

```````````````````````````````` example
<a href="hi'> <a href=hi'>
.
<p>&lt;a href=&quot;hi'&gt; &lt;a href=hi'&gt;</p>
````````````````````````````````


Illegal [whitespace]:

```````````````````````````````` example
< a><
foo><bar/ >
<foo bar=baz
bim!bop />
.
<p>&lt; a&gt;&lt;
foo&gt;&lt;bar/ &gt;
&lt;foo bar=baz
bim!bop /&gt;</p>
````````````````````````````````


Missing [whitespace]:

```````````````````````````````` example
<a href='bar'title=title>
.
<p>&lt;a href='bar'title=title&gt;</p>
````````````````````````````````


Closing tags:

```````````````````````````````` example
</a></foo >
.
<p></a></foo ></p>
````````````````````````````````


Illegal attributes in closing tag:

```````````````````````````````` example
</a href="foo">
.
<p>&lt;/a href=&quot;foo&quot;&gt;</p>
````````````````````````````````


Comments:

```````````````````````````````` example
foo <!-- this is a
comment - with hyphen -->
.
<p>foo <!-- this is a
comment - with hyphen --></p>
````````````````````````````````


```````````````````````````````` example
foo <!-- not a comment -- two hyphens -->
.
<p>foo &lt;!-- not a comment -- two hyphens --&gt;</p>
````````````````````````````````


Not comments:

```````````````````````````````` example
foo <!--> foo -->

foo <!-- foo--->
.
<p>foo &lt;!--&gt; foo --&gt;</p>
<p>foo &lt;!-- foo---&gt;</p>
````````````````````````````````


Processing instructions:

```````````````````````````````` example
foo <?php echo $a; ?>
.
<p>foo <?php echo $a; ?></p>
````````````````````````````````


Declarations:

```````````````````````````````` example
foo <!ELEMENT br EMPTY>
.
<p>foo <!ELEMENT br EMPTY></p>
````````````````````````````````


CDATA sections:

```````````````````````````````` example
foo <![CDATA[>&<]]>
.
<p>foo <![CDATA[>&<]]></p>
````````````````````````````````


Entity and numeric character references are preserved in HTML
attributes:

```````````````````````````````` example
foo <a href="&ouml;">
.
<p>foo <a href="&ouml;"></p>
````````````````````````````````


Backslash escapes do not work in HTML attributes:

```````````````````````````````` example
foo <a href="\*">
.
<p>foo <a href="\*"></p>
````````````````````````````````


```````````````````````````````` example
<a href="\"">
.
<p>&lt;a href=&quot;&quot;&quot;&gt;</p>
````````````````````````````````


## Hard line breaks

A line break (not in a code span or HTML tag) that is preceded
by two or more spaces and does not occur at the end of a block
is parsed as a [hard line break](@) (rendered
in HTML as a `<br />` tag):

```````````````````````````````` example
foo  
baz
.
<p>foo<br />
baz</p>
````````````````````````````````


For a more visible alternative, a backslash before the
[line ending] may be used instead of two spaces:

```````````````````````````````` example
foo\
baz
.
<p>foo<br />
baz</p>
````````````````````````````````


More than two spaces can be used:

```````````````````````````````` example
foo       
baz
.
<p>foo<br />
baz</p>
````````````````````````````````


Leading spaces at the beginning of the next line are ignored:

```````````````````````````````` example
foo  
     bar
.
<p>foo<br />
bar</p>
````````````````````````````````


```````````````````````````````` example
foo\
     bar
.
<p>foo<br />
bar</p>
````````````````````````````````


Line breaks can occur inside emphasis, links, and other constructs
that allow inline content:

```````````````````````````````` example
*foo  
bar*
.
<p><em>foo<br />
bar</em></p>
````````````````````````````````


```````````````````````````````` example
*foo\
bar*
.
<p><em>foo<br />
bar</em></p>
````````````````````````````````


Line breaks do not occur inside code spans

```````````````````````````````` example
`code 
span`
.
<p><code>code  span</code></p>
````````````````````````````````


```````````````````````````````` example
`code\
span`
.
<p><code>code\ span</code></p>
````````````````````````````````


or HTML tags:

```````````````````````````````` example
<a href="foo  
bar">
.
<p><a href="foo  
bar"></p>
````````````````````````````````


```````````````````````````````` example
<a href="foo\
bar">
.
<p><a href="foo\
bar"></p>
````````````````````````````````


Hard line breaks are for separating inline content within a block.
Neither syntax for hard line breaks works at the end of a paragraph or
other block element:

```````````````````````````````` example
foo\
.
<p>foo\</p>
````````````````````````````````


```````````````````````````````` example
foo  
.
<p>foo</p>
````````````````````````````````


```````````````````````````````` example
### foo\
.
<h3>foo\</h3>
````````````````````````````````


```````````````````````````````` example
### foo  
.
<h3>foo</h3>
````````````````````````````````


## Soft line breaks

A regular line break (not in a code span or HTML tag) that is not
preceded by two or more spaces or a backslash is parsed as a
[softbreak](@).  (A softbreak may be rendered in HTML either as a
[line ending] or as a space. The result will be the same in
browsers. In the examples here, a [line ending] will be used.)

```````````````````````````````` example
foo
baz
.
<p>foo
baz</p>
````````````````````````````````


Spaces at the end of the line and beginning of the next line are
removed:

```````````````````````````````` example
foo 
 baz
.
<p>foo
baz</p>
````````````````````````````````


A conforming parser may render a soft line break in HTML either as a
line break or as a space.

A renderer may also provide an option to render soft line breaks
as hard line breaks.

## Textual content

Any characters not given an interpretation by the above rules will
be parsed as plain textual content.

```````````````````````````````` example
hello $.;'there
.
<p>hello $.;'there</p>
````````````````````````````````


```````````````````````````````` example
Foo χρῆν
.
<p>Foo χρῆν</p>
````````````````````````````````


Internal spaces are preserved verbatim:

```````````````````````````````` example
Multiple     spaces
.
<p>Multiple     spaces</p>
````````````````````````````````


<!-- END TESTS -->

# Appendix: A parsing strategy

In this appendix we describe some features of the parsing strategy
used in the CommonMark reference implementations.

## Overview

Parsing has two phases:

1. In the first phase, lines of input are consumed and the block
structure of the document---its division into paragraphs, block quotes,
list items, and so on---is constructed.  Text is assigned to these
blocks but not parsed. Link reference definitions are parsed and a
map of links is constructed.

2. In the second phase, the raw text contents of paragraphs and headings
are parsed into sequences of Markdown inline elements (strings,
code spans, links, emphasis, and so on), using the map of link
references constructed in phase 1.

At each point in processing, the document is represented as a tree of
**blocks**.  The root of the tree is a `document` block.  The `document`
may have any number of other blocks as **children**.  These children
may, in turn, have other blocks as children.  The last child of a block
is normally considered **open**, meaning that subsequent lines of input
can alter its contents.  (Blocks that are not open are **closed**.)
Here, for example, is a possible document tree, with the open blocks
marked by arrows:

``` tree
-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             "Qui *quodsi iracundia*"
      -> list_item
        -> paragraph
             "aliquando id"
```

## Phase 1: block structure

Each line that is processed has an effect on this tree.  The line is
analyzed and, depending on its contents, the document may be altered
in one or more of the following ways:

1. One or more open blocks may be closed.
2. One or more new blocks may be created as children of the
   last open block.
3. Text may be added to the last (deepest) open block remaining
   on the tree.

Once a line has been incorporated into the tree in this way,
it can be discarded, so input can be read in a stream.

For each line, we follow this procedure:

1. First we iterate through the open blocks, starting with the
root document, and descending through last children down to the last
open block.  Each block imposes a condition that the line must satisfy
if the block is to remain open.  For example, a block quote requires a
`>` character.  A paragraph requires a non-blank line.
In this phase we may match all or just some of the open
blocks.  But we cannot close unmatched blocks yet, because we may have a
[lazy continuation line].

2.  Next, after consuming the continuation markers for existing
blocks, we look for new block starts (e.g. `>` for a block quote).
If we encounter a new block start, we close any blocks unmatched
in step 1 before creating the new block as a child of the last
matched block.

3.  Finally, we look at the remainder of the line (after block
markers like `>`, list markers, and indentation have been consumed).
This is text that can be incorporated into the last open
block (a paragraph, code block, heading, or raw HTML).

Setext headings are formed when we see a line of a paragraph
that is a [setext heading underline].

Reference link definitions are detected when a paragraph is closed;
the accumulated text lines are parsed to see if they begin with
one or more reference link definitions.  Any remainder becomes a
normal paragraph.

We can see how this works by considering how the tree above is
generated by four lines of Markdown:

``` markdown
> Lorem ipsum dolor
sit amet.
> - Qui *quodsi iracundia*
> - aliquando id
```

At the outset, our document model is just

``` tree
-> document
```

The first line of our text,

``` markdown
> Lorem ipsum dolor
```

causes a `block_quote` block to be created as a child of our
open `document` block, and a `paragraph` block as a child of
the `block_quote`.  Then the text is added to the last open
block, the `paragraph`:

``` tree
-> document
  -> block_quote
    -> paragraph
         "Lorem ipsum dolor"
```

The next line,

``` markdown
sit amet.
```

is a "lazy continuation" of the open `paragraph`, so it gets added
to the paragraph's text:

``` tree
-> document
  -> block_quote
    -> paragraph
         "Lorem ipsum dolor\nsit amet."
```

The third line,

``` markdown
> - Qui *quodsi iracundia*
```

causes the `paragraph` block to be closed, and a new `list` block
opened as a child of the `block_quote`.  A `list_item` is also
added as a child of the `list`, and a `paragraph` as a child of
the `list_item`.  The text is then added to the new `paragraph`:

``` tree
-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
      -> list_item
        -> paragraph
             "Qui *quodsi iracundia*"
```

The fourth line,

``` markdown
> - aliquando id
```

causes the `list_item` (and its child the `paragraph`) to be closed,
and a new `list_item` opened up as child of the `list`.  A `paragraph`
is added as a child of the new `list_item`, to contain the text.
We thus obtain the final tree:

``` tree
-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             "Qui *quodsi iracundia*"
      -> list_item
        -> paragraph
             "aliquando id"
```

## Phase 2: inline structure

Once all of the input has been parsed, all open blocks are closed.

We then "walk the tree," visiting every node, and parse raw
string contents of paragraphs and headings as inlines.  At this
point we have seen all the link reference definitions, so we can
resolve reference links as we go.

``` tree
document
  block_quote
    paragraph
      str "Lorem ipsum dolor"
      softbreak
      str "sit amet."
    list (type=bullet tight=true bullet_char=-)
      list_item
        paragraph
          str "Qui "
          emph
            str "quodsi iracundia"
      list_item
        paragraph
          str "aliquando id"
```

Notice how the [line ending] in the first paragraph has
been parsed as a `softbreak`, and the asterisks in the first list item
have become an `emph`.

### An algorithm for parsing nested emphasis and links

By far the trickiest part of inline parsing is handling emphasis,
strong emphasis, links, and images.  This is done using the following
algorithm.

When we're parsing inlines and we hit either

- a run of `*` or `_` characters, or
- a `[` or `![`

we insert a text node with these symbols as its literal content, and we
add a pointer to this text node to the [delimiter stack](@).

The [delimiter stack] is a doubly linked list.  Each
element contains a pointer to a text node, plus information about

- the type of delimiter (`[`, `![`, `*`, `_`)
- the number of delimiters,
- whether the delimiter is "active" (all are active to start), and
- whether the delimiter is a potential opener, a potential closer,
  or both (which depends on what sort of characters precede
  and follow the delimiters).

When we hit a `]` character, we call the *look for link or image*
procedure (see below).

When we hit the end of the input, we call the *process emphasis*
procedure (see below), with `stack_bottom` = NULL.

#### *look for link or image*

Starting at the top of the delimiter stack, we look backwards
through the stack for an opening `[` or `![` delimiter.

- If we don't find one, we return a literal text node `]`.

- If we do find one, but it's not *active*, we remove the inactive
  delimiter from the stack, and return a literal text node `]`.

- If we find one and it's active, then we parse ahead to see if
  we have an inline link/image, reference link/image, compact reference
  link/image, or shortcut reference link/image.

  + If we don't, then we remove the opening delimiter from the
    delimiter stack and return a literal text node `]`.

  + If we do, then

    * We return a link or image node whose children are the inlines
      after the text node pointed to by the opening delimiter.

    * We run *process emphasis* on these inlines, with the `[` opener
      as `stack_bottom`.

    * We remove the opening delimiter.

    * If we have a link (and not an image), we also set all
      `[` delimiters before the opening delimiter to *inactive*.  (This
      will prevent us from getting links within links.)

#### *process emphasis*

Parameter `stack_bottom` sets a lower bound to how far we
descend in the [delimiter stack].  If it is NULL, we can
go all the way to the bottom.  Otherwise, we stop before
visiting `stack_bottom`.

Let `current_position` point to the element on the [delimiter stack]
just above `stack_bottom` (or the first element if `stack_bottom`
is NULL).

We keep track of the `openers_bottom` for each delimiter
type (`*`, `_`) and each length of the closing delimiter run
(modulo 3).  Initialize this to `stack_bottom`.

Then we repeat the following until we run out of potential
closers:

- Move `current_position` forward in the delimiter stack (if needed)
  until we find the first potential closer with delimiter `*` or `_`.
  (This will be the potential closer closest
  to the beginning of the input -- the first one in parse order.)

- Now, look back in the stack (staying above `stack_bottom` and
  the `openers_bottom` for this delimiter type) for the
  first matching potential opener ("matching" means same delimiter).

- If one is found:

  + Figure out whether we have emphasis or strong emphasis:
    if both closer and opener spans have length >= 2, we have
    strong, otherwise regular.

  + Insert an emph or strong emph node accordingly, after
    the text node corresponding to the opener.

  + Remove any delimiters between the opener and closer from
    the delimiter stack.

  + Remove 1 (for regular emph) or 2 (for strong emph) delimiters
    from the opening and closing text nodes.  If they become empty
    as a result, remove them and remove the corresponding element
    of the delimiter stack.  If the closing node is removed, reset
    `current_position` to the next element in the stack.

- If none is found:

  + Set `openers_bottom` to the element before `current_position`.
    (We know that there are no openers for this kind of closer up to and
    including this point, so this puts a lower bound on future searches.)

  + If the closer at `current_position` is not a potential opener,
    remove it from the delimiter stack (since we know it can't
    be a closer either).

  + Advance `current_position` to the next element in the stack.

After we're done, we remove all delimiters above `stack_bottom` from the
delimiter stack.
</file>

<file path="_benchmark/go/benchmark_test.go">
package benchmark

import (
	"bytes"
	"io/ioutil"
	"testing"

	gomarkdown "github.com/gomarkdown/markdown"
	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/util"
	"gitlab.com/golang-commonmark/markdown"

	"github.com/russross/blackfriday/v2"

	"github.com/88250/lute"
)

func BenchmarkMarkdown(b *testing.B) {
	b.Run("Blackfriday-v2", func(b *testing.B) {
		r := func(src []byte) ([]byte, error) {
			out := blackfriday.Run(src)
			return out, nil
		}
		doBenchmark(b, r)
	})

	b.Run("GoldMark", func(b *testing.B) {
		markdown := goldmark.New(
			goldmark.WithRendererOptions(html.WithXHTML(), html.WithUnsafe()),
		)
		r := func(src []byte) ([]byte, error) {
			var out bytes.Buffer
			err := markdown.Convert(src, &out)
			return out.Bytes(), err
		}
		doBenchmark(b, r)
	})

	b.Run("CommonMark", func(b *testing.B) {
		md := markdown.New(markdown.XHTMLOutput(true))
		r := func(src []byte) ([]byte, error) {
			var out bytes.Buffer
			err := md.Render(&out, src)
			return out.Bytes(), err
		}
		doBenchmark(b, r)
	})

	b.Run("Lute", func(b *testing.B) {
		luteEngine := lute.New()
		luteEngine.SetGFMAutoLink(false)
		luteEngine.SetGFMStrikethrough(false)
		luteEngine.SetGFMTable(false)
		luteEngine.SetGFMTaskListItem(false)
		luteEngine.SetCodeSyntaxHighlight(false)
		luteEngine.SetSoftBreak2HardBreak(false)
		luteEngine.SetAutoSpace(false)
		luteEngine.SetFixTermTypo(false)
		r := func(src []byte) ([]byte, error) {
			out := luteEngine.MarkdownStr("Benchmark", util.BytesToReadOnlyString(src))
			return util.StringToReadOnlyBytes(out), nil
		}
		doBenchmark(b, r)
	})

	b.Run("GoMarkdown", func(b *testing.B) {
		r := func(src []byte) ([]byte, error) {
			out := gomarkdown.ToHTML(src, nil, nil)
			return out, nil
		}
		doBenchmark(b, r)
	})

}

// The different frameworks have different APIs. Create an adapter that
// should behave the same in the memory department.
func doBenchmark(b *testing.B, render func(src []byte) ([]byte, error)) {
	b.StopTimer()
	source, err := ioutil.ReadFile("_data.md")
	if err != nil {
		b.Fatal(err)
	}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		out, err := render(source)
		if err != nil {
			b.Fatal(err)
		}
		if len(out) < 100 {
			b.Fatal("No result")
		}
	}
}
</file>

<file path="_test/options.txt">
1
//- - - - - - - - -//
## Title 0

## Title1 # {#id_1 .class-1}

## Title2 {#id_2}

## Title3 ## {#id_3 .class-3}

## Title4 ## {data-attr3=value3}

## Title5 ## {#id_5 data-attr5=value5}

## Title6 ## {#id_6 .class6 data-attr6=value6}

## Title7 ## {#id_7 data-attr7="value \"7"}

## Title8 {#id .className data-attrName=attrValue class="class1 class2"}
//- - - - - - - - -//
<h2 id="title-0">Title 0</h2>
<h2 id="id_1" class="class-1">Title1</h2>
<h2 id="id_2">Title2</h2>
<h2 id="id_3" class="class-3">Title3</h2>
<h2 data-attr3="value3" id="title4">Title4</h2>
<h2 id="id_5" data-attr5="value5">Title5</h2>
<h2 id="id_6" class="class6" data-attr6="value6">Title6</h2>
<h2 id="id_7" data-attr7="value &quot;7">Title7</h2>
<h2 id="id" class="className class1 class2" data-attrName="attrValue">Title8</h2>
//= = = = = = = = = = = = = = = = = = = = = = = =//

2
//- - - - - - - - -//
#
# FOO
//- - - - - - - - -//
<h1 id="heading"></h1>
<h1 id="foo">FOO</h1>
//= = = = = = = = = = = = = = = = = = = = = = = =//

3
//- - - - - - - - -//
## `records(self, zone, params={})`
//- - - - - - - - -//
<h2 id="recordsself-zone-params"><code>records(self, zone, params={})</code></h2>
//= = = = = = = = = = = = = = = = = = = = = = = =//


4
//- - - - - - - - -//
## Test {#hey .sort,class=fine,class=shell} Doesn't matter
//- - - - - - - - -//
<h2 id="test-hey-sortclassfineclassshell-doesnt-matter">Test {#hey .sort,class=fine,class=shell} Doesn't matter</h2>
//= = = = = = = = = = = = = = = = = = = = = = = =//


5
//- - - - - - - - -//
## Test ## {#hey .sort,class=fine,class=shell} Doesn't matter
//- - - - - - - - -//
<h2 id="test--hey-sortclassfineclassshell-doesnt-matter">Test ## {#hey .sort,class=fine,class=shell} Doesn't matter</h2>
//= = = = = = = = = = = = = = = = = = = = = = = =//


6: class must be a string
//- - - - - - - - -//
# Test ## {class=0#.}
//- - - - - - - - -//
<h1 id="test--class0">Test ## {class=0#.}</h1>
//= = = = = = = = = = = = = = = = = = = = = = = =//


7: short handed ids can contain hyphens ("-"), underscores ("_"), colons (":"), and periods (".")
//- - - - - - - - -//
# Test ## {#id-foo_bar:baz.qux .foobar}
//- - - - - - - - -//
<h1 id="id-foo_bar:baz.qux" class="foobar">Test</h1>
//= = = = = = = = = = = = = = = = = = = = = = = =//
</file>

<file path=".github/ISSUE_TEMPLATE.md">
goldmark has [https://github.com/yuin/goldmark/discussions](Discussions) in github.
You should post only issues here. Feature requests and questions should be posted at discussions.


- [ ] goldmark is fully compliant with the CommonMark. Before submitting issue, you **must** read [CommonMark spec](https://spec.commonmark.org/0.29/) and confirm your output is different from [CommonMark online demo](https://spec.commonmark.org/dingus/).
    - [ ] **Extensions(Autolink without `<` `>`, Table, etc) are not part of CommonMark spec.** You should confirm your output is different from other official renderers correspond with an extension.
- [ ] **goldmark is not dedicated for Hugo**. If you are Hugo user and your issue was raised by your experience in Hugo, **you should consider create issue at Hugo repository at first** .

Please answer the following before submitting your issue:

1. What version of goldmark are you using? : 
2. What version of Go are you using? : 
3. What operating system and processor architecture are you using? :
4. What did you do? :
5. What did you expect to see? :
6. What did you see instead? :
7. Did you confirm your output is different from [CommonMark online demo](https://spec.commonmark.org/dingus/) or other official renderer correspond with an extension?:
</file>

<file path="extension/_test/footnote.txt">
1
//- - - - - - - - -//
That's some text with a footnote.[^1]

[^1]: And that's the footnote.

    That's the second paragraph.
//- - - - - - - - -//
<p>That's some text with a footnote.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>And that's the footnote.</p>
<p>That's the second paragraph.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
//= = = = = = = = = = = = = = = = = = = = = = = =//

3
//- - - - - - - - -//
[^000]:0	[^]:
//- - - - - - - - -//
//= = = = = = = = = = = = = = = = = = = = = = = =//

4
//- - - - - - - - -//
This[^3] is[^1] text with footnotes[^2].

[^1]: Footnote one
[^2]: Footnote two
[^3]: Footnote three
//- - - - - - - - -//
<p>This<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> is<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> text with footnotes<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Footnote three&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Footnote one&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Footnote two&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
//= = = = = = = = = = = = = = = = = = = = = = = =//


5
//- - - - - - - - -//
test![^1]

[^1]: footnote
//- - - - - - - - -//
<p>test!<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>footnote&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
//= = = = = = = = = = = = = = = = = = = = = = = =//

6: Multiple references to the same footnotes should have different ids
//- - - - - - - - -//
something[^fn:1]

something[^fn:1]

something[^fn:1]

[^fn:1]: footnote text
//- - - - - - - - -//
<p>something<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>something<sup id="fnref1:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>something<sup id="fnref2:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>footnote text&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref2:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
//= = = = = = = = = = = = = = = = = = = = = = = =//
</file>

<file path="extension/_test/linkify.txt">
1
//- - - - - - - - -//
www.commonmark.org
//- - - - - - - - -//
<p><a href="http://www.commonmark.org">www.commonmark.org</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



2
//- - - - - - - - -//
Visit www.commonmark.org/help for more information.
//- - - - - - - - -//
<p>Visit <a href="http://www.commonmark.org/help">www.commonmark.org/help</a> for more information.</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



3
//- - - - - - - - -//
www.google.com/search?q=Markup+(business)

www.google.com/search?q=Markup+(business)))

(www.google.com/search?q=Markup+(business))

(www.google.com/search?q=Markup+(business)
//- - - - - - - - -//
<p><a href="http://www.google.com/search?q=Markup+(business)">www.google.com/search?q=Markup+(business)</a></p>
<p><a href="http://www.google.com/search?q=Markup+(business)">www.google.com/search?q=Markup+(business)</a>))</p>
<p>(<a href="http://www.google.com/search?q=Markup+(business)">www.google.com/search?q=Markup+(business)</a>)</p>
<p>(<a href="http://www.google.com/search?q=Markup+(business)">www.google.com/search?q=Markup+(business)</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



4
//- - - - - - - - -//
www.google.com/search?q=(business))+ok
//- - - - - - - - -//
<p><a href="http://www.google.com/search?q=(business))+ok">www.google.com/search?q=(business))+ok</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



5
//- - - - - - - - -//
www.google.com/search?q=commonmark&hl=en

www.google.com/search?q=commonmark&hl;
//- - - - - - - - -//
<p><a href="http://www.google.com/search?q=commonmark&amp;hl=en">www.google.com/search?q=commonmark&amp;hl=en</a></p>
<p><a href="http://www.google.com/search?q=commonmark">www.google.com/search?q=commonmark</a>&amp;hl;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



6
//- - - - - - - - -//
www.commonmark.org/he<lp
//- - - - - - - - -//
<p><a href="http://www.commonmark.org/he">www.commonmark.org/he</a>&lt;lp</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



7
//- - - - - - - - -//
http://commonmark.org

(Visit https://encrypted.google.com/search?q=Markup+(business))

Anonymous FTP is available at ftp://foo.bar.baz.
//- - - - - - - - -//
<p><a href="http://commonmark.org">http://commonmark.org</a></p>
<p>(Visit <a href="https://encrypted.google.com/search?q=Markup+(business)">https://encrypted.google.com/search?q=Markup+(business)</a>)</p>
<p>Anonymous FTP is available at <a href="ftp://foo.bar.baz">ftp://foo.bar.baz</a>.</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



8
//- - - - - - - - -//
foo@bar.baz
//- - - - - - - - -//
<p><a href="mailto:foo@bar.baz">foo@bar.baz</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



9
//- - - - - - - - -//
hello@mail+xyz.example isn't valid, but hello+xyz@mail.example is.
//- - - - - - - - -//
<p>hello@mail+xyz.example isn't valid, but <a href="mailto:hello+xyz@mail.example">hello+xyz@mail.example</a> is.</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



10
//- - - - - - - - -//
a.b-c_d@a.b

a.b-c_d@a.b.

a.b-c_d@a.b-

a.b-c_d@a.b_
//- - - - - - - - -//
<p><a href="mailto:a.b-c_d@a.b">a.b-c_d@a.b</a></p>
<p><a href="mailto:a.b-c_d@a.b">a.b-c_d@a.b</a>.</p>
<p>a.b-c_d@a.b-</p>
<p>a.b-c_d@a.b_</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



11
//- - - - - - - - -//
https://github.com#sun,mon
//- - - - - - - - -//
<p><a href="https://github.com#sun,mon">https://github.com#sun,mon</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



12
//- - - - - - - - -//
https://github.com/sunday's
//- - - - - - - - -//
<p><a href="https://github.com/sunday's">https://github.com/sunday's</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

13
//- - - - - - - - -//
https://github.com?q=stars:>1
//- - - - - - - - -//
<p><a href="https://github.com?q=stars:%3E1">https://github.com?q=stars:&gt;1</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


14
//- - - - - - - - -//
[https://google.com](https://google.com)
//- - - - - - - - -//
<p><a href="https://google.com">https://google.com</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


15
//- - - - - - - - -//
This is a `git@github.com:vim/vim`
//- - - - - - - - -//
<p>This is a <code>git@github.com:vim/vim</code></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


16
//- - - - - - - - -//
https://nic.college
//- - - - - - - - -//
<p><a href="https://nic.college">https://nic.college</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


17
//- - - - - - - - -//
http://server.intranet.acme.com:1313
//- - - - - - - - -//
<p><a href="http://server.intranet.acme.com:1313">http://server.intranet.acme.com:1313</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


18
//- - - - - - - - -//
https://g.page/foo
//- - - - - - - - -//
<p><a href="https://g.page/foo">https://g.page/foo</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


19: Trailing punctuation (specifically, ?, !, ., ,, :, *, _, and ~) will not be considered part of the autolink
//- - - - - - - - -//
__http://test.com/~/a__
__http://test.com/~/__
__http://test.com/~__
__http://test.com/a/~__
//- - - - - - - - -//
<p><strong><a href="http://test.com/~/a">http://test.com/~/a</a></strong>
<strong><a href="http://test.com/~/">http://test.com/~/</a></strong>
<strong><a href="http://test.com/">http://test.com/</a>~</strong>
<strong><a href="http://test.com/a/">http://test.com/a/</a>~</strong></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//
</file>

<file path="extension/ast/definition_list.go">
package ast

import (
	gast "github.com/yuin/goldmark/ast"
)

// A DefinitionList struct represents a definition list of Markdown
// (PHPMarkdownExtra) text.
type DefinitionList struct {
	gast.BaseBlock
	Offset             int
	TemporaryParagraph *gast.Paragraph
}

// Dump implements Node.Dump.
func (n *DefinitionList) Dump(source []byte, level int) {
	gast.DumpHelper(n, source, level, nil, nil)
}

// KindDefinitionList is a NodeKind of the DefinitionList node.
var KindDefinitionList = gast.NewNodeKind("DefinitionList")

// Kind implements Node.Kind.
func (n *DefinitionList) Kind() gast.NodeKind {
	return KindDefinitionList
}

// NewDefinitionList returns a new DefinitionList node.
func NewDefinitionList(offset int, para *gast.Paragraph) *DefinitionList {
	return &DefinitionList{
		Offset:             offset,
		TemporaryParagraph: para,
	}
}

// A DefinitionTerm struct represents a definition list term of Markdown
// (PHPMarkdownExtra) text.
type DefinitionTerm struct {
	gast.BaseBlock
}

// Dump implements Node.Dump.
func (n *DefinitionTerm) Dump(source []byte, level int) {
	gast.DumpHelper(n, source, level, nil, nil)
}

// KindDefinitionTerm is a NodeKind of the DefinitionTerm node.
var KindDefinitionTerm = gast.NewNodeKind("DefinitionTerm")

// Kind implements Node.Kind.
func (n *DefinitionTerm) Kind() gast.NodeKind {
	return KindDefinitionTerm
}

// NewDefinitionTerm returns a new DefinitionTerm node.
func NewDefinitionTerm() *DefinitionTerm {
	return &DefinitionTerm{}
}

// A DefinitionDescription struct represents a definition list description of Markdown
// (PHPMarkdownExtra) text.
type DefinitionDescription struct {
	gast.BaseBlock
	IsTight bool
}

// Dump implements Node.Dump.
func (n *DefinitionDescription) Dump(source []byte, level int) {
	gast.DumpHelper(n, source, level, nil, nil)
}

// KindDefinitionDescription is a NodeKind of the DefinitionDescription node.
var KindDefinitionDescription = gast.NewNodeKind("DefinitionDescription")

// Kind implements Node.Kind.
func (n *DefinitionDescription) Kind() gast.NodeKind {
	return KindDefinitionDescription
}

// NewDefinitionDescription returns a new DefinitionDescription node.
func NewDefinitionDescription() *DefinitionDescription {
	return &DefinitionDescription{}
}
</file>

<file path="extension/ast/strikethrough.go">
// Package ast defines AST nodes that represents extension's elements
package ast

import (
	gast "github.com/yuin/goldmark/ast"
)

// A Strikethrough struct represents a strikethrough of GFM text.
type Strikethrough struct {
	gast.BaseInline
}

// Dump implements Node.Dump.
func (n *Strikethrough) Dump(source []byte, level int) {
	gast.DumpHelper(n, source, level, nil, nil)
}

// KindStrikethrough is a NodeKind of the Strikethrough node.
var KindStrikethrough = gast.NewNodeKind("Strikethrough")

// Kind implements Node.Kind.
func (n *Strikethrough) Kind() gast.NodeKind {
	return KindStrikethrough
}

// NewStrikethrough returns a new Strikethrough node.
func NewStrikethrough() *Strikethrough {
	return &Strikethrough{}
}
</file>

<file path="extension/ast/tasklist.go">
package ast

import (
	"fmt"
	gast "github.com/yuin/goldmark/ast"
)

// A TaskCheckBox struct represents a checkbox of a task list.
type TaskCheckBox struct {
	gast.BaseInline
	IsChecked bool
}

// Dump implements Node.Dump.
func (n *TaskCheckBox) Dump(source []byte, level int) {
	m := map[string]string{
		"Checked": fmt.Sprintf("%v", n.IsChecked),
	}
	gast.DumpHelper(n, source, level, m, nil)
}

// KindTaskCheckBox is a NodeKind of the TaskCheckBox node.
var KindTaskCheckBox = gast.NewNodeKind("TaskCheckBox")

// Kind implements Node.Kind.
func (n *TaskCheckBox) Kind() gast.NodeKind {
	return KindTaskCheckBox
}

// NewTaskCheckBox returns a new TaskCheckBox node.
func NewTaskCheckBox(checked bool) *TaskCheckBox {
	return &TaskCheckBox{
		IsChecked: checked,
	}
}
</file>

<file path="extension/definition_list_test.go">
package extension

import (
	"testing"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
)

func TestDefinitionList(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			DefinitionList,
		),
	)
	testutil.DoTestCaseFile(markdown, "_test/definition_list.txt", t, testutil.ParseCliCaseArg()...)
}
</file>

<file path="extension/gfm.go">
package extension

import (
	"github.com/yuin/goldmark"
)

type gfm struct {
}

// GFM is an extension that provides Github Flavored markdown functionalities.
var GFM = &gfm{}

func (e *gfm) Extend(m goldmark.Markdown) {
	Linkify.Extend(m)
	Table.Extend(m)
	Strikethrough.Extend(m)
	TaskList.Extend(m)
}
</file>

<file path="extension/strikethrough_test.go">
package extension

import (
	"testing"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
)

func TestStrikethrough(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			Strikethrough,
		),
	)
	testutil.DoTestCaseFile(markdown, "_test/strikethrough.txt", t, testutil.ParseCliCaseArg()...)
}
</file>

<file path="extension/tasklist_test.go">
package extension

import (
	"testing"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
)

func TestTaskList(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			TaskList,
		),
	)
	testutil.DoTestCaseFile(markdown, "_test/tasklist.txt", t, testutil.ParseCliCaseArg()...)
}
</file>

<file path="extension/typographer_test.go">
package extension

import (
	"testing"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
)

func TestTypographer(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			Typographer,
		),
	)
	testutil.DoTestCaseFile(markdown, "_test/typographer.txt", t, testutil.ParseCliCaseArg()...)
}
</file>

<file path="parser/auto_link.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type autoLinkParser struct {
}

var defaultAutoLinkParser = &autoLinkParser{}

// NewAutoLinkParser returns a new InlineParser that parses autolinks
// surrounded by '<' and '>' .
func NewAutoLinkParser() InlineParser {
	return defaultAutoLinkParser
}

func (s *autoLinkParser) Trigger() []byte {
	return []byte{'<'}
}

func (s *autoLinkParser) Parse(parent ast.Node, block text.Reader, pc Context) ast.Node {
	line, segment := block.PeekLine()
	stop := util.FindEmailIndex(line[1:])
	typ := ast.AutoLinkType(ast.AutoLinkEmail)
	if stop < 0 {
		stop = util.FindURLIndex(line[1:])
		typ = ast.AutoLinkURL
	}
	if stop < 0 {
		return nil
	}
	stop++
	if stop >= len(line) || line[stop] != '>' {
		return nil
	}
	value := ast.NewTextSegment(text.NewSegment(segment.Start+1, segment.Start+stop))
	block.Advance(stop + 1)
	return ast.NewAutoLink(typ, value)
}
</file>

<file path="parser/code_span.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
)

type codeSpanParser struct {
}

var defaultCodeSpanParser = &codeSpanParser{}

// NewCodeSpanParser return a new InlineParser that parses inline codes
// surrounded by '`' .
func NewCodeSpanParser() InlineParser {
	return defaultCodeSpanParser
}

func (s *codeSpanParser) Trigger() []byte {
	return []byte{'`'}
}

func (s *codeSpanParser) Parse(parent ast.Node, block text.Reader, pc Context) ast.Node {
	line, startSegment := block.PeekLine()
	opener := 0
	for ; opener < len(line) && line[opener] == '`'; opener++ {
	}
	block.Advance(opener)
	l, pos := block.Position()
	node := ast.NewCodeSpan()
	for {
		line, segment := block.PeekLine()
		if line == nil {
			block.SetPosition(l, pos)
			return ast.NewTextSegment(startSegment.WithStop(startSegment.Start + opener))
		}
		for i := 0; i < len(line); i++ {
			c := line[i]
			if c == '`' {
				oldi := i
				for ; i < len(line) && line[i] == '`'; i++ {
				}
				closure := i - oldi
				if closure == opener && (i >= len(line) || line[i] != '`') {
					segment = segment.WithStop(segment.Start + i - closure)
					if !segment.IsEmpty() {
						node.AppendChild(node, ast.NewRawTextSegment(segment))
					}
					block.Advance(i)
					goto end
				}
			}
		}
		node.AppendChild(node, ast.NewRawTextSegment(segment))
		block.AdvanceLine()
	}
end:
	if !node.IsBlank(block.Source()) {
		// trim first halfspace and last halfspace
		segment := node.FirstChild().(*ast.Text).Segment
		shouldTrimmed := true
		if !(!segment.IsEmpty() && isSpaceOrNewline(block.Source()[segment.Start])) {
			shouldTrimmed = false
		}
		segment = node.LastChild().(*ast.Text).Segment
		if !(!segment.IsEmpty() && isSpaceOrNewline(block.Source()[segment.Stop-1])) {
			shouldTrimmed = false
		}
		if shouldTrimmed {
			t := node.FirstChild().(*ast.Text)
			segment := t.Segment
			t.Segment = segment.WithStart(segment.Start + 1)
			t = node.LastChild().(*ast.Text)
			segment = node.LastChild().(*ast.Text).Segment
			t.Segment = segment.WithStop(segment.Stop - 1)
		}

	}
	return node
}

func isSpaceOrNewline(c byte) bool {
	return c == ' ' || c == '\n'
}
</file>

<file path="parser/emphasis.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
)

type emphasisDelimiterProcessor struct {
}

func (p *emphasisDelimiterProcessor) IsDelimiter(b byte) bool {
	return b == '*' || b == '_'
}

func (p *emphasisDelimiterProcessor) CanOpenCloser(opener, closer *Delimiter) bool {
	return opener.Char == closer.Char
}

func (p *emphasisDelimiterProcessor) OnMatch(consumes int) ast.Node {
	return ast.NewEmphasis(consumes)
}

var defaultEmphasisDelimiterProcessor = &emphasisDelimiterProcessor{}

type emphasisParser struct {
}

var defaultEmphasisParser = &emphasisParser{}

// NewEmphasisParser return a new InlineParser that parses emphasises.
func NewEmphasisParser() InlineParser {
	return defaultEmphasisParser
}

func (s *emphasisParser) Trigger() []byte {
	return []byte{'*', '_'}
}

func (s *emphasisParser) Parse(parent ast.Node, block text.Reader, pc Context) ast.Node {
	before := block.PrecendingCharacter()
	line, segment := block.PeekLine()
	node := ScanDelimiter(line, before, 1, defaultEmphasisDelimiterProcessor)
	if node == nil {
		return nil
	}
	node.Segment = segment.WithStop(segment.Start + node.OriginalLength)
	block.Advance(node.OriginalLength)
	pc.PushDelimiter(node)
	return node
}
</file>

<file path="parser/link_ref.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type linkReferenceParagraphTransformer struct {
}

// LinkReferenceParagraphTransformer is a ParagraphTransformer implementation
// that parses and extracts link reference from paragraphs.
var LinkReferenceParagraphTransformer = &linkReferenceParagraphTransformer{}

func (p *linkReferenceParagraphTransformer) Transform(node *ast.Paragraph, reader text.Reader, pc Context) {
	lines := node.Lines()
	block := text.NewBlockReader(reader.Source(), lines)
	removes := [][2]int{}
	for {
		start, end := parseLinkReferenceDefinition(block, pc)
		if start > -1 {
			if start == end {
				end++
			}
			removes = append(removes, [2]int{start, end})
			continue
		}
		break
	}

	offset := 0
	for _, remove := range removes {
		if lines.Len() == 0 {
			break
		}
		s := lines.Sliced(remove[1]-offset, lines.Len())
		lines.SetSliced(0, remove[0]-offset)
		lines.AppendAll(s)
		offset = remove[1]
	}

	if lines.Len() == 0 {
		t := ast.NewTextBlock()
		t.SetBlankPreviousLines(node.HasBlankPreviousLines())
		node.Parent().ReplaceChild(node.Parent(), node, t)
		return
	}

	node.SetLines(lines)
}

func parseLinkReferenceDefinition(block text.Reader, pc Context) (int, int) {
	block.SkipSpaces()
	line, _ := block.PeekLine()
	if line == nil {
		return -1, -1
	}
	startLine, _ := block.Position()
	width, pos := util.IndentWidth(line, 0)
	if width > 3 {
		return -1, -1
	}
	if width != 0 {
		pos++
	}
	if line[pos] != '[' {
		return -1, -1
	}
	block.Advance(pos + 1)
	segments, found := block.FindClosure('[', ']', linkFindClosureOptions)
	if !found {
		return -1, -1
	}
	var label []byte
	if segments.Len() == 1 {
		label = block.Value(segments.At(0))
	} else {
		for i := 0; i < segments.Len(); i++ {
			s := segments.At(i)
			label = append(label, block.Value(s)...)
		}
	}
	if util.IsBlank(label) {
		return -1, -1
	}
	if block.Peek() != ':' {
		return -1, -1
	}
	block.Advance(1)
	block.SkipSpaces()
	destination, ok := parseLinkDestination(block)
	if !ok {
		return -1, -1
	}
	line, _ = block.PeekLine()
	isNewLine := line == nil || util.IsBlank(line)

	endLine, _ := block.Position()
	_, spaces, _ := block.SkipSpaces()
	opener := block.Peek()
	if opener != '"' && opener != '\'' && opener != '(' {
		if !isNewLine {
			return -1, -1
		}
		ref := NewReference(label, destination, nil)
		pc.AddReference(ref)
		return startLine, endLine + 1
	}
	if spaces == 0 {
		return -1, -1
	}
	block.Advance(1)
	closer := opener
	if opener == '(' {
		closer = ')'
	}
	segments, found = block.FindClosure(opener, closer, linkFindClosureOptions)
	if !found {
		if !isNewLine {
			return -1, -1
		}
		ref := NewReference(label, destination, nil)
		pc.AddReference(ref)
		block.AdvanceLine()
		return startLine, endLine + 1
	}
	var title []byte
	if segments.Len() == 1 {
		title = block.Value(segments.At(0))
	} else {
		for i := 0; i < segments.Len(); i++ {
			s := segments.At(i)
			title = append(title, block.Value(s)...)
		}
	}

	line, _ = block.PeekLine()
	if line != nil && !util.IsBlank(line) {
		if !isNewLine {
			return -1, -1
		}
		ref := NewReference(label, destination, title)
		pc.AddReference(ref)
		return startLine, endLine
	}

	endLine, _ = block.Position()
	ref := NewReference(label, destination, title)
	pc.AddReference(ref)
	return startLine, endLine + 1
}
</file>

<file path="testutil/testutil_test.go">
package testutil

import "testing"

// This will fail to compile if the TestingT interface is changed in a way
// that doesn't conform to testing.T.
var _ TestingT = (*testing.T)(nil)
</file>

<file path=".gitignore">
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, build with `go test -c`
*.test
*.pprof

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

.DS_Store
fuzz/corpus
fuzz/crashers
fuzz/suppressions
fuzz/fuzz-fuzz.zip
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2019 Yusuke Inuzuka

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="options_test.go">
package goldmark_test

import (
	"testing"

	. "github.com/yuin/goldmark"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/testutil"
)

func TestAttributeAndAutoHeadingID(t *testing.T) {
	markdown := New(
		WithParserOptions(
			parser.WithAttribute(),
			parser.WithAutoHeadingID(),
		),
	)
	testutil.DoTestCaseFile(markdown, "_test/options.txt", t, testutil.ParseCliCaseArg()...)
}
</file>

<file path="_benchmark/cmark/Makefile">
CMARK_BIN=cmark_benchmark
CMARK_RUN=LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:./cmark-master/build/src ./$(CMARK_BIN)
ifeq ($(OS),Windows_NT)
  CMARK_BIN=cmark_benchmark.exe
  CMARK_RUN=bash -c "PATH=./cmark-master/build/src:$${PATH} ./$(CMARK_BIN)"
endif

.PHONY: run

run: $(CMARK_BIN)
	@ $(CMARK_RUN)
	go run ./goldmark_benchmark.go

./cmark-master/Makefile:
	wget -nc -O cmark.zip https://github.com/commonmark/cmark/archive/master.zip
	unzip cmark.zip
	rm -f cmark.zip
	cd cmark-master && make

$(CMARK_BIN): ./cmark-master/Makefile cmark_benchmark.c
	gcc -I./cmark-master/build/src -I./cmark-master/src  cmark_benchmark.c -o $(CMARK_BIN) -L./cmark-master/build/src -lcmark; \

.PHONY: clean
clean:
	rm -f $(CMARK_BIN)
</file>

<file path="_test/spec.json">
[
  {
    "markdown": "\tfoo\tbaz\t\tbim\n",
    "html": "<pre><code>foo\tbaz\t\tbim\n</code></pre>\n",
    "example": 1,
    "start_line": 355,
    "end_line": 360,
    "section": "Tabs"
  },
  {
    "markdown": "  \tfoo\tbaz\t\tbim\n",
    "html": "<pre><code>foo\tbaz\t\tbim\n</code></pre>\n",
    "example": 2,
    "start_line": 362,
    "end_line": 367,
    "section": "Tabs"
  },
  {
    "markdown": "    a\ta\n    ὐ\ta\n",
    "html": "<pre><code>a\ta\nὐ\ta\n</code></pre>\n",
    "example": 3,
    "start_line": 369,
    "end_line": 376,
    "section": "Tabs"
  },
  {
    "markdown": "  - foo\n\n\tbar\n",
    "html": "<ul>\n<li>\n<p>foo</p>\n<p>bar</p>\n</li>\n</ul>\n",
    "example": 4,
    "start_line": 382,
    "end_line": 393,
    "section": "Tabs"
  },
  {
    "markdown": "- foo\n\n\t\tbar\n",
    "html": "<ul>\n<li>\n<p>foo</p>\n<pre><code>  bar\n</code></pre>\n</li>\n</ul>\n",
    "example": 5,
    "start_line": 395,
    "end_line": 407,
    "section": "Tabs"
  },
  {
    "markdown": ">\t\tfoo\n",
    "html": "<blockquote>\n<pre><code>  foo\n</code></pre>\n</blockquote>\n",
    "example": 6,
    "start_line": 418,
    "end_line": 425,
    "section": "Tabs"
  },
  {
    "markdown": "-\t\tfoo\n",
    "html": "<ul>\n<li>\n<pre><code>  foo\n</code></pre>\n</li>\n</ul>\n",
    "example": 7,
    "start_line": 427,
    "end_line": 436,
    "section": "Tabs"
  },
  {
    "markdown": "    foo\n\tbar\n",
    "html": "<pre><code>foo\nbar\n</code></pre>\n",
    "example": 8,
    "start_line": 439,
    "end_line": 446,
    "section": "Tabs"
  },
  {
    "markdown": " - foo\n   - bar\n\t - baz\n",
    "html": "<ul>\n<li>foo\n<ul>\n<li>bar\n<ul>\n<li>baz</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n",
    "example": 9,
    "start_line": 448,
    "end_line": 464,
    "section": "Tabs"
  },
  {
    "markdown": "#\tFoo\n",
    "html": "<h1>Foo</h1>\n",
    "example": 10,
    "start_line": 466,
    "end_line": 470,
    "section": "Tabs"
  },
  {
    "markdown": "*\t*\t*\t\n",
    "html": "<hr />\n",
    "example": 11,
    "start_line": 472,
    "end_line": 476,
    "section": "Tabs"
  },
  {
    "markdown": "\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\-\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\\\\\]\\^\\_\\`\\{\\|\\}\\~\n",
    "html": "<p>!&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~</p>\n",
    "example": 12,
    "start_line": 489,
    "end_line": 493,
    "section": "Backslash escapes"
  },
  {
    "markdown": "\\\t\\A\\a\\ \\3\\φ\\«\n",
    "html": "<p>\\\t\\A\\a\\ \\3\\φ\\«</p>\n",
    "example": 13,
    "start_line": 499,
    "end_line": 503,
    "section": "Backslash escapes"
  },
  {
    "markdown": "\\*not emphasized*\n\\<br/> not a tag\n\\[not a link](/foo)\n\\`not code`\n1\\. not a list\n\\* not a list\n\\# not a heading\n\\[foo]: /url \"not a reference\"\n\\&ouml; not a character entity\n",
    "html": "<p>*not emphasized*\n&lt;br/&gt; not a tag\n[not a link](/foo)\n`not code`\n1. not a list\n* not a list\n# not a heading\n[foo]: /url &quot;not a reference&quot;\n&amp;ouml; not a character entity</p>\n",
    "example": 14,
    "start_line": 509,
    "end_line": 529,
    "section": "Backslash escapes"
  },
  {
    "markdown": "\\\\*emphasis*\n",
    "html": "<p>\\<em>emphasis</em></p>\n",
    "example": 15,
    "start_line": 534,
    "end_line": 538,
    "section": "Backslash escapes"
  },
  {
    "markdown": "foo\\\nbar\n",
    "html": "<p>foo<br />\nbar</p>\n",
    "example": 16,
    "start_line": 543,
    "end_line": 549,
    "section": "Backslash escapes"
  },
  {
    "markdown": "`` \\[\\` ``\n",
    "html": "<p><code>\\[\\`</code></p>\n",
    "example": 17,
    "start_line": 555,
    "end_line": 559,
    "section": "Backslash escapes"
  },
  {
    "markdown": "    \\[\\]\n",
    "html": "<pre><code>\\[\\]\n</code></pre>\n",
    "example": 18,
    "start_line": 562,
    "end_line": 567,
    "section": "Backslash escapes"
  },
  {
    "markdown": "~~~\n\\[\\]\n~~~\n",
    "html": "<pre><code>\\[\\]\n</code></pre>\n",
    "example": 19,
    "start_line": 570,
    "end_line": 577,
    "section": "Backslash escapes"
  },
  {
    "markdown": "<https://example.com?find=\\*>\n",
    "html": "<p><a href=\"https://example.com?find=%5C*\">https://example.com?find=\\*</a></p>\n",
    "example": 20,
    "start_line": 580,
    "end_line": 584,
    "section": "Backslash escapes"
  },
  {
    "markdown": "<a href=\"/bar\\/)\">\n",
    "html": "<a href=\"/bar\\/)\">\n",
    "example": 21,
    "start_line": 587,
    "end_line": 591,
    "section": "Backslash escapes"
  },
  {
    "markdown": "[foo](/bar\\* \"ti\\*tle\")\n",
    "html": "<p><a href=\"/bar*\" title=\"ti*tle\">foo</a></p>\n",
    "example": 22,
    "start_line": 597,
    "end_line": 601,
    "section": "Backslash escapes"
  },
  {
    "markdown": "[foo]\n\n[foo]: /bar\\* \"ti\\*tle\"\n",
    "html": "<p><a href=\"/bar*\" title=\"ti*tle\">foo</a></p>\n",
    "example": 23,
    "start_line": 604,
    "end_line": 610,
    "section": "Backslash escapes"
  },
  {
    "markdown": "``` foo\\+bar\nfoo\n```\n",
    "html": "<pre><code class=\"language-foo+bar\">foo\n</code></pre>\n",
    "example": 24,
    "start_line": 613,
    "end_line": 620,
    "section": "Backslash escapes"
  },
  {
    "markdown": "&nbsp; &amp; &copy; &AElig; &Dcaron;\n&frac34; &HilbertSpace; &DifferentialD;\n&ClockwiseContourIntegral; &ngE;\n",
    "html": "<p>  &amp; © Æ Ď\n¾ ℋ ⅆ\n∲ ≧̸</p>\n",
    "example": 25,
    "start_line": 649,
    "end_line": 657,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "&#35; &#1234; &#992; &#0;\n",
    "html": "<p># Ӓ Ϡ �</p>\n",
    "example": 26,
    "start_line": 668,
    "end_line": 672,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "&#X22; &#XD06; &#xcab;\n",
    "html": "<p>&quot; ആ ಫ</p>\n",
    "example": 27,
    "start_line": 681,
    "end_line": 685,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "&nbsp &x; &#; &#x;\n&#87654321;\n&#abcdef0;\n&ThisIsNotDefined; &hi?;\n",
    "html": "<p>&amp;nbsp &amp;x; &amp;#; &amp;#x;\n&amp;#87654321;\n&amp;#abcdef0;\n&amp;ThisIsNotDefined; &amp;hi?;</p>\n",
    "example": 28,
    "start_line": 690,
    "end_line": 700,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "&copy\n",
    "html": "<p>&amp;copy</p>\n",
    "example": 29,
    "start_line": 707,
    "end_line": 711,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "&MadeUpEntity;\n",
    "html": "<p>&amp;MadeUpEntity;</p>\n",
    "example": 30,
    "start_line": 717,
    "end_line": 721,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "<a href=\"&ouml;&ouml;.html\">\n",
    "html": "<a href=\"&ouml;&ouml;.html\">\n",
    "example": 31,
    "start_line": 728,
    "end_line": 732,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "[foo](/f&ouml;&ouml; \"f&ouml;&ouml;\")\n",
    "html": "<p><a href=\"/f%C3%B6%C3%B6\" title=\"föö\">foo</a></p>\n",
    "example": 32,
    "start_line": 735,
    "end_line": 739,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "[foo]\n\n[foo]: /f&ouml;&ouml; \"f&ouml;&ouml;\"\n",
    "html": "<p><a href=\"/f%C3%B6%C3%B6\" title=\"föö\">foo</a></p>\n",
    "example": 33,
    "start_line": 742,
    "end_line": 748,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "``` f&ouml;&ouml;\nfoo\n```\n",
    "html": "<pre><code class=\"language-föö\">foo\n</code></pre>\n",
    "example": 34,
    "start_line": 751,
    "end_line": 758,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "`f&ouml;&ouml;`\n",
    "html": "<p><code>f&amp;ouml;&amp;ouml;</code></p>\n",
    "example": 35,
    "start_line": 764,
    "end_line": 768,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "    f&ouml;f&ouml;\n",
    "html": "<pre><code>f&amp;ouml;f&amp;ouml;\n</code></pre>\n",
    "example": 36,
    "start_line": 771,
    "end_line": 776,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "&#42;foo&#42;\n*foo*\n",
    "html": "<p>*foo*\n<em>foo</em></p>\n",
    "example": 37,
    "start_line": 783,
    "end_line": 789,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "&#42; foo\n\n* foo\n",
    "html": "<p>* foo</p>\n<ul>\n<li>foo</li>\n</ul>\n",
    "example": 38,
    "start_line": 791,
    "end_line": 800,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "foo&#10;&#10;bar\n",
    "html": "<p>foo\n\nbar</p>\n",
    "example": 39,
    "start_line": 802,
    "end_line": 808,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "&#9;foo\n",
    "html": "<p>\tfoo</p>\n",
    "example": 40,
    "start_line": 810,
    "end_line": 814,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "[a](url &quot;tit&quot;)\n",
    "html": "<p>[a](url &quot;tit&quot;)</p>\n",
    "example": 41,
    "start_line": 817,
    "end_line": 821,
    "section": "Entity and numeric character references"
  },
  {
    "markdown": "- `one\n- two`\n",
    "html": "<ul>\n<li>`one</li>\n<li>two`</li>\n</ul>\n",
    "example": 42,
    "start_line": 840,
    "end_line": 848,
    "section": "Precedence"
  },
  {
    "markdown": "***\n---\n___\n",
    "html": "<hr />\n<hr />\n<hr />\n",
    "example": 43,
    "start_line": 879,
    "end_line": 887,
    "section": "Thematic breaks"
  },
  {
    "markdown": "+++\n",
    "html": "<p>+++</p>\n",
    "example": 44,
    "start_line": 892,
    "end_line": 896,
    "section": "Thematic breaks"
  },
  {
    "markdown": "===\n",
    "html": "<p>===</p>\n",
    "example": 45,
    "start_line": 899,
    "end_line": 903,
    "section": "Thematic breaks"
  },
  {
    "markdown": "--\n**\n__\n",
    "html": "<p>--\n**\n__</p>\n",
    "example": 46,
    "start_line": 908,
    "end_line": 916,
    "section": "Thematic breaks"
  },
  {
    "markdown": " ***\n  ***\n   ***\n",
    "html": "<hr />\n<hr />\n<hr />\n",
    "example": 47,
    "start_line": 921,
    "end_line": 929,
    "section": "Thematic breaks"
  },
  {
    "markdown": "    ***\n",
    "html": "<pre><code>***\n</code></pre>\n",
    "example": 48,
    "start_line": 934,
    "end_line": 939,
    "section": "Thematic breaks"
  },
  {
    "markdown": "Foo\n    ***\n",
    "html": "<p>Foo\n***</p>\n",
    "example": 49,
    "start_line": 942,
    "end_line": 948,
    "section": "Thematic breaks"
  },
  {
    "markdown": "_____________________________________\n",
    "html": "<hr />\n",
    "example": 50,
    "start_line": 953,
    "end_line": 957,
    "section": "Thematic breaks"
  },
  {
    "markdown": " - - -\n",
    "html": "<hr />\n",
    "example": 51,
    "start_line": 962,
    "end_line": 966,
    "section": "Thematic breaks"
  },
  {
    "markdown": " **  * ** * ** * **\n",
    "html": "<hr />\n",
    "example": 52,
    "start_line": 969,
    "end_line": 973,
    "section": "Thematic breaks"
  },
  {
    "markdown": "-     -      -      -\n",
    "html": "<hr />\n",
    "example": 53,
    "start_line": 976,
    "end_line": 980,
    "section": "Thematic breaks"
  },
  {
    "markdown": "- - - -    \n",
    "html": "<hr />\n",
    "example": 54,
    "start_line": 985,
    "end_line": 989,
    "section": "Thematic breaks"
  },
  {
    "markdown": "_ _ _ _ a\n\na------\n\n---a---\n",
    "html": "<p>_ _ _ _ a</p>\n<p>a------</p>\n<p>---a---</p>\n",
    "example": 55,
    "start_line": 994,
    "end_line": 1004,
    "section": "Thematic breaks"
  },
  {
    "markdown": " *-*\n",
    "html": "<p><em>-</em></p>\n",
    "example": 56,
    "start_line": 1010,
    "end_line": 1014,
    "section": "Thematic breaks"
  },
  {
    "markdown": "- foo\n***\n- bar\n",
    "html": "<ul>\n<li>foo</li>\n</ul>\n<hr />\n<ul>\n<li>bar</li>\n</ul>\n",
    "example": 57,
    "start_line": 1019,
    "end_line": 1031,
    "section": "Thematic breaks"
  },
  {
    "markdown": "Foo\n***\nbar\n",
    "html": "<p>Foo</p>\n<hr />\n<p>bar</p>\n",
    "example": 58,
    "start_line": 1036,
    "end_line": 1044,
    "section": "Thematic breaks"
  },
  {
    "markdown": "Foo\n---\nbar\n",
    "html": "<h2>Foo</h2>\n<p>bar</p>\n",
    "example": 59,
    "start_line": 1053,
    "end_line": 1060,
    "section": "Thematic breaks"
  },
  {
    "markdown": "* Foo\n* * *\n* Bar\n",
    "html": "<ul>\n<li>Foo</li>\n</ul>\n<hr />\n<ul>\n<li>Bar</li>\n</ul>\n",
    "example": 60,
    "start_line": 1066,
    "end_line": 1078,
    "section": "Thematic breaks"
  },
  {
    "markdown": "- Foo\n- * * *\n",
    "html": "<ul>\n<li>Foo</li>\n<li>\n<hr />\n</li>\n</ul>\n",
    "example": 61,
    "start_line": 1083,
    "end_line": 1093,
    "section": "Thematic breaks"
  },
  {
    "markdown": "# foo\n## foo\n### foo\n#### foo\n##### foo\n###### foo\n",
    "html": "<h1>foo</h1>\n<h2>foo</h2>\n<h3>foo</h3>\n<h4>foo</h4>\n<h5>foo</h5>\n<h6>foo</h6>\n",
    "example": 62,
    "start_line": 1112,
    "end_line": 1126,
    "section": "ATX headings"
  },
  {
    "markdown": "####### foo\n",
    "html": "<p>####### foo</p>\n",
    "example": 63,
    "start_line": 1131,
    "end_line": 1135,
    "section": "ATX headings"
  },
  {
    "markdown": "#5 bolt\n\n#hashtag\n",
    "html": "<p>#5 bolt</p>\n<p>#hashtag</p>\n",
    "example": 64,
    "start_line": 1146,
    "end_line": 1153,
    "section": "ATX headings"
  },
  {
    "markdown": "\\## foo\n",
    "html": "<p>## foo</p>\n",
    "example": 65,
    "start_line": 1158,
    "end_line": 1162,
    "section": "ATX headings"
  },
  {
    "markdown": "# foo *bar* \\*baz\\*\n",
    "html": "<h1>foo <em>bar</em> *baz*</h1>\n",
    "example": 66,
    "start_line": 1167,
    "end_line": 1171,
    "section": "ATX headings"
  },
  {
    "markdown": "#                  foo                     \n",
    "html": "<h1>foo</h1>\n",
    "example": 67,
    "start_line": 1176,
    "end_line": 1180,
    "section": "ATX headings"
  },
  {
    "markdown": " ### foo\n  ## foo\n   # foo\n",
    "html": "<h3>foo</h3>\n<h2>foo</h2>\n<h1>foo</h1>\n",
    "example": 68,
    "start_line": 1185,
    "end_line": 1193,
    "section": "ATX headings"
  },
  {
    "markdown": "    # foo\n",
    "html": "<pre><code># foo\n</code></pre>\n",
    "example": 69,
    "start_line": 1198,
    "end_line": 1203,
    "section": "ATX headings"
  },
  {
    "markdown": "foo\n    # bar\n",
    "html": "<p>foo\n# bar</p>\n",
    "example": 70,
    "start_line": 1206,
    "end_line": 1212,
    "section": "ATX headings"
  },
  {
    "markdown": "## foo ##\n  ###   bar    ###\n",
    "html": "<h2>foo</h2>\n<h3>bar</h3>\n",
    "example": 71,
    "start_line": 1217,
    "end_line": 1223,
    "section": "ATX headings"
  },
  {
    "markdown": "# foo ##################################\n##### foo ##\n",
    "html": "<h1>foo</h1>\n<h5>foo</h5>\n",
    "example": 72,
    "start_line": 1228,
    "end_line": 1234,
    "section": "ATX headings"
  },
  {
    "markdown": "### foo ###     \n",
    "html": "<h3>foo</h3>\n",
    "example": 73,
    "start_line": 1239,
    "end_line": 1243,
    "section": "ATX headings"
  },
  {
    "markdown": "### foo ### b\n",
    "html": "<h3>foo ### b</h3>\n",
    "example": 74,
    "start_line": 1250,
    "end_line": 1254,
    "section": "ATX headings"
  },
  {
    "markdown": "# foo#\n",
    "html": "<h1>foo#</h1>\n",
    "example": 75,
    "start_line": 1259,
    "end_line": 1263,
    "section": "ATX headings"
  },
  {
    "markdown": "### foo \\###\n## foo #\\##\n# foo \\#\n",
    "html": "<h3>foo ###</h3>\n<h2>foo ###</h2>\n<h1>foo #</h1>\n",
    "example": 76,
    "start_line": 1269,
    "end_line": 1277,
    "section": "ATX headings"
  },
  {
    "markdown": "****\n## foo\n****\n",
    "html": "<hr />\n<h2>foo</h2>\n<hr />\n",
    "example": 77,
    "start_line": 1283,
    "end_line": 1291,
    "section": "ATX headings"
  },
  {
    "markdown": "Foo bar\n# baz\nBar foo\n",
    "html": "<p>Foo bar</p>\n<h1>baz</h1>\n<p>Bar foo</p>\n",
    "example": 78,
    "start_line": 1294,
    "end_line": 1302,
    "section": "ATX headings"
  },
  {
    "markdown": "## \n#\n### ###\n",
    "html": "<h2></h2>\n<h1></h1>\n<h3></h3>\n",
    "example": 79,
    "start_line": 1307,
    "end_line": 1315,
    "section": "ATX headings"
  },
  {
    "markdown": "Foo *bar*\n=========\n\nFoo *bar*\n---------\n",
    "html": "<h1>Foo <em>bar</em></h1>\n<h2>Foo <em>bar</em></h2>\n",
    "example": 80,
    "start_line": 1347,
    "end_line": 1356,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo *bar\nbaz*\n====\n",
    "html": "<h1>Foo <em>bar\nbaz</em></h1>\n",
    "example": 81,
    "start_line": 1361,
    "end_line": 1368,
    "section": "Setext headings"
  },
  {
    "markdown": "  Foo *bar\nbaz*\t\n====\n",
    "html": "<h1>Foo <em>bar\nbaz</em></h1>\n",
    "example": 82,
    "start_line": 1375,
    "end_line": 1382,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\n-------------------------\n\nFoo\n=\n",
    "html": "<h2>Foo</h2>\n<h1>Foo</h1>\n",
    "example": 83,
    "start_line": 1387,
    "end_line": 1396,
    "section": "Setext headings"
  },
  {
    "markdown": "   Foo\n---\n\n  Foo\n-----\n\n  Foo\n  ===\n",
    "html": "<h2>Foo</h2>\n<h2>Foo</h2>\n<h1>Foo</h1>\n",
    "example": 84,
    "start_line": 1402,
    "end_line": 1415,
    "section": "Setext headings"
  },
  {
    "markdown": "    Foo\n    ---\n\n    Foo\n---\n",
    "html": "<pre><code>Foo\n---\n\nFoo\n</code></pre>\n<hr />\n",
    "example": 85,
    "start_line": 1420,
    "end_line": 1433,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\n   ----      \n",
    "html": "<h2>Foo</h2>\n",
    "example": 86,
    "start_line": 1439,
    "end_line": 1444,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\n    ---\n",
    "html": "<p>Foo\n---</p>\n",
    "example": 87,
    "start_line": 1449,
    "end_line": 1455,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\n= =\n\nFoo\n--- -\n",
    "html": "<p>Foo\n= =</p>\n<p>Foo</p>\n<hr />\n",
    "example": 88,
    "start_line": 1460,
    "end_line": 1471,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo  \n-----\n",
    "html": "<h2>Foo</h2>\n",
    "example": 89,
    "start_line": 1476,
    "end_line": 1481,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\\\n----\n",
    "html": "<h2>Foo\\</h2>\n",
    "example": 90,
    "start_line": 1486,
    "end_line": 1491,
    "section": "Setext headings"
  },
  {
    "markdown": "`Foo\n----\n`\n\n<a title=\"a lot\n---\nof dashes\"/>\n",
    "html": "<h2>`Foo</h2>\n<p>`</p>\n<h2>&lt;a title=&quot;a lot</h2>\n<p>of dashes&quot;/&gt;</p>\n",
    "example": 91,
    "start_line": 1497,
    "end_line": 1510,
    "section": "Setext headings"
  },
  {
    "markdown": "> Foo\n---\n",
    "html": "<blockquote>\n<p>Foo</p>\n</blockquote>\n<hr />\n",
    "example": 92,
    "start_line": 1516,
    "end_line": 1524,
    "section": "Setext headings"
  },
  {
    "markdown": "> foo\nbar\n===\n",
    "html": "<blockquote>\n<p>foo\nbar\n===</p>\n</blockquote>\n",
    "example": 93,
    "start_line": 1527,
    "end_line": 1537,
    "section": "Setext headings"
  },
  {
    "markdown": "- Foo\n---\n",
    "html": "<ul>\n<li>Foo</li>\n</ul>\n<hr />\n",
    "example": 94,
    "start_line": 1540,
    "end_line": 1548,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\nBar\n---\n",
    "html": "<h2>Foo\nBar</h2>\n",
    "example": 95,
    "start_line": 1555,
    "end_line": 1562,
    "section": "Setext headings"
  },
  {
    "markdown": "---\nFoo\n---\nBar\n---\nBaz\n",
    "html": "<hr />\n<h2>Foo</h2>\n<h2>Bar</h2>\n<p>Baz</p>\n",
    "example": 96,
    "start_line": 1568,
    "end_line": 1580,
    "section": "Setext headings"
  },
  {
    "markdown": "\n====\n",
    "html": "<p>====</p>\n",
    "example": 97,
    "start_line": 1585,
    "end_line": 1590,
    "section": "Setext headings"
  },
  {
    "markdown": "---\n---\n",
    "html": "<hr />\n<hr />\n",
    "example": 98,
    "start_line": 1597,
    "end_line": 1603,
    "section": "Setext headings"
  },
  {
    "markdown": "- foo\n-----\n",
    "html": "<ul>\n<li>foo</li>\n</ul>\n<hr />\n",
    "example": 99,
    "start_line": 1606,
    "end_line": 1614,
    "section": "Setext headings"
  },
  {
    "markdown": "    foo\n---\n",
    "html": "<pre><code>foo\n</code></pre>\n<hr />\n",
    "example": 100,
    "start_line": 1617,
    "end_line": 1624,
    "section": "Setext headings"
  },
  {
    "markdown": "> foo\n-----\n",
    "html": "<blockquote>\n<p>foo</p>\n</blockquote>\n<hr />\n",
    "example": 101,
    "start_line": 1627,
    "end_line": 1635,
    "section": "Setext headings"
  },
  {
    "markdown": "\\> foo\n------\n",
    "html": "<h2>&gt; foo</h2>\n",
    "example": 102,
    "start_line": 1641,
    "end_line": 1646,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\n\nbar\n---\nbaz\n",
    "html": "<p>Foo</p>\n<h2>bar</h2>\n<p>baz</p>\n",
    "example": 103,
    "start_line": 1672,
    "end_line": 1682,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\nbar\n\n---\n\nbaz\n",
    "html": "<p>Foo\nbar</p>\n<hr />\n<p>baz</p>\n",
    "example": 104,
    "start_line": 1688,
    "end_line": 1700,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\nbar\n* * *\nbaz\n",
    "html": "<p>Foo\nbar</p>\n<hr />\n<p>baz</p>\n",
    "example": 105,
    "start_line": 1706,
    "end_line": 1716,
    "section": "Setext headings"
  },
  {
    "markdown": "Foo\nbar\n\\---\nbaz\n",
    "html": "<p>Foo\nbar\n---\nbaz</p>\n",
    "example": 106,
    "start_line": 1721,
    "end_line": 1731,
    "section": "Setext headings"
  },
  {
    "markdown": "    a simple\n      indented code block\n",
    "html": "<pre><code>a simple\n  indented code block\n</code></pre>\n",
    "example": 107,
    "start_line": 1749,
    "end_line": 1756,
    "section": "Indented code blocks"
  },
  {
    "markdown": "  - foo\n\n    bar\n",
    "html": "<ul>\n<li>\n<p>foo</p>\n<p>bar</p>\n</li>\n</ul>\n",
    "example": 108,
    "start_line": 1763,
    "end_line": 1774,
    "section": "Indented code blocks"
  },
  {
    "markdown": "1.  foo\n\n    - bar\n",
    "html": "<ol>\n<li>\n<p>foo</p>\n<ul>\n<li>bar</li>\n</ul>\n</li>\n</ol>\n",
    "example": 109,
    "start_line": 1777,
    "end_line": 1790,
    "section": "Indented code blocks"
  },
  {
    "markdown": "    <a/>\n    *hi*\n\n    - one\n",
    "html": "<pre><code>&lt;a/&gt;\n*hi*\n\n- one\n</code></pre>\n",
    "example": 110,
    "start_line": 1797,
    "end_line": 1808,
    "section": "Indented code blocks"
  },
  {
    "markdown": "    chunk1\n\n    chunk2\n  \n \n \n    chunk3\n",
    "html": "<pre><code>chunk1\n\nchunk2\n\n\n\nchunk3\n</code></pre>\n",
    "example": 111,
    "start_line": 1813,
    "end_line": 1830,
    "section": "Indented code blocks"
  },
  {
    "markdown": "    chunk1\n      \n      chunk2\n",
    "html": "<pre><code>chunk1\n  \n  chunk2\n</code></pre>\n",
    "example": 112,
    "start_line": 1836,
    "end_line": 1845,
    "section": "Indented code blocks"
  },
  {
    "markdown": "Foo\n    bar\n\n",
    "html": "<p>Foo\nbar</p>\n",
    "example": 113,
    "start_line": 1851,
    "end_line": 1858,
    "section": "Indented code blocks"
  },
  {
    "markdown": "    foo\nbar\n",
    "html": "<pre><code>foo\n</code></pre>\n<p>bar</p>\n",
    "example": 114,
    "start_line": 1865,
    "end_line": 1872,
    "section": "Indented code blocks"
  },
  {
    "markdown": "# Heading\n    foo\nHeading\n------\n    foo\n----\n",
    "html": "<h1>Heading</h1>\n<pre><code>foo\n</code></pre>\n<h2>Heading</h2>\n<pre><code>foo\n</code></pre>\n<hr />\n",
    "example": 115,
    "start_line": 1878,
    "end_line": 1893,
    "section": "Indented code blocks"
  },
  {
    "markdown": "        foo\n    bar\n",
    "html": "<pre><code>    foo\nbar\n</code></pre>\n",
    "example": 116,
    "start_line": 1898,
    "end_line": 1905,
    "section": "Indented code blocks"
  },
  {
    "markdown": "\n    \n    foo\n    \n\n",
    "html": "<pre><code>foo\n</code></pre>\n",
    "example": 117,
    "start_line": 1911,
    "end_line": 1920,
    "section": "Indented code blocks"
  },
  {
    "markdown": "    foo  \n",
    "html": "<pre><code>foo  \n</code></pre>\n",
    "example": 118,
    "start_line": 1925,
    "end_line": 1930,
    "section": "Indented code blocks"
  },
  {
    "markdown": "```\n<\n >\n```\n",
    "html": "<pre><code>&lt;\n &gt;\n</code></pre>\n",
    "example": 119,
    "start_line": 1980,
    "end_line": 1989,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "~~~\n<\n >\n~~~\n",
    "html": "<pre><code>&lt;\n &gt;\n</code></pre>\n",
    "example": 120,
    "start_line": 1994,
    "end_line": 2003,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "``\nfoo\n``\n",
    "html": "<p><code>foo</code></p>\n",
    "example": 121,
    "start_line": 2007,
    "end_line": 2013,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "```\naaa\n~~~\n```\n",
    "html": "<pre><code>aaa\n~~~\n</code></pre>\n",
    "example": 122,
    "start_line": 2018,
    "end_line": 2027,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "~~~\naaa\n```\n~~~\n",
    "html": "<pre><code>aaa\n```\n</code></pre>\n",
    "example": 123,
    "start_line": 2030,
    "end_line": 2039,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "````\naaa\n```\n``````\n",
    "html": "<pre><code>aaa\n```\n</code></pre>\n",
    "example": 124,
    "start_line": 2044,
    "end_line": 2053,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "~~~~\naaa\n~~~\n~~~~\n",
    "html": "<pre><code>aaa\n~~~\n</code></pre>\n",
    "example": 125,
    "start_line": 2056,
    "end_line": 2065,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "```\n",
    "html": "<pre><code></code></pre>\n",
    "example": 126,
    "start_line": 2071,
    "end_line": 2075,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "`````\n\n```\naaa\n",
    "html": "<pre><code>\n```\naaa\n</code></pre>\n",
    "example": 127,
    "start_line": 2078,
    "end_line": 2088,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "> ```\n> aaa\n\nbbb\n",
    "html": "<blockquote>\n<pre><code>aaa\n</code></pre>\n</blockquote>\n<p>bbb</p>\n",
    "example": 128,
    "start_line": 2091,
    "end_line": 2102,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "```\n\n  \n```\n",
    "html": "<pre><code>\n  \n</code></pre>\n",
    "example": 129,
    "start_line": 2107,
    "end_line": 2116,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "```\n```\n",
    "html": "<pre><code></code></pre>\n",
    "example": 130,
    "start_line": 2121,
    "end_line": 2126,
    "section": "Fenced code blocks"
  },
  {
    "markdown": " ```\n aaa\naaa\n```\n",
    "html": "<pre><code>aaa\naaa\n</code></pre>\n",
    "example": 131,
    "start_line": 2133,
    "end_line": 2142,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "  ```\naaa\n  aaa\naaa\n  ```\n",
    "html": "<pre><code>aaa\naaa\naaa\n</code></pre>\n",
    "example": 132,
    "start_line": 2145,
    "end_line": 2156,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "   ```\n   aaa\n    aaa\n  aaa\n   ```\n",
    "html": "<pre><code>aaa\n aaa\naaa\n</code></pre>\n",
    "example": 133,
    "start_line": 2159,
    "end_line": 2170,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "    ```\n    aaa\n    ```\n",
    "html": "<pre><code>```\naaa\n```\n</code></pre>\n",
    "example": 134,
    "start_line": 2175,
    "end_line": 2184,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "```\naaa\n  ```\n",
    "html": "<pre><code>aaa\n</code></pre>\n",
    "example": 135,
    "start_line": 2190,
    "end_line": 2197,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "   ```\naaa\n  ```\n",
    "html": "<pre><code>aaa\n</code></pre>\n",
    "example": 136,
    "start_line": 2200,
    "end_line": 2207,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "```\naaa\n    ```\n",
    "html": "<pre><code>aaa\n    ```\n</code></pre>\n",
    "example": 137,
    "start_line": 2212,
    "end_line": 2220,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "``` ```\naaa\n",
    "html": "<p><code> </code>\naaa</p>\n",
    "example": 138,
    "start_line": 2226,
    "end_line": 2232,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "~~~~~~\naaa\n~~~ ~~\n",
    "html": "<pre><code>aaa\n~~~ ~~\n</code></pre>\n",
    "example": 139,
    "start_line": 2235,
    "end_line": 2243,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "foo\n```\nbar\n```\nbaz\n",
    "html": "<p>foo</p>\n<pre><code>bar\n</code></pre>\n<p>baz</p>\n",
    "example": 140,
    "start_line": 2249,
    "end_line": 2260,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "foo\n---\n~~~\nbar\n~~~\n# baz\n",
    "html": "<h2>foo</h2>\n<pre><code>bar\n</code></pre>\n<h1>baz</h1>\n",
    "example": 141,
    "start_line": 2266,
    "end_line": 2278,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "```ruby\ndef foo(x)\n  return 3\nend\n```\n",
    "html": "<pre><code class=\"language-ruby\">def foo(x)\n  return 3\nend\n</code></pre>\n",
    "example": 142,
    "start_line": 2288,
    "end_line": 2299,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "~~~~    ruby startline=3 $%@#$\ndef foo(x)\n  return 3\nend\n~~~~~~~\n",
    "html": "<pre><code class=\"language-ruby\">def foo(x)\n  return 3\nend\n</code></pre>\n",
    "example": 143,
    "start_line": 2302,
    "end_line": 2313,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "````;\n````\n",
    "html": "<pre><code class=\"language-;\"></code></pre>\n",
    "example": 144,
    "start_line": 2316,
    "end_line": 2321,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "``` aa ```\nfoo\n",
    "html": "<p><code>aa</code>\nfoo</p>\n",
    "example": 145,
    "start_line": 2326,
    "end_line": 2332,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "~~~ aa ``` ~~~\nfoo\n~~~\n",
    "html": "<pre><code class=\"language-aa\">foo\n</code></pre>\n",
    "example": 146,
    "start_line": 2337,
    "end_line": 2344,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "```\n``` aaa\n```\n",
    "html": "<pre><code>``` aaa\n</code></pre>\n",
    "example": 147,
    "start_line": 2349,
    "end_line": 2356,
    "section": "Fenced code blocks"
  },
  {
    "markdown": "<table><tr><td>\n<pre>\n**Hello**,\n\n_world_.\n</pre>\n</td></tr></table>\n",
    "html": "<table><tr><td>\n<pre>\n**Hello**,\n<p><em>world</em>.\n</pre></p>\n</td></tr></table>\n",
    "example": 148,
    "start_line": 2428,
    "end_line": 2443,
    "section": "HTML blocks"
  },
  {
    "markdown": "<table>\n  <tr>\n    <td>\n           hi\n    </td>\n  </tr>\n</table>\n\nokay.\n",
    "html": "<table>\n  <tr>\n    <td>\n           hi\n    </td>\n  </tr>\n</table>\n<p>okay.</p>\n",
    "example": 149,
    "start_line": 2457,
    "end_line": 2476,
    "section": "HTML blocks"
  },
  {
    "markdown": " <div>\n  *hello*\n         <foo><a>\n",
    "html": " <div>\n  *hello*\n         <foo><a>\n",
    "example": 150,
    "start_line": 2479,
    "end_line": 2487,
    "section": "HTML blocks"
  },
  {
    "markdown": "</div>\n*foo*\n",
    "html": "</div>\n*foo*\n",
    "example": 151,
    "start_line": 2492,
    "end_line": 2498,
    "section": "HTML blocks"
  },
  {
    "markdown": "<DIV CLASS=\"foo\">\n\n*Markdown*\n\n</DIV>\n",
    "html": "<DIV CLASS=\"foo\">\n<p><em>Markdown</em></p>\n</DIV>\n",
    "example": 152,
    "start_line": 2503,
    "end_line": 2513,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div id=\"foo\"\n  class=\"bar\">\n</div>\n",
    "html": "<div id=\"foo\"\n  class=\"bar\">\n</div>\n",
    "example": 153,
    "start_line": 2519,
    "end_line": 2527,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div id=\"foo\" class=\"bar\n  baz\">\n</div>\n",
    "html": "<div id=\"foo\" class=\"bar\n  baz\">\n</div>\n",
    "example": 154,
    "start_line": 2530,
    "end_line": 2538,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div>\n*foo*\n\n*bar*\n",
    "html": "<div>\n*foo*\n<p><em>bar</em></p>\n",
    "example": 155,
    "start_line": 2542,
    "end_line": 2551,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div id=\"foo\"\n*hi*\n",
    "html": "<div id=\"foo\"\n*hi*\n",
    "example": 156,
    "start_line": 2558,
    "end_line": 2564,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div class\nfoo\n",
    "html": "<div class\nfoo\n",
    "example": 157,
    "start_line": 2567,
    "end_line": 2573,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div *???-&&&-<---\n*foo*\n",
    "html": "<div *???-&&&-<---\n*foo*\n",
    "example": 158,
    "start_line": 2579,
    "end_line": 2585,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div><a href=\"bar\">*foo*</a></div>\n",
    "html": "<div><a href=\"bar\">*foo*</a></div>\n",
    "example": 159,
    "start_line": 2591,
    "end_line": 2595,
    "section": "HTML blocks"
  },
  {
    "markdown": "<table><tr><td>\nfoo\n</td></tr></table>\n",
    "html": "<table><tr><td>\nfoo\n</td></tr></table>\n",
    "example": 160,
    "start_line": 2598,
    "end_line": 2606,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div></div>\n``` c\nint x = 33;\n```\n",
    "html": "<div></div>\n``` c\nint x = 33;\n```\n",
    "example": 161,
    "start_line": 2615,
    "end_line": 2625,
    "section": "HTML blocks"
  },
  {
    "markdown": "<a href=\"foo\">\n*bar*\n</a>\n",
    "html": "<a href=\"foo\">\n*bar*\n</a>\n",
    "example": 162,
    "start_line": 2632,
    "end_line": 2640,
    "section": "HTML blocks"
  },
  {
    "markdown": "<Warning>\n*bar*\n</Warning>\n",
    "html": "<Warning>\n*bar*\n</Warning>\n",
    "example": 163,
    "start_line": 2645,
    "end_line": 2653,
    "section": "HTML blocks"
  },
  {
    "markdown": "<i class=\"foo\">\n*bar*\n</i>\n",
    "html": "<i class=\"foo\">\n*bar*\n</i>\n",
    "example": 164,
    "start_line": 2656,
    "end_line": 2664,
    "section": "HTML blocks"
  },
  {
    "markdown": "</ins>\n*bar*\n",
    "html": "</ins>\n*bar*\n",
    "example": 165,
    "start_line": 2667,
    "end_line": 2673,
    "section": "HTML blocks"
  },
  {
    "markdown": "<del>\n*foo*\n</del>\n",
    "html": "<del>\n*foo*\n</del>\n",
    "example": 166,
    "start_line": 2682,
    "end_line": 2690,
    "section": "HTML blocks"
  },
  {
    "markdown": "<del>\n\n*foo*\n\n</del>\n",
    "html": "<del>\n<p><em>foo</em></p>\n</del>\n",
    "example": 167,
    "start_line": 2697,
    "end_line": 2707,
    "section": "HTML blocks"
  },
  {
    "markdown": "<del>*foo*</del>\n",
    "html": "<p><del><em>foo</em></del></p>\n",
    "example": 168,
    "start_line": 2715,
    "end_line": 2719,
    "section": "HTML blocks"
  },
  {
    "markdown": "<pre language=\"haskell\"><code>\nimport Text.HTML.TagSoup\n\nmain :: IO ()\nmain = print $ parseTags tags\n</code></pre>\nokay\n",
    "html": "<pre language=\"haskell\"><code>\nimport Text.HTML.TagSoup\n\nmain :: IO ()\nmain = print $ parseTags tags\n</code></pre>\n<p>okay</p>\n",
    "example": 169,
    "start_line": 2731,
    "end_line": 2747,
    "section": "HTML blocks"
  },
  {
    "markdown": "<script type=\"text/javascript\">\n// JavaScript example\n\ndocument.getElementById(\"demo\").innerHTML = \"Hello JavaScript!\";\n</script>\nokay\n",
    "html": "<script type=\"text/javascript\">\n// JavaScript example\n\ndocument.getElementById(\"demo\").innerHTML = \"Hello JavaScript!\";\n</script>\n<p>okay</p>\n",
    "example": 170,
    "start_line": 2752,
    "end_line": 2766,
    "section": "HTML blocks"
  },
  {
    "markdown": "<textarea>\n\n*foo*\n\n_bar_\n\n</textarea>\n",
    "html": "<textarea>\n\n*foo*\n\n_bar_\n\n</textarea>\n",
    "example": 171,
    "start_line": 2771,
    "end_line": 2787,
    "section": "HTML blocks"
  },
  {
    "markdown": "<style\n  type=\"text/css\">\nh1 {color:red;}\n\np {color:blue;}\n</style>\nokay\n",
    "html": "<style\n  type=\"text/css\">\nh1 {color:red;}\n\np {color:blue;}\n</style>\n<p>okay</p>\n",
    "example": 172,
    "start_line": 2791,
    "end_line": 2807,
    "section": "HTML blocks"
  },
  {
    "markdown": "<style\n  type=\"text/css\">\n\nfoo\n",
    "html": "<style\n  type=\"text/css\">\n\nfoo\n",
    "example": 173,
    "start_line": 2814,
    "end_line": 2824,
    "section": "HTML blocks"
  },
  {
    "markdown": "> <div>\n> foo\n\nbar\n",
    "html": "<blockquote>\n<div>\nfoo\n</blockquote>\n<p>bar</p>\n",
    "example": 174,
    "start_line": 2827,
    "end_line": 2838,
    "section": "HTML blocks"
  },
  {
    "markdown": "- <div>\n- foo\n",
    "html": "<ul>\n<li>\n<div>\n</li>\n<li>foo</li>\n</ul>\n",
    "example": 175,
    "start_line": 2841,
    "end_line": 2851,
    "section": "HTML blocks"
  },
  {
    "markdown": "<style>p{color:red;}</style>\n*foo*\n",
    "html": "<style>p{color:red;}</style>\n<p><em>foo</em></p>\n",
    "example": 176,
    "start_line": 2856,
    "end_line": 2862,
    "section": "HTML blocks"
  },
  {
    "markdown": "<!-- foo -->*bar*\n*baz*\n",
    "html": "<!-- foo -->*bar*\n<p><em>baz</em></p>\n",
    "example": 177,
    "start_line": 2865,
    "end_line": 2871,
    "section": "HTML blocks"
  },
  {
    "markdown": "<script>\nfoo\n</script>1. *bar*\n",
    "html": "<script>\nfoo\n</script>1. *bar*\n",
    "example": 178,
    "start_line": 2877,
    "end_line": 2885,
    "section": "HTML blocks"
  },
  {
    "markdown": "<!-- Foo\n\nbar\n   baz -->\nokay\n",
    "html": "<!-- Foo\n\nbar\n   baz -->\n<p>okay</p>\n",
    "example": 179,
    "start_line": 2890,
    "end_line": 2902,
    "section": "HTML blocks"
  },
  {
    "markdown": "<?php\n\n  echo '>';\n\n?>\nokay\n",
    "html": "<?php\n\n  echo '>';\n\n?>\n<p>okay</p>\n",
    "example": 180,
    "start_line": 2908,
    "end_line": 2922,
    "section": "HTML blocks"
  },
  {
    "markdown": "<!DOCTYPE html>\n",
    "html": "<!DOCTYPE html>\n",
    "example": 181,
    "start_line": 2927,
    "end_line": 2931,
    "section": "HTML blocks"
  },
  {
    "markdown": "<![CDATA[\nfunction matchwo(a,b)\n{\n  if (a < b && a < 0) then {\n    return 1;\n\n  } else {\n\n    return 0;\n  }\n}\n]]>\nokay\n",
    "html": "<![CDATA[\nfunction matchwo(a,b)\n{\n  if (a < b && a < 0) then {\n    return 1;\n\n  } else {\n\n    return 0;\n  }\n}\n]]>\n<p>okay</p>\n",
    "example": 182,
    "start_line": 2936,
    "end_line": 2964,
    "section": "HTML blocks"
  },
  {
    "markdown": "  <!-- foo -->\n\n    <!-- foo -->\n",
    "html": "  <!-- foo -->\n<pre><code>&lt;!-- foo --&gt;\n</code></pre>\n",
    "example": 183,
    "start_line": 2970,
    "end_line": 2978,
    "section": "HTML blocks"
  },
  {
    "markdown": "  <div>\n\n    <div>\n",
    "html": "  <div>\n<pre><code>&lt;div&gt;\n</code></pre>\n",
    "example": 184,
    "start_line": 2981,
    "end_line": 2989,
    "section": "HTML blocks"
  },
  {
    "markdown": "Foo\n<div>\nbar\n</div>\n",
    "html": "<p>Foo</p>\n<div>\nbar\n</div>\n",
    "example": 185,
    "start_line": 2995,
    "end_line": 3005,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div>\nbar\n</div>\n*foo*\n",
    "html": "<div>\nbar\n</div>\n*foo*\n",
    "example": 186,
    "start_line": 3012,
    "end_line": 3022,
    "section": "HTML blocks"
  },
  {
    "markdown": "Foo\n<a href=\"bar\">\nbaz\n",
    "html": "<p>Foo\n<a href=\"bar\">\nbaz</p>\n",
    "example": 187,
    "start_line": 3027,
    "end_line": 3035,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div>\n\n*Emphasized* text.\n\n</div>\n",
    "html": "<div>\n<p><em>Emphasized</em> text.</p>\n</div>\n",
    "example": 188,
    "start_line": 3068,
    "end_line": 3078,
    "section": "HTML blocks"
  },
  {
    "markdown": "<div>\n*Emphasized* text.\n</div>\n",
    "html": "<div>\n*Emphasized* text.\n</div>\n",
    "example": 189,
    "start_line": 3081,
    "end_line": 3089,
    "section": "HTML blocks"
  },
  {
    "markdown": "<table>\n\n<tr>\n\n<td>\nHi\n</td>\n\n</tr>\n\n</table>\n",
    "html": "<table>\n<tr>\n<td>\nHi\n</td>\n</tr>\n</table>\n",
    "example": 190,
    "start_line": 3103,
    "end_line": 3123,
    "section": "HTML blocks"
  },
  {
    "markdown": "<table>\n\n  <tr>\n\n    <td>\n      Hi\n    </td>\n\n  </tr>\n\n</table>\n",
    "html": "<table>\n  <tr>\n<pre><code>&lt;td&gt;\n  Hi\n&lt;/td&gt;\n</code></pre>\n  </tr>\n</table>\n",
    "example": 191,
    "start_line": 3130,
    "end_line": 3151,
    "section": "HTML blocks"
  },
  {
    "markdown": "[foo]: /url \"title\"\n\n[foo]\n",
    "html": "<p><a href=\"/url\" title=\"title\">foo</a></p>\n",
    "example": 192,
    "start_line": 3179,
    "end_line": 3185,
    "section": "Link reference definitions"
  },
  {
    "markdown": "   [foo]: \n      /url  \n           'the title'  \n\n[foo]\n",
    "html": "<p><a href=\"/url\" title=\"the title\">foo</a></p>\n",
    "example": 193,
    "start_line": 3188,
    "end_line": 3196,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[Foo*bar\\]]:my_(url) 'title (with parens)'\n\n[Foo*bar\\]]\n",
    "html": "<p><a href=\"my_(url)\" title=\"title (with parens)\">Foo*bar]</a></p>\n",
    "example": 194,
    "start_line": 3199,
    "end_line": 3205,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[Foo bar]:\n<my url>\n'title'\n\n[Foo bar]\n",
    "html": "<p><a href=\"my%20url\" title=\"title\">Foo bar</a></p>\n",
    "example": 195,
    "start_line": 3208,
    "end_line": 3216,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: /url '\ntitle\nline1\nline2\n'\n\n[foo]\n",
    "html": "<p><a href=\"/url\" title=\"\ntitle\nline1\nline2\n\">foo</a></p>\n",
    "example": 196,
    "start_line": 3221,
    "end_line": 3235,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: /url 'title\n\nwith blank line'\n\n[foo]\n",
    "html": "<p>[foo]: /url 'title</p>\n<p>with blank line'</p>\n<p>[foo]</p>\n",
    "example": 197,
    "start_line": 3240,
    "end_line": 3250,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]:\n/url\n\n[foo]\n",
    "html": "<p><a href=\"/url\">foo</a></p>\n",
    "example": 198,
    "start_line": 3255,
    "end_line": 3262,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]:\n\n[foo]\n",
    "html": "<p>[foo]:</p>\n<p>[foo]</p>\n",
    "example": 199,
    "start_line": 3267,
    "end_line": 3274,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: <>\n\n[foo]\n",
    "html": "<p><a href=\"\">foo</a></p>\n",
    "example": 200,
    "start_line": 3279,
    "end_line": 3285,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: <bar>(baz)\n\n[foo]\n",
    "html": "<p>[foo]: <bar>(baz)</p>\n<p>[foo]</p>\n",
    "example": 201,
    "start_line": 3290,
    "end_line": 3297,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: /url\\bar\\*baz \"foo\\\"bar\\baz\"\n\n[foo]\n",
    "html": "<p><a href=\"/url%5Cbar*baz\" title=\"foo&quot;bar\\baz\">foo</a></p>\n",
    "example": 202,
    "start_line": 3303,
    "end_line": 3309,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]\n\n[foo]: url\n",
    "html": "<p><a href=\"url\">foo</a></p>\n",
    "example": 203,
    "start_line": 3314,
    "end_line": 3320,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]\n\n[foo]: first\n[foo]: second\n",
    "html": "<p><a href=\"first\">foo</a></p>\n",
    "example": 204,
    "start_line": 3326,
    "end_line": 3333,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[FOO]: /url\n\n[Foo]\n",
    "html": "<p><a href=\"/url\">Foo</a></p>\n",
    "example": 205,
    "start_line": 3339,
    "end_line": 3345,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[ΑΓΩ]: /φου\n\n[αγω]\n",
    "html": "<p><a href=\"/%CF%86%CE%BF%CF%85\">αγω</a></p>\n",
    "example": 206,
    "start_line": 3348,
    "end_line": 3354,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: /url\n",
    "html": "",
    "example": 207,
    "start_line": 3363,
    "end_line": 3366,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[\nfoo\n]: /url\nbar\n",
    "html": "<p>bar</p>\n",
    "example": 208,
    "start_line": 3371,
    "end_line": 3378,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: /url \"title\" ok\n",
    "html": "<p>[foo]: /url &quot;title&quot; ok</p>\n",
    "example": 209,
    "start_line": 3384,
    "end_line": 3388,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: /url\n\"title\" ok\n",
    "html": "<p>&quot;title&quot; ok</p>\n",
    "example": 210,
    "start_line": 3393,
    "end_line": 3398,
    "section": "Link reference definitions"
  },
  {
    "markdown": "    [foo]: /url \"title\"\n\n[foo]\n",
    "html": "<pre><code>[foo]: /url &quot;title&quot;\n</code></pre>\n<p>[foo]</p>\n",
    "example": 211,
    "start_line": 3404,
    "end_line": 3412,
    "section": "Link reference definitions"
  },
  {
    "markdown": "```\n[foo]: /url\n```\n\n[foo]\n",
    "html": "<pre><code>[foo]: /url\n</code></pre>\n<p>[foo]</p>\n",
    "example": 212,
    "start_line": 3418,
    "end_line": 3428,
    "section": "Link reference definitions"
  },
  {
    "markdown": "Foo\n[bar]: /baz\n\n[bar]\n",
    "html": "<p>Foo\n[bar]: /baz</p>\n<p>[bar]</p>\n",
    "example": 213,
    "start_line": 3433,
    "end_line": 3442,
    "section": "Link reference definitions"
  },
  {
    "markdown": "# [Foo]\n[foo]: /url\n> bar\n",
    "html": "<h1><a href=\"/url\">Foo</a></h1>\n<blockquote>\n<p>bar</p>\n</blockquote>\n",
    "example": 214,
    "start_line": 3448,
    "end_line": 3457,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: /url\nbar\n===\n[foo]\n",
    "html": "<h1>bar</h1>\n<p><a href=\"/url\">foo</a></p>\n",
    "example": 215,
    "start_line": 3459,
    "end_line": 3467,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: /url\n===\n[foo]\n",
    "html": "<p>===\n<a href=\"/url\">foo</a></p>\n",
    "example": 216,
    "start_line": 3469,
    "end_line": 3476,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]: /foo-url \"foo\"\n[bar]: /bar-url\n  \"bar\"\n[baz]: /baz-url\n\n[foo],\n[bar],\n[baz]\n",
    "html": "<p><a href=\"/foo-url\" title=\"foo\">foo</a>,\n<a href=\"/bar-url\" title=\"bar\">bar</a>,\n<a href=\"/baz-url\">baz</a></p>\n",
    "example": 217,
    "start_line": 3482,
    "end_line": 3495,
    "section": "Link reference definitions"
  },
  {
    "markdown": "[foo]\n\n> [foo]: /url\n",
    "html": "<p><a href=\"/url\">foo</a></p>\n<blockquote>\n</blockquote>\n",
    "example": 218,
    "start_line": 3503,
    "end_line": 3511,
    "section": "Link reference definitions"
  },
  {
    "markdown": "aaa\n\nbbb\n",
    "html": "<p>aaa</p>\n<p>bbb</p>\n",
    "example": 219,
    "start_line": 3525,
    "end_line": 3532,
    "section": "Paragraphs"
  },
  {
    "markdown": "aaa\nbbb\n\nccc\nddd\n",
    "html": "<p>aaa\nbbb</p>\n<p>ccc\nddd</p>\n",
    "example": 220,
    "start_line": 3537,
    "end_line": 3548,
    "section": "Paragraphs"
  },
  {
    "markdown": "aaa\n\n\nbbb\n",
    "html": "<p>aaa</p>\n<p>bbb</p>\n",
    "example": 221,
    "start_line": 3553,
    "end_line": 3561,
    "section": "Paragraphs"
  },
  {
    "markdown": "  aaa\n bbb\n",
    "html": "<p>aaa\nbbb</p>\n",
    "example": 222,
    "start_line": 3566,
    "end_line": 3572,
    "section": "Paragraphs"
  },
  {
    "markdown": "aaa\n             bbb\n                                       ccc\n",
    "html": "<p>aaa\nbbb\nccc</p>\n",
    "example": 223,
    "start_line": 3578,
    "end_line": 3586,
    "section": "Paragraphs"
  },
  {
    "markdown": "   aaa\nbbb\n",
    "html": "<p>aaa\nbbb</p>\n",
    "example": 224,
    "start_line": 3592,
    "end_line": 3598,
    "section": "Paragraphs"
  },
  {
    "markdown": "    aaa\nbbb\n",
    "html": "<pre><code>aaa\n</code></pre>\n<p>bbb</p>\n",
    "example": 225,
    "start_line": 3601,
    "end_line": 3608,
    "section": "Paragraphs"
  },
  {
    "markdown": "aaa     \nbbb     \n",
    "html": "<p>aaa<br />\nbbb</p>\n",
    "example": 226,
    "start_line": 3615,
    "end_line": 3621,
    "section": "Paragraphs"
  },
  {
    "markdown": "  \n\naaa\n  \n\n# aaa\n\n  \n",
    "html": "<p>aaa</p>\n<h1>aaa</h1>\n",
    "example": 227,
    "start_line": 3632,
    "end_line": 3644,
    "section": "Blank lines"
  },
  {
    "markdown": "> # Foo\n> bar\n> baz\n",
    "html": "<blockquote>\n<h1>Foo</h1>\n<p>bar\nbaz</p>\n</blockquote>\n",
    "example": 228,
    "start_line": 3700,
    "end_line": 3710,
    "section": "Block quotes"
  },
  {
    "markdown": "># Foo\n>bar\n> baz\n",
    "html": "<blockquote>\n<h1>Foo</h1>\n<p>bar\nbaz</p>\n</blockquote>\n",
    "example": 229,
    "start_line": 3715,
    "end_line": 3725,
    "section": "Block quotes"
  },
  {
    "markdown": "   > # Foo\n   > bar\n > baz\n",
    "html": "<blockquote>\n<h1>Foo</h1>\n<p>bar\nbaz</p>\n</blockquote>\n",
    "example": 230,
    "start_line": 3730,
    "end_line": 3740,
    "section": "Block quotes"
  },
  {
    "markdown": "    > # Foo\n    > bar\n    > baz\n",
    "html": "<pre><code>&gt; # Foo\n&gt; bar\n&gt; baz\n</code></pre>\n",
    "example": 231,
    "start_line": 3745,
    "end_line": 3754,
    "section": "Block quotes"
  },
  {
    "markdown": "> # Foo\n> bar\nbaz\n",
    "html": "<blockquote>\n<h1>Foo</h1>\n<p>bar\nbaz</p>\n</blockquote>\n",
    "example": 232,
    "start_line": 3760,
    "end_line": 3770,
    "section": "Block quotes"
  },
  {
    "markdown": "> bar\nbaz\n> foo\n",
    "html": "<blockquote>\n<p>bar\nbaz\nfoo</p>\n</blockquote>\n",
    "example": 233,
    "start_line": 3776,
    "end_line": 3786,
    "section": "Block quotes"
  },
  {
    "markdown": "> foo\n---\n",
    "html": "<blockquote>\n<p>foo</p>\n</blockquote>\n<hr />\n",
    "example": 234,
    "start_line": 3800,
    "end_line": 3808,
    "section": "Block quotes"
  },
  {
    "markdown": "> - foo\n- bar\n",
    "html": "<blockquote>\n<ul>\n<li>foo</li>\n</ul>\n</blockquote>\n<ul>\n<li>bar</li>\n</ul>\n",
    "example": 235,
    "start_line": 3820,
    "end_line": 3832,
    "section": "Block quotes"
  },
  {
    "markdown": ">     foo\n    bar\n",
    "html": "<blockquote>\n<pre><code>foo\n</code></pre>\n</blockquote>\n<pre><code>bar\n</code></pre>\n",
    "example": 236,
    "start_line": 3838,
    "end_line": 3848,
    "section": "Block quotes"
  },
  {
    "markdown": "> ```\nfoo\n```\n",
    "html": "<blockquote>\n<pre><code></code></pre>\n</blockquote>\n<p>foo</p>\n<pre><code></code></pre>\n",
    "example": 237,
    "start_line": 3851,
    "end_line": 3861,
    "section": "Block quotes"
  },
  {
    "markdown": "> foo\n    - bar\n",
    "html": "<blockquote>\n<p>foo\n- bar</p>\n</blockquote>\n",
    "example": 238,
    "start_line": 3867,
    "end_line": 3875,
    "section": "Block quotes"
  },
  {
    "markdown": ">\n",
    "html": "<blockquote>\n</blockquote>\n",
    "example": 239,
    "start_line": 3891,
    "end_line": 3896,
    "section": "Block quotes"
  },
  {
    "markdown": ">\n>  \n> \n",
    "html": "<blockquote>\n</blockquote>\n",
    "example": 240,
    "start_line": 3899,
    "end_line": 3906,
    "section": "Block quotes"
  },
  {
    "markdown": ">\n> foo\n>  \n",
    "html": "<blockquote>\n<p>foo</p>\n</blockquote>\n",
    "example": 241,
    "start_line": 3911,
    "end_line": 3919,
    "section": "Block quotes"
  },
  {
    "markdown": "> foo\n\n> bar\n",
    "html": "<blockquote>\n<p>foo</p>\n</blockquote>\n<blockquote>\n<p>bar</p>\n</blockquote>\n",
    "example": 242,
    "start_line": 3924,
    "end_line": 3935,
    "section": "Block quotes"
  },
  {
    "markdown": "> foo\n> bar\n",
    "html": "<blockquote>\n<p>foo\nbar</p>\n</blockquote>\n",
    "example": 243,
    "start_line": 3946,
    "end_line": 3954,
    "section": "Block quotes"
  },
  {
    "markdown": "> foo\n>\n> bar\n",
    "html": "<blockquote>\n<p>foo</p>\n<p>bar</p>\n</blockquote>\n",
    "example": 244,
    "start_line": 3959,
    "end_line": 3968,
    "section": "Block quotes"
  },
  {
    "markdown": "foo\n> bar\n",
    "html": "<p>foo</p>\n<blockquote>\n<p>bar</p>\n</blockquote>\n",
    "example": 245,
    "start_line": 3973,
    "end_line": 3981,
    "section": "Block quotes"
  },
  {
    "markdown": "> aaa\n***\n> bbb\n",
    "html": "<blockquote>\n<p>aaa</p>\n</blockquote>\n<hr />\n<blockquote>\n<p>bbb</p>\n</blockquote>\n",
    "example": 246,
    "start_line": 3987,
    "end_line": 3999,
    "section": "Block quotes"
  },
  {
    "markdown": "> bar\nbaz\n",
    "html": "<blockquote>\n<p>bar\nbaz</p>\n</blockquote>\n",
    "example": 247,
    "start_line": 4005,
    "end_line": 4013,
    "section": "Block quotes"
  },
  {
    "markdown": "> bar\n\nbaz\n",
    "html": "<blockquote>\n<p>bar</p>\n</blockquote>\n<p>baz</p>\n",
    "example": 248,
    "start_line": 4016,
    "end_line": 4025,
    "section": "Block quotes"
  },
  {
    "markdown": "> bar\n>\nbaz\n",
    "html": "<blockquote>\n<p>bar</p>\n</blockquote>\n<p>baz</p>\n",
    "example": 249,
    "start_line": 4028,
    "end_line": 4037,
    "section": "Block quotes"
  },
  {
    "markdown": "> > > foo\nbar\n",
    "html": "<blockquote>\n<blockquote>\n<blockquote>\n<p>foo\nbar</p>\n</blockquote>\n</blockquote>\n</blockquote>\n",
    "example": 250,
    "start_line": 4044,
    "end_line": 4056,
    "section": "Block quotes"
  },
  {
    "markdown": ">>> foo\n> bar\n>>baz\n",
    "html": "<blockquote>\n<blockquote>\n<blockquote>\n<p>foo\nbar\nbaz</p>\n</blockquote>\n</blockquote>\n</blockquote>\n",
    "example": 251,
    "start_line": 4059,
    "end_line": 4073,
    "section": "Block quotes"
  },
  {
    "markdown": ">     code\n\n>    not code\n",
    "html": "<blockquote>\n<pre><code>code\n</code></pre>\n</blockquote>\n<blockquote>\n<p>not code</p>\n</blockquote>\n",
    "example": 252,
    "start_line": 4081,
    "end_line": 4093,
    "section": "Block quotes"
  },
  {
    "markdown": "A paragraph\nwith two lines.\n\n    indented code\n\n> A block quote.\n",
    "html": "<p>A paragraph\nwith two lines.</p>\n<pre><code>indented code\n</code></pre>\n<blockquote>\n<p>A block quote.</p>\n</blockquote>\n",
    "example": 253,
    "start_line": 4135,
    "end_line": 4150,
    "section": "List items"
  },
  {
    "markdown": "1.  A paragraph\n    with two lines.\n\n        indented code\n\n    > A block quote.\n",
    "html": "<ol>\n<li>\n<p>A paragraph\nwith two lines.</p>\n<pre><code>indented code\n</code></pre>\n<blockquote>\n<p>A block quote.</p>\n</blockquote>\n</li>\n</ol>\n",
    "example": 254,
    "start_line": 4157,
    "end_line": 4176,
    "section": "List items"
  },
  {
    "markdown": "- one\n\n two\n",
    "html": "<ul>\n<li>one</li>\n</ul>\n<p>two</p>\n",
    "example": 255,
    "start_line": 4190,
    "end_line": 4199,
    "section": "List items"
  },
  {
    "markdown": "- one\n\n  two\n",
    "html": "<ul>\n<li>\n<p>one</p>\n<p>two</p>\n</li>\n</ul>\n",
    "example": 256,
    "start_line": 4202,
    "end_line": 4213,
    "section": "List items"
  },
  {
    "markdown": " -    one\n\n     two\n",
    "html": "<ul>\n<li>one</li>\n</ul>\n<pre><code> two\n</code></pre>\n",
    "example": 257,
    "start_line": 4216,
    "end_line": 4226,
    "section": "List items"
  },
  {
    "markdown": " -    one\n\n      two\n",
    "html": "<ul>\n<li>\n<p>one</p>\n<p>two</p>\n</li>\n</ul>\n",
    "example": 258,
    "start_line": 4229,
    "end_line": 4240,
    "section": "List items"
  },
  {
    "markdown": "   > > 1.  one\n>>\n>>     two\n",
    "html": "<blockquote>\n<blockquote>\n<ol>\n<li>\n<p>one</p>\n<p>two</p>\n</li>\n</ol>\n</blockquote>\n</blockquote>\n",
    "example": 259,
    "start_line": 4251,
    "end_line": 4266,
    "section": "List items"
  },
  {
    "markdown": ">>- one\n>>\n  >  > two\n",
    "html": "<blockquote>\n<blockquote>\n<ul>\n<li>one</li>\n</ul>\n<p>two</p>\n</blockquote>\n</blockquote>\n",
    "example": 260,
    "start_line": 4278,
    "end_line": 4291,
    "section": "List items"
  },
  {
    "markdown": "-one\n\n2.two\n",
    "html": "<p>-one</p>\n<p>2.two</p>\n",
    "example": 261,
    "start_line": 4297,
    "end_line": 4304,
    "section": "List items"
  },
  {
    "markdown": "- foo\n\n\n  bar\n",
    "html": "<ul>\n<li>\n<p>foo</p>\n<p>bar</p>\n</li>\n</ul>\n",
    "example": 262,
    "start_line": 4310,
    "end_line": 4322,
    "section": "List items"
  },
  {
    "markdown": "1.  foo\n\n    ```\n    bar\n    ```\n\n    baz\n\n    > bam\n",
    "html": "<ol>\n<li>\n<p>foo</p>\n<pre><code>bar\n</code></pre>\n<p>baz</p>\n<blockquote>\n<p>bam</p>\n</blockquote>\n</li>\n</ol>\n",
    "example": 263,
    "start_line": 4327,
    "end_line": 4349,
    "section": "List items"
  },
  {
    "markdown": "- Foo\n\n      bar\n\n\n      baz\n",
    "html": "<ul>\n<li>\n<p>Foo</p>\n<pre><code>bar\n\n\nbaz\n</code></pre>\n</li>\n</ul>\n",
    "example": 264,
    "start_line": 4355,
    "end_line": 4373,
    "section": "List items"
  },
  {
    "markdown": "123456789. ok\n",
    "html": "<ol start=\"123456789\">\n<li>ok</li>\n</ol>\n",
    "example": 265,
    "start_line": 4377,
    "end_line": 4383,
    "section": "List items"
  },
  {
    "markdown": "1234567890. not ok\n",
    "html": "<p>1234567890. not ok</p>\n",
    "example": 266,
    "start_line": 4386,
    "end_line": 4390,
    "section": "List items"
  },
  {
    "markdown": "0. ok\n",
    "html": "<ol start=\"0\">\n<li>ok</li>\n</ol>\n",
    "example": 267,
    "start_line": 4395,
    "end_line": 4401,
    "section": "List items"
  },
  {
    "markdown": "003. ok\n",
    "html": "<ol start=\"3\">\n<li>ok</li>\n</ol>\n",
    "example": 268,
    "start_line": 4404,
    "end_line": 4410,
    "section": "List items"
  },
  {
    "markdown": "-1. not ok\n",
    "html": "<p>-1. not ok</p>\n",
    "example": 269,
    "start_line": 4415,
    "end_line": 4419,
    "section": "List items"
  },
  {
    "markdown": "- foo\n\n      bar\n",
    "html": "<ul>\n<li>\n<p>foo</p>\n<pre><code>bar\n</code></pre>\n</li>\n</ul>\n",
    "example": 270,
    "start_line": 4438,
    "end_line": 4450,
    "section": "List items"
  },
  {
    "markdown": "  10.  foo\n\n           bar\n",
    "html": "<ol start=\"10\">\n<li>\n<p>foo</p>\n<pre><code>bar\n</code></pre>\n</li>\n</ol>\n",
    "example": 271,
    "start_line": 4455,
    "end_line": 4467,
    "section": "List items"
  },
  {
    "markdown": "    indented code\n\nparagraph\n\n    more code\n",
    "html": "<pre><code>indented code\n</code></pre>\n<p>paragraph</p>\n<pre><code>more code\n</code></pre>\n",
    "example": 272,
    "start_line": 4474,
    "end_line": 4486,
    "section": "List items"
  },
  {
    "markdown": "1.     indented code\n\n   paragraph\n\n       more code\n",
    "html": "<ol>\n<li>\n<pre><code>indented code\n</code></pre>\n<p>paragraph</p>\n<pre><code>more code\n</code></pre>\n</li>\n</ol>\n",
    "example": 273,
    "start_line": 4489,
    "end_line": 4505,
    "section": "List items"
  },
  {
    "markdown": "1.      indented code\n\n   paragraph\n\n       more code\n",
    "html": "<ol>\n<li>\n<pre><code> indented code\n</code></pre>\n<p>paragraph</p>\n<pre><code>more code\n</code></pre>\n</li>\n</ol>\n",
    "example": 274,
    "start_line": 4511,
    "end_line": 4527,
    "section": "List items"
  },
  {
    "markdown": "   foo\n\nbar\n",
    "html": "<p>foo</p>\n<p>bar</p>\n",
    "example": 275,
    "start_line": 4538,
    "end_line": 4545,
    "section": "List items"
  },
  {
    "markdown": "-    foo\n\n  bar\n",
    "html": "<ul>\n<li>foo</li>\n</ul>\n<p>bar</p>\n",
    "example": 276,
    "start_line": 4548,
    "end_line": 4557,
    "section": "List items"
  },
  {
    "markdown": "-  foo\n\n   bar\n",
    "html": "<ul>\n<li>\n<p>foo</p>\n<p>bar</p>\n</li>\n</ul>\n",
    "example": 277,
    "start_line": 4565,
    "end_line": 4576,
    "section": "List items"
  },
  {
    "markdown": "-\n  foo\n-\n  ```\n  bar\n  ```\n-\n      baz\n",
    "html": "<ul>\n<li>foo</li>\n<li>\n<pre><code>bar\n</code></pre>\n</li>\n<li>\n<pre><code>baz\n</code></pre>\n</li>\n</ul>\n",
    "example": 278,
    "start_line": 4592,
    "end_line": 4613,
    "section": "List items"
  },
  {
    "markdown": "-   \n  foo\n",
    "html": "<ul>\n<li>foo</li>\n</ul>\n",
    "example": 279,
    "start_line": 4618,
    "end_line": 4625,
    "section": "List items"
  },
  {
    "markdown": "-\n\n  foo\n",
    "html": "<ul>\n<li></li>\n</ul>\n<p>foo</p>\n",
    "example": 280,
    "start_line": 4632,
    "end_line": 4641,
    "section": "List items"
  },
  {
    "markdown": "- foo\n-\n- bar\n",
    "html": "<ul>\n<li>foo</li>\n<li></li>\n<li>bar</li>\n</ul>\n",
    "example": 281,
    "start_line": 4646,
    "end_line": 4656,
    "section": "List items"
  },
  {
    "markdown": "- foo\n-   \n- bar\n",
    "html": "<ul>\n<li>foo</li>\n<li></li>\n<li>bar</li>\n</ul>\n",
    "example": 282,
    "start_line": 4661,
    "end_line": 4671,
    "section": "List items"
  },
  {
    "markdown": "1. foo\n2.\n3. bar\n",
    "html": "<ol>\n<li>foo</li>\n<li></li>\n<li>bar</li>\n</ol>\n",
    "example": 283,
    "start_line": 4676,
    "end_line": 4686,
    "section": "List items"
  },
  {
    "markdown": "*\n",
    "html": "<ul>\n<li></li>\n</ul>\n",
    "example": 284,
    "start_line": 4691,
    "end_line": 4697,
    "section": "List items"
  },
  {
    "markdown": "foo\n*\n\nfoo\n1.\n",
    "html": "<p>foo\n*</p>\n<p>foo\n1.</p>\n",
    "example": 285,
    "start_line": 4701,
    "end_line": 4712,
    "section": "List items"
  },
  {
    "markdown": " 1.  A paragraph\n     with two lines.\n\n         indented code\n\n     > A block quote.\n",
    "html": "<ol>\n<li>\n<p>A paragraph\nwith two lines.</p>\n<pre><code>indented code\n</code></pre>\n<blockquote>\n<p>A block quote.</p>\n</blockquote>\n</li>\n</ol>\n",
    "example": 286,
    "start_line": 4723,
    "end_line": 4742,
    "section": "List items"
  },
  {
    "markdown": "  1.  A paragraph\n      with two lines.\n\n          indented code\n\n      > A block quote.\n",
    "html": "<ol>\n<li>\n<p>A paragraph\nwith two lines.</p>\n<pre><code>indented code\n</code></pre>\n<blockquote>\n<p>A block quote.</p>\n</blockquote>\n</li>\n</ol>\n",
    "example": 287,
    "start_line": 4747,
    "end_line": 4766,
    "section": "List items"
  },
  {
    "markdown": "   1.  A paragraph\n       with two lines.\n\n           indented code\n\n       > A block quote.\n",
    "html": "<ol>\n<li>\n<p>A paragraph\nwith two lines.</p>\n<pre><code>indented code\n</code></pre>\n<blockquote>\n<p>A block quote.</p>\n</blockquote>\n</li>\n</ol>\n",
    "example": 288,
    "start_line": 4771,
    "end_line": 4790,
    "section": "List items"
  },
  {
    "markdown": "    1.  A paragraph\n        with two lines.\n\n            indented code\n\n        > A block quote.\n",
    "html": "<pre><code>1.  A paragraph\n    with two lines.\n\n        indented code\n\n    &gt; A block quote.\n</code></pre>\n",
    "example": 289,
    "start_line": 4795,
    "end_line": 4810,
    "section": "List items"
  },
  {
    "markdown": "  1.  A paragraph\nwith two lines.\n\n          indented code\n\n      > A block quote.\n",
    "html": "<ol>\n<li>\n<p>A paragraph\nwith two lines.</p>\n<pre><code>indented code\n</code></pre>\n<blockquote>\n<p>A block quote.</p>\n</blockquote>\n</li>\n</ol>\n",
    "example": 290,
    "start_line": 4825,
    "end_line": 4844,
    "section": "List items"
  },
  {
    "markdown": "  1.  A paragraph\n    with two lines.\n",
    "html": "<ol>\n<li>A paragraph\nwith two lines.</li>\n</ol>\n",
    "example": 291,
    "start_line": 4849,
    "end_line": 4857,
    "section": "List items"
  },
  {
    "markdown": "> 1. > Blockquote\ncontinued here.\n",
    "html": "<blockquote>\n<ol>\n<li>\n<blockquote>\n<p>Blockquote\ncontinued here.</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n",
    "example": 292,
    "start_line": 4862,
    "end_line": 4876,
    "section": "List items"
  },
  {
    "markdown": "> 1. > Blockquote\n> continued here.\n",
    "html": "<blockquote>\n<ol>\n<li>\n<blockquote>\n<p>Blockquote\ncontinued here.</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n",
    "example": 293,
    "start_line": 4879,
    "end_line": 4893,
    "section": "List items"
  },
  {
    "markdown": "- foo\n  - bar\n    - baz\n      - boo\n",
    "html": "<ul>\n<li>foo\n<ul>\n<li>bar\n<ul>\n<li>baz\n<ul>\n<li>boo</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n",
    "example": 294,
    "start_line": 4907,
    "end_line": 4928,
    "section": "List items"
  },
  {
    "markdown": "- foo\n - bar\n  - baz\n   - boo\n",
    "html": "<ul>\n<li>foo</li>\n<li>bar</li>\n<li>baz</li>\n<li>boo</li>\n</ul>\n",
    "example": 295,
    "start_line": 4933,
    "end_line": 4945,
    "section": "List items"
  },
  {
    "markdown": "10) foo\n    - bar\n",
    "html": "<ol start=\"10\">\n<li>foo\n<ul>\n<li>bar</li>\n</ul>\n</li>\n</ol>\n",
    "example": 296,
    "start_line": 4950,
    "end_line": 4961,
    "section": "List items"
  },
  {
    "markdown": "10) foo\n   - bar\n",
    "html": "<ol start=\"10\">\n<li>foo</li>\n</ol>\n<ul>\n<li>bar</li>\n</ul>\n",
    "example": 297,
    "start_line": 4966,
    "end_line": 4976,
    "section": "List items"
  },
  {
    "markdown": "- - foo\n",
    "html": "<ul>\n<li>\n<ul>\n<li>foo</li>\n</ul>\n</li>\n</ul>\n",
    "example": 298,
    "start_line": 4981,
    "end_line": 4991,
    "section": "List items"
  },
  {
    "markdown": "1. - 2. foo\n",
    "html": "<ol>\n<li>\n<ul>\n<li>\n<ol start=\"2\">\n<li>foo</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n",
    "example": 299,
    "start_line": 4994,
    "end_line": 5008,
    "section": "List items"
  },
  {
    "markdown": "- # Foo\n- Bar\n  ---\n  baz\n",
    "html": "<ul>\n<li>\n<h1>Foo</h1>\n</li>\n<li>\n<h2>Bar</h2>\nbaz</li>\n</ul>\n",
    "example": 300,
    "start_line": 5013,
    "end_line": 5027,
    "section": "List items"
  },
  {
    "markdown": "- foo\n- bar\n+ baz\n",
    "html": "<ul>\n<li>foo</li>\n<li>bar</li>\n</ul>\n<ul>\n<li>baz</li>\n</ul>\n",
    "example": 301,
    "start_line": 5249,
    "end_line": 5261,
    "section": "Lists"
  },
  {
    "markdown": "1. foo\n2. bar\n3) baz\n",
    "html": "<ol>\n<li>foo</li>\n<li>bar</li>\n</ol>\n<ol start=\"3\">\n<li>baz</li>\n</ol>\n",
    "example": 302,
    "start_line": 5264,
    "end_line": 5276,
    "section": "Lists"
  },
  {
    "markdown": "Foo\n- bar\n- baz\n",
    "html": "<p>Foo</p>\n<ul>\n<li>bar</li>\n<li>baz</li>\n</ul>\n",
    "example": 303,
    "start_line": 5283,
    "end_line": 5293,
    "section": "Lists"
  },
  {
    "markdown": "The number of windows in my house is\n14.  The number of doors is 6.\n",
    "html": "<p>The number of windows in my house is\n14.  The number of doors is 6.</p>\n",
    "example": 304,
    "start_line": 5360,
    "end_line": 5366,
    "section": "Lists"
  },
  {
    "markdown": "The number of windows in my house is\n1.  The number of doors is 6.\n",
    "html": "<p>The number of windows in my house is</p>\n<ol>\n<li>The number of doors is 6.</li>\n</ol>\n",
    "example": 305,
    "start_line": 5370,
    "end_line": 5378,
    "section": "Lists"
  },
  {
    "markdown": "- foo\n\n- bar\n\n\n- baz\n",
    "html": "<ul>\n<li>\n<p>foo</p>\n</li>\n<li>\n<p>bar</p>\n</li>\n<li>\n<p>baz</p>\n</li>\n</ul>\n",
    "example": 306,
    "start_line": 5384,
    "end_line": 5403,
    "section": "Lists"
  },
  {
    "markdown": "- foo\n  - bar\n    - baz\n\n\n      bim\n",
    "html": "<ul>\n<li>foo\n<ul>\n<li>bar\n<ul>\n<li>\n<p>baz</p>\n<p>bim</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n",
    "example": 307,
    "start_line": 5405,
    "end_line": 5427,
    "section": "Lists"
  },
  {
    "markdown": "- foo\n- bar\n\n<!-- -->\n\n- baz\n- bim\n",
    "html": "<ul>\n<li>foo</li>\n<li>bar</li>\n</ul>\n<!-- -->\n<ul>\n<li>baz</li>\n<li>bim</li>\n</ul>\n",
    "example": 308,
    "start_line": 5435,
    "end_line": 5453,
    "section": "Lists"
  },
  {
    "markdown": "-   foo\n\n    notcode\n\n-   foo\n\n<!-- -->\n\n    code\n",
    "html": "<ul>\n<li>\n<p>foo</p>\n<p>notcode</p>\n</li>\n<li>\n<p>foo</p>\n</li>\n</ul>\n<!-- -->\n<pre><code>code\n</code></pre>\n",
    "example": 309,
    "start_line": 5456,
    "end_line": 5479,
    "section": "Lists"
  },
  {
    "markdown": "- a\n - b\n  - c\n   - d\n  - e\n - f\n- g\n",
    "html": "<ul>\n<li>a</li>\n<li>b</li>\n<li>c</li>\n<li>d</li>\n<li>e</li>\n<li>f</li>\n<li>g</li>\n</ul>\n",
    "example": 310,
    "start_line": 5487,
    "end_line": 5505,
    "section": "Lists"
  },
  {
    "markdown": "1. a\n\n  2. b\n\n   3. c\n",
    "html": "<ol>\n<li>\n<p>a</p>\n</li>\n<li>\n<p>b</p>\n</li>\n<li>\n<p>c</p>\n</li>\n</ol>\n",
    "example": 311,
    "start_line": 5508,
    "end_line": 5526,
    "section": "Lists"
  },
  {
    "markdown": "- a\n - b\n  - c\n   - d\n    - e\n",
    "html": "<ul>\n<li>a</li>\n<li>b</li>\n<li>c</li>\n<li>d\n- e</li>\n</ul>\n",
    "example": 312,
    "start_line": 5532,
    "end_line": 5546,
    "section": "Lists"
  },
  {
    "markdown": "1. a\n\n  2. b\n\n    3. c\n",
    "html": "<ol>\n<li>\n<p>a</p>\n</li>\n<li>\n<p>b</p>\n</li>\n</ol>\n<pre><code>3. c\n</code></pre>\n",
    "example": 313,
    "start_line": 5552,
    "end_line": 5569,
    "section": "Lists"
  },
  {
    "markdown": "- a\n- b\n\n- c\n",
    "html": "<ul>\n<li>\n<p>a</p>\n</li>\n<li>\n<p>b</p>\n</li>\n<li>\n<p>c</p>\n</li>\n</ul>\n",
    "example": 314,
    "start_line": 5575,
    "end_line": 5592,
    "section": "Lists"
  },
  {
    "markdown": "* a\n*\n\n* c\n",
    "html": "<ul>\n<li>\n<p>a</p>\n</li>\n<li></li>\n<li>\n<p>c</p>\n</li>\n</ul>\n",
    "example": 315,
    "start_line": 5597,
    "end_line": 5612,
    "section": "Lists"
  },
  {
    "markdown": "- a\n- b\n\n  c\n- d\n",
    "html": "<ul>\n<li>\n<p>a</p>\n</li>\n<li>\n<p>b</p>\n<p>c</p>\n</li>\n<li>\n<p>d</p>\n</li>\n</ul>\n",
    "example": 316,
    "start_line": 5619,
    "end_line": 5638,
    "section": "Lists"
  },
  {
    "markdown": "- a\n- b\n\n  [ref]: /url\n- d\n",
    "html": "<ul>\n<li>\n<p>a</p>\n</li>\n<li>\n<p>b</p>\n</li>\n<li>\n<p>d</p>\n</li>\n</ul>\n",
    "example": 317,
    "start_line": 5641,
    "end_line": 5659,
    "section": "Lists"
  },
  {
    "markdown": "- a\n- ```\n  b\n\n\n  ```\n- c\n",
    "html": "<ul>\n<li>a</li>\n<li>\n<pre><code>b\n\n\n</code></pre>\n</li>\n<li>c</li>\n</ul>\n",
    "example": 318,
    "start_line": 5664,
    "end_line": 5683,
    "section": "Lists"
  },
  {
    "markdown": "- a\n  - b\n\n    c\n- d\n",
    "html": "<ul>\n<li>a\n<ul>\n<li>\n<p>b</p>\n<p>c</p>\n</li>\n</ul>\n</li>\n<li>d</li>\n</ul>\n",
    "example": 319,
    "start_line": 5690,
    "end_line": 5708,
    "section": "Lists"
  },
  {
    "markdown": "* a\n  > b\n  >\n* c\n",
    "html": "<ul>\n<li>a\n<blockquote>\n<p>b</p>\n</blockquote>\n</li>\n<li>c</li>\n</ul>\n",
    "example": 320,
    "start_line": 5714,
    "end_line": 5728,
    "section": "Lists"
  },
  {
    "markdown": "- a\n  > b\n  ```\n  c\n  ```\n- d\n",
    "html": "<ul>\n<li>a\n<blockquote>\n<p>b</p>\n</blockquote>\n<pre><code>c\n</code></pre>\n</li>\n<li>d</li>\n</ul>\n",
    "example": 321,
    "start_line": 5734,
    "end_line": 5752,
    "section": "Lists"
  },
  {
    "markdown": "- a\n",
    "html": "<ul>\n<li>a</li>\n</ul>\n",
    "example": 322,
    "start_line": 5757,
    "end_line": 5763,
    "section": "Lists"
  },
  {
    "markdown": "- a\n  - b\n",
    "html": "<ul>\n<li>a\n<ul>\n<li>b</li>\n</ul>\n</li>\n</ul>\n",
    "example": 323,
    "start_line": 5766,
    "end_line": 5777,
    "section": "Lists"
  },
  {
    "markdown": "1. ```\n   foo\n   ```\n\n   bar\n",
    "html": "<ol>\n<li>\n<pre><code>foo\n</code></pre>\n<p>bar</p>\n</li>\n</ol>\n",
    "example": 324,
    "start_line": 5783,
    "end_line": 5797,
    "section": "Lists"
  },
  {
    "markdown": "* foo\n  * bar\n\n  baz\n",
    "html": "<ul>\n<li>\n<p>foo</p>\n<ul>\n<li>bar</li>\n</ul>\n<p>baz</p>\n</li>\n</ul>\n",
    "example": 325,
    "start_line": 5802,
    "end_line": 5817,
    "section": "Lists"
  },
  {
    "markdown": "- a\n  - b\n  - c\n\n- d\n  - e\n  - f\n",
    "html": "<ul>\n<li>\n<p>a</p>\n<ul>\n<li>b</li>\n<li>c</li>\n</ul>\n</li>\n<li>\n<p>d</p>\n<ul>\n<li>e</li>\n<li>f</li>\n</ul>\n</li>\n</ul>\n",
    "example": 326,
    "start_line": 5820,
    "end_line": 5845,
    "section": "Lists"
  },
  {
    "markdown": "`hi`lo`\n",
    "html": "<p><code>hi</code>lo`</p>\n",
    "example": 327,
    "start_line": 5854,
    "end_line": 5858,
    "section": "Inlines"
  },
  {
    "markdown": "`foo`\n",
    "html": "<p><code>foo</code></p>\n",
    "example": 328,
    "start_line": 5886,
    "end_line": 5890,
    "section": "Code spans"
  },
  {
    "markdown": "`` foo ` bar ``\n",
    "html": "<p><code>foo ` bar</code></p>\n",
    "example": 329,
    "start_line": 5897,
    "end_line": 5901,
    "section": "Code spans"
  },
  {
    "markdown": "` `` `\n",
    "html": "<p><code>``</code></p>\n",
    "example": 330,
    "start_line": 5907,
    "end_line": 5911,
    "section": "Code spans"
  },
  {
    "markdown": "`  ``  `\n",
    "html": "<p><code> `` </code></p>\n",
    "example": 331,
    "start_line": 5915,
    "end_line": 5919,
    "section": "Code spans"
  },
  {
    "markdown": "` a`\n",
    "html": "<p><code> a</code></p>\n",
    "example": 332,
    "start_line": 5924,
    "end_line": 5928,
    "section": "Code spans"
  },
  {
    "markdown": "` b `\n",
    "html": "<p><code> b </code></p>\n",
    "example": 333,
    "start_line": 5933,
    "end_line": 5937,
    "section": "Code spans"
  },
  {
    "markdown": "` `\n`  `\n",
    "html": "<p><code> </code>\n<code>  </code></p>\n",
    "example": 334,
    "start_line": 5941,
    "end_line": 5947,
    "section": "Code spans"
  },
  {
    "markdown": "``\nfoo\nbar  \nbaz\n``\n",
    "html": "<p><code>foo bar   baz</code></p>\n",
    "example": 335,
    "start_line": 5952,
    "end_line": 5960,
    "section": "Code spans"
  },
  {
    "markdown": "``\nfoo \n``\n",
    "html": "<p><code>foo </code></p>\n",
    "example": 336,
    "start_line": 5962,
    "end_line": 5968,
    "section": "Code spans"
  },
  {
    "markdown": "`foo   bar \nbaz`\n",
    "html": "<p><code>foo   bar  baz</code></p>\n",
    "example": 337,
    "start_line": 5973,
    "end_line": 5978,
    "section": "Code spans"
  },
  {
    "markdown": "`foo\\`bar`\n",
    "html": "<p><code>foo\\</code>bar`</p>\n",
    "example": 338,
    "start_line": 5990,
    "end_line": 5994,
    "section": "Code spans"
  },
  {
    "markdown": "``foo`bar``\n",
    "html": "<p><code>foo`bar</code></p>\n",
    "example": 339,
    "start_line": 6001,
    "end_line": 6005,
    "section": "Code spans"
  },
  {
    "markdown": "` foo `` bar `\n",
    "html": "<p><code>foo `` bar</code></p>\n",
    "example": 340,
    "start_line": 6007,
    "end_line": 6011,
    "section": "Code spans"
  },
  {
    "markdown": "*foo`*`\n",
    "html": "<p>*foo<code>*</code></p>\n",
    "example": 341,
    "start_line": 6019,
    "end_line": 6023,
    "section": "Code spans"
  },
  {
    "markdown": "[not a `link](/foo`)\n",
    "html": "<p>[not a <code>link](/foo</code>)</p>\n",
    "example": 342,
    "start_line": 6028,
    "end_line": 6032,
    "section": "Code spans"
  },
  {
    "markdown": "`<a href=\"`\">`\n",
    "html": "<p><code>&lt;a href=&quot;</code>&quot;&gt;`</p>\n",
    "example": 343,
    "start_line": 6038,
    "end_line": 6042,
    "section": "Code spans"
  },
  {
    "markdown": "<a href=\"`\">`\n",
    "html": "<p><a href=\"`\">`</p>\n",
    "example": 344,
    "start_line": 6047,
    "end_line": 6051,
    "section": "Code spans"
  },
  {
    "markdown": "`<https://foo.bar.`baz>`\n",
    "html": "<p><code>&lt;https://foo.bar.</code>baz&gt;`</p>\n",
    "example": 345,
    "start_line": 6056,
    "end_line": 6060,
    "section": "Code spans"
  },
  {
    "markdown": "<https://foo.bar.`baz>`\n",
    "html": "<p><a href=\"https://foo.bar.%60baz\">https://foo.bar.`baz</a>`</p>\n",
    "example": 346,
    "start_line": 6065,
    "end_line": 6069,
    "section": "Code spans"
  },
  {
    "markdown": "```foo``\n",
    "html": "<p>```foo``</p>\n",
    "example": 347,
    "start_line": 6075,
    "end_line": 6079,
    "section": "Code spans"
  },
  {
    "markdown": "`foo\n",
    "html": "<p>`foo</p>\n",
    "example": 348,
    "start_line": 6082,
    "end_line": 6086,
    "section": "Code spans"
  },
  {
    "markdown": "`foo``bar``\n",
    "html": "<p>`foo<code>bar</code></p>\n",
    "example": 349,
    "start_line": 6091,
    "end_line": 6095,
    "section": "Code spans"
  },
  {
    "markdown": "*foo bar*\n",
    "html": "<p><em>foo bar</em></p>\n",
    "example": 350,
    "start_line": 6308,
    "end_line": 6312,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "a * foo bar*\n",
    "html": "<p>a * foo bar*</p>\n",
    "example": 351,
    "start_line": 6318,
    "end_line": 6322,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "a*\"foo\"*\n",
    "html": "<p>a*&quot;foo&quot;*</p>\n",
    "example": 352,
    "start_line": 6329,
    "end_line": 6333,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "* a *\n",
    "html": "<p>* a *</p>\n",
    "example": 353,
    "start_line": 6338,
    "end_line": 6342,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*$*alpha.\n\n*£*bravo.\n\n*€*charlie.\n",
    "html": "<p>*$*alpha.</p>\n<p>*£*bravo.</p>\n<p>*€*charlie.</p>\n",
    "example": 354,
    "start_line": 6347,
    "end_line": 6357,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo*bar*\n",
    "html": "<p>foo<em>bar</em></p>\n",
    "example": 355,
    "start_line": 6362,
    "end_line": 6366,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "5*6*78\n",
    "html": "<p>5<em>6</em>78</p>\n",
    "example": 356,
    "start_line": 6369,
    "end_line": 6373,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo bar_\n",
    "html": "<p><em>foo bar</em></p>\n",
    "example": 357,
    "start_line": 6378,
    "end_line": 6382,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_ foo bar_\n",
    "html": "<p>_ foo bar_</p>\n",
    "example": 358,
    "start_line": 6388,
    "end_line": 6392,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "a_\"foo\"_\n",
    "html": "<p>a_&quot;foo&quot;_</p>\n",
    "example": 359,
    "start_line": 6398,
    "end_line": 6402,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo_bar_\n",
    "html": "<p>foo_bar_</p>\n",
    "example": 360,
    "start_line": 6407,
    "end_line": 6411,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "5_6_78\n",
    "html": "<p>5_6_78</p>\n",
    "example": 361,
    "start_line": 6414,
    "end_line": 6418,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "пристаням_стремятся_\n",
    "html": "<p>пристаням_стремятся_</p>\n",
    "example": 362,
    "start_line": 6421,
    "end_line": 6425,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "aa_\"bb\"_cc\n",
    "html": "<p>aa_&quot;bb&quot;_cc</p>\n",
    "example": 363,
    "start_line": 6431,
    "end_line": 6435,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo-_(bar)_\n",
    "html": "<p>foo-<em>(bar)</em></p>\n",
    "example": 364,
    "start_line": 6442,
    "end_line": 6446,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo*\n",
    "html": "<p>_foo*</p>\n",
    "example": 365,
    "start_line": 6454,
    "end_line": 6458,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo bar *\n",
    "html": "<p>*foo bar *</p>\n",
    "example": 366,
    "start_line": 6464,
    "end_line": 6468,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo bar\n*\n",
    "html": "<p>*foo bar\n*</p>\n",
    "example": 367,
    "start_line": 6473,
    "end_line": 6479,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*(*foo)\n",
    "html": "<p>*(*foo)</p>\n",
    "example": 368,
    "start_line": 6486,
    "end_line": 6490,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*(*foo*)*\n",
    "html": "<p><em>(<em>foo</em>)</em></p>\n",
    "example": 369,
    "start_line": 6496,
    "end_line": 6500,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo*bar\n",
    "html": "<p><em>foo</em>bar</p>\n",
    "example": 370,
    "start_line": 6505,
    "end_line": 6509,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo bar _\n",
    "html": "<p>_foo bar _</p>\n",
    "example": 371,
    "start_line": 6518,
    "end_line": 6522,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_(_foo)\n",
    "html": "<p>_(_foo)</p>\n",
    "example": 372,
    "start_line": 6528,
    "end_line": 6532,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_(_foo_)_\n",
    "html": "<p><em>(<em>foo</em>)</em></p>\n",
    "example": 373,
    "start_line": 6537,
    "end_line": 6541,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo_bar\n",
    "html": "<p>_foo_bar</p>\n",
    "example": 374,
    "start_line": 6546,
    "end_line": 6550,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_пристаням_стремятся\n",
    "html": "<p>_пристаням_стремятся</p>\n",
    "example": 375,
    "start_line": 6553,
    "end_line": 6557,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo_bar_baz_\n",
    "html": "<p><em>foo_bar_baz</em></p>\n",
    "example": 376,
    "start_line": 6560,
    "end_line": 6564,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_(bar)_.\n",
    "html": "<p><em>(bar)</em>.</p>\n",
    "example": 377,
    "start_line": 6571,
    "end_line": 6575,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo bar**\n",
    "html": "<p><strong>foo bar</strong></p>\n",
    "example": 378,
    "start_line": 6580,
    "end_line": 6584,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "** foo bar**\n",
    "html": "<p>** foo bar**</p>\n",
    "example": 379,
    "start_line": 6590,
    "end_line": 6594,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "a**\"foo\"**\n",
    "html": "<p>a**&quot;foo&quot;**</p>\n",
    "example": 380,
    "start_line": 6601,
    "end_line": 6605,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo**bar**\n",
    "html": "<p>foo<strong>bar</strong></p>\n",
    "example": 381,
    "start_line": 6610,
    "end_line": 6614,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo bar__\n",
    "html": "<p><strong>foo bar</strong></p>\n",
    "example": 382,
    "start_line": 6619,
    "end_line": 6623,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__ foo bar__\n",
    "html": "<p>__ foo bar__</p>\n",
    "example": 383,
    "start_line": 6629,
    "end_line": 6633,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__\nfoo bar__\n",
    "html": "<p>__\nfoo bar__</p>\n",
    "example": 384,
    "start_line": 6637,
    "end_line": 6643,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "a__\"foo\"__\n",
    "html": "<p>a__&quot;foo&quot;__</p>\n",
    "example": 385,
    "start_line": 6649,
    "end_line": 6653,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo__bar__\n",
    "html": "<p>foo__bar__</p>\n",
    "example": 386,
    "start_line": 6658,
    "end_line": 6662,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "5__6__78\n",
    "html": "<p>5__6__78</p>\n",
    "example": 387,
    "start_line": 6665,
    "end_line": 6669,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "пристаням__стремятся__\n",
    "html": "<p>пристаням__стремятся__</p>\n",
    "example": 388,
    "start_line": 6672,
    "end_line": 6676,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo, __bar__, baz__\n",
    "html": "<p><strong>foo, <strong>bar</strong>, baz</strong></p>\n",
    "example": 389,
    "start_line": 6679,
    "end_line": 6683,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo-__(bar)__\n",
    "html": "<p>foo-<strong>(bar)</strong></p>\n",
    "example": 390,
    "start_line": 6690,
    "end_line": 6694,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo bar **\n",
    "html": "<p>**foo bar **</p>\n",
    "example": 391,
    "start_line": 6703,
    "end_line": 6707,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**(**foo)\n",
    "html": "<p>**(**foo)</p>\n",
    "example": 392,
    "start_line": 6716,
    "end_line": 6720,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*(**foo**)*\n",
    "html": "<p><em>(<strong>foo</strong>)</em></p>\n",
    "example": 393,
    "start_line": 6726,
    "end_line": 6730,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**Gomphocarpus (*Gomphocarpus physocarpus*, syn.\n*Asclepias physocarpa*)**\n",
    "html": "<p><strong>Gomphocarpus (<em>Gomphocarpus physocarpus</em>, syn.\n<em>Asclepias physocarpa</em>)</strong></p>\n",
    "example": 394,
    "start_line": 6733,
    "end_line": 6739,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo \"*bar*\" foo**\n",
    "html": "<p><strong>foo &quot;<em>bar</em>&quot; foo</strong></p>\n",
    "example": 395,
    "start_line": 6742,
    "end_line": 6746,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo**bar\n",
    "html": "<p><strong>foo</strong>bar</p>\n",
    "example": 396,
    "start_line": 6751,
    "end_line": 6755,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo bar __\n",
    "html": "<p>__foo bar __</p>\n",
    "example": 397,
    "start_line": 6763,
    "end_line": 6767,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__(__foo)\n",
    "html": "<p>__(__foo)</p>\n",
    "example": 398,
    "start_line": 6773,
    "end_line": 6777,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_(__foo__)_\n",
    "html": "<p><em>(<strong>foo</strong>)</em></p>\n",
    "example": 399,
    "start_line": 6783,
    "end_line": 6787,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo__bar\n",
    "html": "<p>__foo__bar</p>\n",
    "example": 400,
    "start_line": 6792,
    "end_line": 6796,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__пристаням__стремятся\n",
    "html": "<p>__пристаням__стремятся</p>\n",
    "example": 401,
    "start_line": 6799,
    "end_line": 6803,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo__bar__baz__\n",
    "html": "<p><strong>foo__bar__baz</strong></p>\n",
    "example": 402,
    "start_line": 6806,
    "end_line": 6810,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__(bar)__.\n",
    "html": "<p><strong>(bar)</strong>.</p>\n",
    "example": 403,
    "start_line": 6817,
    "end_line": 6821,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo [bar](/url)*\n",
    "html": "<p><em>foo <a href=\"/url\">bar</a></em></p>\n",
    "example": 404,
    "start_line": 6829,
    "end_line": 6833,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo\nbar*\n",
    "html": "<p><em>foo\nbar</em></p>\n",
    "example": 405,
    "start_line": 6836,
    "end_line": 6842,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo __bar__ baz_\n",
    "html": "<p><em>foo <strong>bar</strong> baz</em></p>\n",
    "example": 406,
    "start_line": 6848,
    "end_line": 6852,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo _bar_ baz_\n",
    "html": "<p><em>foo <em>bar</em> baz</em></p>\n",
    "example": 407,
    "start_line": 6855,
    "end_line": 6859,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo_ bar_\n",
    "html": "<p><em><em>foo</em> bar</em></p>\n",
    "example": 408,
    "start_line": 6862,
    "end_line": 6866,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo *bar**\n",
    "html": "<p><em>foo <em>bar</em></em></p>\n",
    "example": 409,
    "start_line": 6869,
    "end_line": 6873,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo **bar** baz*\n",
    "html": "<p><em>foo <strong>bar</strong> baz</em></p>\n",
    "example": 410,
    "start_line": 6876,
    "end_line": 6880,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo**bar**baz*\n",
    "html": "<p><em>foo<strong>bar</strong>baz</em></p>\n",
    "example": 411,
    "start_line": 6882,
    "end_line": 6886,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo**bar*\n",
    "html": "<p><em>foo**bar</em></p>\n",
    "example": 412,
    "start_line": 6906,
    "end_line": 6910,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "***foo** bar*\n",
    "html": "<p><em><strong>foo</strong> bar</em></p>\n",
    "example": 413,
    "start_line": 6919,
    "end_line": 6923,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo **bar***\n",
    "html": "<p><em>foo <strong>bar</strong></em></p>\n",
    "example": 414,
    "start_line": 6926,
    "end_line": 6930,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo**bar***\n",
    "html": "<p><em>foo<strong>bar</strong></em></p>\n",
    "example": 415,
    "start_line": 6933,
    "end_line": 6937,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo***bar***baz\n",
    "html": "<p>foo<em><strong>bar</strong></em>baz</p>\n",
    "example": 416,
    "start_line": 6944,
    "end_line": 6948,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo******bar*********baz\n",
    "html": "<p>foo<strong><strong><strong>bar</strong></strong></strong>***baz</p>\n",
    "example": 417,
    "start_line": 6950,
    "end_line": 6954,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo **bar *baz* bim** bop*\n",
    "html": "<p><em>foo <strong>bar <em>baz</em> bim</strong> bop</em></p>\n",
    "example": 418,
    "start_line": 6959,
    "end_line": 6963,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo [*bar*](/url)*\n",
    "html": "<p><em>foo <a href=\"/url\"><em>bar</em></a></em></p>\n",
    "example": 419,
    "start_line": 6966,
    "end_line": 6970,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "** is not an empty emphasis\n",
    "html": "<p>** is not an empty emphasis</p>\n",
    "example": 420,
    "start_line": 6975,
    "end_line": 6979,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**** is not an empty strong emphasis\n",
    "html": "<p>**** is not an empty strong emphasis</p>\n",
    "example": 421,
    "start_line": 6982,
    "end_line": 6986,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo [bar](/url)**\n",
    "html": "<p><strong>foo <a href=\"/url\">bar</a></strong></p>\n",
    "example": 422,
    "start_line": 6995,
    "end_line": 6999,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo\nbar**\n",
    "html": "<p><strong>foo\nbar</strong></p>\n",
    "example": 423,
    "start_line": 7002,
    "end_line": 7008,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo _bar_ baz__\n",
    "html": "<p><strong>foo <em>bar</em> baz</strong></p>\n",
    "example": 424,
    "start_line": 7014,
    "end_line": 7018,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo __bar__ baz__\n",
    "html": "<p><strong>foo <strong>bar</strong> baz</strong></p>\n",
    "example": 425,
    "start_line": 7021,
    "end_line": 7025,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "____foo__ bar__\n",
    "html": "<p><strong><strong>foo</strong> bar</strong></p>\n",
    "example": 426,
    "start_line": 7028,
    "end_line": 7032,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo **bar****\n",
    "html": "<p><strong>foo <strong>bar</strong></strong></p>\n",
    "example": 427,
    "start_line": 7035,
    "end_line": 7039,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo *bar* baz**\n",
    "html": "<p><strong>foo <em>bar</em> baz</strong></p>\n",
    "example": 428,
    "start_line": 7042,
    "end_line": 7046,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo*bar*baz**\n",
    "html": "<p><strong>foo<em>bar</em>baz</strong></p>\n",
    "example": 429,
    "start_line": 7049,
    "end_line": 7053,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "***foo* bar**\n",
    "html": "<p><strong><em>foo</em> bar</strong></p>\n",
    "example": 430,
    "start_line": 7056,
    "end_line": 7060,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo *bar***\n",
    "html": "<p><strong>foo <em>bar</em></strong></p>\n",
    "example": 431,
    "start_line": 7063,
    "end_line": 7067,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo *bar **baz**\nbim* bop**\n",
    "html": "<p><strong>foo <em>bar <strong>baz</strong>\nbim</em> bop</strong></p>\n",
    "example": 432,
    "start_line": 7072,
    "end_line": 7078,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo [*bar*](/url)**\n",
    "html": "<p><strong>foo <a href=\"/url\"><em>bar</em></a></strong></p>\n",
    "example": 433,
    "start_line": 7081,
    "end_line": 7085,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__ is not an empty emphasis\n",
    "html": "<p>__ is not an empty emphasis</p>\n",
    "example": 434,
    "start_line": 7090,
    "end_line": 7094,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "____ is not an empty strong emphasis\n",
    "html": "<p>____ is not an empty strong emphasis</p>\n",
    "example": 435,
    "start_line": 7097,
    "end_line": 7101,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo ***\n",
    "html": "<p>foo ***</p>\n",
    "example": 436,
    "start_line": 7107,
    "end_line": 7111,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo *\\**\n",
    "html": "<p>foo <em>*</em></p>\n",
    "example": 437,
    "start_line": 7114,
    "end_line": 7118,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo *_*\n",
    "html": "<p>foo <em>_</em></p>\n",
    "example": 438,
    "start_line": 7121,
    "end_line": 7125,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo *****\n",
    "html": "<p>foo *****</p>\n",
    "example": 439,
    "start_line": 7128,
    "end_line": 7132,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo **\\***\n",
    "html": "<p>foo <strong>*</strong></p>\n",
    "example": 440,
    "start_line": 7135,
    "end_line": 7139,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo **_**\n",
    "html": "<p>foo <strong>_</strong></p>\n",
    "example": 441,
    "start_line": 7142,
    "end_line": 7146,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo*\n",
    "html": "<p>*<em>foo</em></p>\n",
    "example": 442,
    "start_line": 7153,
    "end_line": 7157,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo**\n",
    "html": "<p><em>foo</em>*</p>\n",
    "example": 443,
    "start_line": 7160,
    "end_line": 7164,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "***foo**\n",
    "html": "<p>*<strong>foo</strong></p>\n",
    "example": 444,
    "start_line": 7167,
    "end_line": 7171,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "****foo*\n",
    "html": "<p>***<em>foo</em></p>\n",
    "example": 445,
    "start_line": 7174,
    "end_line": 7178,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo***\n",
    "html": "<p><strong>foo</strong>*</p>\n",
    "example": 446,
    "start_line": 7181,
    "end_line": 7185,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo****\n",
    "html": "<p><em>foo</em>***</p>\n",
    "example": 447,
    "start_line": 7188,
    "end_line": 7192,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo ___\n",
    "html": "<p>foo ___</p>\n",
    "example": 448,
    "start_line": 7198,
    "end_line": 7202,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo _\\__\n",
    "html": "<p>foo <em>_</em></p>\n",
    "example": 449,
    "start_line": 7205,
    "end_line": 7209,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo _*_\n",
    "html": "<p>foo <em>*</em></p>\n",
    "example": 450,
    "start_line": 7212,
    "end_line": 7216,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo _____\n",
    "html": "<p>foo _____</p>\n",
    "example": 451,
    "start_line": 7219,
    "end_line": 7223,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo __\\___\n",
    "html": "<p>foo <strong>_</strong></p>\n",
    "example": 452,
    "start_line": 7226,
    "end_line": 7230,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "foo __*__\n",
    "html": "<p>foo <strong>*</strong></p>\n",
    "example": 453,
    "start_line": 7233,
    "end_line": 7237,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo_\n",
    "html": "<p>_<em>foo</em></p>\n",
    "example": 454,
    "start_line": 7240,
    "end_line": 7244,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo__\n",
    "html": "<p><em>foo</em>_</p>\n",
    "example": 455,
    "start_line": 7251,
    "end_line": 7255,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "___foo__\n",
    "html": "<p>_<strong>foo</strong></p>\n",
    "example": 456,
    "start_line": 7258,
    "end_line": 7262,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "____foo_\n",
    "html": "<p>___<em>foo</em></p>\n",
    "example": 457,
    "start_line": 7265,
    "end_line": 7269,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo___\n",
    "html": "<p><strong>foo</strong>_</p>\n",
    "example": 458,
    "start_line": 7272,
    "end_line": 7276,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo____\n",
    "html": "<p><em>foo</em>___</p>\n",
    "example": 459,
    "start_line": 7279,
    "end_line": 7283,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo**\n",
    "html": "<p><strong>foo</strong></p>\n",
    "example": 460,
    "start_line": 7289,
    "end_line": 7293,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*_foo_*\n",
    "html": "<p><em><em>foo</em></em></p>\n",
    "example": 461,
    "start_line": 7296,
    "end_line": 7300,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__foo__\n",
    "html": "<p><strong>foo</strong></p>\n",
    "example": 462,
    "start_line": 7303,
    "end_line": 7307,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_*foo*_\n",
    "html": "<p><em><em>foo</em></em></p>\n",
    "example": 463,
    "start_line": 7310,
    "end_line": 7314,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "****foo****\n",
    "html": "<p><strong><strong>foo</strong></strong></p>\n",
    "example": 464,
    "start_line": 7320,
    "end_line": 7324,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "____foo____\n",
    "html": "<p><strong><strong>foo</strong></strong></p>\n",
    "example": 465,
    "start_line": 7327,
    "end_line": 7331,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "******foo******\n",
    "html": "<p><strong><strong><strong>foo</strong></strong></strong></p>\n",
    "example": 466,
    "start_line": 7338,
    "end_line": 7342,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "***foo***\n",
    "html": "<p><em><strong>foo</strong></em></p>\n",
    "example": 467,
    "start_line": 7347,
    "end_line": 7351,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_____foo_____\n",
    "html": "<p><em><strong><strong>foo</strong></strong></em></p>\n",
    "example": 468,
    "start_line": 7354,
    "end_line": 7358,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo _bar* baz_\n",
    "html": "<p><em>foo _bar</em> baz_</p>\n",
    "example": 469,
    "start_line": 7363,
    "end_line": 7367,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo __bar *baz bim__ bam*\n",
    "html": "<p><em>foo <strong>bar *baz bim</strong> bam</em></p>\n",
    "example": 470,
    "start_line": 7370,
    "end_line": 7374,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**foo **bar baz**\n",
    "html": "<p>**foo <strong>bar baz</strong></p>\n",
    "example": 471,
    "start_line": 7379,
    "end_line": 7383,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*foo *bar baz*\n",
    "html": "<p>*foo <em>bar baz</em></p>\n",
    "example": 472,
    "start_line": 7386,
    "end_line": 7390,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*[bar*](/url)\n",
    "html": "<p>*<a href=\"/url\">bar*</a></p>\n",
    "example": 473,
    "start_line": 7395,
    "end_line": 7399,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_foo [bar_](/url)\n",
    "html": "<p>_foo <a href=\"/url\">bar_</a></p>\n",
    "example": 474,
    "start_line": 7402,
    "end_line": 7406,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*<img src=\"foo\" title=\"*\"/>\n",
    "html": "<p>*<img src=\"foo\" title=\"*\"/></p>\n",
    "example": 475,
    "start_line": 7409,
    "end_line": 7413,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**<a href=\"**\">\n",
    "html": "<p>**<a href=\"**\"></p>\n",
    "example": 476,
    "start_line": 7416,
    "end_line": 7420,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__<a href=\"__\">\n",
    "html": "<p>__<a href=\"__\"></p>\n",
    "example": 477,
    "start_line": 7423,
    "end_line": 7427,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "*a `*`*\n",
    "html": "<p><em>a <code>*</code></em></p>\n",
    "example": 478,
    "start_line": 7430,
    "end_line": 7434,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "_a `_`_\n",
    "html": "<p><em>a <code>_</code></em></p>\n",
    "example": 479,
    "start_line": 7437,
    "end_line": 7441,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "**a<https://foo.bar/?q=**>\n",
    "html": "<p>**a<a href=\"https://foo.bar/?q=**\">https://foo.bar/?q=**</a></p>\n",
    "example": 480,
    "start_line": 7444,
    "end_line": 7448,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "__a<https://foo.bar/?q=__>\n",
    "html": "<p>__a<a href=\"https://foo.bar/?q=__\">https://foo.bar/?q=__</a></p>\n",
    "example": 481,
    "start_line": 7451,
    "end_line": 7455,
    "section": "Emphasis and strong emphasis"
  },
  {
    "markdown": "[link](/uri \"title\")\n",
    "html": "<p><a href=\"/uri\" title=\"title\">link</a></p>\n",
    "example": 482,
    "start_line": 7539,
    "end_line": 7543,
    "section": "Links"
  },
  {
    "markdown": "[link](/uri)\n",
    "html": "<p><a href=\"/uri\">link</a></p>\n",
    "example": 483,
    "start_line": 7549,
    "end_line": 7553,
    "section": "Links"
  },
  {
    "markdown": "[](./target.md)\n",
    "html": "<p><a href=\"./target.md\"></a></p>\n",
    "example": 484,
    "start_line": 7555,
    "end_line": 7559,
    "section": "Links"
  },
  {
    "markdown": "[link]()\n",
    "html": "<p><a href=\"\">link</a></p>\n",
    "example": 485,
    "start_line": 7562,
    "end_line": 7566,
    "section": "Links"
  },
  {
    "markdown": "[link](<>)\n",
    "html": "<p><a href=\"\">link</a></p>\n",
    "example": 486,
    "start_line": 7569,
    "end_line": 7573,
    "section": "Links"
  },
  {
    "markdown": "[]()\n",
    "html": "<p><a href=\"\"></a></p>\n",
    "example": 487,
    "start_line": 7576,
    "end_line": 7580,
    "section": "Links"
  },
  {
    "markdown": "[link](/my uri)\n",
    "html": "<p>[link](/my uri)</p>\n",
    "example": 488,
    "start_line": 7585,
    "end_line": 7589,
    "section": "Links"
  },
  {
    "markdown": "[link](</my uri>)\n",
    "html": "<p><a href=\"/my%20uri\">link</a></p>\n",
    "example": 489,
    "start_line": 7591,
    "end_line": 7595,
    "section": "Links"
  },
  {
    "markdown": "[link](foo\nbar)\n",
    "html": "<p>[link](foo\nbar)</p>\n",
    "example": 490,
    "start_line": 7600,
    "end_line": 7606,
    "section": "Links"
  },
  {
    "markdown": "[link](<foo\nbar>)\n",
    "html": "<p>[link](<foo\nbar>)</p>\n",
    "example": 491,
    "start_line": 7608,
    "end_line": 7614,
    "section": "Links"
  },
  {
    "markdown": "[a](<b)c>)\n",
    "html": "<p><a href=\"b)c\">a</a></p>\n",
    "example": 492,
    "start_line": 7619,
    "end_line": 7623,
    "section": "Links"
  },
  {
    "markdown": "[link](<foo\\>)\n",
    "html": "<p>[link](&lt;foo&gt;)</p>\n",
    "example": 493,
    "start_line": 7627,
    "end_line": 7631,
    "section": "Links"
  },
  {
    "markdown": "[a](<b)c\n[a](<b)c>\n[a](<b>c)\n",
    "html": "<p>[a](&lt;b)c\n[a](&lt;b)c&gt;\n[a](<b>c)</p>\n",
    "example": 494,
    "start_line": 7636,
    "end_line": 7644,
    "section": "Links"
  },
  {
    "markdown": "[link](\\(foo\\))\n",
    "html": "<p><a href=\"(foo)\">link</a></p>\n",
    "example": 495,
    "start_line": 7648,
    "end_line": 7652,
    "section": "Links"
  },
  {
    "markdown": "[link](foo(and(bar)))\n",
    "html": "<p><a href=\"foo(and(bar))\">link</a></p>\n",
    "example": 496,
    "start_line": 7657,
    "end_line": 7661,
    "section": "Links"
  },
  {
    "markdown": "[link](foo(and(bar))\n",
    "html": "<p>[link](foo(and(bar))</p>\n",
    "example": 497,
    "start_line": 7666,
    "end_line": 7670,
    "section": "Links"
  },
  {
    "markdown": "[link](foo\\(and\\(bar\\))\n",
    "html": "<p><a href=\"foo(and(bar)\">link</a></p>\n",
    "example": 498,
    "start_line": 7673,
    "end_line": 7677,
    "section": "Links"
  },
  {
    "markdown": "[link](<foo(and(bar)>)\n",
    "html": "<p><a href=\"foo(and(bar)\">link</a></p>\n",
    "example": 499,
    "start_line": 7680,
    "end_line": 7684,
    "section": "Links"
  },
  {
    "markdown": "[link](foo\\)\\:)\n",
    "html": "<p><a href=\"foo):\">link</a></p>\n",
    "example": 500,
    "start_line": 7690,
    "end_line": 7694,
    "section": "Links"
  },
  {
    "markdown": "[link](#fragment)\n\n[link](https://example.com#fragment)\n\n[link](https://example.com?foo=3#frag)\n",
    "html": "<p><a href=\"#fragment\">link</a></p>\n<p><a href=\"https://example.com#fragment\">link</a></p>\n<p><a href=\"https://example.com?foo=3#frag\">link</a></p>\n",
    "example": 501,
    "start_line": 7699,
    "end_line": 7709,
    "section": "Links"
  },
  {
    "markdown": "[link](foo\\bar)\n",
    "html": "<p><a href=\"foo%5Cbar\">link</a></p>\n",
    "example": 502,
    "start_line": 7715,
    "end_line": 7719,
    "section": "Links"
  },
  {
    "markdown": "[link](foo%20b&auml;)\n",
    "html": "<p><a href=\"foo%20b%C3%A4\">link</a></p>\n",
    "example": 503,
    "start_line": 7731,
    "end_line": 7735,
    "section": "Links"
  },
  {
    "markdown": "[link](\"title\")\n",
    "html": "<p><a href=\"%22title%22\">link</a></p>\n",
    "example": 504,
    "start_line": 7742,
    "end_line": 7746,
    "section": "Links"
  },
  {
    "markdown": "[link](/url \"title\")\n[link](/url 'title')\n[link](/url (title))\n",
    "html": "<p><a href=\"/url\" title=\"title\">link</a>\n<a href=\"/url\" title=\"title\">link</a>\n<a href=\"/url\" title=\"title\">link</a></p>\n",
    "example": 505,
    "start_line": 7751,
    "end_line": 7759,
    "section": "Links"
  },
  {
    "markdown": "[link](/url \"title \\\"&quot;\")\n",
    "html": "<p><a href=\"/url\" title=\"title &quot;&quot;\">link</a></p>\n",
    "example": 506,
    "start_line": 7765,
    "end_line": 7769,
    "section": "Links"
  },
  {
    "markdown": "[link](/url \"title\")\n",
    "html": "<p><a href=\"/url%C2%A0%22title%22\">link</a></p>\n",
    "example": 507,
    "start_line": 7776,
    "end_line": 7780,
    "section": "Links"
  },
  {
    "markdown": "[link](/url \"title \"and\" title\")\n",
    "html": "<p>[link](/url &quot;title &quot;and&quot; title&quot;)</p>\n",
    "example": 508,
    "start_line": 7785,
    "end_line": 7789,
    "section": "Links"
  },
  {
    "markdown": "[link](/url 'title \"and\" title')\n",
    "html": "<p><a href=\"/url\" title=\"title &quot;and&quot; title\">link</a></p>\n",
    "example": 509,
    "start_line": 7794,
    "end_line": 7798,
    "section": "Links"
  },
  {
    "markdown": "[link](   /uri\n  \"title\"  )\n",
    "html": "<p><a href=\"/uri\" title=\"title\">link</a></p>\n",
    "example": 510,
    "start_line": 7819,
    "end_line": 7824,
    "section": "Links"
  },
  {
    "markdown": "[link] (/uri)\n",
    "html": "<p>[link] (/uri)</p>\n",
    "example": 511,
    "start_line": 7830,
    "end_line": 7834,
    "section": "Links"
  },
  {
    "markdown": "[link [foo [bar]]](/uri)\n",
    "html": "<p><a href=\"/uri\">link [foo [bar]]</a></p>\n",
    "example": 512,
    "start_line": 7840,
    "end_line": 7844,
    "section": "Links"
  },
  {
    "markdown": "[link] bar](/uri)\n",
    "html": "<p>[link] bar](/uri)</p>\n",
    "example": 513,
    "start_line": 7847,
    "end_line": 7851,
    "section": "Links"
  },
  {
    "markdown": "[link [bar](/uri)\n",
    "html": "<p>[link <a href=\"/uri\">bar</a></p>\n",
    "example": 514,
    "start_line": 7854,
    "end_line": 7858,
    "section": "Links"
  },
  {
    "markdown": "[link \\[bar](/uri)\n",
    "html": "<p><a href=\"/uri\">link [bar</a></p>\n",
    "example": 515,
    "start_line": 7861,
    "end_line": 7865,
    "section": "Links"
  },
  {
    "markdown": "[link *foo **bar** `#`*](/uri)\n",
    "html": "<p><a href=\"/uri\">link <em>foo <strong>bar</strong> <code>#</code></em></a></p>\n",
    "example": 516,
    "start_line": 7870,
    "end_line": 7874,
    "section": "Links"
  },
  {
    "markdown": "[![moon](moon.jpg)](/uri)\n",
    "html": "<p><a href=\"/uri\"><img src=\"moon.jpg\" alt=\"moon\" /></a></p>\n",
    "example": 517,
    "start_line": 7877,
    "end_line": 7881,
    "section": "Links"
  },
  {
    "markdown": "[foo [bar](/uri)](/uri)\n",
    "html": "<p>[foo <a href=\"/uri\">bar</a>](/uri)</p>\n",
    "example": 518,
    "start_line": 7886,
    "end_line": 7890,
    "section": "Links"
  },
  {
    "markdown": "[foo *[bar [baz](/uri)](/uri)*](/uri)\n",
    "html": "<p>[foo <em>[bar <a href=\"/uri\">baz</a>](/uri)</em>](/uri)</p>\n",
    "example": 519,
    "start_line": 7893,
    "end_line": 7897,
    "section": "Links"
  },
  {
    "markdown": "![[[foo](uri1)](uri2)](uri3)\n",
    "html": "<p><img src=\"uri3\" alt=\"[foo](uri2)\" /></p>\n",
    "example": 520,
    "start_line": 7900,
    "end_line": 7904,
    "section": "Links"
  },
  {
    "markdown": "*[foo*](/uri)\n",
    "html": "<p>*<a href=\"/uri\">foo*</a></p>\n",
    "example": 521,
    "start_line": 7910,
    "end_line": 7914,
    "section": "Links"
  },
  {
    "markdown": "[foo *bar](baz*)\n",
    "html": "<p><a href=\"baz*\">foo *bar</a></p>\n",
    "example": 522,
    "start_line": 7917,
    "end_line": 7921,
    "section": "Links"
  },
  {
    "markdown": "*foo [bar* baz]\n",
    "html": "<p><em>foo [bar</em> baz]</p>\n",
    "example": 523,
    "start_line": 7927,
    "end_line": 7931,
    "section": "Links"
  },
  {
    "markdown": "[foo <bar attr=\"](baz)\">\n",
    "html": "<p>[foo <bar attr=\"](baz)\"></p>\n",
    "example": 524,
    "start_line": 7937,
    "end_line": 7941,
    "section": "Links"
  },
  {
    "markdown": "[foo`](/uri)`\n",
    "html": "<p>[foo<code>](/uri)</code></p>\n",
    "example": 525,
    "start_line": 7944,
    "end_line": 7948,
    "section": "Links"
  },
  {
    "markdown": "[foo<https://example.com/?search=](uri)>\n",
    "html": "<p>[foo<a href=\"https://example.com/?search=%5D(uri)\">https://example.com/?search=](uri)</a></p>\n",
    "example": 526,
    "start_line": 7951,
    "end_line": 7955,
    "section": "Links"
  },
  {
    "markdown": "[foo][bar]\n\n[bar]: /url \"title\"\n",
    "html": "<p><a href=\"/url\" title=\"title\">foo</a></p>\n",
    "example": 527,
    "start_line": 7989,
    "end_line": 7995,
    "section": "Links"
  },
  {
    "markdown": "[link [foo [bar]]][ref]\n\n[ref]: /uri\n",
    "html": "<p><a href=\"/uri\">link [foo [bar]]</a></p>\n",
    "example": 528,
    "start_line": 8004,
    "end_line": 8010,
    "section": "Links"
  },
  {
    "markdown": "[link \\[bar][ref]\n\n[ref]: /uri\n",
    "html": "<p><a href=\"/uri\">link [bar</a></p>\n",
    "example": 529,
    "start_line": 8013,
    "end_line": 8019,
    "section": "Links"
  },
  {
    "markdown": "[link *foo **bar** `#`*][ref]\n\n[ref]: /uri\n",
    "html": "<p><a href=\"/uri\">link <em>foo <strong>bar</strong> <code>#</code></em></a></p>\n",
    "example": 530,
    "start_line": 8024,
    "end_line": 8030,
    "section": "Links"
  },
  {
    "markdown": "[![moon](moon.jpg)][ref]\n\n[ref]: /uri\n",
    "html": "<p><a href=\"/uri\"><img src=\"moon.jpg\" alt=\"moon\" /></a></p>\n",
    "example": 531,
    "start_line": 8033,
    "end_line": 8039,
    "section": "Links"
  },
  {
    "markdown": "[foo [bar](/uri)][ref]\n\n[ref]: /uri\n",
    "html": "<p>[foo <a href=\"/uri\">bar</a>]<a href=\"/uri\">ref</a></p>\n",
    "example": 532,
    "start_line": 8044,
    "end_line": 8050,
    "section": "Links"
  },
  {
    "markdown": "[foo *bar [baz][ref]*][ref]\n\n[ref]: /uri\n",
    "html": "<p>[foo <em>bar <a href=\"/uri\">baz</a></em>]<a href=\"/uri\">ref</a></p>\n",
    "example": 533,
    "start_line": 8053,
    "end_line": 8059,
    "section": "Links"
  },
  {
    "markdown": "*[foo*][ref]\n\n[ref]: /uri\n",
    "html": "<p>*<a href=\"/uri\">foo*</a></p>\n",
    "example": 534,
    "start_line": 8068,
    "end_line": 8074,
    "section": "Links"
  },
  {
    "markdown": "[foo *bar][ref]*\n\n[ref]: /uri\n",
    "html": "<p><a href=\"/uri\">foo *bar</a>*</p>\n",
    "example": 535,
    "start_line": 8077,
    "end_line": 8083,
    "section": "Links"
  },
  {
    "markdown": "[foo <bar attr=\"][ref]\">\n\n[ref]: /uri\n",
    "html": "<p>[foo <bar attr=\"][ref]\"></p>\n",
    "example": 536,
    "start_line": 8089,
    "end_line": 8095,
    "section": "Links"
  },
  {
    "markdown": "[foo`][ref]`\n\n[ref]: /uri\n",
    "html": "<p>[foo<code>][ref]</code></p>\n",
    "example": 537,
    "start_line": 8098,
    "end_line": 8104,
    "section": "Links"
  },
  {
    "markdown": "[foo<https://example.com/?search=][ref]>\n\n[ref]: /uri\n",
    "html": "<p>[foo<a href=\"https://example.com/?search=%5D%5Bref%5D\">https://example.com/?search=][ref]</a></p>\n",
    "example": 538,
    "start_line": 8107,
    "end_line": 8113,
    "section": "Links"
  },
  {
    "markdown": "[foo][BaR]\n\n[bar]: /url \"title\"\n",
    "html": "<p><a href=\"/url\" title=\"title\">foo</a></p>\n",
    "example": 539,
    "start_line": 8118,
    "end_line": 8124,
    "section": "Links"
  },
  {
    "markdown": "[ẞ]\n\n[SS]: /url\n",
    "html": "<p><a href=\"/url\">ẞ</a></p>\n",
    "example": 540,
    "start_line": 8129,
    "end_line": 8135,
    "section": "Links"
  },
  {
    "markdown": "[Foo\n  bar]: /url\n\n[Baz][Foo bar]\n",
    "html": "<p><a href=\"/url\">Baz</a></p>\n",
    "example": 541,
    "start_line": 8141,
    "end_line": 8148,
    "section": "Links"
  },
  {
    "markdown": "[foo] [bar]\n\n[bar]: /url \"title\"\n",
    "html": "<p>[foo] <a href=\"/url\" title=\"title\">bar</a></p>\n",
    "example": 542,
    "start_line": 8154,
    "end_line": 8160,
    "section": "Links"
  },
  {
    "markdown": "[foo]\n[bar]\n\n[bar]: /url \"title\"\n",
    "html": "<p>[foo]\n<a href=\"/url\" title=\"title\">bar</a></p>\n",
    "example": 543,
    "start_line": 8163,
    "end_line": 8171,
    "section": "Links"
  },
  {
    "markdown": "[foo]: /url1\n\n[foo]: /url2\n\n[bar][foo]\n",
    "html": "<p><a href=\"/url1\">bar</a></p>\n",
    "example": 544,
    "start_line": 8204,
    "end_line": 8212,
    "section": "Links"
  },
  {
    "markdown": "[bar][foo\\!]\n\n[foo!]: /url\n",
    "html": "<p>[bar][foo!]</p>\n",
    "example": 545,
    "start_line": 8219,
    "end_line": 8225,
    "section": "Links"
  },
  {
    "markdown": "[foo][ref[]\n\n[ref[]: /uri\n",
    "html": "<p>[foo][ref[]</p>\n<p>[ref[]: /uri</p>\n",
    "example": 546,
    "start_line": 8231,
    "end_line": 8238,
    "section": "Links"
  },
  {
    "markdown": "[foo][ref[bar]]\n\n[ref[bar]]: /uri\n",
    "html": "<p>[foo][ref[bar]]</p>\n<p>[ref[bar]]: /uri</p>\n",
    "example": 547,
    "start_line": 8241,
    "end_line": 8248,
    "section": "Links"
  },
  {
    "markdown": "[[[foo]]]\n\n[[[foo]]]: /url\n",
    "html": "<p>[[[foo]]]</p>\n<p>[[[foo]]]: /url</p>\n",
    "example": 548,
    "start_line": 8251,
    "end_line": 8258,
    "section": "Links"
  },
  {
    "markdown": "[foo][ref\\[]\n\n[ref\\[]: /uri\n",
    "html": "<p><a href=\"/uri\">foo</a></p>\n",
    "example": 549,
    "start_line": 8261,
    "end_line": 8267,
    "section": "Links"
  },
  {
    "markdown": "[bar\\\\]: /uri\n\n[bar\\\\]\n",
    "html": "<p><a href=\"/uri\">bar\\</a></p>\n",
    "example": 550,
    "start_line": 8272,
    "end_line": 8278,
    "section": "Links"
  },
  {
    "markdown": "[]\n\n[]: /uri\n",
    "html": "<p>[]</p>\n<p>[]: /uri</p>\n",
    "example": 551,
    "start_line": 8284,
    "end_line": 8291,
    "section": "Links"
  },
  {
    "markdown": "[\n ]\n\n[\n ]: /uri\n",
    "html": "<p>[\n]</p>\n<p>[\n]: /uri</p>\n",
    "example": 552,
    "start_line": 8294,
    "end_line": 8305,
    "section": "Links"
  },
  {
    "markdown": "[foo][]\n\n[foo]: /url \"title\"\n",
    "html": "<p><a href=\"/url\" title=\"title\">foo</a></p>\n",
    "example": 553,
    "start_line": 8317,
    "end_line": 8323,
    "section": "Links"
  },
  {
    "markdown": "[*foo* bar][]\n\n[*foo* bar]: /url \"title\"\n",
    "html": "<p><a href=\"/url\" title=\"title\"><em>foo</em> bar</a></p>\n",
    "example": 554,
    "start_line": 8326,
    "end_line": 8332,
    "section": "Links"
  },
  {
    "markdown": "[Foo][]\n\n[foo]: /url \"title\"\n",
    "html": "<p><a href=\"/url\" title=\"title\">Foo</a></p>\n",
    "example": 555,
    "start_line": 8337,
    "end_line": 8343,
    "section": "Links"
  },
  {
    "markdown": "[foo] \n[]\n\n[foo]: /url \"title\"\n",
    "html": "<p><a href=\"/url\" title=\"title\">foo</a>\n[]</p>\n",
    "example": 556,
    "start_line": 8350,
    "end_line": 8358,
    "section": "Links"
  },
  {
    "markdown": "[foo]\n\n[foo]: /url \"title\"\n",
    "html": "<p><a href=\"/url\" title=\"title\">foo</a></p>\n",
    "example": 557,
    "start_line": 8370,
    "end_line": 8376,
    "section": "Links"
  },
  {
    "markdown": "[*foo* bar]\n\n[*foo* bar]: /url \"title\"\n",
    "html": "<p><a href=\"/url\" title=\"title\"><em>foo</em> bar</a></p>\n",
    "example": 558,
    "start_line": 8379,
    "end_line": 8385,
    "section": "Links"
  },
  {
    "markdown": "[[*foo* bar]]\n\n[*foo* bar]: /url \"title\"\n",
    "html": "<p>[<a href=\"/url\" title=\"title\"><em>foo</em> bar</a>]</p>\n",
    "example": 559,
    "start_line": 8388,
    "end_line": 8394,
    "section": "Links"
  },
  {
    "markdown": "[[bar [foo]\n\n[foo]: /url\n",
    "html": "<p>[[bar <a href=\"/url\">foo</a></p>\n",
    "example": 560,
    "start_line": 8397,
    "end_line": 8403,
    "section": "Links"
  },
  {
    "markdown": "[Foo]\n\n[foo]: /url \"title\"\n",
    "html": "<p><a href=\"/url\" title=\"title\">Foo</a></p>\n",
    "example": 561,
    "start_line": 8408,
    "end_line": 8414,
    "section": "Links"
  },
  {
    "markdown": "[foo] bar\n\n[foo]: /url\n",
    "html": "<p><a href=\"/url\">foo</a> bar</p>\n",
    "example": 562,
    "start_line": 8419,
    "end_line": 8425,
    "section": "Links"
  },
  {
    "markdown": "\\[foo]\n\n[foo]: /url \"title\"\n",
    "html": "<p>[foo]</p>\n",
    "example": 563,
    "start_line": 8431,
    "end_line": 8437,
    "section": "Links"
  },
  {
    "markdown": "[foo*]: /url\n\n*[foo*]\n",
    "html": "<p>*<a href=\"/url\">foo*</a></p>\n",
    "example": 564,
    "start_line": 8443,
    "end_line": 8449,
    "section": "Links"
  },
  {
    "markdown": "[foo][bar]\n\n[foo]: /url1\n[bar]: /url2\n",
    "html": "<p><a href=\"/url2\">foo</a></p>\n",
    "example": 565,
    "start_line": 8455,
    "end_line": 8462,
    "section": "Links"
  },
  {
    "markdown": "[foo][]\n\n[foo]: /url1\n",
    "html": "<p><a href=\"/url1\">foo</a></p>\n",
    "example": 566,
    "start_line": 8464,
    "end_line": 8470,
    "section": "Links"
  },
  {
    "markdown": "[foo]()\n\n[foo]: /url1\n",
    "html": "<p><a href=\"\">foo</a></p>\n",
    "example": 567,
    "start_line": 8474,
    "end_line": 8480,
    "section": "Links"
  },
  {
    "markdown": "[foo](not a link)\n\n[foo]: /url1\n",
    "html": "<p><a href=\"/url1\">foo</a>(not a link)</p>\n",
    "example": 568,
    "start_line": 8482,
    "end_line": 8488,
    "section": "Links"
  },
  {
    "markdown": "[foo][bar][baz]\n\n[baz]: /url\n",
    "html": "<p>[foo]<a href=\"/url\">bar</a></p>\n",
    "example": 569,
    "start_line": 8493,
    "end_line": 8499,
    "section": "Links"
  },
  {
    "markdown": "[foo][bar][baz]\n\n[baz]: /url1\n[bar]: /url2\n",
    "html": "<p><a href=\"/url2\">foo</a><a href=\"/url1\">baz</a></p>\n",
    "example": 570,
    "start_line": 8505,
    "end_line": 8512,
    "section": "Links"
  },
  {
    "markdown": "[foo][bar][baz]\n\n[baz]: /url1\n[foo]: /url2\n",
    "html": "<p>[foo]<a href=\"/url1\">bar</a></p>\n",
    "example": 571,
    "start_line": 8518,
    "end_line": 8525,
    "section": "Links"
  },
  {
    "markdown": "![foo](/url \"title\")\n",
    "html": "<p><img src=\"/url\" alt=\"foo\" title=\"title\" /></p>\n",
    "example": 572,
    "start_line": 8541,
    "end_line": 8545,
    "section": "Images"
  },
  {
    "markdown": "![foo *bar*]\n\n[foo *bar*]: train.jpg \"train & tracks\"\n",
    "html": "<p><img src=\"train.jpg\" alt=\"foo bar\" title=\"train &amp; tracks\" /></p>\n",
    "example": 573,
    "start_line": 8548,
    "end_line": 8554,
    "section": "Images"
  },
  {
    "markdown": "![foo ![bar](/url)](/url2)\n",
    "html": "<p><img src=\"/url2\" alt=\"foo bar\" /></p>\n",
    "example": 574,
    "start_line": 8557,
    "end_line": 8561,
    "section": "Images"
  },
  {
    "markdown": "![foo [bar](/url)](/url2)\n",
    "html": "<p><img src=\"/url2\" alt=\"foo bar\" /></p>\n",
    "example": 575,
    "start_line": 8564,
    "end_line": 8568,
    "section": "Images"
  },
  {
    "markdown": "![foo *bar*][]\n\n[foo *bar*]: train.jpg \"train & tracks\"\n",
    "html": "<p><img src=\"train.jpg\" alt=\"foo bar\" title=\"train &amp; tracks\" /></p>\n",
    "example": 576,
    "start_line": 8578,
    "end_line": 8584,
    "section": "Images"
  },
  {
    "markdown": "![foo *bar*][foobar]\n\n[FOOBAR]: train.jpg \"train & tracks\"\n",
    "html": "<p><img src=\"train.jpg\" alt=\"foo bar\" title=\"train &amp; tracks\" /></p>\n",
    "example": 577,
    "start_line": 8587,
    "end_line": 8593,
    "section": "Images"
  },
  {
    "markdown": "![foo](train.jpg)\n",
    "html": "<p><img src=\"train.jpg\" alt=\"foo\" /></p>\n",
    "example": 578,
    "start_line": 8596,
    "end_line": 8600,
    "section": "Images"
  },
  {
    "markdown": "My ![foo bar](/path/to/train.jpg  \"title\"   )\n",
    "html": "<p>My <img src=\"/path/to/train.jpg\" alt=\"foo bar\" title=\"title\" /></p>\n",
    "example": 579,
    "start_line": 8603,
    "end_line": 8607,
    "section": "Images"
  },
  {
    "markdown": "![foo](<url>)\n",
    "html": "<p><img src=\"url\" alt=\"foo\" /></p>\n",
    "example": 580,
    "start_line": 8610,
    "end_line": 8614,
    "section": "Images"
  },
  {
    "markdown": "![](/url)\n",
    "html": "<p><img src=\"/url\" alt=\"\" /></p>\n",
    "example": 581,
    "start_line": 8617,
    "end_line": 8621,
    "section": "Images"
  },
  {
    "markdown": "![foo][bar]\n\n[bar]: /url\n",
    "html": "<p><img src=\"/url\" alt=\"foo\" /></p>\n",
    "example": 582,
    "start_line": 8626,
    "end_line": 8632,
    "section": "Images"
  },
  {
    "markdown": "![foo][bar]\n\n[BAR]: /url\n",
    "html": "<p><img src=\"/url\" alt=\"foo\" /></p>\n",
    "example": 583,
    "start_line": 8635,
    "end_line": 8641,
    "section": "Images"
  },
  {
    "markdown": "![foo][]\n\n[foo]: /url \"title\"\n",
    "html": "<p><img src=\"/url\" alt=\"foo\" title=\"title\" /></p>\n",
    "example": 584,
    "start_line": 8646,
    "end_line": 8652,
    "section": "Images"
  },
  {
    "markdown": "![*foo* bar][]\n\n[*foo* bar]: /url \"title\"\n",
    "html": "<p><img src=\"/url\" alt=\"foo bar\" title=\"title\" /></p>\n",
    "example": 585,
    "start_line": 8655,
    "end_line": 8661,
    "section": "Images"
  },
  {
    "markdown": "![Foo][]\n\n[foo]: /url \"title\"\n",
    "html": "<p><img src=\"/url\" alt=\"Foo\" title=\"title\" /></p>\n",
    "example": 586,
    "start_line": 8666,
    "end_line": 8672,
    "section": "Images"
  },
  {
    "markdown": "![foo] \n[]\n\n[foo]: /url \"title\"\n",
    "html": "<p><img src=\"/url\" alt=\"foo\" title=\"title\" />\n[]</p>\n",
    "example": 587,
    "start_line": 8678,
    "end_line": 8686,
    "section": "Images"
  },
  {
    "markdown": "![foo]\n\n[foo]: /url \"title\"\n",
    "html": "<p><img src=\"/url\" alt=\"foo\" title=\"title\" /></p>\n",
    "example": 588,
    "start_line": 8691,
    "end_line": 8697,
    "section": "Images"
  },
  {
    "markdown": "![*foo* bar]\n\n[*foo* bar]: /url \"title\"\n",
    "html": "<p><img src=\"/url\" alt=\"foo bar\" title=\"title\" /></p>\n",
    "example": 589,
    "start_line": 8700,
    "end_line": 8706,
    "section": "Images"
  },
  {
    "markdown": "![[foo]]\n\n[[foo]]: /url \"title\"\n",
    "html": "<p>![[foo]]</p>\n<p>[[foo]]: /url &quot;title&quot;</p>\n",
    "example": 590,
    "start_line": 8711,
    "end_line": 8718,
    "section": "Images"
  },
  {
    "markdown": "![Foo]\n\n[foo]: /url \"title\"\n",
    "html": "<p><img src=\"/url\" alt=\"Foo\" title=\"title\" /></p>\n",
    "example": 591,
    "start_line": 8723,
    "end_line": 8729,
    "section": "Images"
  },
  {
    "markdown": "!\\[foo]\n\n[foo]: /url \"title\"\n",
    "html": "<p>![foo]</p>\n",
    "example": 592,
    "start_line": 8735,
    "end_line": 8741,
    "section": "Images"
  },
  {
    "markdown": "\\![foo]\n\n[foo]: /url \"title\"\n",
    "html": "<p>!<a href=\"/url\" title=\"title\">foo</a></p>\n",
    "example": 593,
    "start_line": 8747,
    "end_line": 8753,
    "section": "Images"
  },
  {
    "markdown": "<http://foo.bar.baz>\n",
    "html": "<p><a href=\"http://foo.bar.baz\">http://foo.bar.baz</a></p>\n",
    "example": 594,
    "start_line": 8780,
    "end_line": 8784,
    "section": "Autolinks"
  },
  {
    "markdown": "<https://foo.bar.baz/test?q=hello&id=22&boolean>\n",
    "html": "<p><a href=\"https://foo.bar.baz/test?q=hello&amp;id=22&amp;boolean\">https://foo.bar.baz/test?q=hello&amp;id=22&amp;boolean</a></p>\n",
    "example": 595,
    "start_line": 8787,
    "end_line": 8791,
    "section": "Autolinks"
  },
  {
    "markdown": "<irc://foo.bar:2233/baz>\n",
    "html": "<p><a href=\"irc://foo.bar:2233/baz\">irc://foo.bar:2233/baz</a></p>\n",
    "example": 596,
    "start_line": 8794,
    "end_line": 8798,
    "section": "Autolinks"
  },
  {
    "markdown": "<MAILTO:FOO@BAR.BAZ>\n",
    "html": "<p><a href=\"MAILTO:FOO@BAR.BAZ\">MAILTO:FOO@BAR.BAZ</a></p>\n",
    "example": 597,
    "start_line": 8803,
    "end_line": 8807,
    "section": "Autolinks"
  },
  {
    "markdown": "<a+b+c:d>\n",
    "html": "<p><a href=\"a+b+c:d\">a+b+c:d</a></p>\n",
    "example": 598,
    "start_line": 8815,
    "end_line": 8819,
    "section": "Autolinks"
  },
  {
    "markdown": "<made-up-scheme://foo,bar>\n",
    "html": "<p><a href=\"made-up-scheme://foo,bar\">made-up-scheme://foo,bar</a></p>\n",
    "example": 599,
    "start_line": 8822,
    "end_line": 8826,
    "section": "Autolinks"
  },
  {
    "markdown": "<https://../>\n",
    "html": "<p><a href=\"https://../\">https://../</a></p>\n",
    "example": 600,
    "start_line": 8829,
    "end_line": 8833,
    "section": "Autolinks"
  },
  {
    "markdown": "<localhost:5001/foo>\n",
    "html": "<p><a href=\"localhost:5001/foo\">localhost:5001/foo</a></p>\n",
    "example": 601,
    "start_line": 8836,
    "end_line": 8840,
    "section": "Autolinks"
  },
  {
    "markdown": "<https://foo.bar/baz bim>\n",
    "html": "<p>&lt;https://foo.bar/baz bim&gt;</p>\n",
    "example": 602,
    "start_line": 8845,
    "end_line": 8849,
    "section": "Autolinks"
  },
  {
    "markdown": "<https://example.com/\\[\\>\n",
    "html": "<p><a href=\"https://example.com/%5C%5B%5C\">https://example.com/\\[\\</a></p>\n",
    "example": 603,
    "start_line": 8854,
    "end_line": 8858,
    "section": "Autolinks"
  },
  {
    "markdown": "<foo@bar.example.com>\n",
    "html": "<p><a href=\"mailto:foo@bar.example.com\">foo@bar.example.com</a></p>\n",
    "example": 604,
    "start_line": 8876,
    "end_line": 8880,
    "section": "Autolinks"
  },
  {
    "markdown": "<foo+special@Bar.baz-bar0.com>\n",
    "html": "<p><a href=\"mailto:foo+special@Bar.baz-bar0.com\">foo+special@Bar.baz-bar0.com</a></p>\n",
    "example": 605,
    "start_line": 8883,
    "end_line": 8887,
    "section": "Autolinks"
  },
  {
    "markdown": "<foo\\+@bar.example.com>\n",
    "html": "<p>&lt;foo+@bar.example.com&gt;</p>\n",
    "example": 606,
    "start_line": 8892,
    "end_line": 8896,
    "section": "Autolinks"
  },
  {
    "markdown": "<>\n",
    "html": "<p>&lt;&gt;</p>\n",
    "example": 607,
    "start_line": 8901,
    "end_line": 8905,
    "section": "Autolinks"
  },
  {
    "markdown": "< https://foo.bar >\n",
    "html": "<p>&lt; https://foo.bar &gt;</p>\n",
    "example": 608,
    "start_line": 8908,
    "end_line": 8912,
    "section": "Autolinks"
  },
  {
    "markdown": "<m:abc>\n",
    "html": "<p>&lt;m:abc&gt;</p>\n",
    "example": 609,
    "start_line": 8915,
    "end_line": 8919,
    "section": "Autolinks"
  },
  {
    "markdown": "<foo.bar.baz>\n",
    "html": "<p>&lt;foo.bar.baz&gt;</p>\n",
    "example": 610,
    "start_line": 8922,
    "end_line": 8926,
    "section": "Autolinks"
  },
  {
    "markdown": "https://example.com\n",
    "html": "<p>https://example.com</p>\n",
    "example": 611,
    "start_line": 8929,
    "end_line": 8933,
    "section": "Autolinks"
  },
  {
    "markdown": "foo@bar.example.com\n",
    "html": "<p>foo@bar.example.com</p>\n",
    "example": 612,
    "start_line": 8936,
    "end_line": 8940,
    "section": "Autolinks"
  },
  {
    "markdown": "<a><bab><c2c>\n",
    "html": "<p><a><bab><c2c></p>\n",
    "example": 613,
    "start_line": 9016,
    "end_line": 9020,
    "section": "Raw HTML"
  },
  {
    "markdown": "<a/><b2/>\n",
    "html": "<p><a/><b2/></p>\n",
    "example": 614,
    "start_line": 9025,
    "end_line": 9029,
    "section": "Raw HTML"
  },
  {
    "markdown": "<a  /><b2\ndata=\"foo\" >\n",
    "html": "<p><a  /><b2\ndata=\"foo\" ></p>\n",
    "example": 615,
    "start_line": 9034,
    "end_line": 9040,
    "section": "Raw HTML"
  },
  {
    "markdown": "<a foo=\"bar\" bam = 'baz <em>\"</em>'\n_boolean zoop:33=zoop:33 />\n",
    "html": "<p><a foo=\"bar\" bam = 'baz <em>\"</em>'\n_boolean zoop:33=zoop:33 /></p>\n",
    "example": 616,
    "start_line": 9045,
    "end_line": 9051,
    "section": "Raw HTML"
  },
  {
    "markdown": "Foo <responsive-image src=\"foo.jpg\" />\n",
    "html": "<p>Foo <responsive-image src=\"foo.jpg\" /></p>\n",
    "example": 617,
    "start_line": 9056,
    "end_line": 9060,
    "section": "Raw HTML"
  },
  {
    "markdown": "<33> <__>\n",
    "html": "<p>&lt;33&gt; &lt;__&gt;</p>\n",
    "example": 618,
    "start_line": 9065,
    "end_line": 9069,
    "section": "Raw HTML"
  },
  {
    "markdown": "<a h*#ref=\"hi\">\n",
    "html": "<p>&lt;a h*#ref=&quot;hi&quot;&gt;</p>\n",
    "example": 619,
    "start_line": 9074,
    "end_line": 9078,
    "section": "Raw HTML"
  },
  {
    "markdown": "<a href=\"hi'> <a href=hi'>\n",
    "html": "<p>&lt;a href=&quot;hi'&gt; &lt;a href=hi'&gt;</p>\n",
    "example": 620,
    "start_line": 9083,
    "end_line": 9087,
    "section": "Raw HTML"
  },
  {
    "markdown": "< a><\nfoo><bar/ >\n<foo bar=baz\nbim!bop />\n",
    "html": "<p>&lt; a&gt;&lt;\nfoo&gt;&lt;bar/ &gt;\n&lt;foo bar=baz\nbim!bop /&gt;</p>\n",
    "example": 621,
    "start_line": 9092,
    "end_line": 9102,
    "section": "Raw HTML"
  },
  {
    "markdown": "<a href='bar'title=title>\n",
    "html": "<p>&lt;a href='bar'title=title&gt;</p>\n",
    "example": 622,
    "start_line": 9107,
    "end_line": 9111,
    "section": "Raw HTML"
  },
  {
    "markdown": "</a></foo >\n",
    "html": "<p></a></foo ></p>\n",
    "example": 623,
    "start_line": 9116,
    "end_line": 9120,
    "section": "Raw HTML"
  },
  {
    "markdown": "</a href=\"foo\">\n",
    "html": "<p>&lt;/a href=&quot;foo&quot;&gt;</p>\n",
    "example": 624,
    "start_line": 9125,
    "end_line": 9129,
    "section": "Raw HTML"
  },
  {
    "markdown": "foo <!-- this is a --\ncomment - with hyphens -->\n",
    "html": "<p>foo <!-- this is a --\ncomment - with hyphens --></p>\n",
    "example": 625,
    "start_line": 9134,
    "end_line": 9140,
    "section": "Raw HTML"
  },
  {
    "markdown": "foo <!--> foo -->\n\nfoo <!---> foo -->\n",
    "html": "<p>foo <!--> foo --&gt;</p>\n<p>foo <!---> foo --&gt;</p>\n",
    "example": 626,
    "start_line": 9142,
    "end_line": 9149,
    "section": "Raw HTML"
  },
  {
    "markdown": "foo <?php echo $a; ?>\n",
    "html": "<p>foo <?php echo $a; ?></p>\n",
    "example": 627,
    "start_line": 9154,
    "end_line": 9158,
    "section": "Raw HTML"
  },
  {
    "markdown": "foo <!ELEMENT br EMPTY>\n",
    "html": "<p>foo <!ELEMENT br EMPTY></p>\n",
    "example": 628,
    "start_line": 9163,
    "end_line": 9167,
    "section": "Raw HTML"
  },
  {
    "markdown": "foo <![CDATA[>&<]]>\n",
    "html": "<p>foo <![CDATA[>&<]]></p>\n",
    "example": 629,
    "start_line": 9172,
    "end_line": 9176,
    "section": "Raw HTML"
  },
  {
    "markdown": "foo <a href=\"&ouml;\">\n",
    "html": "<p>foo <a href=\"&ouml;\"></p>\n",
    "example": 630,
    "start_line": 9182,
    "end_line": 9186,
    "section": "Raw HTML"
  },
  {
    "markdown": "foo <a href=\"\\*\">\n",
    "html": "<p>foo <a href=\"\\*\"></p>\n",
    "example": 631,
    "start_line": 9191,
    "end_line": 9195,
    "section": "Raw HTML"
  },
  {
    "markdown": "<a href=\"\\\"\">\n",
    "html": "<p>&lt;a href=&quot;&quot;&quot;&gt;</p>\n",
    "example": 632,
    "start_line": 9198,
    "end_line": 9202,
    "section": "Raw HTML"
  },
  {
    "markdown": "foo  \nbaz\n",
    "html": "<p>foo<br />\nbaz</p>\n",
    "example": 633,
    "start_line": 9212,
    "end_line": 9218,
    "section": "Hard line breaks"
  },
  {
    "markdown": "foo\\\nbaz\n",
    "html": "<p>foo<br />\nbaz</p>\n",
    "example": 634,
    "start_line": 9224,
    "end_line": 9230,
    "section": "Hard line breaks"
  },
  {
    "markdown": "foo       \nbaz\n",
    "html": "<p>foo<br />\nbaz</p>\n",
    "example": 635,
    "start_line": 9235,
    "end_line": 9241,
    "section": "Hard line breaks"
  },
  {
    "markdown": "foo  \n     bar\n",
    "html": "<p>foo<br />\nbar</p>\n",
    "example": 636,
    "start_line": 9246,
    "end_line": 9252,
    "section": "Hard line breaks"
  },
  {
    "markdown": "foo\\\n     bar\n",
    "html": "<p>foo<br />\nbar</p>\n",
    "example": 637,
    "start_line": 9255,
    "end_line": 9261,
    "section": "Hard line breaks"
  },
  {
    "markdown": "*foo  \nbar*\n",
    "html": "<p><em>foo<br />\nbar</em></p>\n",
    "example": 638,
    "start_line": 9267,
    "end_line": 9273,
    "section": "Hard line breaks"
  },
  {
    "markdown": "*foo\\\nbar*\n",
    "html": "<p><em>foo<br />\nbar</em></p>\n",
    "example": 639,
    "start_line": 9276,
    "end_line": 9282,
    "section": "Hard line breaks"
  },
  {
    "markdown": "`code  \nspan`\n",
    "html": "<p><code>code   span</code></p>\n",
    "example": 640,
    "start_line": 9287,
    "end_line": 9292,
    "section": "Hard line breaks"
  },
  {
    "markdown": "`code\\\nspan`\n",
    "html": "<p><code>code\\ span</code></p>\n",
    "example": 641,
    "start_line": 9295,
    "end_line": 9300,
    "section": "Hard line breaks"
  },
  {
    "markdown": "<a href=\"foo  \nbar\">\n",
    "html": "<p><a href=\"foo  \nbar\"></p>\n",
    "example": 642,
    "start_line": 9305,
    "end_line": 9311,
    "section": "Hard line breaks"
  },
  {
    "markdown": "<a href=\"foo\\\nbar\">\n",
    "html": "<p><a href=\"foo\\\nbar\"></p>\n",
    "example": 643,
    "start_line": 9314,
    "end_line": 9320,
    "section": "Hard line breaks"
  },
  {
    "markdown": "foo\\\n",
    "html": "<p>foo\\</p>\n",
    "example": 644,
    "start_line": 9327,
    "end_line": 9331,
    "section": "Hard line breaks"
  },
  {
    "markdown": "foo  \n",
    "html": "<p>foo</p>\n",
    "example": 645,
    "start_line": 9334,
    "end_line": 9338,
    "section": "Hard line breaks"
  },
  {
    "markdown": "### foo\\\n",
    "html": "<h3>foo\\</h3>\n",
    "example": 646,
    "start_line": 9341,
    "end_line": 9345,
    "section": "Hard line breaks"
  },
  {
    "markdown": "### foo  \n",
    "html": "<h3>foo</h3>\n",
    "example": 647,
    "start_line": 9348,
    "end_line": 9352,
    "section": "Hard line breaks"
  },
  {
    "markdown": "foo\nbaz\n",
    "html": "<p>foo\nbaz</p>\n",
    "example": 648,
    "start_line": 9363,
    "end_line": 9369,
    "section": "Soft line breaks"
  },
  {
    "markdown": "foo \n baz\n",
    "html": "<p>foo\nbaz</p>\n",
    "example": 649,
    "start_line": 9375,
    "end_line": 9381,
    "section": "Soft line breaks"
  },
  {
    "markdown": "hello $.;'there\n",
    "html": "<p>hello $.;'there</p>\n",
    "example": 650,
    "start_line": 9395,
    "end_line": 9399,
    "section": "Textual content"
  },
  {
    "markdown": "Foo χρῆν\n",
    "html": "<p>Foo χρῆν</p>\n",
    "example": 651,
    "start_line": 9402,
    "end_line": 9406,
    "section": "Textual content"
  },
  {
    "markdown": "Multiple     spaces\n",
    "html": "<p>Multiple     spaces</p>\n",
    "example": 652,
    "start_line": 9411,
    "end_line": 9415,
    "section": "Textual content"
  }
]
</file>

<file path="_tools/gen-emb-structs.go">
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func embStructsSubCommand(args []string) {
	cmdName := "emb-structs"
	cmd := flag.NewFlagSet(cmdName, flag.ExitOnError)
	cmd.Usage = func() {
		_, _ = fmt.Fprintf(cmd.Output(), `Usage of %s:

  Embed Go structs as compact format in the binary.
  JSON file format:
    {
      "prefix": "html5entities", // prefix for the generated const/var
      "types": { // struct field types
          "Name": "string",         // struct fields
          "CodePoints": "[]int",
          "Characters": "[]byte"
      },

      // array of struct data
      // all data must be a string
      "data": [ 
        {"Name": "AElig", "CodePoints": ["198"], "Characters": ["0xc3", "0x86"]},
        {"Name": "AMP", "CodePoints": ["38"], "Characters": ["0x26"]},
      ]
    }

`, cmdName)
		cmd.PrintDefaults()
	}

	inputJSONPath := cmd.String("i", "", "source JSON file path(required)")
	outputPath := cmd.String("o", "", "output file path(required)")

	if err := cmd.Parse(args); err != nil ||
		len(*inputJSONPath) == 0 ||
		len(*outputPath) == 0 {
		usage(cmd.Usage, err)
	}
	var source map[string]any
	inputJSONSource, err := os.ReadFile(*inputJSONPath)
	if err != nil {
		panic(err)
	}
	if err := json.Unmarshal(inputJSONSource, &source); err != nil {
		panic(err)
	}

	f, err := os.Create(*outputPath)
	if err != nil {
		fmt.Printf("Failed to open %s: %v\n", *outputPath, err)
		os.Exit(1)
	}
	defer f.Close()

	abs, _ := filepath.Abs(*outputPath)
	pkg := filepath.Base(filepath.Dir(abs))

	write := func(ft string, v ...any) {
		if len(v) == 0 {
			_, _ = f.WriteString(ft)
			return
		}
		_, _ = f.WriteString(fmt.Sprintf(ft, v...))
	}
	writeln := func(ft string, v ...any) {
		write(ft+"\n", v...)
	}

	writeln("// Code generated by _tools; DO NOT EDIT.")
	writeln("package " + pkg)

	prefix := source["prefix"].(string)
	types := source["types"].(map[string]any)
	data := source["data"].([]any)

	writeln("const _%sLength = %d", prefix, len(data))

	for prop, _typ := range types {
		typ := _typ.(string)
		if typ == "string" {
			write("const _%s%s string = \"", prefix, prop)
			for _, _d := range data {
				d := _d.(map[string]any)
				v := d[prop].(string)
				write(v)
			}
			writeln(`"`)
			write("const _%s%sIndex  = \"", prefix, prop)
			for _, _d := range data {
				d := _d.(map[string]any)
				v := d[prop].(string)
				write("\\x%02x", len(v))
			}
			writeln(`"`)
			continue
		}

		if strings.HasPrefix(typ, "[]") {
			elmTyp := typ[2:]
			write("var _%s%s = [...]%s{", prefix, prop, elmTyp)
			for i, _d := range data {
				d := _d.(map[string]any)
				arr := d[prop].([]any)
				for j, a := range arr {
					v := a.(string)
					write(v)
					if i != len(data)-1 || j != len(arr)-1 {
						write(", ")
					}
				}
			}
			writeln("}")
			write("var _%s%sIndex  = \"", prefix, prop)
			for _, _d := range data {
				d := _d.(map[string]any)
				arr := d[prop].([]any)
				write("\\x%02x", len(arr))
			}
			writeln(`"`)
			continue
		}

		write("var _%s%s = [...]%s{", prefix, prop, typ)
		for i, _d := range data {
			d := _d.(map[string]any)
			v := d[prop].(string)
			write(v)
			if i != len(data)-1 {
				write(", ")
			}
		}
		writeln(`}`)
	}
}
</file>

<file path="_tools/gen-oss-fuzz-corpus.go">
package main

import (
	"archive/zip"
	"encoding/json"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
)

type TestCase struct {
	Example  int    `json:"example"`
	Markdown string `json:"markdown"`
}

func ossFuzzCorpusSubCommand(args []string) {
	corpus_out := args[0]
	if !strings.HasSuffix(corpus_out, ".zip") {
		log.Fatalln("Expected command line:", os.Args[0], "<corpus_output>.zip")
	}

	zip_file, err := os.Create(corpus_out)

	zip_writer := zip.NewWriter(zip_file)

	if err != nil {
		log.Fatalln("Failed creating file:", err)
	}

	json_corpus := "_test/spec.json"
	bs, err := ioutil.ReadFile(json_corpus)
	if err != nil {
		log.Fatalln("Could not open file:", json_corpus)
		panic(err)
	}
	var testCases []TestCase
	if err := json.Unmarshal(bs, &testCases); err != nil {
		panic(err)
	}

	for _, c := range testCases {
		file_in_zip := "example-" + strconv.Itoa(c.Example)
		f, err := zip_writer.Create(file_in_zip)
		if err != nil {
			log.Fatal(err)
		}
		_, err = f.Write([]byte(c.Markdown))
		if err != nil {
			log.Fatalf("Failed to write file: %s into zip file", file_in_zip)
		}
	}

	err = zip_writer.Close()
	if err != nil {
		log.Fatal("Failed to close zip writer", err)
	}

	zip_file.Close()
}
</file>

<file path="_tools/gen-unicode-case-folding-map.go">
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"
)

type caseFolding struct {
	Class byte
	From  rune
	To    []rune
}

func unicodeCaseFoldingMapSubCommand(args []string) {
	cmdName := "unicode-case-folding-map"
	cmd := flag.NewFlagSet(cmdName, flag.ExitOnError)
	cmd.Usage = func() {
		_, _ = fmt.Fprintf(cmd.Output(), `Usage of %s:

  Generate input JSON data for emb-structs subcommand from unicode.org

`, cmdName)
		cmd.PrintDefaults()
	}

	outputPath := cmd.String("o", "", "output file path(required)")
	unicodeVersion := cmd.String("u", "15.0.0", "unicode version")

	if err := cmd.Parse(args); err != nil ||
		len(*outputPath) == 0 {
		usage(cmd.Usage, err)
	}

	url := "http://www.unicode.org/Public/" + *unicodeVersion + "/ucd/CaseFolding.txt"

	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf("Failed to get CaseFolding.txt: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	bs, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Failed to get CaseFolding.txt: %v\n", err)
		os.Exit(1)
	}

	buf := bytes.NewBuffer(bs)
	scanner := bufio.NewScanner(buf)

	embstructmap := make(map[string]any)
	embstructmap["prefix"] = "unicodeCaseFolding"
	embstructmap["types"] = map[string]any{
		"From": "rune",
		"To":   "[]rune",
	}
	var data []any

	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "#") || len(strings.TrimSpace(line)) == 0 {
			continue
		}
		line = strings.Split(line, "#")[0]
		parts := strings.Split(line, ";")
		for i, p := range parts {
			parts[i] = strings.TrimSpace(p)
		}
		cf := caseFolding{}
		v, _ := strconv.ParseInt(parts[0], 16, 32)
		cf.From = rune(int32(v))
		cf.Class = parts[1][0]
		for _, v := range strings.Split(parts[2], " ") {
			c, _ := strconv.ParseInt(v, 16, 32)
			cf.To = append(cf.To, rune(int32(c)))
		}
		if cf.Class != 'C' && cf.Class != 'F' {
			continue
		}
		var tos []string
		for _, v := range cf.To {
			tos = append(tos, fmt.Sprintf("%d", v))
		}
		data = append(data, map[string]any{
			"From": fmt.Sprintf("0x%x", cf.From),
			"To":   tos,
		})
	}
	embstructmap["data"] = data
	jsonData, err := json.MarshalIndent(embstructmap, "", "  ")
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(*outputPath, jsonData, 0644)
	if err != nil {
		panic(err)
	}

}
</file>

<file path="_tools/html5entities.json">
{
  "prefix": "html5entities",
  "types": {
    "Name": "string",
    "Characters": "[]byte"
  },
  "data": [
    {"Name": "AElig", "Characters": ["0xc3", "0x86"]},
    {"Name": "AMP", "Characters": ["0x26"]},
    {"Name": "Aacute", "Characters": ["0xc3", "0x81"]},
    {"Name": "Acirc", "Characters": ["0xc3", "0x82"]},
    {"Name": "Acy", "Characters": ["0xd0", "0x90"]},
    {"Name": "Afr", "Characters": ["0xf0", "0x9d", "0x94", "0x84"]},
    {"Name": "Agrave", "Characters": ["0xc3", "0x80"]},
    {"Name": "Alpha", "Characters": ["0xce", "0x91"]},
    {"Name": "Amacr", "Characters": ["0xc4", "0x80"]},
    {"Name": "And", "Characters": ["0xe2", "0xa9", "0x93"]},
    {"Name": "Aogon", "Characters": ["0xc4", "0x84"]},
    {"Name": "Aopf", "Characters": ["0xf0", "0x9d", "0x94", "0xb8"]},
    {"Name": "ApplyFunction", "Characters": ["0xe2", "0x81", "0xa1"]},
    {"Name": "Aring", "Characters": ["0xc3", "0x85"]},
    {"Name": "Ascr", "Characters": ["0xf0", "0x9d", "0x92", "0x9c"]},
    {"Name": "Assign", "Characters": ["0xe2", "0x89", "0x94"]},
    {"Name": "Atilde", "Characters": ["0xc3", "0x83"]},
    {"Name": "Auml", "Characters": ["0xc3", "0x84"]},
    {"Name": "Backslash", "Characters": ["0xe2", "0x88", "0x96"]},
    {"Name": "Barv", "Characters": ["0xe2", "0xab", "0xa7"]},
    {"Name": "Barwed", "Characters": ["0xe2", "0x8c", "0x86"]},
    {"Name": "Bcy", "Characters": ["0xd0", "0x91"]},
    {"Name": "Because", "Characters": ["0xe2", "0x88", "0xb5"]},
    {"Name": "Bernoullis", "Characters": ["0xe2", "0x84", "0xac"]},
    {"Name": "Beta", "Characters": ["0xce", "0x92"]},
    {"Name": "Bfr", "Characters": ["0xf0", "0x9d", "0x94", "0x85"]},
    {"Name": "Bopf", "Characters": ["0xf0", "0x9d", "0x94", "0xb9"]},
    {"Name": "Breve", "Characters": ["0xcb", "0x98"]},
    {"Name": "Bscr", "Characters": ["0xe2", "0x84", "0xac"]},
    {"Name": "Bumpeq", "Characters": ["0xe2", "0x89", "0x8e"]},
    {"Name": "CHcy", "Characters": ["0xd0", "0xa7"]},
    {"Name": "COPY", "Characters": ["0xc2", "0xa9"]},
    {"Name": "Cacute", "Characters": ["0xc4", "0x86"]},
    {"Name": "Cap", "Characters": ["0xe2", "0x8b", "0x92"]},
    {"Name": "CapitalDifferentialD", "Characters": ["0xe2", "0x85", "0x85"]},
    {"Name": "Cayleys", "Characters": ["0xe2", "0x84", "0xad"]},
    {"Name": "Ccaron", "Characters": ["0xc4", "0x8c"]},
    {"Name": "Ccedil", "Characters": ["0xc3", "0x87"]},
    {"Name": "Ccirc", "Characters": ["0xc4", "0x88"]},
    {"Name": "Cconint", "Characters": ["0xe2", "0x88", "0xb0"]},
    {"Name": "Cdot", "Characters": ["0xc4", "0x8a"]},
    {"Name": "Cedilla", "Characters": ["0xc2", "0xb8"]},
    {"Name": "CenterDot", "Characters": ["0xc2", "0xb7"]},
    {"Name": "Cfr", "Characters": ["0xe2", "0x84", "0xad"]},
    {"Name": "Chi", "Characters": ["0xce", "0xa7"]},
    {"Name": "CircleDot", "Characters": ["0xe2", "0x8a", "0x99"]},
    {"Name": "CircleMinus", "Characters": ["0xe2", "0x8a", "0x96"]},
    {"Name": "CirclePlus", "Characters": ["0xe2", "0x8a", "0x95"]},
    {"Name": "CircleTimes", "Characters": ["0xe2", "0x8a", "0x97"]},
    {"Name": "ClockwiseContourIntegral", "Characters": ["0xe2", "0x88", "0xb2"]},
    {"Name": "CloseCurlyDoubleQuote", "Characters": ["0xe2", "0x80", "0x9d"]},
    {"Name": "CloseCurlyQuote", "Characters": ["0xe2", "0x80", "0x99"]},
    {"Name": "Colon", "Characters": ["0xe2", "0x88", "0xb7"]},
    {"Name": "Colone", "Characters": ["0xe2", "0xa9", "0xb4"]},
    {"Name": "Congruent", "Characters": ["0xe2", "0x89", "0xa1"]},
    {"Name": "Conint", "Characters": ["0xe2", "0x88", "0xaf"]},
    {"Name": "ContourIntegral", "Characters": ["0xe2", "0x88", "0xae"]},
    {"Name": "Copf", "Characters": ["0xe2", "0x84", "0x82"]},
    {"Name": "Coproduct", "Characters": ["0xe2", "0x88", "0x90"]},
    {"Name": "CounterClockwiseContourIntegral", "Characters": ["0xe2", "0x88", "0xb3"]},
    {"Name": "Cross", "Characters": ["0xe2", "0xa8", "0xaf"]},
    {"Name": "Cscr", "Characters": ["0xf0", "0x9d", "0x92", "0x9e"]},
    {"Name": "Cup", "Characters": ["0xe2", "0x8b", "0x93"]},
    {"Name": "CupCap", "Characters": ["0xe2", "0x89", "0x8d"]},
    {"Name": "DD", "Characters": ["0xe2", "0x85", "0x85"]},
    {"Name": "DDotrahd", "Characters": ["0xe2", "0xa4", "0x91"]},
    {"Name": "DJcy", "Characters": ["0xd0", "0x82"]},
    {"Name": "DScy", "Characters": ["0xd0", "0x85"]},
    {"Name": "DZcy", "Characters": ["0xd0", "0x8f"]},
    {"Name": "Dagger", "Characters": ["0xe2", "0x80", "0xa1"]},
    {"Name": "Darr", "Characters": ["0xe2", "0x86", "0xa1"]},
    {"Name": "Dashv", "Characters": ["0xe2", "0xab", "0xa4"]},
    {"Name": "Dcaron", "Characters": ["0xc4", "0x8e"]},
    {"Name": "Dcy", "Characters": ["0xd0", "0x94"]},
    {"Name": "Del", "Characters": ["0xe2", "0x88", "0x87"]},
    {"Name": "Delta", "Characters": ["0xce", "0x94"]},
    {"Name": "Dfr", "Characters": ["0xf0", "0x9d", "0x94", "0x87"]},
    {"Name": "DiacriticalAcute", "Characters": ["0xc2", "0xb4"]},
    {"Name": "DiacriticalDot", "Characters": ["0xcb", "0x99"]},
    {"Name": "DiacriticalDoubleAcute", "Characters": ["0xcb", "0x9d"]},
    {"Name": "DiacriticalGrave", "Characters": ["0x60"]},
    {"Name": "DiacriticalTilde", "Characters": ["0xcb", "0x9c"]},
    {"Name": "Diamond", "Characters": ["0xe2", "0x8b", "0x84"]},
    {"Name": "DifferentialD", "Characters": ["0xe2", "0x85", "0x86"]},
    {"Name": "Dopf", "Characters": ["0xf0", "0x9d", "0x94", "0xbb"]},
    {"Name": "Dot", "Characters": ["0xc2", "0xa8"]},
    {"Name": "DotDot", "Characters": ["0xe2", "0x83", "0x9c"]},
    {"Name": "DotEqual", "Characters": ["0xe2", "0x89", "0x90"]},
    {"Name": "DoubleContourIntegral", "Characters": ["0xe2", "0x88", "0xaf"]},
    {"Name": "DoubleDot", "Characters": ["0xc2", "0xa8"]},
    {"Name": "DoubleDownArrow", "Characters": ["0xe2", "0x87", "0x93"]},
    {"Name": "DoubleLeftArrow", "Characters": ["0xe2", "0x87", "0x90"]},
    {"Name": "DoubleLeftRightArrow", "Characters": ["0xe2", "0x87", "0x94"]},
    {"Name": "DoubleLeftTee", "Characters": ["0xe2", "0xab", "0xa4"]},
    {"Name": "DoubleLongLeftArrow", "Characters": ["0xe2", "0x9f", "0xb8"]},
    {"Name": "DoubleLongLeftRightArrow", "Characters": ["0xe2", "0x9f", "0xba"]},
    {"Name": "DoubleLongRightArrow", "Characters": ["0xe2", "0x9f", "0xb9"]},
    {"Name": "DoubleRightArrow", "Characters": ["0xe2", "0x87", "0x92"]},
    {"Name": "DoubleRightTee", "Characters": ["0xe2", "0x8a", "0xa8"]},
    {"Name": "DoubleUpArrow", "Characters": ["0xe2", "0x87", "0x91"]},
    {"Name": "DoubleUpDownArrow", "Characters": ["0xe2", "0x87", "0x95"]},
    {"Name": "DoubleVerticalBar", "Characters": ["0xe2", "0x88", "0xa5"]},
    {"Name": "DownArrow", "Characters": ["0xe2", "0x86", "0x93"]},
    {"Name": "DownArrowBar", "Characters": ["0xe2", "0xa4", "0x93"]},
    {"Name": "DownArrowUpArrow", "Characters": ["0xe2", "0x87", "0xb5"]},
    {"Name": "DownBreve", "Characters": ["0xcc", "0x91"]},
    {"Name": "DownLeftRightVector", "Characters": ["0xe2", "0xa5", "0x90"]},
    {"Name": "DownLeftTeeVector", "Characters": ["0xe2", "0xa5", "0x9e"]},
    {"Name": "DownLeftVector", "Characters": ["0xe2", "0x86", "0xbd"]},
    {"Name": "DownLeftVectorBar", "Characters": ["0xe2", "0xa5", "0x96"]},
    {"Name": "DownRightTeeVector", "Characters": ["0xe2", "0xa5", "0x9f"]},
    {"Name": "DownRightVector", "Characters": ["0xe2", "0x87", "0x81"]},
    {"Name": "DownRightVectorBar", "Characters": ["0xe2", "0xa5", "0x97"]},
    {"Name": "DownTee", "Characters": ["0xe2", "0x8a", "0xa4"]},
    {"Name": "DownTeeArrow", "Characters": ["0xe2", "0x86", "0xa7"]},
    {"Name": "Downarrow", "Characters": ["0xe2", "0x87", "0x93"]},
    {"Name": "Dscr", "Characters": ["0xf0", "0x9d", "0x92", "0x9f"]},
    {"Name": "Dstrok", "Characters": ["0xc4", "0x90"]},
    {"Name": "ENG", "Characters": ["0xc5", "0x8a"]},
    {"Name": "ETH", "Characters": ["0xc3", "0x90"]},
    {"Name": "Eacute", "Characters": ["0xc3", "0x89"]},
    {"Name": "Ecaron", "Characters": ["0xc4", "0x9a"]},
    {"Name": "Ecirc", "Characters": ["0xc3", "0x8a"]},
    {"Name": "Ecy", "Characters": ["0xd0", "0xad"]},
    {"Name": "Edot", "Characters": ["0xc4", "0x96"]},
    {"Name": "Efr", "Characters": ["0xf0", "0x9d", "0x94", "0x88"]},
    {"Name": "Egrave", "Characters": ["0xc3", "0x88"]},
    {"Name": "Element", "Characters": ["0xe2", "0x88", "0x88"]},
    {"Name": "Emacr", "Characters": ["0xc4", "0x92"]},
    {"Name": "EmptySmallSquare", "Characters": ["0xe2", "0x97", "0xbb"]},
    {"Name": "EmptyVerySmallSquare", "Characters": ["0xe2", "0x96", "0xab"]},
    {"Name": "Eogon", "Characters": ["0xc4", "0x98"]},
    {"Name": "Eopf", "Characters": ["0xf0", "0x9d", "0x94", "0xbc"]},
    {"Name": "Epsilon", "Characters": ["0xce", "0x95"]},
    {"Name": "Equal", "Characters": ["0xe2", "0xa9", "0xb5"]},
    {"Name": "EqualTilde", "Characters": ["0xe2", "0x89", "0x82"]},
    {"Name": "Equilibrium", "Characters": ["0xe2", "0x87", "0x8c"]},
    {"Name": "Escr", "Characters": ["0xe2", "0x84", "0xb0"]},
    {"Name": "Esim", "Characters": ["0xe2", "0xa9", "0xb3"]},
    {"Name": "Eta", "Characters": ["0xce", "0x97"]},
    {"Name": "Euml", "Characters": ["0xc3", "0x8b"]},
    {"Name": "Exists", "Characters": ["0xe2", "0x88", "0x83"]},
    {"Name": "ExponentialE", "Characters": ["0xe2", "0x85", "0x87"]},
    {"Name": "Fcy", "Characters": ["0xd0", "0xa4"]},
    {"Name": "Ffr", "Characters": ["0xf0", "0x9d", "0x94", "0x89"]},
    {"Name": "FilledSmallSquare", "Characters": ["0xe2", "0x97", "0xbc"]},
    {"Name": "FilledVerySmallSquare", "Characters": ["0xe2", "0x96", "0xaa"]},
    {"Name": "Fopf", "Characters": ["0xf0", "0x9d", "0x94", "0xbd"]},
    {"Name": "ForAll", "Characters": ["0xe2", "0x88", "0x80"]},
    {"Name": "Fouriertrf", "Characters": ["0xe2", "0x84", "0xb1"]},
    {"Name": "Fscr", "Characters": ["0xe2", "0x84", "0xb1"]},
    {"Name": "GJcy", "Characters": ["0xd0", "0x83"]},
    {"Name": "GT", "Characters": ["0x3e"]},
    {"Name": "Gamma", "Characters": ["0xce", "0x93"]},
    {"Name": "Gammad", "Characters": ["0xcf", "0x9c"]},
    {"Name": "Gbreve", "Characters": ["0xc4", "0x9e"]},
    {"Name": "Gcedil", "Characters": ["0xc4", "0xa2"]},
    {"Name": "Gcirc", "Characters": ["0xc4", "0x9c"]},
    {"Name": "Gcy", "Characters": ["0xd0", "0x93"]},
    {"Name": "Gdot", "Characters": ["0xc4", "0xa0"]},
    {"Name": "Gfr", "Characters": ["0xf0", "0x9d", "0x94", "0x8a"]},
    {"Name": "Gg", "Characters": ["0xe2", "0x8b", "0x99"]},
    {"Name": "Gopf", "Characters": ["0xf0", "0x9d", "0x94", "0xbe"]},
    {"Name": "GreaterEqual", "Characters": ["0xe2", "0x89", "0xa5"]},
    {"Name": "GreaterEqualLess", "Characters": ["0xe2", "0x8b", "0x9b"]},
    {"Name": "GreaterFullEqual", "Characters": ["0xe2", "0x89", "0xa7"]},
    {"Name": "GreaterGreater", "Characters": ["0xe2", "0xaa", "0xa2"]},
    {"Name": "GreaterLess", "Characters": ["0xe2", "0x89", "0xb7"]},
    {"Name": "GreaterSlantEqual", "Characters": ["0xe2", "0xa9", "0xbe"]},
    {"Name": "GreaterTilde", "Characters": ["0xe2", "0x89", "0xb3"]},
    {"Name": "Gscr", "Characters": ["0xf0", "0x9d", "0x92", "0xa2"]},
    {"Name": "Gt", "Characters": ["0xe2", "0x89", "0xab"]},
    {"Name": "HARDcy", "Characters": ["0xd0", "0xaa"]},
    {"Name": "Hacek", "Characters": ["0xcb", "0x87"]},
    {"Name": "Hat", "Characters": ["0x5e"]},
    {"Name": "Hcirc", "Characters": ["0xc4", "0xa4"]},
    {"Name": "Hfr", "Characters": ["0xe2", "0x84", "0x8c"]},
    {"Name": "HilbertSpace", "Characters": ["0xe2", "0x84", "0x8b"]},
    {"Name": "Hopf", "Characters": ["0xe2", "0x84", "0x8d"]},
    {"Name": "HorizontalLine", "Characters": ["0xe2", "0x94", "0x80"]},
    {"Name": "Hscr", "Characters": ["0xe2", "0x84", "0x8b"]},
    {"Name": "Hstrok", "Characters": ["0xc4", "0xa6"]},
    {"Name": "HumpDownHump", "Characters": ["0xe2", "0x89", "0x8e"]},
    {"Name": "HumpEqual", "Characters": ["0xe2", "0x89", "0x8f"]},
    {"Name": "IEcy", "Characters": ["0xd0", "0x95"]},
    {"Name": "IJlig", "Characters": ["0xc4", "0xb2"]},
    {"Name": "IOcy", "Characters": ["0xd0", "0x81"]},
    {"Name": "Iacute", "Characters": ["0xc3", "0x8d"]},
    {"Name": "Icirc", "Characters": ["0xc3", "0x8e"]},
    {"Name": "Icy", "Characters": ["0xd0", "0x98"]},
    {"Name": "Idot", "Characters": ["0xc4", "0xb0"]},
    {"Name": "Ifr", "Characters": ["0xe2", "0x84", "0x91"]},
    {"Name": "Igrave", "Characters": ["0xc3", "0x8c"]},
    {"Name": "Im", "Characters": ["0xe2", "0x84", "0x91"]},
    {"Name": "Imacr", "Characters": ["0xc4", "0xaa"]},
    {"Name": "ImaginaryI", "Characters": ["0xe2", "0x85", "0x88"]},
    {"Name": "Implies", "Characters": ["0xe2", "0x87", "0x92"]},
    {"Name": "Int", "Characters": ["0xe2", "0x88", "0xac"]},
    {"Name": "Integral", "Characters": ["0xe2", "0x88", "0xab"]},
    {"Name": "Intersection", "Characters": ["0xe2", "0x8b", "0x82"]},
    {"Name": "InvisibleComma", "Characters": ["0xe2", "0x81", "0xa3"]},
    {"Name": "InvisibleTimes", "Characters": ["0xe2", "0x81", "0xa2"]},
    {"Name": "Iogon", "Characters": ["0xc4", "0xae"]},
    {"Name": "Iopf", "Characters": ["0xf0", "0x9d", "0x95", "0x80"]},
    {"Name": "Iota", "Characters": ["0xce", "0x99"]},
    {"Name": "Iscr", "Characters": ["0xe2", "0x84", "0x90"]},
    {"Name": "Itilde", "Characters": ["0xc4", "0xa8"]},
    {"Name": "Iukcy", "Characters": ["0xd0", "0x86"]},
    {"Name": "Iuml", "Characters": ["0xc3", "0x8f"]},
    {"Name": "Jcirc", "Characters": ["0xc4", "0xb4"]},
    {"Name": "Jcy", "Characters": ["0xd0", "0x99"]},
    {"Name": "Jfr", "Characters": ["0xf0", "0x9d", "0x94", "0x8d"]},
    {"Name": "Jopf", "Characters": ["0xf0", "0x9d", "0x95", "0x81"]},
    {"Name": "Jscr", "Characters": ["0xf0", "0x9d", "0x92", "0xa5"]},
    {"Name": "Jsercy", "Characters": ["0xd0", "0x88"]},
    {"Name": "Jukcy", "Characters": ["0xd0", "0x84"]},
    {"Name": "KHcy", "Characters": ["0xd0", "0xa5"]},
    {"Name": "KJcy", "Characters": ["0xd0", "0x8c"]},
    {"Name": "Kappa", "Characters": ["0xce", "0x9a"]},
    {"Name": "Kcedil", "Characters": ["0xc4", "0xb6"]},
    {"Name": "Kcy", "Characters": ["0xd0", "0x9a"]},
    {"Name": "Kfr", "Characters": ["0xf0", "0x9d", "0x94", "0x8e"]},
    {"Name": "Kopf", "Characters": ["0xf0", "0x9d", "0x95", "0x82"]},
    {"Name": "Kscr", "Characters": ["0xf0", "0x9d", "0x92", "0xa6"]},
    {"Name": "LJcy", "Characters": ["0xd0", "0x89"]},
    {"Name": "LT", "Characters": ["0x3c"]},
    {"Name": "Lacute", "Characters": ["0xc4", "0xb9"]},
    {"Name": "Lambda", "Characters": ["0xce", "0x9b"]},
    {"Name": "Lang", "Characters": ["0xe2", "0x9f", "0xaa"]},
    {"Name": "Laplacetrf", "Characters": ["0xe2", "0x84", "0x92"]},
    {"Name": "Larr", "Characters": ["0xe2", "0x86", "0x9e"]},
    {"Name": "Lcaron", "Characters": ["0xc4", "0xbd"]},
    {"Name": "Lcedil", "Characters": ["0xc4", "0xbb"]},
    {"Name": "Lcy", "Characters": ["0xd0", "0x9b"]},
    {"Name": "LeftAngleBracket", "Characters": ["0xe2", "0x9f", "0xa8"]},
    {"Name": "LeftArrow", "Characters": ["0xe2", "0x86", "0x90"]},
    {"Name": "LeftArrowBar", "Characters": ["0xe2", "0x87", "0xa4"]},
    {"Name": "LeftArrowRightArrow", "Characters": ["0xe2", "0x87", "0x86"]},
    {"Name": "LeftCeiling", "Characters": ["0xe2", "0x8c", "0x88"]},
    {"Name": "LeftDoubleBracket", "Characters": ["0xe2", "0x9f", "0xa6"]},
    {"Name": "LeftDownTeeVector", "Characters": ["0xe2", "0xa5", "0xa1"]},
    {"Name": "LeftDownVector", "Characters": ["0xe2", "0x87", "0x83"]},
    {"Name": "LeftDownVectorBar", "Characters": ["0xe2", "0xa5", "0x99"]},
    {"Name": "LeftFloor", "Characters": ["0xe2", "0x8c", "0x8a"]},
    {"Name": "LeftRightArrow", "Characters": ["0xe2", "0x86", "0x94"]},
    {"Name": "LeftRightVector", "Characters": ["0xe2", "0xa5", "0x8e"]},
    {"Name": "LeftTee", "Characters": ["0xe2", "0x8a", "0xa3"]},
    {"Name": "LeftTeeArrow", "Characters": ["0xe2", "0x86", "0xa4"]},
    {"Name": "LeftTeeVector", "Characters": ["0xe2", "0xa5", "0x9a"]},
    {"Name": "LeftTriangle", "Characters": ["0xe2", "0x8a", "0xb2"]},
    {"Name": "LeftTriangleBar", "Characters": ["0xe2", "0xa7", "0x8f"]},
    {"Name": "LeftTriangleEqual", "Characters": ["0xe2", "0x8a", "0xb4"]},
    {"Name": "LeftUpDownVector", "Characters": ["0xe2", "0xa5", "0x91"]},
    {"Name": "LeftUpTeeVector", "Characters": ["0xe2", "0xa5", "0xa0"]},
    {"Name": "LeftUpVector", "Characters": ["0xe2", "0x86", "0xbf"]},
    {"Name": "LeftUpVectorBar", "Characters": ["0xe2", "0xa5", "0x98"]},
    {"Name": "LeftVector", "Characters": ["0xe2", "0x86", "0xbc"]},
    {"Name": "LeftVectorBar", "Characters": ["0xe2", "0xa5", "0x92"]},
    {"Name": "Leftarrow", "Characters": ["0xe2", "0x87", "0x90"]},
    {"Name": "Leftrightarrow", "Characters": ["0xe2", "0x87", "0x94"]},
    {"Name": "LessEqualGreater", "Characters": ["0xe2", "0x8b", "0x9a"]},
    {"Name": "LessFullEqual", "Characters": ["0xe2", "0x89", "0xa6"]},
    {"Name": "LessGreater", "Characters": ["0xe2", "0x89", "0xb6"]},
    {"Name": "LessLess", "Characters": ["0xe2", "0xaa", "0xa1"]},
    {"Name": "LessSlantEqual", "Characters": ["0xe2", "0xa9", "0xbd"]},
    {"Name": "LessTilde", "Characters": ["0xe2", "0x89", "0xb2"]},
    {"Name": "Lfr", "Characters": ["0xf0", "0x9d", "0x94", "0x8f"]},
    {"Name": "Ll", "Characters": ["0xe2", "0x8b", "0x98"]},
    {"Name": "Lleftarrow", "Characters": ["0xe2", "0x87", "0x9a"]},
    {"Name": "Lmidot", "Characters": ["0xc4", "0xbf"]},
    {"Name": "LongLeftArrow", "Characters": ["0xe2", "0x9f", "0xb5"]},
    {"Name": "LongLeftRightArrow", "Characters": ["0xe2", "0x9f", "0xb7"]},
    {"Name": "LongRightArrow", "Characters": ["0xe2", "0x9f", "0xb6"]},
    {"Name": "Longleftarrow", "Characters": ["0xe2", "0x9f", "0xb8"]},
    {"Name": "Longleftrightarrow", "Characters": ["0xe2", "0x9f", "0xba"]},
    {"Name": "Longrightarrow", "Characters": ["0xe2", "0x9f", "0xb9"]},
    {"Name": "Lopf", "Characters": ["0xf0", "0x9d", "0x95", "0x83"]},
    {"Name": "LowerLeftArrow", "Characters": ["0xe2", "0x86", "0x99"]},
    {"Name": "LowerRightArrow", "Characters": ["0xe2", "0x86", "0x98"]},
    {"Name": "Lscr", "Characters": ["0xe2", "0x84", "0x92"]},
    {"Name": "Lsh", "Characters": ["0xe2", "0x86", "0xb0"]},
    {"Name": "Lstrok", "Characters": ["0xc5", "0x81"]},
    {"Name": "Lt", "Characters": ["0xe2", "0x89", "0xaa"]},
    {"Name": "Map", "Characters": ["0xe2", "0xa4", "0x85"]},
    {"Name": "Mcy", "Characters": ["0xd0", "0x9c"]},
    {"Name": "MediumSpace", "Characters": ["0xe2", "0x81", "0x9f"]},
    {"Name": "Mellintrf", "Characters": ["0xe2", "0x84", "0xb3"]},
    {"Name": "Mfr", "Characters": ["0xf0", "0x9d", "0x94", "0x90"]},
    {"Name": "MinusPlus", "Characters": ["0xe2", "0x88", "0x93"]},
    {"Name": "Mopf", "Characters": ["0xf0", "0x9d", "0x95", "0x84"]},
    {"Name": "Mscr", "Characters": ["0xe2", "0x84", "0xb3"]},
    {"Name": "Mu", "Characters": ["0xce", "0x9c"]},
    {"Name": "NJcy", "Characters": ["0xd0", "0x8a"]},
    {"Name": "Nacute", "Characters": ["0xc5", "0x83"]},
    {"Name": "Ncaron", "Characters": ["0xc5", "0x87"]},
    {"Name": "Ncedil", "Characters": ["0xc5", "0x85"]},
    {"Name": "Ncy", "Characters": ["0xd0", "0x9d"]},
    {"Name": "NegativeMediumSpace", "Characters": ["0xe2", "0x80", "0x8b"]},
    {"Name": "NegativeThickSpace", "Characters": ["0xe2", "0x80", "0x8b"]},
    {"Name": "NegativeThinSpace", "Characters": ["0xe2", "0x80", "0x8b"]},
    {"Name": "NegativeVeryThinSpace", "Characters": ["0xe2", "0x80", "0x8b"]},
    {"Name": "NestedGreaterGreater", "Characters": ["0xe2", "0x89", "0xab"]},
    {"Name": "NestedLessLess", "Characters": ["0xe2", "0x89", "0xaa"]},
    {"Name": "NewLine", "Characters": ["0xa"]},
    {"Name": "Nfr", "Characters": ["0xf0", "0x9d", "0x94", "0x91"]},
    {"Name": "NoBreak", "Characters": ["0xe2", "0x81", "0xa0"]},
    {"Name": "NonBreakingSpace", "Characters": ["0xc2", "0xa0"]},
    {"Name": "Nopf", "Characters": ["0xe2", "0x84", "0x95"]},
    {"Name": "Not", "Characters": ["0xe2", "0xab", "0xac"]},
    {"Name": "NotCongruent", "Characters": ["0xe2", "0x89", "0xa2"]},
    {"Name": "NotCupCap", "Characters": ["0xe2", "0x89", "0xad"]},
    {"Name": "NotDoubleVerticalBar", "Characters": ["0xe2", "0x88", "0xa6"]},
    {"Name": "NotElement", "Characters": ["0xe2", "0x88", "0x89"]},
    {"Name": "NotEqual", "Characters": ["0xe2", "0x89", "0xa0"]},
    {"Name": "NotEqualTilde", "Characters": ["0xe2", "0x89", "0x82", "0xcc", "0xb8"]},
    {"Name": "NotExists", "Characters": ["0xe2", "0x88", "0x84"]},
    {"Name": "NotGreater", "Characters": ["0xe2", "0x89", "0xaf"]},
    {"Name": "NotGreaterEqual", "Characters": ["0xe2", "0x89", "0xb1"]},
    {"Name": "NotGreaterFullEqual", "Characters": ["0xe2", "0x89", "0xa7", "0xcc", "0xb8"]},
    {"Name": "NotGreaterGreater", "Characters": ["0xe2", "0x89", "0xab", "0xcc", "0xb8"]},
    {"Name": "NotGreaterLess", "Characters": ["0xe2", "0x89", "0xb9"]},
    {"Name": "NotGreaterSlantEqual", "Characters": ["0xe2", "0xa9", "0xbe", "0xcc", "0xb8"]},
    {"Name": "NotGreaterTilde", "Characters": ["0xe2", "0x89", "0xb5"]},
    {"Name": "NotHumpDownHump", "Characters": ["0xe2", "0x89", "0x8e", "0xcc", "0xb8"]},
    {"Name": "NotHumpEqual", "Characters": ["0xe2", "0x89", "0x8f", "0xcc", "0xb8"]},
    {"Name": "NotLeftTriangle", "Characters": ["0xe2", "0x8b", "0xaa"]},
    {"Name": "NotLeftTriangleBar", "Characters": ["0xe2", "0xa7", "0x8f", "0xcc", "0xb8"]},
    {"Name": "NotLeftTriangleEqual", "Characters": ["0xe2", "0x8b", "0xac"]},
    {"Name": "NotLess", "Characters": ["0xe2", "0x89", "0xae"]},
    {"Name": "NotLessEqual", "Characters": ["0xe2", "0x89", "0xb0"]},
    {"Name": "NotLessGreater", "Characters": ["0xe2", "0x89", "0xb8"]},
    {"Name": "NotLessLess", "Characters": ["0xe2", "0x89", "0xaa", "0xcc", "0xb8"]},
    {"Name": "NotLessSlantEqual", "Characters": ["0xe2", "0xa9", "0xbd", "0xcc", "0xb8"]},
    {"Name": "NotLessTilde", "Characters": ["0xe2", "0x89", "0xb4"]},
    {"Name": "NotNestedGreaterGreater", "Characters": ["0xe2", "0xaa", "0xa2", "0xcc", "0xb8"]},
    {"Name": "NotNestedLessLess", "Characters": ["0xe2", "0xaa", "0xa1", "0xcc", "0xb8"]},
    {"Name": "NotPrecedes", "Characters": ["0xe2", "0x8a", "0x80"]},
    {"Name": "NotPrecedesEqual", "Characters": ["0xe2", "0xaa", "0xaf", "0xcc", "0xb8"]},
    {"Name": "NotPrecedesSlantEqual", "Characters": ["0xe2", "0x8b", "0xa0"]},
    {"Name": "NotReverseElement", "Characters": ["0xe2", "0x88", "0x8c"]},
    {"Name": "NotRightTriangle", "Characters": ["0xe2", "0x8b", "0xab"]},
    {"Name": "NotRightTriangleBar", "Characters": ["0xe2", "0xa7", "0x90", "0xcc", "0xb8"]},
    {"Name": "NotRightTriangleEqual", "Characters": ["0xe2", "0x8b", "0xad"]},
    {"Name": "NotSquareSubset", "Characters": ["0xe2", "0x8a", "0x8f", "0xcc", "0xb8"]},
    {"Name": "NotSquareSubsetEqual", "Characters": ["0xe2", "0x8b", "0xa2"]},
    {"Name": "NotSquareSuperset", "Characters": ["0xe2", "0x8a", "0x90", "0xcc", "0xb8"]},
    {"Name": "NotSquareSupersetEqual", "Characters": ["0xe2", "0x8b", "0xa3"]},
    {"Name": "NotSubset", "Characters": ["0xe2", "0x8a", "0x82", "0xe2", "0x83", "0x92"]},
    {"Name": "NotSubsetEqual", "Characters": ["0xe2", "0x8a", "0x88"]},
    {"Name": "NotSucceeds", "Characters": ["0xe2", "0x8a", "0x81"]},
    {"Name": "NotSucceedsEqual", "Characters": ["0xe2", "0xaa", "0xb0", "0xcc", "0xb8"]},
    {"Name": "NotSucceedsSlantEqual", "Characters": ["0xe2", "0x8b", "0xa1"]},
    {"Name": "NotSucceedsTilde", "Characters": ["0xe2", "0x89", "0xbf", "0xcc", "0xb8"]},
    {"Name": "NotSuperset", "Characters": ["0xe2", "0x8a", "0x83", "0xe2", "0x83", "0x92"]},
    {"Name": "NotSupersetEqual", "Characters": ["0xe2", "0x8a", "0x89"]},
    {"Name": "NotTilde", "Characters": ["0xe2", "0x89", "0x81"]},
    {"Name": "NotTildeEqual", "Characters": ["0xe2", "0x89", "0x84"]},
    {"Name": "NotTildeFullEqual", "Characters": ["0xe2", "0x89", "0x87"]},
    {"Name": "NotTildeTilde", "Characters": ["0xe2", "0x89", "0x89"]},
    {"Name": "NotVerticalBar", "Characters": ["0xe2", "0x88", "0xa4"]},
    {"Name": "Nscr", "Characters": ["0xf0", "0x9d", "0x92", "0xa9"]},
    {"Name": "Ntilde", "Characters": ["0xc3", "0x91"]},
    {"Name": "Nu", "Characters": ["0xce", "0x9d"]},
    {"Name": "OElig", "Characters": ["0xc5", "0x92"]},
    {"Name": "Oacute", "Characters": ["0xc3", "0x93"]},
    {"Name": "Ocirc", "Characters": ["0xc3", "0x94"]},
    {"Name": "Ocy", "Characters": ["0xd0", "0x9e"]},
    {"Name": "Odblac", "Characters": ["0xc5", "0x90"]},
    {"Name": "Ofr", "Characters": ["0xf0", "0x9d", "0x94", "0x92"]},
    {"Name": "Ograve", "Characters": ["0xc3", "0x92"]},
    {"Name": "Omacr", "Characters": ["0xc5", "0x8c"]},
    {"Name": "Omega", "Characters": ["0xce", "0xa9"]},
    {"Name": "Omicron", "Characters": ["0xce", "0x9f"]},
    {"Name": "Oopf", "Characters": ["0xf0", "0x9d", "0x95", "0x86"]},
    {"Name": "OpenCurlyDoubleQuote", "Characters": ["0xe2", "0x80", "0x9c"]},
    {"Name": "OpenCurlyQuote", "Characters": ["0xe2", "0x80", "0x98"]},
    {"Name": "Or", "Characters": ["0xe2", "0xa9", "0x94"]},
    {"Name": "Oscr", "Characters": ["0xf0", "0x9d", "0x92", "0xaa"]},
    {"Name": "Oslash", "Characters": ["0xc3", "0x98"]},
    {"Name": "Otilde", "Characters": ["0xc3", "0x95"]},
    {"Name": "Otimes", "Characters": ["0xe2", "0xa8", "0xb7"]},
    {"Name": "Ouml", "Characters": ["0xc3", "0x96"]},
    {"Name": "OverBar", "Characters": ["0xe2", "0x80", "0xbe"]},
    {"Name": "OverBrace", "Characters": ["0xe2", "0x8f", "0x9e"]},
    {"Name": "OverBracket", "Characters": ["0xe2", "0x8e", "0xb4"]},
    {"Name": "OverParenthesis", "Characters": ["0xe2", "0x8f", "0x9c"]},
    {"Name": "PartialD", "Characters": ["0xe2", "0x88", "0x82"]},
    {"Name": "Pcy", "Characters": ["0xd0", "0x9f"]},
    {"Name": "Pfr", "Characters": ["0xf0", "0x9d", "0x94", "0x93"]},
    {"Name": "Phi", "Characters": ["0xce", "0xa6"]},
    {"Name": "Pi", "Characters": ["0xce", "0xa0"]},
    {"Name": "PlusMinus", "Characters": ["0xc2", "0xb1"]},
    {"Name": "Poincareplane", "Characters": ["0xe2", "0x84", "0x8c"]},
    {"Name": "Popf", "Characters": ["0xe2", "0x84", "0x99"]},
    {"Name": "Pr", "Characters": ["0xe2", "0xaa", "0xbb"]},
    {"Name": "Precedes", "Characters": ["0xe2", "0x89", "0xba"]},
    {"Name": "PrecedesEqual", "Characters": ["0xe2", "0xaa", "0xaf"]},
    {"Name": "PrecedesSlantEqual", "Characters": ["0xe2", "0x89", "0xbc"]},
    {"Name": "PrecedesTilde", "Characters": ["0xe2", "0x89", "0xbe"]},
    {"Name": "Prime", "Characters": ["0xe2", "0x80", "0xb3"]},
    {"Name": "Product", "Characters": ["0xe2", "0x88", "0x8f"]},
    {"Name": "Proportion", "Characters": ["0xe2", "0x88", "0xb7"]},
    {"Name": "Proportional", "Characters": ["0xe2", "0x88", "0x9d"]},
    {"Name": "Pscr", "Characters": ["0xf0", "0x9d", "0x92", "0xab"]},
    {"Name": "Psi", "Characters": ["0xce", "0xa8"]},
    {"Name": "QUOT", "Characters": ["0x22"]},
    {"Name": "Qfr", "Characters": ["0xf0", "0x9d", "0x94", "0x94"]},
    {"Name": "Qopf", "Characters": ["0xe2", "0x84", "0x9a"]},
    {"Name": "Qscr", "Characters": ["0xf0", "0x9d", "0x92", "0xac"]},
    {"Name": "RBarr", "Characters": ["0xe2", "0xa4", "0x90"]},
    {"Name": "REG", "Characters": ["0xc2", "0xae"]},
    {"Name": "Racute", "Characters": ["0xc5", "0x94"]},
    {"Name": "Rang", "Characters": ["0xe2", "0x9f", "0xab"]},
    {"Name": "Rarr", "Characters": ["0xe2", "0x86", "0xa0"]},
    {"Name": "Rarrtl", "Characters": ["0xe2", "0xa4", "0x96"]},
    {"Name": "Rcaron", "Characters": ["0xc5", "0x98"]},
    {"Name": "Rcedil", "Characters": ["0xc5", "0x96"]},
    {"Name": "Rcy", "Characters": ["0xd0", "0xa0"]},
    {"Name": "Re", "Characters": ["0xe2", "0x84", "0x9c"]},
    {"Name": "ReverseElement", "Characters": ["0xe2", "0x88", "0x8b"]},
    {"Name": "ReverseEquilibrium", "Characters": ["0xe2", "0x87", "0x8b"]},
    {"Name": "ReverseUpEquilibrium", "Characters": ["0xe2", "0xa5", "0xaf"]},
    {"Name": "Rfr", "Characters": ["0xe2", "0x84", "0x9c"]},
    {"Name": "Rho", "Characters": ["0xce", "0xa1"]},
    {"Name": "RightAngleBracket", "Characters": ["0xe2", "0x9f", "0xa9"]},
    {"Name": "RightArrow", "Characters": ["0xe2", "0x86", "0x92"]},
    {"Name": "RightArrowBar", "Characters": ["0xe2", "0x87", "0xa5"]},
    {"Name": "RightArrowLeftArrow", "Characters": ["0xe2", "0x87", "0x84"]},
    {"Name": "RightCeiling", "Characters": ["0xe2", "0x8c", "0x89"]},
    {"Name": "RightDoubleBracket", "Characters": ["0xe2", "0x9f", "0xa7"]},
    {"Name": "RightDownTeeVector", "Characters": ["0xe2", "0xa5", "0x9d"]},
    {"Name": "RightDownVector", "Characters": ["0xe2", "0x87", "0x82"]},
    {"Name": "RightDownVectorBar", "Characters": ["0xe2", "0xa5", "0x95"]},
    {"Name": "RightFloor", "Characters": ["0xe2", "0x8c", "0x8b"]},
    {"Name": "RightTee", "Characters": ["0xe2", "0x8a", "0xa2"]},
    {"Name": "RightTeeArrow", "Characters": ["0xe2", "0x86", "0xa6"]},
    {"Name": "RightTeeVector", "Characters": ["0xe2", "0xa5", "0x9b"]},
    {"Name": "RightTriangle", "Characters": ["0xe2", "0x8a", "0xb3"]},
    {"Name": "RightTriangleBar", "Characters": ["0xe2", "0xa7", "0x90"]},
    {"Name": "RightTriangleEqual", "Characters": ["0xe2", "0x8a", "0xb5"]},
    {"Name": "RightUpDownVector", "Characters": ["0xe2", "0xa5", "0x8f"]},
    {"Name": "RightUpTeeVector", "Characters": ["0xe2", "0xa5", "0x9c"]},
    {"Name": "RightUpVector", "Characters": ["0xe2", "0x86", "0xbe"]},
    {"Name": "RightUpVectorBar", "Characters": ["0xe2", "0xa5", "0x94"]},
    {"Name": "RightVector", "Characters": ["0xe2", "0x87", "0x80"]},
    {"Name": "RightVectorBar", "Characters": ["0xe2", "0xa5", "0x93"]},
    {"Name": "Rightarrow", "Characters": ["0xe2", "0x87", "0x92"]},
    {"Name": "Ropf", "Characters": ["0xe2", "0x84", "0x9d"]},
    {"Name": "RoundImplies", "Characters": ["0xe2", "0xa5", "0xb0"]},
    {"Name": "Rrightarrow", "Characters": ["0xe2", "0x87", "0x9b"]},
    {"Name": "Rscr", "Characters": ["0xe2", "0x84", "0x9b"]},
    {"Name": "Rsh", "Characters": ["0xe2", "0x86", "0xb1"]},
    {"Name": "RuleDelayed", "Characters": ["0xe2", "0xa7", "0xb4"]},
    {"Name": "SHCHcy", "Characters": ["0xd0", "0xa9"]},
    {"Name": "SHcy", "Characters": ["0xd0", "0xa8"]},
    {"Name": "SOFTcy", "Characters": ["0xd0", "0xac"]},
    {"Name": "Sacute", "Characters": ["0xc5", "0x9a"]},
    {"Name": "Sc", "Characters": ["0xe2", "0xaa", "0xbc"]},
    {"Name": "Scaron", "Characters": ["0xc5", "0xa0"]},
    {"Name": "Scedil", "Characters": ["0xc5", "0x9e"]},
    {"Name": "Scirc", "Characters": ["0xc5", "0x9c"]},
    {"Name": "Scy", "Characters": ["0xd0", "0xa1"]},
    {"Name": "Sfr", "Characters": ["0xf0", "0x9d", "0x94", "0x96"]},
    {"Name": "ShortDownArrow", "Characters": ["0xe2", "0x86", "0x93"]},
    {"Name": "ShortLeftArrow", "Characters": ["0xe2", "0x86", "0x90"]},
    {"Name": "ShortRightArrow", "Characters": ["0xe2", "0x86", "0x92"]},
    {"Name": "ShortUpArrow", "Characters": ["0xe2", "0x86", "0x91"]},
    {"Name": "Sigma", "Characters": ["0xce", "0xa3"]},
    {"Name": "SmallCircle", "Characters": ["0xe2", "0x88", "0x98"]},
    {"Name": "Sopf", "Characters": ["0xf0", "0x9d", "0x95", "0x8a"]},
    {"Name": "Sqrt", "Characters": ["0xe2", "0x88", "0x9a"]},
    {"Name": "Square", "Characters": ["0xe2", "0x96", "0xa1"]},
    {"Name": "SquareIntersection", "Characters": ["0xe2", "0x8a", "0x93"]},
    {"Name": "SquareSubset", "Characters": ["0xe2", "0x8a", "0x8f"]},
    {"Name": "SquareSubsetEqual", "Characters": ["0xe2", "0x8a", "0x91"]},
    {"Name": "SquareSuperset", "Characters": ["0xe2", "0x8a", "0x90"]},
    {"Name": "SquareSupersetEqual", "Characters": ["0xe2", "0x8a", "0x92"]},
    {"Name": "SquareUnion", "Characters": ["0xe2", "0x8a", "0x94"]},
    {"Name": "Sscr", "Characters": ["0xf0", "0x9d", "0x92", "0xae"]},
    {"Name": "Star", "Characters": ["0xe2", "0x8b", "0x86"]},
    {"Name": "Sub", "Characters": ["0xe2", "0x8b", "0x90"]},
    {"Name": "Subset", "Characters": ["0xe2", "0x8b", "0x90"]},
    {"Name": "SubsetEqual", "Characters": ["0xe2", "0x8a", "0x86"]},
    {"Name": "Succeeds", "Characters": ["0xe2", "0x89", "0xbb"]},
    {"Name": "SucceedsEqual", "Characters": ["0xe2", "0xaa", "0xb0"]},
    {"Name": "SucceedsSlantEqual", "Characters": ["0xe2", "0x89", "0xbd"]},
    {"Name": "SucceedsTilde", "Characters": ["0xe2", "0x89", "0xbf"]},
    {"Name": "SuchThat", "Characters": ["0xe2", "0x88", "0x8b"]},
    {"Name": "Sum", "Characters": ["0xe2", "0x88", "0x91"]},
    {"Name": "Sup", "Characters": ["0xe2", "0x8b", "0x91"]},
    {"Name": "Superset", "Characters": ["0xe2", "0x8a", "0x83"]},
    {"Name": "SupersetEqual", "Characters": ["0xe2", "0x8a", "0x87"]},
    {"Name": "Supset", "Characters": ["0xe2", "0x8b", "0x91"]},
    {"Name": "THORN", "Characters": ["0xc3", "0x9e"]},
    {"Name": "TRADE", "Characters": ["0xe2", "0x84", "0xa2"]},
    {"Name": "TSHcy", "Characters": ["0xd0", "0x8b"]},
    {"Name": "TScy", "Characters": ["0xd0", "0xa6"]},
    {"Name": "Tab", "Characters": ["0x9"]},
    {"Name": "Tau", "Characters": ["0xce", "0xa4"]},
    {"Name": "Tcaron", "Characters": ["0xc5", "0xa4"]},
    {"Name": "Tcedil", "Characters": ["0xc5", "0xa2"]},
    {"Name": "Tcy", "Characters": ["0xd0", "0xa2"]},
    {"Name": "Tfr", "Characters": ["0xf0", "0x9d", "0x94", "0x97"]},
    {"Name": "Therefore", "Characters": ["0xe2", "0x88", "0xb4"]},
    {"Name": "Theta", "Characters": ["0xce", "0x98"]},
    {"Name": "ThickSpace", "Characters": ["0xe2", "0x81", "0x9f", "0xe2", "0x80", "0x8a"]},
    {"Name": "ThinSpace", "Characters": ["0xe2", "0x80", "0x89"]},
    {"Name": "Tilde", "Characters": ["0xe2", "0x88", "0xbc"]},
    {"Name": "TildeEqual", "Characters": ["0xe2", "0x89", "0x83"]},
    {"Name": "TildeFullEqual", "Characters": ["0xe2", "0x89", "0x85"]},
    {"Name": "TildeTilde", "Characters": ["0xe2", "0x89", "0x88"]},
    {"Name": "Topf", "Characters": ["0xf0", "0x9d", "0x95", "0x8b"]},
    {"Name": "TripleDot", "Characters": ["0xe2", "0x83", "0x9b"]},
    {"Name": "Tscr", "Characters": ["0xf0", "0x9d", "0x92", "0xaf"]},
    {"Name": "Tstrok", "Characters": ["0xc5", "0xa6"]},
    {"Name": "Uacute", "Characters": ["0xc3", "0x9a"]},
    {"Name": "Uarr", "Characters": ["0xe2", "0x86", "0x9f"]},
    {"Name": "Uarrocir", "Characters": ["0xe2", "0xa5", "0x89"]},
    {"Name": "Ubrcy", "Characters": ["0xd0", "0x8e"]},
    {"Name": "Ubreve", "Characters": ["0xc5", "0xac"]},
    {"Name": "Ucirc", "Characters": ["0xc3", "0x9b"]},
    {"Name": "Ucy", "Characters": ["0xd0", "0xa3"]},
    {"Name": "Udblac", "Characters": ["0xc5", "0xb0"]},
    {"Name": "Ufr", "Characters": ["0xf0", "0x9d", "0x94", "0x98"]},
    {"Name": "Ugrave", "Characters": ["0xc3", "0x99"]},
    {"Name": "Umacr", "Characters": ["0xc5", "0xaa"]},
    {"Name": "UnderBar", "Characters": ["0x5f"]},
    {"Name": "UnderBrace", "Characters": ["0xe2", "0x8f", "0x9f"]},
    {"Name": "UnderBracket", "Characters": ["0xe2", "0x8e", "0xb5"]},
    {"Name": "UnderParenthesis", "Characters": ["0xe2", "0x8f", "0x9d"]},
    {"Name": "Union", "Characters": ["0xe2", "0x8b", "0x83"]},
    {"Name": "UnionPlus", "Characters": ["0xe2", "0x8a", "0x8e"]},
    {"Name": "Uogon", "Characters": ["0xc5", "0xb2"]},
    {"Name": "Uopf", "Characters": ["0xf0", "0x9d", "0x95", "0x8c"]},
    {"Name": "UpArrow", "Characters": ["0xe2", "0x86", "0x91"]},
    {"Name": "UpArrowBar", "Characters": ["0xe2", "0xa4", "0x92"]},
    {"Name": "UpArrowDownArrow", "Characters": ["0xe2", "0x87", "0x85"]},
    {"Name": "UpDownArrow", "Characters": ["0xe2", "0x86", "0x95"]},
    {"Name": "UpEquilibrium", "Characters": ["0xe2", "0xa5", "0xae"]},
    {"Name": "UpTee", "Characters": ["0xe2", "0x8a", "0xa5"]},
    {"Name": "UpTeeArrow", "Characters": ["0xe2", "0x86", "0xa5"]},
    {"Name": "Uparrow", "Characters": ["0xe2", "0x87", "0x91"]},
    {"Name": "Updownarrow", "Characters": ["0xe2", "0x87", "0x95"]},
    {"Name": "UpperLeftArrow", "Characters": ["0xe2", "0x86", "0x96"]},
    {"Name": "UpperRightArrow", "Characters": ["0xe2", "0x86", "0x97"]},
    {"Name": "Upsi", "Characters": ["0xcf", "0x92"]},
    {"Name": "Upsilon", "Characters": ["0xce", "0xa5"]},
    {"Name": "Uring", "Characters": ["0xc5", "0xae"]},
    {"Name": "Uscr", "Characters": ["0xf0", "0x9d", "0x92", "0xb0"]},
    {"Name": "Utilde", "Characters": ["0xc5", "0xa8"]},
    {"Name": "Uuml", "Characters": ["0xc3", "0x9c"]},
    {"Name": "VDash", "Characters": ["0xe2", "0x8a", "0xab"]},
    {"Name": "Vbar", "Characters": ["0xe2", "0xab", "0xab"]},
    {"Name": "Vcy", "Characters": ["0xd0", "0x92"]},
    {"Name": "Vdash", "Characters": ["0xe2", "0x8a", "0xa9"]},
    {"Name": "Vdashl", "Characters": ["0xe2", "0xab", "0xa6"]},
    {"Name": "Vee", "Characters": ["0xe2", "0x8b", "0x81"]},
    {"Name": "Verbar", "Characters": ["0xe2", "0x80", "0x96"]},
    {"Name": "Vert", "Characters": ["0xe2", "0x80", "0x96"]},
    {"Name": "VerticalBar", "Characters": ["0xe2", "0x88", "0xa3"]},
    {"Name": "VerticalLine", "Characters": ["0x7c"]},
    {"Name": "VerticalSeparator", "Characters": ["0xe2", "0x9d", "0x98"]},
    {"Name": "VerticalTilde", "Characters": ["0xe2", "0x89", "0x80"]},
    {"Name": "VeryThinSpace", "Characters": ["0xe2", "0x80", "0x8a"]},
    {"Name": "Vfr", "Characters": ["0xf0", "0x9d", "0x94", "0x99"]},
    {"Name": "Vopf", "Characters": ["0xf0", "0x9d", "0x95", "0x8d"]},
    {"Name": "Vscr", "Characters": ["0xf0", "0x9d", "0x92", "0xb1"]},
    {"Name": "Vvdash", "Characters": ["0xe2", "0x8a", "0xaa"]},
    {"Name": "Wcirc", "Characters": ["0xc5", "0xb4"]},
    {"Name": "Wedge", "Characters": ["0xe2", "0x8b", "0x80"]},
    {"Name": "Wfr", "Characters": ["0xf0", "0x9d", "0x94", "0x9a"]},
    {"Name": "Wopf", "Characters": ["0xf0", "0x9d", "0x95", "0x8e"]},
    {"Name": "Wscr", "Characters": ["0xf0", "0x9d", "0x92", "0xb2"]},
    {"Name": "Xfr", "Characters": ["0xf0", "0x9d", "0x94", "0x9b"]},
    {"Name": "Xi", "Characters": ["0xce", "0x9e"]},
    {"Name": "Xopf", "Characters": ["0xf0", "0x9d", "0x95", "0x8f"]},
    {"Name": "Xscr", "Characters": ["0xf0", "0x9d", "0x92", "0xb3"]},
    {"Name": "YAcy", "Characters": ["0xd0", "0xaf"]},
    {"Name": "YIcy", "Characters": ["0xd0", "0x87"]},
    {"Name": "YUcy", "Characters": ["0xd0", "0xae"]},
    {"Name": "Yacute", "Characters": ["0xc3", "0x9d"]},
    {"Name": "Ycirc", "Characters": ["0xc5", "0xb6"]},
    {"Name": "Ycy", "Characters": ["0xd0", "0xab"]},
    {"Name": "Yfr", "Characters": ["0xf0", "0x9d", "0x94", "0x9c"]},
    {"Name": "Yopf", "Characters": ["0xf0", "0x9d", "0x95", "0x90"]},
    {"Name": "Yscr", "Characters": ["0xf0", "0x9d", "0x92", "0xb4"]},
    {"Name": "Yuml", "Characters": ["0xc5", "0xb8"]},
    {"Name": "ZHcy", "Characters": ["0xd0", "0x96"]},
    {"Name": "Zacute", "Characters": ["0xc5", "0xb9"]},
    {"Name": "Zcaron", "Characters": ["0xc5", "0xbd"]},
    {"Name": "Zcy", "Characters": ["0xd0", "0x97"]},
    {"Name": "Zdot", "Characters": ["0xc5", "0xbb"]},
    {"Name": "ZeroWidthSpace", "Characters": ["0xe2", "0x80", "0x8b"]},
    {"Name": "Zeta", "Characters": ["0xce", "0x96"]},
    {"Name": "Zfr", "Characters": ["0xe2", "0x84", "0xa8"]},
    {"Name": "Zopf", "Characters": ["0xe2", "0x84", "0xa4"]},
    {"Name": "Zscr", "Characters": ["0xf0", "0x9d", "0x92", "0xb5"]},
    {"Name": "aacute", "Characters": ["0xc3", "0xa1"]},
    {"Name": "abreve", "Characters": ["0xc4", "0x83"]},
    {"Name": "ac", "Characters": ["0xe2", "0x88", "0xbe"]},
    {"Name": "acE", "Characters": ["0xe2", "0x88", "0xbe", "0xcc", "0xb3"]},
    {"Name": "acd", "Characters": ["0xe2", "0x88", "0xbf"]},
    {"Name": "acirc", "Characters": ["0xc3", "0xa2"]},
    {"Name": "acute", "Characters": ["0xc2", "0xb4"]},
    {"Name": "acy", "Characters": ["0xd0", "0xb0"]},
    {"Name": "aelig", "Characters": ["0xc3", "0xa6"]},
    {"Name": "af", "Characters": ["0xe2", "0x81", "0xa1"]},
    {"Name": "afr", "Characters": ["0xf0", "0x9d", "0x94", "0x9e"]},
    {"Name": "agrave", "Characters": ["0xc3", "0xa0"]},
    {"Name": "alefsym", "Characters": ["0xe2", "0x84", "0xb5"]},
    {"Name": "aleph", "Characters": ["0xe2", "0x84", "0xb5"]},
    {"Name": "alpha", "Characters": ["0xce", "0xb1"]},
    {"Name": "amacr", "Characters": ["0xc4", "0x81"]},
    {"Name": "amalg", "Characters": ["0xe2", "0xa8", "0xbf"]},
    {"Name": "amp", "Characters": ["0x26"]},
    {"Name": "and", "Characters": ["0xe2", "0x88", "0xa7"]},
    {"Name": "andand", "Characters": ["0xe2", "0xa9", "0x95"]},
    {"Name": "andd", "Characters": ["0xe2", "0xa9", "0x9c"]},
    {"Name": "andslope", "Characters": ["0xe2", "0xa9", "0x98"]},
    {"Name": "andv", "Characters": ["0xe2", "0xa9", "0x9a"]},
    {"Name": "ang", "Characters": ["0xe2", "0x88", "0xa0"]},
    {"Name": "ange", "Characters": ["0xe2", "0xa6", "0xa4"]},
    {"Name": "angle", "Characters": ["0xe2", "0x88", "0xa0"]},
    {"Name": "angmsd", "Characters": ["0xe2", "0x88", "0xa1"]},
    {"Name": "angmsdaa", "Characters": ["0xe2", "0xa6", "0xa8"]},
    {"Name": "angmsdab", "Characters": ["0xe2", "0xa6", "0xa9"]},
    {"Name": "angmsdac", "Characters": ["0xe2", "0xa6", "0xaa"]},
    {"Name": "angmsdad", "Characters": ["0xe2", "0xa6", "0xab"]},
    {"Name": "angmsdae", "Characters": ["0xe2", "0xa6", "0xac"]},
    {"Name": "angmsdaf", "Characters": ["0xe2", "0xa6", "0xad"]},
    {"Name": "angmsdag", "Characters": ["0xe2", "0xa6", "0xae"]},
    {"Name": "angmsdah", "Characters": ["0xe2", "0xa6", "0xaf"]},
    {"Name": "angrt", "Characters": ["0xe2", "0x88", "0x9f"]},
    {"Name": "angrtvb", "Characters": ["0xe2", "0x8a", "0xbe"]},
    {"Name": "angrtvbd", "Characters": ["0xe2", "0xa6", "0x9d"]},
    {"Name": "angsph", "Characters": ["0xe2", "0x88", "0xa2"]},
    {"Name": "angst", "Characters": ["0xc3", "0x85"]},
    {"Name": "angzarr", "Characters": ["0xe2", "0x8d", "0xbc"]},
    {"Name": "aogon", "Characters": ["0xc4", "0x85"]},
    {"Name": "aopf", "Characters": ["0xf0", "0x9d", "0x95", "0x92"]},
    {"Name": "ap", "Characters": ["0xe2", "0x89", "0x88"]},
    {"Name": "apE", "Characters": ["0xe2", "0xa9", "0xb0"]},
    {"Name": "apacir", "Characters": ["0xe2", "0xa9", "0xaf"]},
    {"Name": "ape", "Characters": ["0xe2", "0x89", "0x8a"]},
    {"Name": "apid", "Characters": ["0xe2", "0x89", "0x8b"]},
    {"Name": "apos", "Characters": ["0x27"]},
    {"Name": "approx", "Characters": ["0xe2", "0x89", "0x88"]},
    {"Name": "approxeq", "Characters": ["0xe2", "0x89", "0x8a"]},
    {"Name": "aring", "Characters": ["0xc3", "0xa5"]},
    {"Name": "ascr", "Characters": ["0xf0", "0x9d", "0x92", "0xb6"]},
    {"Name": "ast", "Characters": ["0x2a"]},
    {"Name": "asymp", "Characters": ["0xe2", "0x89", "0x88"]},
    {"Name": "asympeq", "Characters": ["0xe2", "0x89", "0x8d"]},
    {"Name": "atilde", "Characters": ["0xc3", "0xa3"]},
    {"Name": "auml", "Characters": ["0xc3", "0xa4"]},
    {"Name": "awconint", "Characters": ["0xe2", "0x88", "0xb3"]},
    {"Name": "awint", "Characters": ["0xe2", "0xa8", "0x91"]},
    {"Name": "bNot", "Characters": ["0xe2", "0xab", "0xad"]},
    {"Name": "backcong", "Characters": ["0xe2", "0x89", "0x8c"]},
    {"Name": "backepsilon", "Characters": ["0xcf", "0xb6"]},
    {"Name": "backprime", "Characters": ["0xe2", "0x80", "0xb5"]},
    {"Name": "backsim", "Characters": ["0xe2", "0x88", "0xbd"]},
    {"Name": "backsimeq", "Characters": ["0xe2", "0x8b", "0x8d"]},
    {"Name": "barvee", "Characters": ["0xe2", "0x8a", "0xbd"]},
    {"Name": "barwed", "Characters": ["0xe2", "0x8c", "0x85"]},
    {"Name": "barwedge", "Characters": ["0xe2", "0x8c", "0x85"]},
    {"Name": "bbrk", "Characters": ["0xe2", "0x8e", "0xb5"]},
    {"Name": "bbrktbrk", "Characters": ["0xe2", "0x8e", "0xb6"]},
    {"Name": "bcong", "Characters": ["0xe2", "0x89", "0x8c"]},
    {"Name": "bcy", "Characters": ["0xd0", "0xb1"]},
    {"Name": "bdquo", "Characters": ["0xe2", "0x80", "0x9e"]},
    {"Name": "becaus", "Characters": ["0xe2", "0x88", "0xb5"]},
    {"Name": "because", "Characters": ["0xe2", "0x88", "0xb5"]},
    {"Name": "bemptyv", "Characters": ["0xe2", "0xa6", "0xb0"]},
    {"Name": "bepsi", "Characters": ["0xcf", "0xb6"]},
    {"Name": "bernou", "Characters": ["0xe2", "0x84", "0xac"]},
    {"Name": "beta", "Characters": ["0xce", "0xb2"]},
    {"Name": "beth", "Characters": ["0xe2", "0x84", "0xb6"]},
    {"Name": "between", "Characters": ["0xe2", "0x89", "0xac"]},
    {"Name": "bfr", "Characters": ["0xf0", "0x9d", "0x94", "0x9f"]},
    {"Name": "bigcap", "Characters": ["0xe2", "0x8b", "0x82"]},
    {"Name": "bigcirc", "Characters": ["0xe2", "0x97", "0xaf"]},
    {"Name": "bigcup", "Characters": ["0xe2", "0x8b", "0x83"]},
    {"Name": "bigodot", "Characters": ["0xe2", "0xa8", "0x80"]},
    {"Name": "bigoplus", "Characters": ["0xe2", "0xa8", "0x81"]},
    {"Name": "bigotimes", "Characters": ["0xe2", "0xa8", "0x82"]},
    {"Name": "bigsqcup", "Characters": ["0xe2", "0xa8", "0x86"]},
    {"Name": "bigstar", "Characters": ["0xe2", "0x98", "0x85"]},
    {"Name": "bigtriangledown", "Characters": ["0xe2", "0x96", "0xbd"]},
    {"Name": "bigtriangleup", "Characters": ["0xe2", "0x96", "0xb3"]},
    {"Name": "biguplus", "Characters": ["0xe2", "0xa8", "0x84"]},
    {"Name": "bigvee", "Characters": ["0xe2", "0x8b", "0x81"]},
    {"Name": "bigwedge", "Characters": ["0xe2", "0x8b", "0x80"]},
    {"Name": "bkarow", "Characters": ["0xe2", "0xa4", "0x8d"]},
    {"Name": "blacklozenge", "Characters": ["0xe2", "0xa7", "0xab"]},
    {"Name": "blacksquare", "Characters": ["0xe2", "0x96", "0xaa"]},
    {"Name": "blacktriangle", "Characters": ["0xe2", "0x96", "0xb4"]},
    {"Name": "blacktriangledown", "Characters": ["0xe2", "0x96", "0xbe"]},
    {"Name": "blacktriangleleft", "Characters": ["0xe2", "0x97", "0x82"]},
    {"Name": "blacktriangleright", "Characters": ["0xe2", "0x96", "0xb8"]},
    {"Name": "blank", "Characters": ["0xe2", "0x90", "0xa3"]},
    {"Name": "blk12", "Characters": ["0xe2", "0x96", "0x92"]},
    {"Name": "blk14", "Characters": ["0xe2", "0x96", "0x91"]},
    {"Name": "blk34", "Characters": ["0xe2", "0x96", "0x93"]},
    {"Name": "block", "Characters": ["0xe2", "0x96", "0x88"]},
    {"Name": "bne", "Characters": ["0x3d", "0xe2", "0x83", "0xa5"]},
    {"Name": "bnequiv", "Characters": ["0xe2", "0x89", "0xa1", "0xe2", "0x83", "0xa5"]},
    {"Name": "bnot", "Characters": ["0xe2", "0x8c", "0x90"]},
    {"Name": "bopf", "Characters": ["0xf0", "0x9d", "0x95", "0x93"]},
    {"Name": "bot", "Characters": ["0xe2", "0x8a", "0xa5"]},
    {"Name": "bottom", "Characters": ["0xe2", "0x8a", "0xa5"]},
    {"Name": "bowtie", "Characters": ["0xe2", "0x8b", "0x88"]},
    {"Name": "boxDL", "Characters": ["0xe2", "0x95", "0x97"]},
    {"Name": "boxDR", "Characters": ["0xe2", "0x95", "0x94"]},
    {"Name": "boxDl", "Characters": ["0xe2", "0x95", "0x96"]},
    {"Name": "boxDr", "Characters": ["0xe2", "0x95", "0x93"]},
    {"Name": "boxH", "Characters": ["0xe2", "0x95", "0x90"]},
    {"Name": "boxHD", "Characters": ["0xe2", "0x95", "0xa6"]},
    {"Name": "boxHU", "Characters": ["0xe2", "0x95", "0xa9"]},
    {"Name": "boxHd", "Characters": ["0xe2", "0x95", "0xa4"]},
    {"Name": "boxHu", "Characters": ["0xe2", "0x95", "0xa7"]},
    {"Name": "boxUL", "Characters": ["0xe2", "0x95", "0x9d"]},
    {"Name": "boxUR", "Characters": ["0xe2", "0x95", "0x9a"]},
    {"Name": "boxUl", "Characters": ["0xe2", "0x95", "0x9c"]},
    {"Name": "boxUr", "Characters": ["0xe2", "0x95", "0x99"]},
    {"Name": "boxV", "Characters": ["0xe2", "0x95", "0x91"]},
    {"Name": "boxVH", "Characters": ["0xe2", "0x95", "0xac"]},
    {"Name": "boxVL", "Characters": ["0xe2", "0x95", "0xa3"]},
    {"Name": "boxVR", "Characters": ["0xe2", "0x95", "0xa0"]},
    {"Name": "boxVh", "Characters": ["0xe2", "0x95", "0xab"]},
    {"Name": "boxVl", "Characters": ["0xe2", "0x95", "0xa2"]},
    {"Name": "boxVr", "Characters": ["0xe2", "0x95", "0x9f"]},
    {"Name": "boxbox", "Characters": ["0xe2", "0xa7", "0x89"]},
    {"Name": "boxdL", "Characters": ["0xe2", "0x95", "0x95"]},
    {"Name": "boxdR", "Characters": ["0xe2", "0x95", "0x92"]},
    {"Name": "boxdl", "Characters": ["0xe2", "0x94", "0x90"]},
    {"Name": "boxdr", "Characters": ["0xe2", "0x94", "0x8c"]},
    {"Name": "boxh", "Characters": ["0xe2", "0x94", "0x80"]},
    {"Name": "boxhD", "Characters": ["0xe2", "0x95", "0xa5"]},
    {"Name": "boxhU", "Characters": ["0xe2", "0x95", "0xa8"]},
    {"Name": "boxhd", "Characters": ["0xe2", "0x94", "0xac"]},
    {"Name": "boxhu", "Characters": ["0xe2", "0x94", "0xb4"]},
    {"Name": "boxminus", "Characters": ["0xe2", "0x8a", "0x9f"]},
    {"Name": "boxplus", "Characters": ["0xe2", "0x8a", "0x9e"]},
    {"Name": "boxtimes", "Characters": ["0xe2", "0x8a", "0xa0"]},
    {"Name": "boxuL", "Characters": ["0xe2", "0x95", "0x9b"]},
    {"Name": "boxuR", "Characters": ["0xe2", "0x95", "0x98"]},
    {"Name": "boxul", "Characters": ["0xe2", "0x94", "0x98"]},
    {"Name": "boxur", "Characters": ["0xe2", "0x94", "0x94"]},
    {"Name": "boxv", "Characters": ["0xe2", "0x94", "0x82"]},
    {"Name": "boxvH", "Characters": ["0xe2", "0x95", "0xaa"]},
    {"Name": "boxvL", "Characters": ["0xe2", "0x95", "0xa1"]},
    {"Name": "boxvR", "Characters": ["0xe2", "0x95", "0x9e"]},
    {"Name": "boxvh", "Characters": ["0xe2", "0x94", "0xbc"]},
    {"Name": "boxvl", "Characters": ["0xe2", "0x94", "0xa4"]},
    {"Name": "boxvr", "Characters": ["0xe2", "0x94", "0x9c"]},
    {"Name": "bprime", "Characters": ["0xe2", "0x80", "0xb5"]},
    {"Name": "breve", "Characters": ["0xcb", "0x98"]},
    {"Name": "brvbar", "Characters": ["0xc2", "0xa6"]},
    {"Name": "bscr", "Characters": ["0xf0", "0x9d", "0x92", "0xb7"]},
    {"Name": "bsemi", "Characters": ["0xe2", "0x81", "0x8f"]},
    {"Name": "bsim", "Characters": ["0xe2", "0x88", "0xbd"]},
    {"Name": "bsime", "Characters": ["0xe2", "0x8b", "0x8d"]},
    {"Name": "bsol", "Characters": ["0x5c"]},
    {"Name": "bsolb", "Characters": ["0xe2", "0xa7", "0x85"]},
    {"Name": "bsolhsub", "Characters": ["0xe2", "0x9f", "0x88"]},
    {"Name": "bull", "Characters": ["0xe2", "0x80", "0xa2"]},
    {"Name": "bullet", "Characters": ["0xe2", "0x80", "0xa2"]},
    {"Name": "bump", "Characters": ["0xe2", "0x89", "0x8e"]},
    {"Name": "bumpE", "Characters": ["0xe2", "0xaa", "0xae"]},
    {"Name": "bumpe", "Characters": ["0xe2", "0x89", "0x8f"]},
    {"Name": "bumpeq", "Characters": ["0xe2", "0x89", "0x8f"]},
    {"Name": "cacute", "Characters": ["0xc4", "0x87"]},
    {"Name": "cap", "Characters": ["0xe2", "0x88", "0xa9"]},
    {"Name": "capand", "Characters": ["0xe2", "0xa9", "0x84"]},
    {"Name": "capbrcup", "Characters": ["0xe2", "0xa9", "0x89"]},
    {"Name": "capcap", "Characters": ["0xe2", "0xa9", "0x8b"]},
    {"Name": "capcup", "Characters": ["0xe2", "0xa9", "0x87"]},
    {"Name": "capdot", "Characters": ["0xe2", "0xa9", "0x80"]},
    {"Name": "caps", "Characters": ["0xe2", "0x88", "0xa9", "0xef", "0xb8", "0x80"]},
    {"Name": "caret", "Characters": ["0xe2", "0x81", "0x81"]},
    {"Name": "caron", "Characters": ["0xcb", "0x87"]},
    {"Name": "ccaps", "Characters": ["0xe2", "0xa9", "0x8d"]},
    {"Name": "ccaron", "Characters": ["0xc4", "0x8d"]},
    {"Name": "ccedil", "Characters": ["0xc3", "0xa7"]},
    {"Name": "ccirc", "Characters": ["0xc4", "0x89"]},
    {"Name": "ccups", "Characters": ["0xe2", "0xa9", "0x8c"]},
    {"Name": "ccupssm", "Characters": ["0xe2", "0xa9", "0x90"]},
    {"Name": "cdot", "Characters": ["0xc4", "0x8b"]},
    {"Name": "cedil", "Characters": ["0xc2", "0xb8"]},
    {"Name": "cemptyv", "Characters": ["0xe2", "0xa6", "0xb2"]},
    {"Name": "cent", "Characters": ["0xc2", "0xa2"]},
    {"Name": "centerdot", "Characters": ["0xc2", "0xb7"]},
    {"Name": "cfr", "Characters": ["0xf0", "0x9d", "0x94", "0xa0"]},
    {"Name": "chcy", "Characters": ["0xd1", "0x87"]},
    {"Name": "check", "Characters": ["0xe2", "0x9c", "0x93"]},
    {"Name": "checkmark", "Characters": ["0xe2", "0x9c", "0x93"]},
    {"Name": "chi", "Characters": ["0xcf", "0x87"]},
    {"Name": "cir", "Characters": ["0xe2", "0x97", "0x8b"]},
    {"Name": "cirE", "Characters": ["0xe2", "0xa7", "0x83"]},
    {"Name": "circ", "Characters": ["0xcb", "0x86"]},
    {"Name": "circeq", "Characters": ["0xe2", "0x89", "0x97"]},
    {"Name": "circlearrowleft", "Characters": ["0xe2", "0x86", "0xba"]},
    {"Name": "circlearrowright", "Characters": ["0xe2", "0x86", "0xbb"]},
    {"Name": "circledR", "Characters": ["0xc2", "0xae"]},
    {"Name": "circledS", "Characters": ["0xe2", "0x93", "0x88"]},
    {"Name": "circledast", "Characters": ["0xe2", "0x8a", "0x9b"]},
    {"Name": "circledcirc", "Characters": ["0xe2", "0x8a", "0x9a"]},
    {"Name": "circleddash", "Characters": ["0xe2", "0x8a", "0x9d"]},
    {"Name": "cire", "Characters": ["0xe2", "0x89", "0x97"]},
    {"Name": "cirfnint", "Characters": ["0xe2", "0xa8", "0x90"]},
    {"Name": "cirmid", "Characters": ["0xe2", "0xab", "0xaf"]},
    {"Name": "cirscir", "Characters": ["0xe2", "0xa7", "0x82"]},
    {"Name": "clubs", "Characters": ["0xe2", "0x99", "0xa3"]},
    {"Name": "clubsuit", "Characters": ["0xe2", "0x99", "0xa3"]},
    {"Name": "colon", "Characters": ["0x3a"]},
    {"Name": "colone", "Characters": ["0xe2", "0x89", "0x94"]},
    {"Name": "coloneq", "Characters": ["0xe2", "0x89", "0x94"]},
    {"Name": "comma", "Characters": ["0x2c"]},
    {"Name": "commat", "Characters": ["0x40"]},
    {"Name": "comp", "Characters": ["0xe2", "0x88", "0x81"]},
    {"Name": "compfn", "Characters": ["0xe2", "0x88", "0x98"]},
    {"Name": "complement", "Characters": ["0xe2", "0x88", "0x81"]},
    {"Name": "complexes", "Characters": ["0xe2", "0x84", "0x82"]},
    {"Name": "cong", "Characters": ["0xe2", "0x89", "0x85"]},
    {"Name": "congdot", "Characters": ["0xe2", "0xa9", "0xad"]},
    {"Name": "conint", "Characters": ["0xe2", "0x88", "0xae"]},
    {"Name": "copf", "Characters": ["0xf0", "0x9d", "0x95", "0x94"]},
    {"Name": "coprod", "Characters": ["0xe2", "0x88", "0x90"]},
    {"Name": "copy", "Characters": ["0xc2", "0xa9"]},
    {"Name": "copysr", "Characters": ["0xe2", "0x84", "0x97"]},
    {"Name": "crarr", "Characters": ["0xe2", "0x86", "0xb5"]},
    {"Name": "cross", "Characters": ["0xe2", "0x9c", "0x97"]},
    {"Name": "cscr", "Characters": ["0xf0", "0x9d", "0x92", "0xb8"]},
    {"Name": "csub", "Characters": ["0xe2", "0xab", "0x8f"]},
    {"Name": "csube", "Characters": ["0xe2", "0xab", "0x91"]},
    {"Name": "csup", "Characters": ["0xe2", "0xab", "0x90"]},
    {"Name": "csupe", "Characters": ["0xe2", "0xab", "0x92"]},
    {"Name": "ctdot", "Characters": ["0xe2", "0x8b", "0xaf"]},
    {"Name": "cudarrl", "Characters": ["0xe2", "0xa4", "0xb8"]},
    {"Name": "cudarrr", "Characters": ["0xe2", "0xa4", "0xb5"]},
    {"Name": "cuepr", "Characters": ["0xe2", "0x8b", "0x9e"]},
    {"Name": "cuesc", "Characters": ["0xe2", "0x8b", "0x9f"]},
    {"Name": "cularr", "Characters": ["0xe2", "0x86", "0xb6"]},
    {"Name": "cularrp", "Characters": ["0xe2", "0xa4", "0xbd"]},
    {"Name": "cup", "Characters": ["0xe2", "0x88", "0xaa"]},
    {"Name": "cupbrcap", "Characters": ["0xe2", "0xa9", "0x88"]},
    {"Name": "cupcap", "Characters": ["0xe2", "0xa9", "0x86"]},
    {"Name": "cupcup", "Characters": ["0xe2", "0xa9", "0x8a"]},
    {"Name": "cupdot", "Characters": ["0xe2", "0x8a", "0x8d"]},
    {"Name": "cupor", "Characters": ["0xe2", "0xa9", "0x85"]},
    {"Name": "cups", "Characters": ["0xe2", "0x88", "0xaa", "0xef", "0xb8", "0x80"]},
    {"Name": "curarr", "Characters": ["0xe2", "0x86", "0xb7"]},
    {"Name": "curarrm", "Characters": ["0xe2", "0xa4", "0xbc"]},
    {"Name": "curlyeqprec", "Characters": ["0xe2", "0x8b", "0x9e"]},
    {"Name": "curlyeqsucc", "Characters": ["0xe2", "0x8b", "0x9f"]},
    {"Name": "curlyvee", "Characters": ["0xe2", "0x8b", "0x8e"]},
    {"Name": "curlywedge", "Characters": ["0xe2", "0x8b", "0x8f"]},
    {"Name": "curren", "Characters": ["0xc2", "0xa4"]},
    {"Name": "curvearrowleft", "Characters": ["0xe2", "0x86", "0xb6"]},
    {"Name": "curvearrowright", "Characters": ["0xe2", "0x86", "0xb7"]},
    {"Name": "cuvee", "Characters": ["0xe2", "0x8b", "0x8e"]},
    {"Name": "cuwed", "Characters": ["0xe2", "0x8b", "0x8f"]},
    {"Name": "cwconint", "Characters": ["0xe2", "0x88", "0xb2"]},
    {"Name": "cwint", "Characters": ["0xe2", "0x88", "0xb1"]},
    {"Name": "cylcty", "Characters": ["0xe2", "0x8c", "0xad"]},
    {"Name": "dArr", "Characters": ["0xe2", "0x87", "0x93"]},
    {"Name": "dHar", "Characters": ["0xe2", "0xa5", "0xa5"]},
    {"Name": "dagger", "Characters": ["0xe2", "0x80", "0xa0"]},
    {"Name": "daleth", "Characters": ["0xe2", "0x84", "0xb8"]},
    {"Name": "darr", "Characters": ["0xe2", "0x86", "0x93"]},
    {"Name": "dash", "Characters": ["0xe2", "0x80", "0x90"]},
    {"Name": "dashv", "Characters": ["0xe2", "0x8a", "0xa3"]},
    {"Name": "dbkarow", "Characters": ["0xe2", "0xa4", "0x8f"]},
    {"Name": "dblac", "Characters": ["0xcb", "0x9d"]},
    {"Name": "dcaron", "Characters": ["0xc4", "0x8f"]},
    {"Name": "dcy", "Characters": ["0xd0", "0xb4"]},
    {"Name": "dd", "Characters": ["0xe2", "0x85", "0x86"]},
    {"Name": "ddagger", "Characters": ["0xe2", "0x80", "0xa1"]},
    {"Name": "ddarr", "Characters": ["0xe2", "0x87", "0x8a"]},
    {"Name": "ddotseq", "Characters": ["0xe2", "0xa9", "0xb7"]},
    {"Name": "deg", "Characters": ["0xc2", "0xb0"]},
    {"Name": "delta", "Characters": ["0xce", "0xb4"]},
    {"Name": "demptyv", "Characters": ["0xe2", "0xa6", "0xb1"]},
    {"Name": "dfisht", "Characters": ["0xe2", "0xa5", "0xbf"]},
    {"Name": "dfr", "Characters": ["0xf0", "0x9d", "0x94", "0xa1"]},
    {"Name": "dharl", "Characters": ["0xe2", "0x87", "0x83"]},
    {"Name": "dharr", "Characters": ["0xe2", "0x87", "0x82"]},
    {"Name": "diam", "Characters": ["0xe2", "0x8b", "0x84"]},
    {"Name": "diamond", "Characters": ["0xe2", "0x8b", "0x84"]},
    {"Name": "diamondsuit", "Characters": ["0xe2", "0x99", "0xa6"]},
    {"Name": "diams", "Characters": ["0xe2", "0x99", "0xa6"]},
    {"Name": "die", "Characters": ["0xc2", "0xa8"]},
    {"Name": "digamma", "Characters": ["0xcf", "0x9d"]},
    {"Name": "disin", "Characters": ["0xe2", "0x8b", "0xb2"]},
    {"Name": "div", "Characters": ["0xc3", "0xb7"]},
    {"Name": "divide", "Characters": ["0xc3", "0xb7"]},
    {"Name": "divideontimes", "Characters": ["0xe2", "0x8b", "0x87"]},
    {"Name": "divonx", "Characters": ["0xe2", "0x8b", "0x87"]},
    {"Name": "djcy", "Characters": ["0xd1", "0x92"]},
    {"Name": "dlcorn", "Characters": ["0xe2", "0x8c", "0x9e"]},
    {"Name": "dlcrop", "Characters": ["0xe2", "0x8c", "0x8d"]},
    {"Name": "dollar", "Characters": ["0x24"]},
    {"Name": "dopf", "Characters": ["0xf0", "0x9d", "0x95", "0x95"]},
    {"Name": "dot", "Characters": ["0xcb", "0x99"]},
    {"Name": "doteq", "Characters": ["0xe2", "0x89", "0x90"]},
    {"Name": "doteqdot", "Characters": ["0xe2", "0x89", "0x91"]},
    {"Name": "dotminus", "Characters": ["0xe2", "0x88", "0xb8"]},
    {"Name": "dotplus", "Characters": ["0xe2", "0x88", "0x94"]},
    {"Name": "dotsquare", "Characters": ["0xe2", "0x8a", "0xa1"]},
    {"Name": "doublebarwedge", "Characters": ["0xe2", "0x8c", "0x86"]},
    {"Name": "downarrow", "Characters": ["0xe2", "0x86", "0x93"]},
    {"Name": "downdownarrows", "Characters": ["0xe2", "0x87", "0x8a"]},
    {"Name": "downharpoonleft", "Characters": ["0xe2", "0x87", "0x83"]},
    {"Name": "downharpoonright", "Characters": ["0xe2", "0x87", "0x82"]},
    {"Name": "drbkarow", "Characters": ["0xe2", "0xa4", "0x90"]},
    {"Name": "drcorn", "Characters": ["0xe2", "0x8c", "0x9f"]},
    {"Name": "drcrop", "Characters": ["0xe2", "0x8c", "0x8c"]},
    {"Name": "dscr", "Characters": ["0xf0", "0x9d", "0x92", "0xb9"]},
    {"Name": "dscy", "Characters": ["0xd1", "0x95"]},
    {"Name": "dsol", "Characters": ["0xe2", "0xa7", "0xb6"]},
    {"Name": "dstrok", "Characters": ["0xc4", "0x91"]},
    {"Name": "dtdot", "Characters": ["0xe2", "0x8b", "0xb1"]},
    {"Name": "dtri", "Characters": ["0xe2", "0x96", "0xbf"]},
    {"Name": "dtrif", "Characters": ["0xe2", "0x96", "0xbe"]},
    {"Name": "duarr", "Characters": ["0xe2", "0x87", "0xb5"]},
    {"Name": "duhar", "Characters": ["0xe2", "0xa5", "0xaf"]},
    {"Name": "dwangle", "Characters": ["0xe2", "0xa6", "0xa6"]},
    {"Name": "dzcy", "Characters": ["0xd1", "0x9f"]},
    {"Name": "dzigrarr", "Characters": ["0xe2", "0x9f", "0xbf"]},
    {"Name": "eDDot", "Characters": ["0xe2", "0xa9", "0xb7"]},
    {"Name": "eDot", "Characters": ["0xe2", "0x89", "0x91"]},
    {"Name": "eacute", "Characters": ["0xc3", "0xa9"]},
    {"Name": "easter", "Characters": ["0xe2", "0xa9", "0xae"]},
    {"Name": "ecaron", "Characters": ["0xc4", "0x9b"]},
    {"Name": "ecir", "Characters": ["0xe2", "0x89", "0x96"]},
    {"Name": "ecirc", "Characters": ["0xc3", "0xaa"]},
    {"Name": "ecolon", "Characters": ["0xe2", "0x89", "0x95"]},
    {"Name": "ecy", "Characters": ["0xd1", "0x8d"]},
    {"Name": "edot", "Characters": ["0xc4", "0x97"]},
    {"Name": "ee", "Characters": ["0xe2", "0x85", "0x87"]},
    {"Name": "efDot", "Characters": ["0xe2", "0x89", "0x92"]},
    {"Name": "efr", "Characters": ["0xf0", "0x9d", "0x94", "0xa2"]},
    {"Name": "eg", "Characters": ["0xe2", "0xaa", "0x9a"]},
    {"Name": "egrave", "Characters": ["0xc3", "0xa8"]},
    {"Name": "egs", "Characters": ["0xe2", "0xaa", "0x96"]},
    {"Name": "egsdot", "Characters": ["0xe2", "0xaa", "0x98"]},
    {"Name": "el", "Characters": ["0xe2", "0xaa", "0x99"]},
    {"Name": "elinters", "Characters": ["0xe2", "0x8f", "0xa7"]},
    {"Name": "ell", "Characters": ["0xe2", "0x84", "0x93"]},
    {"Name": "els", "Characters": ["0xe2", "0xaa", "0x95"]},
    {"Name": "elsdot", "Characters": ["0xe2", "0xaa", "0x97"]},
    {"Name": "emacr", "Characters": ["0xc4", "0x93"]},
    {"Name": "empty", "Characters": ["0xe2", "0x88", "0x85"]},
    {"Name": "emptyset", "Characters": ["0xe2", "0x88", "0x85"]},
    {"Name": "emptyv", "Characters": ["0xe2", "0x88", "0x85"]},
    {"Name": "emsp", "Characters": ["0xe2", "0x80", "0x83"]},
    {"Name": "emsp13", "Characters": ["0xe2", "0x80", "0x84"]},
    {"Name": "emsp14", "Characters": ["0xe2", "0x80", "0x85"]},
    {"Name": "eng", "Characters": ["0xc5", "0x8b"]},
    {"Name": "ensp", "Characters": ["0xe2", "0x80", "0x82"]},
    {"Name": "eogon", "Characters": ["0xc4", "0x99"]},
    {"Name": "eopf", "Characters": ["0xf0", "0x9d", "0x95", "0x96"]},
    {"Name": "epar", "Characters": ["0xe2", "0x8b", "0x95"]},
    {"Name": "eparsl", "Characters": ["0xe2", "0xa7", "0xa3"]},
    {"Name": "eplus", "Characters": ["0xe2", "0xa9", "0xb1"]},
    {"Name": "epsi", "Characters": ["0xce", "0xb5"]},
    {"Name": "epsilon", "Characters": ["0xce", "0xb5"]},
    {"Name": "epsiv", "Characters": ["0xcf", "0xb5"]},
    {"Name": "eqcirc", "Characters": ["0xe2", "0x89", "0x96"]},
    {"Name": "eqcolon", "Characters": ["0xe2", "0x89", "0x95"]},
    {"Name": "eqsim", "Characters": ["0xe2", "0x89", "0x82"]},
    {"Name": "eqslantgtr", "Characters": ["0xe2", "0xaa", "0x96"]},
    {"Name": "eqslantless", "Characters": ["0xe2", "0xaa", "0x95"]},
    {"Name": "equals", "Characters": ["0x3d"]},
    {"Name": "equest", "Characters": ["0xe2", "0x89", "0x9f"]},
    {"Name": "equiv", "Characters": ["0xe2", "0x89", "0xa1"]},
    {"Name": "equivDD", "Characters": ["0xe2", "0xa9", "0xb8"]},
    {"Name": "eqvparsl", "Characters": ["0xe2", "0xa7", "0xa5"]},
    {"Name": "erDot", "Characters": ["0xe2", "0x89", "0x93"]},
    {"Name": "erarr", "Characters": ["0xe2", "0xa5", "0xb1"]},
    {"Name": "escr", "Characters": ["0xe2", "0x84", "0xaf"]},
    {"Name": "esdot", "Characters": ["0xe2", "0x89", "0x90"]},
    {"Name": "esim", "Characters": ["0xe2", "0x89", "0x82"]},
    {"Name": "eta", "Characters": ["0xce", "0xb7"]},
    {"Name": "eth", "Characters": ["0xc3", "0xb0"]},
    {"Name": "euml", "Characters": ["0xc3", "0xab"]},
    {"Name": "euro", "Characters": ["0xe2", "0x82", "0xac"]},
    {"Name": "excl", "Characters": ["0x21"]},
    {"Name": "exist", "Characters": ["0xe2", "0x88", "0x83"]},
    {"Name": "expectation", "Characters": ["0xe2", "0x84", "0xb0"]},
    {"Name": "exponentiale", "Characters": ["0xe2", "0x85", "0x87"]},
    {"Name": "fallingdotseq", "Characters": ["0xe2", "0x89", "0x92"]},
    {"Name": "fcy", "Characters": ["0xd1", "0x84"]},
    {"Name": "female", "Characters": ["0xe2", "0x99", "0x80"]},
    {"Name": "ffilig", "Characters": ["0xef", "0xac", "0x83"]},
    {"Name": "fflig", "Characters": ["0xef", "0xac", "0x80"]},
    {"Name": "ffllig", "Characters": ["0xef", "0xac", "0x84"]},
    {"Name": "ffr", "Characters": ["0xf0", "0x9d", "0x94", "0xa3"]},
    {"Name": "filig", "Characters": ["0xef", "0xac", "0x81"]},
    {"Name": "fjlig", "Characters": ["0x66", "0x6a"]},
    {"Name": "flat", "Characters": ["0xe2", "0x99", "0xad"]},
    {"Name": "fllig", "Characters": ["0xef", "0xac", "0x82"]},
    {"Name": "fltns", "Characters": ["0xe2", "0x96", "0xb1"]},
    {"Name": "fnof", "Characters": ["0xc6", "0x92"]},
    {"Name": "fopf", "Characters": ["0xf0", "0x9d", "0x95", "0x97"]},
    {"Name": "forall", "Characters": ["0xe2", "0x88", "0x80"]},
    {"Name": "fork", "Characters": ["0xe2", "0x8b", "0x94"]},
    {"Name": "forkv", "Characters": ["0xe2", "0xab", "0x99"]},
    {"Name": "fpartint", "Characters": ["0xe2", "0xa8", "0x8d"]},
    {"Name": "frac12", "Characters": ["0xc2", "0xbd"]},
    {"Name": "frac13", "Characters": ["0xe2", "0x85", "0x93"]},
    {"Name": "frac14", "Characters": ["0xc2", "0xbc"]},
    {"Name": "frac15", "Characters": ["0xe2", "0x85", "0x95"]},
    {"Name": "frac16", "Characters": ["0xe2", "0x85", "0x99"]},
    {"Name": "frac18", "Characters": ["0xe2", "0x85", "0x9b"]},
    {"Name": "frac23", "Characters": ["0xe2", "0x85", "0x94"]},
    {"Name": "frac25", "Characters": ["0xe2", "0x85", "0x96"]},
    {"Name": "frac34", "Characters": ["0xc2", "0xbe"]},
    {"Name": "frac35", "Characters": ["0xe2", "0x85", "0x97"]},
    {"Name": "frac38", "Characters": ["0xe2", "0x85", "0x9c"]},
    {"Name": "frac45", "Characters": ["0xe2", "0x85", "0x98"]},
    {"Name": "frac56", "Characters": ["0xe2", "0x85", "0x9a"]},
    {"Name": "frac58", "Characters": ["0xe2", "0x85", "0x9d"]},
    {"Name": "frac78", "Characters": ["0xe2", "0x85", "0x9e"]},
    {"Name": "frasl", "Characters": ["0xe2", "0x81", "0x84"]},
    {"Name": "frown", "Characters": ["0xe2", "0x8c", "0xa2"]},
    {"Name": "fscr", "Characters": ["0xf0", "0x9d", "0x92", "0xbb"]},
    {"Name": "gE", "Characters": ["0xe2", "0x89", "0xa7"]},
    {"Name": "gEl", "Characters": ["0xe2", "0xaa", "0x8c"]},
    {"Name": "gacute", "Characters": ["0xc7", "0xb5"]},
    {"Name": "gamma", "Characters": ["0xce", "0xb3"]},
    {"Name": "gammad", "Characters": ["0xcf", "0x9d"]},
    {"Name": "gap", "Characters": ["0xe2", "0xaa", "0x86"]},
    {"Name": "gbreve", "Characters": ["0xc4", "0x9f"]},
    {"Name": "gcirc", "Characters": ["0xc4", "0x9d"]},
    {"Name": "gcy", "Characters": ["0xd0", "0xb3"]},
    {"Name": "gdot", "Characters": ["0xc4", "0xa1"]},
    {"Name": "ge", "Characters": ["0xe2", "0x89", "0xa5"]},
    {"Name": "gel", "Characters": ["0xe2", "0x8b", "0x9b"]},
    {"Name": "geq", "Characters": ["0xe2", "0x89", "0xa5"]},
    {"Name": "geqq", "Characters": ["0xe2", "0x89", "0xa7"]},
    {"Name": "geqslant", "Characters": ["0xe2", "0xa9", "0xbe"]},
    {"Name": "ges", "Characters": ["0xe2", "0xa9", "0xbe"]},
    {"Name": "gescc", "Characters": ["0xe2", "0xaa", "0xa9"]},
    {"Name": "gesdot", "Characters": ["0xe2", "0xaa", "0x80"]},
    {"Name": "gesdoto", "Characters": ["0xe2", "0xaa", "0x82"]},
    {"Name": "gesdotol", "Characters": ["0xe2", "0xaa", "0x84"]},
    {"Name": "gesl", "Characters": ["0xe2", "0x8b", "0x9b", "0xef", "0xb8", "0x80"]},
    {"Name": "gesles", "Characters": ["0xe2", "0xaa", "0x94"]},
    {"Name": "gfr", "Characters": ["0xf0", "0x9d", "0x94", "0xa4"]},
    {"Name": "gg", "Characters": ["0xe2", "0x89", "0xab"]},
    {"Name": "ggg", "Characters": ["0xe2", "0x8b", "0x99"]},
    {"Name": "gimel", "Characters": ["0xe2", "0x84", "0xb7"]},
    {"Name": "gjcy", "Characters": ["0xd1", "0x93"]},
    {"Name": "gl", "Characters": ["0xe2", "0x89", "0xb7"]},
    {"Name": "glE", "Characters": ["0xe2", "0xaa", "0x92"]},
    {"Name": "gla", "Characters": ["0xe2", "0xaa", "0xa5"]},
    {"Name": "glj", "Characters": ["0xe2", "0xaa", "0xa4"]},
    {"Name": "gnE", "Characters": ["0xe2", "0x89", "0xa9"]},
    {"Name": "gnap", "Characters": ["0xe2", "0xaa", "0x8a"]},
    {"Name": "gnapprox", "Characters": ["0xe2", "0xaa", "0x8a"]},
    {"Name": "gne", "Characters": ["0xe2", "0xaa", "0x88"]},
    {"Name": "gneq", "Characters": ["0xe2", "0xaa", "0x88"]},
    {"Name": "gneqq", "Characters": ["0xe2", "0x89", "0xa9"]},
    {"Name": "gnsim", "Characters": ["0xe2", "0x8b", "0xa7"]},
    {"Name": "gopf", "Characters": ["0xf0", "0x9d", "0x95", "0x98"]},
    {"Name": "grave", "Characters": ["0x60"]},
    {"Name": "gscr", "Characters": ["0xe2", "0x84", "0x8a"]},
    {"Name": "gsim", "Characters": ["0xe2", "0x89", "0xb3"]},
    {"Name": "gsime", "Characters": ["0xe2", "0xaa", "0x8e"]},
    {"Name": "gsiml", "Characters": ["0xe2", "0xaa", "0x90"]},
    {"Name": "gt", "Characters": ["0x3e"]},
    {"Name": "gtcc", "Characters": ["0xe2", "0xaa", "0xa7"]},
    {"Name": "gtcir", "Characters": ["0xe2", "0xa9", "0xba"]},
    {"Name": "gtdot", "Characters": ["0xe2", "0x8b", "0x97"]},
    {"Name": "gtlPar", "Characters": ["0xe2", "0xa6", "0x95"]},
    {"Name": "gtquest", "Characters": ["0xe2", "0xa9", "0xbc"]},
    {"Name": "gtrapprox", "Characters": ["0xe2", "0xaa", "0x86"]},
    {"Name": "gtrarr", "Characters": ["0xe2", "0xa5", "0xb8"]},
    {"Name": "gtrdot", "Characters": ["0xe2", "0x8b", "0x97"]},
    {"Name": "gtreqless", "Characters": ["0xe2", "0x8b", "0x9b"]},
    {"Name": "gtreqqless", "Characters": ["0xe2", "0xaa", "0x8c"]},
    {"Name": "gtrless", "Characters": ["0xe2", "0x89", "0xb7"]},
    {"Name": "gtrsim", "Characters": ["0xe2", "0x89", "0xb3"]},
    {"Name": "gvertneqq", "Characters": ["0xe2", "0x89", "0xa9", "0xef", "0xb8", "0x80"]},
    {"Name": "gvnE", "Characters": ["0xe2", "0x89", "0xa9", "0xef", "0xb8", "0x80"]},
    {"Name": "hArr", "Characters": ["0xe2", "0x87", "0x94"]},
    {"Name": "hairsp", "Characters": ["0xe2", "0x80", "0x8a"]},
    {"Name": "half", "Characters": ["0xc2", "0xbd"]},
    {"Name": "hamilt", "Characters": ["0xe2", "0x84", "0x8b"]},
    {"Name": "hardcy", "Characters": ["0xd1", "0x8a"]},
    {"Name": "harr", "Characters": ["0xe2", "0x86", "0x94"]},
    {"Name": "harrcir", "Characters": ["0xe2", "0xa5", "0x88"]},
    {"Name": "harrw", "Characters": ["0xe2", "0x86", "0xad"]},
    {"Name": "hbar", "Characters": ["0xe2", "0x84", "0x8f"]},
    {"Name": "hcirc", "Characters": ["0xc4", "0xa5"]},
    {"Name": "hearts", "Characters": ["0xe2", "0x99", "0xa5"]},
    {"Name": "heartsuit", "Characters": ["0xe2", "0x99", "0xa5"]},
    {"Name": "hellip", "Characters": ["0xe2", "0x80", "0xa6"]},
    {"Name": "hercon", "Characters": ["0xe2", "0x8a", "0xb9"]},
    {"Name": "hfr", "Characters": ["0xf0", "0x9d", "0x94", "0xa5"]},
    {"Name": "hksearow", "Characters": ["0xe2", "0xa4", "0xa5"]},
    {"Name": "hkswarow", "Characters": ["0xe2", "0xa4", "0xa6"]},
    {"Name": "hoarr", "Characters": ["0xe2", "0x87", "0xbf"]},
    {"Name": "homtht", "Characters": ["0xe2", "0x88", "0xbb"]},
    {"Name": "hookleftarrow", "Characters": ["0xe2", "0x86", "0xa9"]},
    {"Name": "hookrightarrow", "Characters": ["0xe2", "0x86", "0xaa"]},
    {"Name": "hopf", "Characters": ["0xf0", "0x9d", "0x95", "0x99"]},
    {"Name": "horbar", "Characters": ["0xe2", "0x80", "0x95"]},
    {"Name": "hscr", "Characters": ["0xf0", "0x9d", "0x92", "0xbd"]},
    {"Name": "hslash", "Characters": ["0xe2", "0x84", "0x8f"]},
    {"Name": "hstrok", "Characters": ["0xc4", "0xa7"]},
    {"Name": "hybull", "Characters": ["0xe2", "0x81", "0x83"]},
    {"Name": "hyphen", "Characters": ["0xe2", "0x80", "0x90"]},
    {"Name": "iacute", "Characters": ["0xc3", "0xad"]},
    {"Name": "ic", "Characters": ["0xe2", "0x81", "0xa3"]},
    {"Name": "icirc", "Characters": ["0xc3", "0xae"]},
    {"Name": "icy", "Characters": ["0xd0", "0xb8"]},
    {"Name": "iecy", "Characters": ["0xd0", "0xb5"]},
    {"Name": "iexcl", "Characters": ["0xc2", "0xa1"]},
    {"Name": "iff", "Characters": ["0xe2", "0x87", "0x94"]},
    {"Name": "ifr", "Characters": ["0xf0", "0x9d", "0x94", "0xa6"]},
    {"Name": "igrave", "Characters": ["0xc3", "0xac"]},
    {"Name": "ii", "Characters": ["0xe2", "0x85", "0x88"]},
    {"Name": "iiiint", "Characters": ["0xe2", "0xa8", "0x8c"]},
    {"Name": "iiint", "Characters": ["0xe2", "0x88", "0xad"]},
    {"Name": "iinfin", "Characters": ["0xe2", "0xa7", "0x9c"]},
    {"Name": "iiota", "Characters": ["0xe2", "0x84", "0xa9"]},
    {"Name": "ijlig", "Characters": ["0xc4", "0xb3"]},
    {"Name": "imacr", "Characters": ["0xc4", "0xab"]},
    {"Name": "image", "Characters": ["0xe2", "0x84", "0x91"]},
    {"Name": "imagline", "Characters": ["0xe2", "0x84", "0x90"]},
    {"Name": "imagpart", "Characters": ["0xe2", "0x84", "0x91"]},
    {"Name": "imath", "Characters": ["0xc4", "0xb1"]},
    {"Name": "imof", "Characters": ["0xe2", "0x8a", "0xb7"]},
    {"Name": "imped", "Characters": ["0xc6", "0xb5"]},
    {"Name": "in", "Characters": ["0xe2", "0x88", "0x88"]},
    {"Name": "incare", "Characters": ["0xe2", "0x84", "0x85"]},
    {"Name": "infin", "Characters": ["0xe2", "0x88", "0x9e"]},
    {"Name": "infintie", "Characters": ["0xe2", "0xa7", "0x9d"]},
    {"Name": "inodot", "Characters": ["0xc4", "0xb1"]},
    {"Name": "int", "Characters": ["0xe2", "0x88", "0xab"]},
    {"Name": "intcal", "Characters": ["0xe2", "0x8a", "0xba"]},
    {"Name": "integers", "Characters": ["0xe2", "0x84", "0xa4"]},
    {"Name": "intercal", "Characters": ["0xe2", "0x8a", "0xba"]},
    {"Name": "intlarhk", "Characters": ["0xe2", "0xa8", "0x97"]},
    {"Name": "intprod", "Characters": ["0xe2", "0xa8", "0xbc"]},
    {"Name": "iocy", "Characters": ["0xd1", "0x91"]},
    {"Name": "iogon", "Characters": ["0xc4", "0xaf"]},
    {"Name": "iopf", "Characters": ["0xf0", "0x9d", "0x95", "0x9a"]},
    {"Name": "iota", "Characters": ["0xce", "0xb9"]},
    {"Name": "iprod", "Characters": ["0xe2", "0xa8", "0xbc"]},
    {"Name": "iquest", "Characters": ["0xc2", "0xbf"]},
    {"Name": "iscr", "Characters": ["0xf0", "0x9d", "0x92", "0xbe"]},
    {"Name": "isin", "Characters": ["0xe2", "0x88", "0x88"]},
    {"Name": "isinE", "Characters": ["0xe2", "0x8b", "0xb9"]},
    {"Name": "isindot", "Characters": ["0xe2", "0x8b", "0xb5"]},
    {"Name": "isins", "Characters": ["0xe2", "0x8b", "0xb4"]},
    {"Name": "isinsv", "Characters": ["0xe2", "0x8b", "0xb3"]},
    {"Name": "isinv", "Characters": ["0xe2", "0x88", "0x88"]},
    {"Name": "it", "Characters": ["0xe2", "0x81", "0xa2"]},
    {"Name": "itilde", "Characters": ["0xc4", "0xa9"]},
    {"Name": "iukcy", "Characters": ["0xd1", "0x96"]},
    {"Name": "iuml", "Characters": ["0xc3", "0xaf"]},
    {"Name": "jcirc", "Characters": ["0xc4", "0xb5"]},
    {"Name": "jcy", "Characters": ["0xd0", "0xb9"]},
    {"Name": "jfr", "Characters": ["0xf0", "0x9d", "0x94", "0xa7"]},
    {"Name": "jmath", "Characters": ["0xc8", "0xb7"]},
    {"Name": "jopf", "Characters": ["0xf0", "0x9d", "0x95", "0x9b"]},
    {"Name": "jscr", "Characters": ["0xf0", "0x9d", "0x92", "0xbf"]},
    {"Name": "jsercy", "Characters": ["0xd1", "0x98"]},
    {"Name": "jukcy", "Characters": ["0xd1", "0x94"]},
    {"Name": "kappa", "Characters": ["0xce", "0xba"]},
    {"Name": "kappav", "Characters": ["0xcf", "0xb0"]},
    {"Name": "kcedil", "Characters": ["0xc4", "0xb7"]},
    {"Name": "kcy", "Characters": ["0xd0", "0xba"]},
    {"Name": "kfr", "Characters": ["0xf0", "0x9d", "0x94", "0xa8"]},
    {"Name": "kgreen", "Characters": ["0xc4", "0xb8"]},
    {"Name": "khcy", "Characters": ["0xd1", "0x85"]},
    {"Name": "kjcy", "Characters": ["0xd1", "0x9c"]},
    {"Name": "kopf", "Characters": ["0xf0", "0x9d", "0x95", "0x9c"]},
    {"Name": "kscr", "Characters": ["0xf0", "0x9d", "0x93", "0x80"]},
    {"Name": "lAarr", "Characters": ["0xe2", "0x87", "0x9a"]},
    {"Name": "lArr", "Characters": ["0xe2", "0x87", "0x90"]},
    {"Name": "lAtail", "Characters": ["0xe2", "0xa4", "0x9b"]},
    {"Name": "lBarr", "Characters": ["0xe2", "0xa4", "0x8e"]},
    {"Name": "lE", "Characters": ["0xe2", "0x89", "0xa6"]},
    {"Name": "lEg", "Characters": ["0xe2", "0xaa", "0x8b"]},
    {"Name": "lHar", "Characters": ["0xe2", "0xa5", "0xa2"]},
    {"Name": "lacute", "Characters": ["0xc4", "0xba"]},
    {"Name": "laemptyv", "Characters": ["0xe2", "0xa6", "0xb4"]},
    {"Name": "lagran", "Characters": ["0xe2", "0x84", "0x92"]},
    {"Name": "lambda", "Characters": ["0xce", "0xbb"]},
    {"Name": "lang", "Characters": ["0xe2", "0x9f", "0xa8"]},
    {"Name": "langd", "Characters": ["0xe2", "0xa6", "0x91"]},
    {"Name": "langle", "Characters": ["0xe2", "0x9f", "0xa8"]},
    {"Name": "lap", "Characters": ["0xe2", "0xaa", "0x85"]},
    {"Name": "laquo", "Characters": ["0xc2", "0xab"]},
    {"Name": "larr", "Characters": ["0xe2", "0x86", "0x90"]},
    {"Name": "larrb", "Characters": ["0xe2", "0x87", "0xa4"]},
    {"Name": "larrbfs", "Characters": ["0xe2", "0xa4", "0x9f"]},
    {"Name": "larrfs", "Characters": ["0xe2", "0xa4", "0x9d"]},
    {"Name": "larrhk", "Characters": ["0xe2", "0x86", "0xa9"]},
    {"Name": "larrlp", "Characters": ["0xe2", "0x86", "0xab"]},
    {"Name": "larrpl", "Characters": ["0xe2", "0xa4", "0xb9"]},
    {"Name": "larrsim", "Characters": ["0xe2", "0xa5", "0xb3"]},
    {"Name": "larrtl", "Characters": ["0xe2", "0x86", "0xa2"]},
    {"Name": "lat", "Characters": ["0xe2", "0xaa", "0xab"]},
    {"Name": "latail", "Characters": ["0xe2", "0xa4", "0x99"]},
    {"Name": "late", "Characters": ["0xe2", "0xaa", "0xad"]},
    {"Name": "lates", "Characters": ["0xe2", "0xaa", "0xad", "0xef", "0xb8", "0x80"]},
    {"Name": "lbarr", "Characters": ["0xe2", "0xa4", "0x8c"]},
    {"Name": "lbbrk", "Characters": ["0xe2", "0x9d", "0xb2"]},
    {"Name": "lbrace", "Characters": ["0x7b"]},
    {"Name": "lbrack", "Characters": ["0x5b"]},
    {"Name": "lbrke", "Characters": ["0xe2", "0xa6", "0x8b"]},
    {"Name": "lbrksld", "Characters": ["0xe2", "0xa6", "0x8f"]},
    {"Name": "lbrkslu", "Characters": ["0xe2", "0xa6", "0x8d"]},
    {"Name": "lcaron", "Characters": ["0xc4", "0xbe"]},
    {"Name": "lcedil", "Characters": ["0xc4", "0xbc"]},
    {"Name": "lceil", "Characters": ["0xe2", "0x8c", "0x88"]},
    {"Name": "lcub", "Characters": ["0x7b"]},
    {"Name": "lcy", "Characters": ["0xd0", "0xbb"]},
    {"Name": "ldca", "Characters": ["0xe2", "0xa4", "0xb6"]},
    {"Name": "ldquo", "Characters": ["0xe2", "0x80", "0x9c"]},
    {"Name": "ldquor", "Characters": ["0xe2", "0x80", "0x9e"]},
    {"Name": "ldrdhar", "Characters": ["0xe2", "0xa5", "0xa7"]},
    {"Name": "ldrushar", "Characters": ["0xe2", "0xa5", "0x8b"]},
    {"Name": "ldsh", "Characters": ["0xe2", "0x86", "0xb2"]},
    {"Name": "le", "Characters": ["0xe2", "0x89", "0xa4"]},
    {"Name": "leftarrow", "Characters": ["0xe2", "0x86", "0x90"]},
    {"Name": "leftarrowtail", "Characters": ["0xe2", "0x86", "0xa2"]},
    {"Name": "leftharpoondown", "Characters": ["0xe2", "0x86", "0xbd"]},
    {"Name": "leftharpoonup", "Characters": ["0xe2", "0x86", "0xbc"]},
    {"Name": "leftleftarrows", "Characters": ["0xe2", "0x87", "0x87"]},
    {"Name": "leftrightarrow", "Characters": ["0xe2", "0x86", "0x94"]},
    {"Name": "leftrightarrows", "Characters": ["0xe2", "0x87", "0x86"]},
    {"Name": "leftrightharpoons", "Characters": ["0xe2", "0x87", "0x8b"]},
    {"Name": "leftrightsquigarrow", "Characters": ["0xe2", "0x86", "0xad"]},
    {"Name": "leftthreetimes", "Characters": ["0xe2", "0x8b", "0x8b"]},
    {"Name": "leg", "Characters": ["0xe2", "0x8b", "0x9a"]},
    {"Name": "leq", "Characters": ["0xe2", "0x89", "0xa4"]},
    {"Name": "leqq", "Characters": ["0xe2", "0x89", "0xa6"]},
    {"Name": "leqslant", "Characters": ["0xe2", "0xa9", "0xbd"]},
    {"Name": "les", "Characters": ["0xe2", "0xa9", "0xbd"]},
    {"Name": "lescc", "Characters": ["0xe2", "0xaa", "0xa8"]},
    {"Name": "lesdot", "Characters": ["0xe2", "0xa9", "0xbf"]},
    {"Name": "lesdoto", "Characters": ["0xe2", "0xaa", "0x81"]},
    {"Name": "lesdotor", "Characters": ["0xe2", "0xaa", "0x83"]},
    {"Name": "lesg", "Characters": ["0xe2", "0x8b", "0x9a", "0xef", "0xb8", "0x80"]},
    {"Name": "lesges", "Characters": ["0xe2", "0xaa", "0x93"]},
    {"Name": "lessapprox", "Characters": ["0xe2", "0xaa", "0x85"]},
    {"Name": "lessdot", "Characters": ["0xe2", "0x8b", "0x96"]},
    {"Name": "lesseqgtr", "Characters": ["0xe2", "0x8b", "0x9a"]},
    {"Name": "lesseqqgtr", "Characters": ["0xe2", "0xaa", "0x8b"]},
    {"Name": "lessgtr", "Characters": ["0xe2", "0x89", "0xb6"]},
    {"Name": "lesssim", "Characters": ["0xe2", "0x89", "0xb2"]},
    {"Name": "lfisht", "Characters": ["0xe2", "0xa5", "0xbc"]},
    {"Name": "lfloor", "Characters": ["0xe2", "0x8c", "0x8a"]},
    {"Name": "lfr", "Characters": ["0xf0", "0x9d", "0x94", "0xa9"]},
    {"Name": "lg", "Characters": ["0xe2", "0x89", "0xb6"]},
    {"Name": "lgE", "Characters": ["0xe2", "0xaa", "0x91"]},
    {"Name": "lhard", "Characters": ["0xe2", "0x86", "0xbd"]},
    {"Name": "lharu", "Characters": ["0xe2", "0x86", "0xbc"]},
    {"Name": "lharul", "Characters": ["0xe2", "0xa5", "0xaa"]},
    {"Name": "lhblk", "Characters": ["0xe2", "0x96", "0x84"]},
    {"Name": "ljcy", "Characters": ["0xd1", "0x99"]},
    {"Name": "ll", "Characters": ["0xe2", "0x89", "0xaa"]},
    {"Name": "llarr", "Characters": ["0xe2", "0x87", "0x87"]},
    {"Name": "llcorner", "Characters": ["0xe2", "0x8c", "0x9e"]},
    {"Name": "llhard", "Characters": ["0xe2", "0xa5", "0xab"]},
    {"Name": "lltri", "Characters": ["0xe2", "0x97", "0xba"]},
    {"Name": "lmidot", "Characters": ["0xc5", "0x80"]},
    {"Name": "lmoust", "Characters": ["0xe2", "0x8e", "0xb0"]},
    {"Name": "lmoustache", "Characters": ["0xe2", "0x8e", "0xb0"]},
    {"Name": "lnE", "Characters": ["0xe2", "0x89", "0xa8"]},
    {"Name": "lnap", "Characters": ["0xe2", "0xaa", "0x89"]},
    {"Name": "lnapprox", "Characters": ["0xe2", "0xaa", "0x89"]},
    {"Name": "lne", "Characters": ["0xe2", "0xaa", "0x87"]},
    {"Name": "lneq", "Characters": ["0xe2", "0xaa", "0x87"]},
    {"Name": "lneqq", "Characters": ["0xe2", "0x89", "0xa8"]},
    {"Name": "lnsim", "Characters": ["0xe2", "0x8b", "0xa6"]},
    {"Name": "loang", "Characters": ["0xe2", "0x9f", "0xac"]},
    {"Name": "loarr", "Characters": ["0xe2", "0x87", "0xbd"]},
    {"Name": "lobrk", "Characters": ["0xe2", "0x9f", "0xa6"]},
    {"Name": "longleftarrow", "Characters": ["0xe2", "0x9f", "0xb5"]},
    {"Name": "longleftrightarrow", "Characters": ["0xe2", "0x9f", "0xb7"]},
    {"Name": "longmapsto", "Characters": ["0xe2", "0x9f", "0xbc"]},
    {"Name": "longrightarrow", "Characters": ["0xe2", "0x9f", "0xb6"]},
    {"Name": "looparrowleft", "Characters": ["0xe2", "0x86", "0xab"]},
    {"Name": "looparrowright", "Characters": ["0xe2", "0x86", "0xac"]},
    {"Name": "lopar", "Characters": ["0xe2", "0xa6", "0x85"]},
    {"Name": "lopf", "Characters": ["0xf0", "0x9d", "0x95", "0x9d"]},
    {"Name": "loplus", "Characters": ["0xe2", "0xa8", "0xad"]},
    {"Name": "lotimes", "Characters": ["0xe2", "0xa8", "0xb4"]},
    {"Name": "lowast", "Characters": ["0xe2", "0x88", "0x97"]},
    {"Name": "lowbar", "Characters": ["0x5f"]},
    {"Name": "loz", "Characters": ["0xe2", "0x97", "0x8a"]},
    {"Name": "lozenge", "Characters": ["0xe2", "0x97", "0x8a"]},
    {"Name": "lozf", "Characters": ["0xe2", "0xa7", "0xab"]},
    {"Name": "lpar", "Characters": ["0x28"]},
    {"Name": "lparlt", "Characters": ["0xe2", "0xa6", "0x93"]},
    {"Name": "lrarr", "Characters": ["0xe2", "0x87", "0x86"]},
    {"Name": "lrcorner", "Characters": ["0xe2", "0x8c", "0x9f"]},
    {"Name": "lrhar", "Characters": ["0xe2", "0x87", "0x8b"]},
    {"Name": "lrhard", "Characters": ["0xe2", "0xa5", "0xad"]},
    {"Name": "lrm", "Characters": ["0xe2", "0x80", "0x8e"]},
    {"Name": "lrtri", "Characters": ["0xe2", "0x8a", "0xbf"]},
    {"Name": "lsaquo", "Characters": ["0xe2", "0x80", "0xb9"]},
    {"Name": "lscr", "Characters": ["0xf0", "0x9d", "0x93", "0x81"]},
    {"Name": "lsh", "Characters": ["0xe2", "0x86", "0xb0"]},
    {"Name": "lsim", "Characters": ["0xe2", "0x89", "0xb2"]},
    {"Name": "lsime", "Characters": ["0xe2", "0xaa", "0x8d"]},
    {"Name": "lsimg", "Characters": ["0xe2", "0xaa", "0x8f"]},
    {"Name": "lsqb", "Characters": ["0x5b"]},
    {"Name": "lsquo", "Characters": ["0xe2", "0x80", "0x98"]},
    {"Name": "lsquor", "Characters": ["0xe2", "0x80", "0x9a"]},
    {"Name": "lstrok", "Characters": ["0xc5", "0x82"]},
    {"Name": "lt", "Characters": ["0x3c"]},
    {"Name": "ltcc", "Characters": ["0xe2", "0xaa", "0xa6"]},
    {"Name": "ltcir", "Characters": ["0xe2", "0xa9", "0xb9"]},
    {"Name": "ltdot", "Characters": ["0xe2", "0x8b", "0x96"]},
    {"Name": "lthree", "Characters": ["0xe2", "0x8b", "0x8b"]},
    {"Name": "ltimes", "Characters": ["0xe2", "0x8b", "0x89"]},
    {"Name": "ltlarr", "Characters": ["0xe2", "0xa5", "0xb6"]},
    {"Name": "ltquest", "Characters": ["0xe2", "0xa9", "0xbb"]},
    {"Name": "ltrPar", "Characters": ["0xe2", "0xa6", "0x96"]},
    {"Name": "ltri", "Characters": ["0xe2", "0x97", "0x83"]},
    {"Name": "ltrie", "Characters": ["0xe2", "0x8a", "0xb4"]},
    {"Name": "ltrif", "Characters": ["0xe2", "0x97", "0x82"]},
    {"Name": "lurdshar", "Characters": ["0xe2", "0xa5", "0x8a"]},
    {"Name": "luruhar", "Characters": ["0xe2", "0xa5", "0xa6"]},
    {"Name": "lvertneqq", "Characters": ["0xe2", "0x89", "0xa8", "0xef", "0xb8", "0x80"]},
    {"Name": "lvnE", "Characters": ["0xe2", "0x89", "0xa8", "0xef", "0xb8", "0x80"]},
    {"Name": "mDDot", "Characters": ["0xe2", "0x88", "0xba"]},
    {"Name": "macr", "Characters": ["0xc2", "0xaf"]},
    {"Name": "male", "Characters": ["0xe2", "0x99", "0x82"]},
    {"Name": "malt", "Characters": ["0xe2", "0x9c", "0xa0"]},
    {"Name": "maltese", "Characters": ["0xe2", "0x9c", "0xa0"]},
    {"Name": "map", "Characters": ["0xe2", "0x86", "0xa6"]},
    {"Name": "mapsto", "Characters": ["0xe2", "0x86", "0xa6"]},
    {"Name": "mapstodown", "Characters": ["0xe2", "0x86", "0xa7"]},
    {"Name": "mapstoleft", "Characters": ["0xe2", "0x86", "0xa4"]},
    {"Name": "mapstoup", "Characters": ["0xe2", "0x86", "0xa5"]},
    {"Name": "marker", "Characters": ["0xe2", "0x96", "0xae"]},
    {"Name": "mcomma", "Characters": ["0xe2", "0xa8", "0xa9"]},
    {"Name": "mcy", "Characters": ["0xd0", "0xbc"]},
    {"Name": "mdash", "Characters": ["0xe2", "0x80", "0x94"]},
    {"Name": "measuredangle", "Characters": ["0xe2", "0x88", "0xa1"]},
    {"Name": "mfr", "Characters": ["0xf0", "0x9d", "0x94", "0xaa"]},
    {"Name": "mho", "Characters": ["0xe2", "0x84", "0xa7"]},
    {"Name": "micro", "Characters": ["0xc2", "0xb5"]},
    {"Name": "mid", "Characters": ["0xe2", "0x88", "0xa3"]},
    {"Name": "midast", "Characters": ["0x2a"]},
    {"Name": "midcir", "Characters": ["0xe2", "0xab", "0xb0"]},
    {"Name": "middot", "Characters": ["0xc2", "0xb7"]},
    {"Name": "minus", "Characters": ["0xe2", "0x88", "0x92"]},
    {"Name": "minusb", "Characters": ["0xe2", "0x8a", "0x9f"]},
    {"Name": "minusd", "Characters": ["0xe2", "0x88", "0xb8"]},
    {"Name": "minusdu", "Characters": ["0xe2", "0xa8", "0xaa"]},
    {"Name": "mlcp", "Characters": ["0xe2", "0xab", "0x9b"]},
    {"Name": "mldr", "Characters": ["0xe2", "0x80", "0xa6"]},
    {"Name": "mnplus", "Characters": ["0xe2", "0x88", "0x93"]},
    {"Name": "models", "Characters": ["0xe2", "0x8a", "0xa7"]},
    {"Name": "mopf", "Characters": ["0xf0", "0x9d", "0x95", "0x9e"]},
    {"Name": "mp", "Characters": ["0xe2", "0x88", "0x93"]},
    {"Name": "mscr", "Characters": ["0xf0", "0x9d", "0x93", "0x82"]},
    {"Name": "mstpos", "Characters": ["0xe2", "0x88", "0xbe"]},
    {"Name": "mu", "Characters": ["0xce", "0xbc"]},
    {"Name": "multimap", "Characters": ["0xe2", "0x8a", "0xb8"]},
    {"Name": "mumap", "Characters": ["0xe2", "0x8a", "0xb8"]},
    {"Name": "nGg", "Characters": ["0xe2", "0x8b", "0x99", "0xcc", "0xb8"]},
    {"Name": "nGt", "Characters": ["0xe2", "0x89", "0xab", "0xe2", "0x83", "0x92"]},
    {"Name": "nGtv", "Characters": ["0xe2", "0x89", "0xab", "0xcc", "0xb8"]},
    {"Name": "nLeftarrow", "Characters": ["0xe2", "0x87", "0x8d"]},
    {"Name": "nLeftrightarrow", "Characters": ["0xe2", "0x87", "0x8e"]},
    {"Name": "nLl", "Characters": ["0xe2", "0x8b", "0x98", "0xcc", "0xb8"]},
    {"Name": "nLt", "Characters": ["0xe2", "0x89", "0xaa", "0xe2", "0x83", "0x92"]},
    {"Name": "nLtv", "Characters": ["0xe2", "0x89", "0xaa", "0xcc", "0xb8"]},
    {"Name": "nRightarrow", "Characters": ["0xe2", "0x87", "0x8f"]},
    {"Name": "nVDash", "Characters": ["0xe2", "0x8a", "0xaf"]},
    {"Name": "nVdash", "Characters": ["0xe2", "0x8a", "0xae"]},
    {"Name": "nabla", "Characters": ["0xe2", "0x88", "0x87"]},
    {"Name": "nacute", "Characters": ["0xc5", "0x84"]},
    {"Name": "nang", "Characters": ["0xe2", "0x88", "0xa0", "0xe2", "0x83", "0x92"]},
    {"Name": "nap", "Characters": ["0xe2", "0x89", "0x89"]},
    {"Name": "napE", "Characters": ["0xe2", "0xa9", "0xb0", "0xcc", "0xb8"]},
    {"Name": "napid", "Characters": ["0xe2", "0x89", "0x8b", "0xcc", "0xb8"]},
    {"Name": "napos", "Characters": ["0xc5", "0x89"]},
    {"Name": "napprox", "Characters": ["0xe2", "0x89", "0x89"]},
    {"Name": "natur", "Characters": ["0xe2", "0x99", "0xae"]},
    {"Name": "natural", "Characters": ["0xe2", "0x99", "0xae"]},
    {"Name": "naturals", "Characters": ["0xe2", "0x84", "0x95"]},
    {"Name": "nbsp", "Characters": ["0xc2", "0xa0"]},
    {"Name": "nbump", "Characters": ["0xe2", "0x89", "0x8e", "0xcc", "0xb8"]},
    {"Name": "nbumpe", "Characters": ["0xe2", "0x89", "0x8f", "0xcc", "0xb8"]},
    {"Name": "ncap", "Characters": ["0xe2", "0xa9", "0x83"]},
    {"Name": "ncaron", "Characters": ["0xc5", "0x88"]},
    {"Name": "ncedil", "Characters": ["0xc5", "0x86"]},
    {"Name": "ncong", "Characters": ["0xe2", "0x89", "0x87"]},
    {"Name": "ncongdot", "Characters": ["0xe2", "0xa9", "0xad", "0xcc", "0xb8"]},
    {"Name": "ncup", "Characters": ["0xe2", "0xa9", "0x82"]},
    {"Name": "ncy", "Characters": ["0xd0", "0xbd"]},
    {"Name": "ndash", "Characters": ["0xe2", "0x80", "0x93"]},
    {"Name": "ne", "Characters": ["0xe2", "0x89", "0xa0"]},
    {"Name": "neArr", "Characters": ["0xe2", "0x87", "0x97"]},
    {"Name": "nearhk", "Characters": ["0xe2", "0xa4", "0xa4"]},
    {"Name": "nearr", "Characters": ["0xe2", "0x86", "0x97"]},
    {"Name": "nearrow", "Characters": ["0xe2", "0x86", "0x97"]},
    {"Name": "nedot", "Characters": ["0xe2", "0x89", "0x90", "0xcc", "0xb8"]},
    {"Name": "nequiv", "Characters": ["0xe2", "0x89", "0xa2"]},
    {"Name": "nesear", "Characters": ["0xe2", "0xa4", "0xa8"]},
    {"Name": "nesim", "Characters": ["0xe2", "0x89", "0x82", "0xcc", "0xb8"]},
    {"Name": "nexist", "Characters": ["0xe2", "0x88", "0x84"]},
    {"Name": "nexists", "Characters": ["0xe2", "0x88", "0x84"]},
    {"Name": "nfr", "Characters": ["0xf0", "0x9d", "0x94", "0xab"]},
    {"Name": "ngE", "Characters": ["0xe2", "0x89", "0xa7", "0xcc", "0xb8"]},
    {"Name": "nge", "Characters": ["0xe2", "0x89", "0xb1"]},
    {"Name": "ngeq", "Characters": ["0xe2", "0x89", "0xb1"]},
    {"Name": "ngeqq", "Characters": ["0xe2", "0x89", "0xa7", "0xcc", "0xb8"]},
    {"Name": "ngeqslant", "Characters": ["0xe2", "0xa9", "0xbe", "0xcc", "0xb8"]},
    {"Name": "nges", "Characters": ["0xe2", "0xa9", "0xbe", "0xcc", "0xb8"]},
    {"Name": "ngsim", "Characters": ["0xe2", "0x89", "0xb5"]},
    {"Name": "ngt", "Characters": ["0xe2", "0x89", "0xaf"]},
    {"Name": "ngtr", "Characters": ["0xe2", "0x89", "0xaf"]},
    {"Name": "nhArr", "Characters": ["0xe2", "0x87", "0x8e"]},
    {"Name": "nharr", "Characters": ["0xe2", "0x86", "0xae"]},
    {"Name": "nhpar", "Characters": ["0xe2", "0xab", "0xb2"]},
    {"Name": "ni", "Characters": ["0xe2", "0x88", "0x8b"]},
    {"Name": "nis", "Characters": ["0xe2", "0x8b", "0xbc"]},
    {"Name": "nisd", "Characters": ["0xe2", "0x8b", "0xba"]},
    {"Name": "niv", "Characters": ["0xe2", "0x88", "0x8b"]},
    {"Name": "njcy", "Characters": ["0xd1", "0x9a"]},
    {"Name": "nlArr", "Characters": ["0xe2", "0x87", "0x8d"]},
    {"Name": "nlE", "Characters": ["0xe2", "0x89", "0xa6", "0xcc", "0xb8"]},
    {"Name": "nlarr", "Characters": ["0xe2", "0x86", "0x9a"]},
    {"Name": "nldr", "Characters": ["0xe2", "0x80", "0xa5"]},
    {"Name": "nle", "Characters": ["0xe2", "0x89", "0xb0"]},
    {"Name": "nleftarrow", "Characters": ["0xe2", "0x86", "0x9a"]},
    {"Name": "nleftrightarrow", "Characters": ["0xe2", "0x86", "0xae"]},
    {"Name": "nleq", "Characters": ["0xe2", "0x89", "0xb0"]},
    {"Name": "nleqq", "Characters": ["0xe2", "0x89", "0xa6", "0xcc", "0xb8"]},
    {"Name": "nleqslant", "Characters": ["0xe2", "0xa9", "0xbd", "0xcc", "0xb8"]},
    {"Name": "nles", "Characters": ["0xe2", "0xa9", "0xbd", "0xcc", "0xb8"]},
    {"Name": "nless", "Characters": ["0xe2", "0x89", "0xae"]},
    {"Name": "nlsim", "Characters": ["0xe2", "0x89", "0xb4"]},
    {"Name": "nlt", "Characters": ["0xe2", "0x89", "0xae"]},
    {"Name": "nltri", "Characters": ["0xe2", "0x8b", "0xaa"]},
    {"Name": "nltrie", "Characters": ["0xe2", "0x8b", "0xac"]},
    {"Name": "nmid", "Characters": ["0xe2", "0x88", "0xa4"]},
    {"Name": "nopf", "Characters": ["0xf0", "0x9d", "0x95", "0x9f"]},
    {"Name": "not", "Characters": ["0xc2", "0xac"]},
    {"Name": "notin", "Characters": ["0xe2", "0x88", "0x89"]},
    {"Name": "notinE", "Characters": ["0xe2", "0x8b", "0xb9", "0xcc", "0xb8"]},
    {"Name": "notindot", "Characters": ["0xe2", "0x8b", "0xb5", "0xcc", "0xb8"]},
    {"Name": "notinva", "Characters": ["0xe2", "0x88", "0x89"]},
    {"Name": "notinvb", "Characters": ["0xe2", "0x8b", "0xb7"]},
    {"Name": "notinvc", "Characters": ["0xe2", "0x8b", "0xb6"]},
    {"Name": "notni", "Characters": ["0xe2", "0x88", "0x8c"]},
    {"Name": "notniva", "Characters": ["0xe2", "0x88", "0x8c"]},
    {"Name": "notnivb", "Characters": ["0xe2", "0x8b", "0xbe"]},
    {"Name": "notnivc", "Characters": ["0xe2", "0x8b", "0xbd"]},
    {"Name": "npar", "Characters": ["0xe2", "0x88", "0xa6"]},
    {"Name": "nparallel", "Characters": ["0xe2", "0x88", "0xa6"]},
    {"Name": "nparsl", "Characters": ["0xe2", "0xab", "0xbd", "0xe2", "0x83", "0xa5"]},
    {"Name": "npart", "Characters": ["0xe2", "0x88", "0x82", "0xcc", "0xb8"]},
    {"Name": "npolint", "Characters": ["0xe2", "0xa8", "0x94"]},
    {"Name": "npr", "Characters": ["0xe2", "0x8a", "0x80"]},
    {"Name": "nprcue", "Characters": ["0xe2", "0x8b", "0xa0"]},
    {"Name": "npre", "Characters": ["0xe2", "0xaa", "0xaf", "0xcc", "0xb8"]},
    {"Name": "nprec", "Characters": ["0xe2", "0x8a", "0x80"]},
    {"Name": "npreceq", "Characters": ["0xe2", "0xaa", "0xaf", "0xcc", "0xb8"]},
    {"Name": "nrArr", "Characters": ["0xe2", "0x87", "0x8f"]},
    {"Name": "nrarr", "Characters": ["0xe2", "0x86", "0x9b"]},
    {"Name": "nrarrc", "Characters": ["0xe2", "0xa4", "0xb3", "0xcc", "0xb8"]},
    {"Name": "nrarrw", "Characters": ["0xe2", "0x86", "0x9d", "0xcc", "0xb8"]},
    {"Name": "nrightarrow", "Characters": ["0xe2", "0x86", "0x9b"]},
    {"Name": "nrtri", "Characters": ["0xe2", "0x8b", "0xab"]},
    {"Name": "nrtrie", "Characters": ["0xe2", "0x8b", "0xad"]},
    {"Name": "nsc", "Characters": ["0xe2", "0x8a", "0x81"]},
    {"Name": "nsccue", "Characters": ["0xe2", "0x8b", "0xa1"]},
    {"Name": "nsce", "Characters": ["0xe2", "0xaa", "0xb0", "0xcc", "0xb8"]},
    {"Name": "nscr", "Characters": ["0xf0", "0x9d", "0x93", "0x83"]},
    {"Name": "nshortmid", "Characters": ["0xe2", "0x88", "0xa4"]},
    {"Name": "nshortparallel", "Characters": ["0xe2", "0x88", "0xa6"]},
    {"Name": "nsim", "Characters": ["0xe2", "0x89", "0x81"]},
    {"Name": "nsime", "Characters": ["0xe2", "0x89", "0x84"]},
    {"Name": "nsimeq", "Characters": ["0xe2", "0x89", "0x84"]},
    {"Name": "nsmid", "Characters": ["0xe2", "0x88", "0xa4"]},
    {"Name": "nspar", "Characters": ["0xe2", "0x88", "0xa6"]},
    {"Name": "nsqsube", "Characters": ["0xe2", "0x8b", "0xa2"]},
    {"Name": "nsqsupe", "Characters": ["0xe2", "0x8b", "0xa3"]},
    {"Name": "nsub", "Characters": ["0xe2", "0x8a", "0x84"]},
    {"Name": "nsubE", "Characters": ["0xe2", "0xab", "0x85", "0xcc", "0xb8"]},
    {"Name": "nsube", "Characters": ["0xe2", "0x8a", "0x88"]},
    {"Name": "nsubset", "Characters": ["0xe2", "0x8a", "0x82", "0xe2", "0x83", "0x92"]},
    {"Name": "nsubseteq", "Characters": ["0xe2", "0x8a", "0x88"]},
    {"Name": "nsubseteqq", "Characters": ["0xe2", "0xab", "0x85", "0xcc", "0xb8"]},
    {"Name": "nsucc", "Characters": ["0xe2", "0x8a", "0x81"]},
    {"Name": "nsucceq", "Characters": ["0xe2", "0xaa", "0xb0", "0xcc", "0xb8"]},
    {"Name": "nsup", "Characters": ["0xe2", "0x8a", "0x85"]},
    {"Name": "nsupE", "Characters": ["0xe2", "0xab", "0x86", "0xcc", "0xb8"]},
    {"Name": "nsupe", "Characters": ["0xe2", "0x8a", "0x89"]},
    {"Name": "nsupset", "Characters": ["0xe2", "0x8a", "0x83", "0xe2", "0x83", "0x92"]},
    {"Name": "nsupseteq", "Characters": ["0xe2", "0x8a", "0x89"]},
    {"Name": "nsupseteqq", "Characters": ["0xe2", "0xab", "0x86", "0xcc", "0xb8"]},
    {"Name": "ntgl", "Characters": ["0xe2", "0x89", "0xb9"]},
    {"Name": "ntilde", "Characters": ["0xc3", "0xb1"]},
    {"Name": "ntlg", "Characters": ["0xe2", "0x89", "0xb8"]},
    {"Name": "ntriangleleft", "Characters": ["0xe2", "0x8b", "0xaa"]},
    {"Name": "ntrianglelefteq", "Characters": ["0xe2", "0x8b", "0xac"]},
    {"Name": "ntriangleright", "Characters": ["0xe2", "0x8b", "0xab"]},
    {"Name": "ntrianglerighteq", "Characters": ["0xe2", "0x8b", "0xad"]},
    {"Name": "nu", "Characters": ["0xce", "0xbd"]},
    {"Name": "num", "Characters": ["0x23"]},
    {"Name": "numero", "Characters": ["0xe2", "0x84", "0x96"]},
    {"Name": "numsp", "Characters": ["0xe2", "0x80", "0x87"]},
    {"Name": "nvDash", "Characters": ["0xe2", "0x8a", "0xad"]},
    {"Name": "nvHarr", "Characters": ["0xe2", "0xa4", "0x84"]},
    {"Name": "nvap", "Characters": ["0xe2", "0x89", "0x8d", "0xe2", "0x83", "0x92"]},
    {"Name": "nvdash", "Characters": ["0xe2", "0x8a", "0xac"]},
    {"Name": "nvge", "Characters": ["0xe2", "0x89", "0xa5", "0xe2", "0x83", "0x92"]},
    {"Name": "nvgt", "Characters": ["0x3e", "0xe2", "0x83", "0x92"]},
    {"Name": "nvinfin", "Characters": ["0xe2", "0xa7", "0x9e"]},
    {"Name": "nvlArr", "Characters": ["0xe2", "0xa4", "0x82"]},
    {"Name": "nvle", "Characters": ["0xe2", "0x89", "0xa4", "0xe2", "0x83", "0x92"]},
    {"Name": "nvlt", "Characters": ["0x3c", "0xe2", "0x83", "0x92"]},
    {"Name": "nvltrie", "Characters": ["0xe2", "0x8a", "0xb4", "0xe2", "0x83", "0x92"]},
    {"Name": "nvrArr", "Characters": ["0xe2", "0xa4", "0x83"]},
    {"Name": "nvrtrie", "Characters": ["0xe2", "0x8a", "0xb5", "0xe2", "0x83", "0x92"]},
    {"Name": "nvsim", "Characters": ["0xe2", "0x88", "0xbc", "0xe2", "0x83", "0x92"]},
    {"Name": "nwArr", "Characters": ["0xe2", "0x87", "0x96"]},
    {"Name": "nwarhk", "Characters": ["0xe2", "0xa4", "0xa3"]},
    {"Name": "nwarr", "Characters": ["0xe2", "0x86", "0x96"]},
    {"Name": "nwarrow", "Characters": ["0xe2", "0x86", "0x96"]},
    {"Name": "nwnear", "Characters": ["0xe2", "0xa4", "0xa7"]},
    {"Name": "oS", "Characters": ["0xe2", "0x93", "0x88"]},
    {"Name": "oacute", "Characters": ["0xc3", "0xb3"]},
    {"Name": "oast", "Characters": ["0xe2", "0x8a", "0x9b"]},
    {"Name": "ocir", "Characters": ["0xe2", "0x8a", "0x9a"]},
    {"Name": "ocirc", "Characters": ["0xc3", "0xb4"]},
    {"Name": "ocy", "Characters": ["0xd0", "0xbe"]},
    {"Name": "odash", "Characters": ["0xe2", "0x8a", "0x9d"]},
    {"Name": "odblac", "Characters": ["0xc5", "0x91"]},
    {"Name": "odiv", "Characters": ["0xe2", "0xa8", "0xb8"]},
    {"Name": "odot", "Characters": ["0xe2", "0x8a", "0x99"]},
    {"Name": "odsold", "Characters": ["0xe2", "0xa6", "0xbc"]},
    {"Name": "oelig", "Characters": ["0xc5", "0x93"]},
    {"Name": "ofcir", "Characters": ["0xe2", "0xa6", "0xbf"]},
    {"Name": "ofr", "Characters": ["0xf0", "0x9d", "0x94", "0xac"]},
    {"Name": "ogon", "Characters": ["0xcb", "0x9b"]},
    {"Name": "ograve", "Characters": ["0xc3", "0xb2"]},
    {"Name": "ogt", "Characters": ["0xe2", "0xa7", "0x81"]},
    {"Name": "ohbar", "Characters": ["0xe2", "0xa6", "0xb5"]},
    {"Name": "ohm", "Characters": ["0xce", "0xa9"]},
    {"Name": "oint", "Characters": ["0xe2", "0x88", "0xae"]},
    {"Name": "olarr", "Characters": ["0xe2", "0x86", "0xba"]},
    {"Name": "olcir", "Characters": ["0xe2", "0xa6", "0xbe"]},
    {"Name": "olcross", "Characters": ["0xe2", "0xa6", "0xbb"]},
    {"Name": "oline", "Characters": ["0xe2", "0x80", "0xbe"]},
    {"Name": "olt", "Characters": ["0xe2", "0xa7", "0x80"]},
    {"Name": "omacr", "Characters": ["0xc5", "0x8d"]},
    {"Name": "omega", "Characters": ["0xcf", "0x89"]},
    {"Name": "omicron", "Characters": ["0xce", "0xbf"]},
    {"Name": "omid", "Characters": ["0xe2", "0xa6", "0xb6"]},
    {"Name": "ominus", "Characters": ["0xe2", "0x8a", "0x96"]},
    {"Name": "oopf", "Characters": ["0xf0", "0x9d", "0x95", "0xa0"]},
    {"Name": "opar", "Characters": ["0xe2", "0xa6", "0xb7"]},
    {"Name": "operp", "Characters": ["0xe2", "0xa6", "0xb9"]},
    {"Name": "oplus", "Characters": ["0xe2", "0x8a", "0x95"]},
    {"Name": "or", "Characters": ["0xe2", "0x88", "0xa8"]},
    {"Name": "orarr", "Characters": ["0xe2", "0x86", "0xbb"]},
    {"Name": "ord", "Characters": ["0xe2", "0xa9", "0x9d"]},
    {"Name": "order", "Characters": ["0xe2", "0x84", "0xb4"]},
    {"Name": "orderof", "Characters": ["0xe2", "0x84", "0xb4"]},
    {"Name": "ordf", "Characters": ["0xc2", "0xaa"]},
    {"Name": "ordm", "Characters": ["0xc2", "0xba"]},
    {"Name": "origof", "Characters": ["0xe2", "0x8a", "0xb6"]},
    {"Name": "oror", "Characters": ["0xe2", "0xa9", "0x96"]},
    {"Name": "orslope", "Characters": ["0xe2", "0xa9", "0x97"]},
    {"Name": "orv", "Characters": ["0xe2", "0xa9", "0x9b"]},
    {"Name": "oscr", "Characters": ["0xe2", "0x84", "0xb4"]},
    {"Name": "oslash", "Characters": ["0xc3", "0xb8"]},
    {"Name": "osol", "Characters": ["0xe2", "0x8a", "0x98"]},
    {"Name": "otilde", "Characters": ["0xc3", "0xb5"]},
    {"Name": "otimes", "Characters": ["0xe2", "0x8a", "0x97"]},
    {"Name": "otimesas", "Characters": ["0xe2", "0xa8", "0xb6"]},
    {"Name": "ouml", "Characters": ["0xc3", "0xb6"]},
    {"Name": "ovbar", "Characters": ["0xe2", "0x8c", "0xbd"]},
    {"Name": "par", "Characters": ["0xe2", "0x88", "0xa5"]},
    {"Name": "para", "Characters": ["0xc2", "0xb6"]},
    {"Name": "parallel", "Characters": ["0xe2", "0x88", "0xa5"]},
    {"Name": "parsim", "Characters": ["0xe2", "0xab", "0xb3"]},
    {"Name": "parsl", "Characters": ["0xe2", "0xab", "0xbd"]},
    {"Name": "part", "Characters": ["0xe2", "0x88", "0x82"]},
    {"Name": "pcy", "Characters": ["0xd0", "0xbf"]},
    {"Name": "percnt", "Characters": ["0x25"]},
    {"Name": "period", "Characters": ["0x2e"]},
    {"Name": "permil", "Characters": ["0xe2", "0x80", "0xb0"]},
    {"Name": "perp", "Characters": ["0xe2", "0x8a", "0xa5"]},
    {"Name": "pertenk", "Characters": ["0xe2", "0x80", "0xb1"]},
    {"Name": "pfr", "Characters": ["0xf0", "0x9d", "0x94", "0xad"]},
    {"Name": "phi", "Characters": ["0xcf", "0x86"]},
    {"Name": "phiv", "Characters": ["0xcf", "0x95"]},
    {"Name": "phmmat", "Characters": ["0xe2", "0x84", "0xb3"]},
    {"Name": "phone", "Characters": ["0xe2", "0x98", "0x8e"]},
    {"Name": "pi", "Characters": ["0xcf", "0x80"]},
    {"Name": "pitchfork", "Characters": ["0xe2", "0x8b", "0x94"]},
    {"Name": "piv", "Characters": ["0xcf", "0x96"]},
    {"Name": "planck", "Characters": ["0xe2", "0x84", "0x8f"]},
    {"Name": "planckh", "Characters": ["0xe2", "0x84", "0x8e"]},
    {"Name": "plankv", "Characters": ["0xe2", "0x84", "0x8f"]},
    {"Name": "plus", "Characters": ["0x2b"]},
    {"Name": "plusacir", "Characters": ["0xe2", "0xa8", "0xa3"]},
    {"Name": "plusb", "Characters": ["0xe2", "0x8a", "0x9e"]},
    {"Name": "pluscir", "Characters": ["0xe2", "0xa8", "0xa2"]},
    {"Name": "plusdo", "Characters": ["0xe2", "0x88", "0x94"]},
    {"Name": "plusdu", "Characters": ["0xe2", "0xa8", "0xa5"]},
    {"Name": "pluse", "Characters": ["0xe2", "0xa9", "0xb2"]},
    {"Name": "plusmn", "Characters": ["0xc2", "0xb1"]},
    {"Name": "plussim", "Characters": ["0xe2", "0xa8", "0xa6"]},
    {"Name": "plustwo", "Characters": ["0xe2", "0xa8", "0xa7"]},
    {"Name": "pm", "Characters": ["0xc2", "0xb1"]},
    {"Name": "pointint", "Characters": ["0xe2", "0xa8", "0x95"]},
    {"Name": "popf", "Characters": ["0xf0", "0x9d", "0x95", "0xa1"]},
    {"Name": "pound", "Characters": ["0xc2", "0xa3"]},
    {"Name": "pr", "Characters": ["0xe2", "0x89", "0xba"]},
    {"Name": "prE", "Characters": ["0xe2", "0xaa", "0xb3"]},
    {"Name": "prap", "Characters": ["0xe2", "0xaa", "0xb7"]},
    {"Name": "prcue", "Characters": ["0xe2", "0x89", "0xbc"]},
    {"Name": "pre", "Characters": ["0xe2", "0xaa", "0xaf"]},
    {"Name": "prec", "Characters": ["0xe2", "0x89", "0xba"]},
    {"Name": "precapprox", "Characters": ["0xe2", "0xaa", "0xb7"]},
    {"Name": "preccurlyeq", "Characters": ["0xe2", "0x89", "0xbc"]},
    {"Name": "preceq", "Characters": ["0xe2", "0xaa", "0xaf"]},
    {"Name": "precnapprox", "Characters": ["0xe2", "0xaa", "0xb9"]},
    {"Name": "precneqq", "Characters": ["0xe2", "0xaa", "0xb5"]},
    {"Name": "precnsim", "Characters": ["0xe2", "0x8b", "0xa8"]},
    {"Name": "precsim", "Characters": ["0xe2", "0x89", "0xbe"]},
    {"Name": "prime", "Characters": ["0xe2", "0x80", "0xb2"]},
    {"Name": "primes", "Characters": ["0xe2", "0x84", "0x99"]},
    {"Name": "prnE", "Characters": ["0xe2", "0xaa", "0xb5"]},
    {"Name": "prnap", "Characters": ["0xe2", "0xaa", "0xb9"]},
    {"Name": "prnsim", "Characters": ["0xe2", "0x8b", "0xa8"]},
    {"Name": "prod", "Characters": ["0xe2", "0x88", "0x8f"]},
    {"Name": "profalar", "Characters": ["0xe2", "0x8c", "0xae"]},
    {"Name": "profline", "Characters": ["0xe2", "0x8c", "0x92"]},
    {"Name": "profsurf", "Characters": ["0xe2", "0x8c", "0x93"]},
    {"Name": "prop", "Characters": ["0xe2", "0x88", "0x9d"]},
    {"Name": "propto", "Characters": ["0xe2", "0x88", "0x9d"]},
    {"Name": "prsim", "Characters": ["0xe2", "0x89", "0xbe"]},
    {"Name": "prurel", "Characters": ["0xe2", "0x8a", "0xb0"]},
    {"Name": "pscr", "Characters": ["0xf0", "0x9d", "0x93", "0x85"]},
    {"Name": "psi", "Characters": ["0xcf", "0x88"]},
    {"Name": "puncsp", "Characters": ["0xe2", "0x80", "0x88"]},
    {"Name": "qfr", "Characters": ["0xf0", "0x9d", "0x94", "0xae"]},
    {"Name": "qint", "Characters": ["0xe2", "0xa8", "0x8c"]},
    {"Name": "qopf", "Characters": ["0xf0", "0x9d", "0x95", "0xa2"]},
    {"Name": "qprime", "Characters": ["0xe2", "0x81", "0x97"]},
    {"Name": "qscr", "Characters": ["0xf0", "0x9d", "0x93", "0x86"]},
    {"Name": "quaternions", "Characters": ["0xe2", "0x84", "0x8d"]},
    {"Name": "quatint", "Characters": ["0xe2", "0xa8", "0x96"]},
    {"Name": "quest", "Characters": ["0x3f"]},
    {"Name": "questeq", "Characters": ["0xe2", "0x89", "0x9f"]},
    {"Name": "quot", "Characters": ["0x22"]},
    {"Name": "rAarr", "Characters": ["0xe2", "0x87", "0x9b"]},
    {"Name": "rArr", "Characters": ["0xe2", "0x87", "0x92"]},
    {"Name": "rAtail", "Characters": ["0xe2", "0xa4", "0x9c"]},
    {"Name": "rBarr", "Characters": ["0xe2", "0xa4", "0x8f"]},
    {"Name": "rHar", "Characters": ["0xe2", "0xa5", "0xa4"]},
    {"Name": "race", "Characters": ["0xe2", "0x88", "0xbd", "0xcc", "0xb1"]},
    {"Name": "racute", "Characters": ["0xc5", "0x95"]},
    {"Name": "radic", "Characters": ["0xe2", "0x88", "0x9a"]},
    {"Name": "raemptyv", "Characters": ["0xe2", "0xa6", "0xb3"]},
    {"Name": "rang", "Characters": ["0xe2", "0x9f", "0xa9"]},
    {"Name": "rangd", "Characters": ["0xe2", "0xa6", "0x92"]},
    {"Name": "range", "Characters": ["0xe2", "0xa6", "0xa5"]},
    {"Name": "rangle", "Characters": ["0xe2", "0x9f", "0xa9"]},
    {"Name": "raquo", "Characters": ["0xc2", "0xbb"]},
    {"Name": "rarr", "Characters": ["0xe2", "0x86", "0x92"]},
    {"Name": "rarrap", "Characters": ["0xe2", "0xa5", "0xb5"]},
    {"Name": "rarrb", "Characters": ["0xe2", "0x87", "0xa5"]},
    {"Name": "rarrbfs", "Characters": ["0xe2", "0xa4", "0xa0"]},
    {"Name": "rarrc", "Characters": ["0xe2", "0xa4", "0xb3"]},
    {"Name": "rarrfs", "Characters": ["0xe2", "0xa4", "0x9e"]},
    {"Name": "rarrhk", "Characters": ["0xe2", "0x86", "0xaa"]},
    {"Name": "rarrlp", "Characters": ["0xe2", "0x86", "0xac"]},
    {"Name": "rarrpl", "Characters": ["0xe2", "0xa5", "0x85"]},
    {"Name": "rarrsim", "Characters": ["0xe2", "0xa5", "0xb4"]},
    {"Name": "rarrtl", "Characters": ["0xe2", "0x86", "0xa3"]},
    {"Name": "rarrw", "Characters": ["0xe2", "0x86", "0x9d"]},
    {"Name": "ratail", "Characters": ["0xe2", "0xa4", "0x9a"]},
    {"Name": "ratio", "Characters": ["0xe2", "0x88", "0xb6"]},
    {"Name": "rationals", "Characters": ["0xe2", "0x84", "0x9a"]},
    {"Name": "rbarr", "Characters": ["0xe2", "0xa4", "0x8d"]},
    {"Name": "rbbrk", "Characters": ["0xe2", "0x9d", "0xb3"]},
    {"Name": "rbrace", "Characters": ["0x7d"]},
    {"Name": "rbrack", "Characters": ["0x5d"]},
    {"Name": "rbrke", "Characters": ["0xe2", "0xa6", "0x8c"]},
    {"Name": "rbrksld", "Characters": ["0xe2", "0xa6", "0x8e"]},
    {"Name": "rbrkslu", "Characters": ["0xe2", "0xa6", "0x90"]},
    {"Name": "rcaron", "Characters": ["0xc5", "0x99"]},
    {"Name": "rcedil", "Characters": ["0xc5", "0x97"]},
    {"Name": "rceil", "Characters": ["0xe2", "0x8c", "0x89"]},
    {"Name": "rcub", "Characters": ["0x7d"]},
    {"Name": "rcy", "Characters": ["0xd1", "0x80"]},
    {"Name": "rdca", "Characters": ["0xe2", "0xa4", "0xb7"]},
    {"Name": "rdldhar", "Characters": ["0xe2", "0xa5", "0xa9"]},
    {"Name": "rdquo", "Characters": ["0xe2", "0x80", "0x9d"]},
    {"Name": "rdquor", "Characters": ["0xe2", "0x80", "0x9d"]},
    {"Name": "rdsh", "Characters": ["0xe2", "0x86", "0xb3"]},
    {"Name": "real", "Characters": ["0xe2", "0x84", "0x9c"]},
    {"Name": "realine", "Characters": ["0xe2", "0x84", "0x9b"]},
    {"Name": "realpart", "Characters": ["0xe2", "0x84", "0x9c"]},
    {"Name": "reals", "Characters": ["0xe2", "0x84", "0x9d"]},
    {"Name": "rect", "Characters": ["0xe2", "0x96", "0xad"]},
    {"Name": "reg", "Characters": ["0xc2", "0xae"]},
    {"Name": "rfisht", "Characters": ["0xe2", "0xa5", "0xbd"]},
    {"Name": "rfloor", "Characters": ["0xe2", "0x8c", "0x8b"]},
    {"Name": "rfr", "Characters": ["0xf0", "0x9d", "0x94", "0xaf"]},
    {"Name": "rhard", "Characters": ["0xe2", "0x87", "0x81"]},
    {"Name": "rharu", "Characters": ["0xe2", "0x87", "0x80"]},
    {"Name": "rharul", "Characters": ["0xe2", "0xa5", "0xac"]},
    {"Name": "rho", "Characters": ["0xcf", "0x81"]},
    {"Name": "rhov", "Characters": ["0xcf", "0xb1"]},
    {"Name": "rightarrow", "Characters": ["0xe2", "0x86", "0x92"]},
    {"Name": "rightarrowtail", "Characters": ["0xe2", "0x86", "0xa3"]},
    {"Name": "rightharpoondown", "Characters": ["0xe2", "0x87", "0x81"]},
    {"Name": "rightharpoonup", "Characters": ["0xe2", "0x87", "0x80"]},
    {"Name": "rightleftarrows", "Characters": ["0xe2", "0x87", "0x84"]},
    {"Name": "rightleftharpoons", "Characters": ["0xe2", "0x87", "0x8c"]},
    {"Name": "rightrightarrows", "Characters": ["0xe2", "0x87", "0x89"]},
    {"Name": "rightsquigarrow", "Characters": ["0xe2", "0x86", "0x9d"]},
    {"Name": "rightthreetimes", "Characters": ["0xe2", "0x8b", "0x8c"]},
    {"Name": "ring", "Characters": ["0xcb", "0x9a"]},
    {"Name": "risingdotseq", "Characters": ["0xe2", "0x89", "0x93"]},
    {"Name": "rlarr", "Characters": ["0xe2", "0x87", "0x84"]},
    {"Name": "rlhar", "Characters": ["0xe2", "0x87", "0x8c"]},
    {"Name": "rlm", "Characters": ["0xe2", "0x80", "0x8f"]},
    {"Name": "rmoust", "Characters": ["0xe2", "0x8e", "0xb1"]},
    {"Name": "rmoustache", "Characters": ["0xe2", "0x8e", "0xb1"]},
    {"Name": "rnmid", "Characters": ["0xe2", "0xab", "0xae"]},
    {"Name": "roang", "Characters": ["0xe2", "0x9f", "0xad"]},
    {"Name": "roarr", "Characters": ["0xe2", "0x87", "0xbe"]},
    {"Name": "robrk", "Characters": ["0xe2", "0x9f", "0xa7"]},
    {"Name": "ropar", "Characters": ["0xe2", "0xa6", "0x86"]},
    {"Name": "ropf", "Characters": ["0xf0", "0x9d", "0x95", "0xa3"]},
    {"Name": "roplus", "Characters": ["0xe2", "0xa8", "0xae"]},
    {"Name": "rotimes", "Characters": ["0xe2", "0xa8", "0xb5"]},
    {"Name": "rpar", "Characters": ["0x29"]},
    {"Name": "rpargt", "Characters": ["0xe2", "0xa6", "0x94"]},
    {"Name": "rppolint", "Characters": ["0xe2", "0xa8", "0x92"]},
    {"Name": "rrarr", "Characters": ["0xe2", "0x87", "0x89"]},
    {"Name": "rsaquo", "Characters": ["0xe2", "0x80", "0xba"]},
    {"Name": "rscr", "Characters": ["0xf0", "0x9d", "0x93", "0x87"]},
    {"Name": "rsh", "Characters": ["0xe2", "0x86", "0xb1"]},
    {"Name": "rsqb", "Characters": ["0x5d"]},
    {"Name": "rsquo", "Characters": ["0xe2", "0x80", "0x99"]},
    {"Name": "rsquor", "Characters": ["0xe2", "0x80", "0x99"]},
    {"Name": "rthree", "Characters": ["0xe2", "0x8b", "0x8c"]},
    {"Name": "rtimes", "Characters": ["0xe2", "0x8b", "0x8a"]},
    {"Name": "rtri", "Characters": ["0xe2", "0x96", "0xb9"]},
    {"Name": "rtrie", "Characters": ["0xe2", "0x8a", "0xb5"]},
    {"Name": "rtrif", "Characters": ["0xe2", "0x96", "0xb8"]},
    {"Name": "rtriltri", "Characters": ["0xe2", "0xa7", "0x8e"]},
    {"Name": "ruluhar", "Characters": ["0xe2", "0xa5", "0xa8"]},
    {"Name": "rx", "Characters": ["0xe2", "0x84", "0x9e"]},
    {"Name": "sacute", "Characters": ["0xc5", "0x9b"]},
    {"Name": "sbquo", "Characters": ["0xe2", "0x80", "0x9a"]},
    {"Name": "sc", "Characters": ["0xe2", "0x89", "0xbb"]},
    {"Name": "scE", "Characters": ["0xe2", "0xaa", "0xb4"]},
    {"Name": "scap", "Characters": ["0xe2", "0xaa", "0xb8"]},
    {"Name": "scaron", "Characters": ["0xc5", "0xa1"]},
    {"Name": "sccue", "Characters": ["0xe2", "0x89", "0xbd"]},
    {"Name": "sce", "Characters": ["0xe2", "0xaa", "0xb0"]},
    {"Name": "scedil", "Characters": ["0xc5", "0x9f"]},
    {"Name": "scirc", "Characters": ["0xc5", "0x9d"]},
    {"Name": "scnE", "Characters": ["0xe2", "0xaa", "0xb6"]},
    {"Name": "scnap", "Characters": ["0xe2", "0xaa", "0xba"]},
    {"Name": "scnsim", "Characters": ["0xe2", "0x8b", "0xa9"]},
    {"Name": "scpolint", "Characters": ["0xe2", "0xa8", "0x93"]},
    {"Name": "scsim", "Characters": ["0xe2", "0x89", "0xbf"]},
    {"Name": "scy", "Characters": ["0xd1", "0x81"]},
    {"Name": "sdot", "Characters": ["0xe2", "0x8b", "0x85"]},
    {"Name": "sdotb", "Characters": ["0xe2", "0x8a", "0xa1"]},
    {"Name": "sdote", "Characters": ["0xe2", "0xa9", "0xa6"]},
    {"Name": "seArr", "Characters": ["0xe2", "0x87", "0x98"]},
    {"Name": "searhk", "Characters": ["0xe2", "0xa4", "0xa5"]},
    {"Name": "searr", "Characters": ["0xe2", "0x86", "0x98"]},
    {"Name": "searrow", "Characters": ["0xe2", "0x86", "0x98"]},
    {"Name": "sect", "Characters": ["0xc2", "0xa7"]},
    {"Name": "semi", "Characters": ["0x3b"]},
    {"Name": "seswar", "Characters": ["0xe2", "0xa4", "0xa9"]},
    {"Name": "setminus", "Characters": ["0xe2", "0x88", "0x96"]},
    {"Name": "setmn", "Characters": ["0xe2", "0x88", "0x96"]},
    {"Name": "sext", "Characters": ["0xe2", "0x9c", "0xb6"]},
    {"Name": "sfr", "Characters": ["0xf0", "0x9d", "0x94", "0xb0"]},
    {"Name": "sfrown", "Characters": ["0xe2", "0x8c", "0xa2"]},
    {"Name": "sharp", "Characters": ["0xe2", "0x99", "0xaf"]},
    {"Name": "shchcy", "Characters": ["0xd1", "0x89"]},
    {"Name": "shcy", "Characters": ["0xd1", "0x88"]},
    {"Name": "shortmid", "Characters": ["0xe2", "0x88", "0xa3"]},
    {"Name": "shortparallel", "Characters": ["0xe2", "0x88", "0xa5"]},
    {"Name": "shy", "Characters": ["0xc2", "0xad"]},
    {"Name": "sigma", "Characters": ["0xcf", "0x83"]},
    {"Name": "sigmaf", "Characters": ["0xcf", "0x82"]},
    {"Name": "sigmav", "Characters": ["0xcf", "0x82"]},
    {"Name": "sim", "Characters": ["0xe2", "0x88", "0xbc"]},
    {"Name": "simdot", "Characters": ["0xe2", "0xa9", "0xaa"]},
    {"Name": "sime", "Characters": ["0xe2", "0x89", "0x83"]},
    {"Name": "simeq", "Characters": ["0xe2", "0x89", "0x83"]},
    {"Name": "simg", "Characters": ["0xe2", "0xaa", "0x9e"]},
    {"Name": "simgE", "Characters": ["0xe2", "0xaa", "0xa0"]},
    {"Name": "siml", "Characters": ["0xe2", "0xaa", "0x9d"]},
    {"Name": "simlE", "Characters": ["0xe2", "0xaa", "0x9f"]},
    {"Name": "simne", "Characters": ["0xe2", "0x89", "0x86"]},
    {"Name": "simplus", "Characters": ["0xe2", "0xa8", "0xa4"]},
    {"Name": "simrarr", "Characters": ["0xe2", "0xa5", "0xb2"]},
    {"Name": "slarr", "Characters": ["0xe2", "0x86", "0x90"]},
    {"Name": "smallsetminus", "Characters": ["0xe2", "0x88", "0x96"]},
    {"Name": "smashp", "Characters": ["0xe2", "0xa8", "0xb3"]},
    {"Name": "smeparsl", "Characters": ["0xe2", "0xa7", "0xa4"]},
    {"Name": "smid", "Characters": ["0xe2", "0x88", "0xa3"]},
    {"Name": "smile", "Characters": ["0xe2", "0x8c", "0xa3"]},
    {"Name": "smt", "Characters": ["0xe2", "0xaa", "0xaa"]},
    {"Name": "smte", "Characters": ["0xe2", "0xaa", "0xac"]},
    {"Name": "smtes", "Characters": ["0xe2", "0xaa", "0xac", "0xef", "0xb8", "0x80"]},
    {"Name": "softcy", "Characters": ["0xd1", "0x8c"]},
    {"Name": "sol", "Characters": ["0x2f"]},
    {"Name": "solb", "Characters": ["0xe2", "0xa7", "0x84"]},
    {"Name": "solbar", "Characters": ["0xe2", "0x8c", "0xbf"]},
    {"Name": "sopf", "Characters": ["0xf0", "0x9d", "0x95", "0xa4"]},
    {"Name": "spades", "Characters": ["0xe2", "0x99", "0xa0"]},
    {"Name": "spadesuit", "Characters": ["0xe2", "0x99", "0xa0"]},
    {"Name": "spar", "Characters": ["0xe2", "0x88", "0xa5"]},
    {"Name": "sqcap", "Characters": ["0xe2", "0x8a", "0x93"]},
    {"Name": "sqcaps", "Characters": ["0xe2", "0x8a", "0x93", "0xef", "0xb8", "0x80"]},
    {"Name": "sqcup", "Characters": ["0xe2", "0x8a", "0x94"]},
    {"Name": "sqcups", "Characters": ["0xe2", "0x8a", "0x94", "0xef", "0xb8", "0x80"]},
    {"Name": "sqsub", "Characters": ["0xe2", "0x8a", "0x8f"]},
    {"Name": "sqsube", "Characters": ["0xe2", "0x8a", "0x91"]},
    {"Name": "sqsubset", "Characters": ["0xe2", "0x8a", "0x8f"]},
    {"Name": "sqsubseteq", "Characters": ["0xe2", "0x8a", "0x91"]},
    {"Name": "sqsup", "Characters": ["0xe2", "0x8a", "0x90"]},
    {"Name": "sqsupe", "Characters": ["0xe2", "0x8a", "0x92"]},
    {"Name": "sqsupset", "Characters": ["0xe2", "0x8a", "0x90"]},
    {"Name": "sqsupseteq", "Characters": ["0xe2", "0x8a", "0x92"]},
    {"Name": "squ", "Characters": ["0xe2", "0x96", "0xa1"]},
    {"Name": "square", "Characters": ["0xe2", "0x96", "0xa1"]},
    {"Name": "squarf", "Characters": ["0xe2", "0x96", "0xaa"]},
    {"Name": "squf", "Characters": ["0xe2", "0x96", "0xaa"]},
    {"Name": "srarr", "Characters": ["0xe2", "0x86", "0x92"]},
    {"Name": "sscr", "Characters": ["0xf0", "0x9d", "0x93", "0x88"]},
    {"Name": "ssetmn", "Characters": ["0xe2", "0x88", "0x96"]},
    {"Name": "ssmile", "Characters": ["0xe2", "0x8c", "0xa3"]},
    {"Name": "sstarf", "Characters": ["0xe2", "0x8b", "0x86"]},
    {"Name": "star", "Characters": ["0xe2", "0x98", "0x86"]},
    {"Name": "starf", "Characters": ["0xe2", "0x98", "0x85"]},
    {"Name": "straightepsilon", "Characters": ["0xcf", "0xb5"]},
    {"Name": "straightphi", "Characters": ["0xcf", "0x95"]},
    {"Name": "strns", "Characters": ["0xc2", "0xaf"]},
    {"Name": "sub", "Characters": ["0xe2", "0x8a", "0x82"]},
    {"Name": "subE", "Characters": ["0xe2", "0xab", "0x85"]},
    {"Name": "subdot", "Characters": ["0xe2", "0xaa", "0xbd"]},
    {"Name": "sube", "Characters": ["0xe2", "0x8a", "0x86"]},
    {"Name": "subedot", "Characters": ["0xe2", "0xab", "0x83"]},
    {"Name": "submult", "Characters": ["0xe2", "0xab", "0x81"]},
    {"Name": "subnE", "Characters": ["0xe2", "0xab", "0x8b"]},
    {"Name": "subne", "Characters": ["0xe2", "0x8a", "0x8a"]},
    {"Name": "subplus", "Characters": ["0xe2", "0xaa", "0xbf"]},
    {"Name": "subrarr", "Characters": ["0xe2", "0xa5", "0xb9"]},
    {"Name": "subset", "Characters": ["0xe2", "0x8a", "0x82"]},
    {"Name": "subseteq", "Characters": ["0xe2", "0x8a", "0x86"]},
    {"Name": "subseteqq", "Characters": ["0xe2", "0xab", "0x85"]},
    {"Name": "subsetneq", "Characters": ["0xe2", "0x8a", "0x8a"]},
    {"Name": "subsetneqq", "Characters": ["0xe2", "0xab", "0x8b"]},
    {"Name": "subsim", "Characters": ["0xe2", "0xab", "0x87"]},
    {"Name": "subsub", "Characters": ["0xe2", "0xab", "0x95"]},
    {"Name": "subsup", "Characters": ["0xe2", "0xab", "0x93"]},
    {"Name": "succ", "Characters": ["0xe2", "0x89", "0xbb"]},
    {"Name": "succapprox", "Characters": ["0xe2", "0xaa", "0xb8"]},
    {"Name": "succcurlyeq", "Characters": ["0xe2", "0x89", "0xbd"]},
    {"Name": "succeq", "Characters": ["0xe2", "0xaa", "0xb0"]},
    {"Name": "succnapprox", "Characters": ["0xe2", "0xaa", "0xba"]},
    {"Name": "succneqq", "Characters": ["0xe2", "0xaa", "0xb6"]},
    {"Name": "succnsim", "Characters": ["0xe2", "0x8b", "0xa9"]},
    {"Name": "succsim", "Characters": ["0xe2", "0x89", "0xbf"]},
    {"Name": "sum", "Characters": ["0xe2", "0x88", "0x91"]},
    {"Name": "sung", "Characters": ["0xe2", "0x99", "0xaa"]},
    {"Name": "sup", "Characters": ["0xe2", "0x8a", "0x83"]},
    {"Name": "sup1", "Characters": ["0xc2", "0xb9"]},
    {"Name": "sup2", "Characters": ["0xc2", "0xb2"]},
    {"Name": "sup3", "Characters": ["0xc2", "0xb3"]},
    {"Name": "supE", "Characters": ["0xe2", "0xab", "0x86"]},
    {"Name": "supdot", "Characters": ["0xe2", "0xaa", "0xbe"]},
    {"Name": "supdsub", "Characters": ["0xe2", "0xab", "0x98"]},
    {"Name": "supe", "Characters": ["0xe2", "0x8a", "0x87"]},
    {"Name": "supedot", "Characters": ["0xe2", "0xab", "0x84"]},
    {"Name": "suphsol", "Characters": ["0xe2", "0x9f", "0x89"]},
    {"Name": "suphsub", "Characters": ["0xe2", "0xab", "0x97"]},
    {"Name": "suplarr", "Characters": ["0xe2", "0xa5", "0xbb"]},
    {"Name": "supmult", "Characters": ["0xe2", "0xab", "0x82"]},
    {"Name": "supnE", "Characters": ["0xe2", "0xab", "0x8c"]},
    {"Name": "supne", "Characters": ["0xe2", "0x8a", "0x8b"]},
    {"Name": "supplus", "Characters": ["0xe2", "0xab", "0x80"]},
    {"Name": "supset", "Characters": ["0xe2", "0x8a", "0x83"]},
    {"Name": "supseteq", "Characters": ["0xe2", "0x8a", "0x87"]},
    {"Name": "supseteqq", "Characters": ["0xe2", "0xab", "0x86"]},
    {"Name": "supsetneq", "Characters": ["0xe2", "0x8a", "0x8b"]},
    {"Name": "supsetneqq", "Characters": ["0xe2", "0xab", "0x8c"]},
    {"Name": "supsim", "Characters": ["0xe2", "0xab", "0x88"]},
    {"Name": "supsub", "Characters": ["0xe2", "0xab", "0x94"]},
    {"Name": "supsup", "Characters": ["0xe2", "0xab", "0x96"]},
    {"Name": "swArr", "Characters": ["0xe2", "0x87", "0x99"]},
    {"Name": "swarhk", "Characters": ["0xe2", "0xa4", "0xa6"]},
    {"Name": "swarr", "Characters": ["0xe2", "0x86", "0x99"]},
    {"Name": "swarrow", "Characters": ["0xe2", "0x86", "0x99"]},
    {"Name": "swnwar", "Characters": ["0xe2", "0xa4", "0xaa"]},
    {"Name": "szlig", "Characters": ["0xc3", "0x9f"]},
    {"Name": "target", "Characters": ["0xe2", "0x8c", "0x96"]},
    {"Name": "tau", "Characters": ["0xcf", "0x84"]},
    {"Name": "tbrk", "Characters": ["0xe2", "0x8e", "0xb4"]},
    {"Name": "tcaron", "Characters": ["0xc5", "0xa5"]},
    {"Name": "tcedil", "Characters": ["0xc5", "0xa3"]},
    {"Name": "tcy", "Characters": ["0xd1", "0x82"]},
    {"Name": "tdot", "Characters": ["0xe2", "0x83", "0x9b"]},
    {"Name": "telrec", "Characters": ["0xe2", "0x8c", "0x95"]},
    {"Name": "tfr", "Characters": ["0xf0", "0x9d", "0x94", "0xb1"]},
    {"Name": "there4", "Characters": ["0xe2", "0x88", "0xb4"]},
    {"Name": "therefore", "Characters": ["0xe2", "0x88", "0xb4"]},
    {"Name": "theta", "Characters": ["0xce", "0xb8"]},
    {"Name": "thetasym", "Characters": ["0xcf", "0x91"]},
    {"Name": "thetav", "Characters": ["0xcf", "0x91"]},
    {"Name": "thickapprox", "Characters": ["0xe2", "0x89", "0x88"]},
    {"Name": "thicksim", "Characters": ["0xe2", "0x88", "0xbc"]},
    {"Name": "thinsp", "Characters": ["0xe2", "0x80", "0x89"]},
    {"Name": "thkap", "Characters": ["0xe2", "0x89", "0x88"]},
    {"Name": "thksim", "Characters": ["0xe2", "0x88", "0xbc"]},
    {"Name": "thorn", "Characters": ["0xc3", "0xbe"]},
    {"Name": "tilde", "Characters": ["0xcb", "0x9c"]},
    {"Name": "times", "Characters": ["0xc3", "0x97"]},
    {"Name": "timesb", "Characters": ["0xe2", "0x8a", "0xa0"]},
    {"Name": "timesbar", "Characters": ["0xe2", "0xa8", "0xb1"]},
    {"Name": "timesd", "Characters": ["0xe2", "0xa8", "0xb0"]},
    {"Name": "tint", "Characters": ["0xe2", "0x88", "0xad"]},
    {"Name": "toea", "Characters": ["0xe2", "0xa4", "0xa8"]},
    {"Name": "top", "Characters": ["0xe2", "0x8a", "0xa4"]},
    {"Name": "topbot", "Characters": ["0xe2", "0x8c", "0xb6"]},
    {"Name": "topcir", "Characters": ["0xe2", "0xab", "0xb1"]},
    {"Name": "topf", "Characters": ["0xf0", "0x9d", "0x95", "0xa5"]},
    {"Name": "topfork", "Characters": ["0xe2", "0xab", "0x9a"]},
    {"Name": "tosa", "Characters": ["0xe2", "0xa4", "0xa9"]},
    {"Name": "tprime", "Characters": ["0xe2", "0x80", "0xb4"]},
    {"Name": "trade", "Characters": ["0xe2", "0x84", "0xa2"]},
    {"Name": "triangle", "Characters": ["0xe2", "0x96", "0xb5"]},
    {"Name": "triangledown", "Characters": ["0xe2", "0x96", "0xbf"]},
    {"Name": "triangleleft", "Characters": ["0xe2", "0x97", "0x83"]},
    {"Name": "trianglelefteq", "Characters": ["0xe2", "0x8a", "0xb4"]},
    {"Name": "triangleq", "Characters": ["0xe2", "0x89", "0x9c"]},
    {"Name": "triangleright", "Characters": ["0xe2", "0x96", "0xb9"]},
    {"Name": "trianglerighteq", "Characters": ["0xe2", "0x8a", "0xb5"]},
    {"Name": "tridot", "Characters": ["0xe2", "0x97", "0xac"]},
    {"Name": "trie", "Characters": ["0xe2", "0x89", "0x9c"]},
    {"Name": "triminus", "Characters": ["0xe2", "0xa8", "0xba"]},
    {"Name": "triplus", "Characters": ["0xe2", "0xa8", "0xb9"]},
    {"Name": "trisb", "Characters": ["0xe2", "0xa7", "0x8d"]},
    {"Name": "tritime", "Characters": ["0xe2", "0xa8", "0xbb"]},
    {"Name": "trpezium", "Characters": ["0xe2", "0x8f", "0xa2"]},
    {"Name": "tscr", "Characters": ["0xf0", "0x9d", "0x93", "0x89"]},
    {"Name": "tscy", "Characters": ["0xd1", "0x86"]},
    {"Name": "tshcy", "Characters": ["0xd1", "0x9b"]},
    {"Name": "tstrok", "Characters": ["0xc5", "0xa7"]},
    {"Name": "twixt", "Characters": ["0xe2", "0x89", "0xac"]},
    {"Name": "twoheadleftarrow", "Characters": ["0xe2", "0x86", "0x9e"]},
    {"Name": "twoheadrightarrow", "Characters": ["0xe2", "0x86", "0xa0"]},
    {"Name": "uArr", "Characters": ["0xe2", "0x87", "0x91"]},
    {"Name": "uHar", "Characters": ["0xe2", "0xa5", "0xa3"]},
    {"Name": "uacute", "Characters": ["0xc3", "0xba"]},
    {"Name": "uarr", "Characters": ["0xe2", "0x86", "0x91"]},
    {"Name": "ubrcy", "Characters": ["0xd1", "0x9e"]},
    {"Name": "ubreve", "Characters": ["0xc5", "0xad"]},
    {"Name": "ucirc", "Characters": ["0xc3", "0xbb"]},
    {"Name": "ucy", "Characters": ["0xd1", "0x83"]},
    {"Name": "udarr", "Characters": ["0xe2", "0x87", "0x85"]},
    {"Name": "udblac", "Characters": ["0xc5", "0xb1"]},
    {"Name": "udhar", "Characters": ["0xe2", "0xa5", "0xae"]},
    {"Name": "ufisht", "Characters": ["0xe2", "0xa5", "0xbe"]},
    {"Name": "ufr", "Characters": ["0xf0", "0x9d", "0x94", "0xb2"]},
    {"Name": "ugrave", "Characters": ["0xc3", "0xb9"]},
    {"Name": "uharl", "Characters": ["0xe2", "0x86", "0xbf"]},
    {"Name": "uharr", "Characters": ["0xe2", "0x86", "0xbe"]},
    {"Name": "uhblk", "Characters": ["0xe2", "0x96", "0x80"]},
    {"Name": "ulcorn", "Characters": ["0xe2", "0x8c", "0x9c"]},
    {"Name": "ulcorner", "Characters": ["0xe2", "0x8c", "0x9c"]},
    {"Name": "ulcrop", "Characters": ["0xe2", "0x8c", "0x8f"]},
    {"Name": "ultri", "Characters": ["0xe2", "0x97", "0xb8"]},
    {"Name": "umacr", "Characters": ["0xc5", "0xab"]},
    {"Name": "uml", "Characters": ["0xc2", "0xa8"]},
    {"Name": "uogon", "Characters": ["0xc5", "0xb3"]},
    {"Name": "uopf", "Characters": ["0xf0", "0x9d", "0x95", "0xa6"]},
    {"Name": "uparrow", "Characters": ["0xe2", "0x86", "0x91"]},
    {"Name": "updownarrow", "Characters": ["0xe2", "0x86", "0x95"]},
    {"Name": "upharpoonleft", "Characters": ["0xe2", "0x86", "0xbf"]},
    {"Name": "upharpoonright", "Characters": ["0xe2", "0x86", "0xbe"]},
    {"Name": "uplus", "Characters": ["0xe2", "0x8a", "0x8e"]},
    {"Name": "upsi", "Characters": ["0xcf", "0x85"]},
    {"Name": "upsih", "Characters": ["0xcf", "0x92"]},
    {"Name": "upsilon", "Characters": ["0xcf", "0x85"]},
    {"Name": "upuparrows", "Characters": ["0xe2", "0x87", "0x88"]},
    {"Name": "urcorn", "Characters": ["0xe2", "0x8c", "0x9d"]},
    {"Name": "urcorner", "Characters": ["0xe2", "0x8c", "0x9d"]},
    {"Name": "urcrop", "Characters": ["0xe2", "0x8c", "0x8e"]},
    {"Name": "uring", "Characters": ["0xc5", "0xaf"]},
    {"Name": "urtri", "Characters": ["0xe2", "0x97", "0xb9"]},
    {"Name": "uscr", "Characters": ["0xf0", "0x9d", "0x93", "0x8a"]},
    {"Name": "utdot", "Characters": ["0xe2", "0x8b", "0xb0"]},
    {"Name": "utilde", "Characters": ["0xc5", "0xa9"]},
    {"Name": "utri", "Characters": ["0xe2", "0x96", "0xb5"]},
    {"Name": "utrif", "Characters": ["0xe2", "0x96", "0xb4"]},
    {"Name": "uuarr", "Characters": ["0xe2", "0x87", "0x88"]},
    {"Name": "uuml", "Characters": ["0xc3", "0xbc"]},
    {"Name": "uwangle", "Characters": ["0xe2", "0xa6", "0xa7"]},
    {"Name": "vArr", "Characters": ["0xe2", "0x87", "0x95"]},
    {"Name": "vBar", "Characters": ["0xe2", "0xab", "0xa8"]},
    {"Name": "vBarv", "Characters": ["0xe2", "0xab", "0xa9"]},
    {"Name": "vDash", "Characters": ["0xe2", "0x8a", "0xa8"]},
    {"Name": "vangrt", "Characters": ["0xe2", "0xa6", "0x9c"]},
    {"Name": "varepsilon", "Characters": ["0xcf", "0xb5"]},
    {"Name": "varkappa", "Characters": ["0xcf", "0xb0"]},
    {"Name": "varnothing", "Characters": ["0xe2", "0x88", "0x85"]},
    {"Name": "varphi", "Characters": ["0xcf", "0x95"]},
    {"Name": "varpi", "Characters": ["0xcf", "0x96"]},
    {"Name": "varpropto", "Characters": ["0xe2", "0x88", "0x9d"]},
    {"Name": "varr", "Characters": ["0xe2", "0x86", "0x95"]},
    {"Name": "varrho", "Characters": ["0xcf", "0xb1"]},
    {"Name": "varsigma", "Characters": ["0xcf", "0x82"]},
    {"Name": "varsubsetneq", "Characters": ["0xe2", "0x8a", "0x8a", "0xef", "0xb8", "0x80"]},
    {"Name": "varsubsetneqq", "Characters": ["0xe2", "0xab", "0x8b", "0xef", "0xb8", "0x80"]},
    {"Name": "varsupsetneq", "Characters": ["0xe2", "0x8a", "0x8b", "0xef", "0xb8", "0x80"]},
    {"Name": "varsupsetneqq", "Characters": ["0xe2", "0xab", "0x8c", "0xef", "0xb8", "0x80"]},
    {"Name": "vartheta", "Characters": ["0xcf", "0x91"]},
    {"Name": "vartriangleleft", "Characters": ["0xe2", "0x8a", "0xb2"]},
    {"Name": "vartriangleright", "Characters": ["0xe2", "0x8a", "0xb3"]},
    {"Name": "vcy", "Characters": ["0xd0", "0xb2"]},
    {"Name": "vdash", "Characters": ["0xe2", "0x8a", "0xa2"]},
    {"Name": "vee", "Characters": ["0xe2", "0x88", "0xa8"]},
    {"Name": "veebar", "Characters": ["0xe2", "0x8a", "0xbb"]},
    {"Name": "veeeq", "Characters": ["0xe2", "0x89", "0x9a"]},
    {"Name": "vellip", "Characters": ["0xe2", "0x8b", "0xae"]},
    {"Name": "verbar", "Characters": ["0x7c"]},
    {"Name": "vert", "Characters": ["0x7c"]},
    {"Name": "vfr", "Characters": ["0xf0", "0x9d", "0x94", "0xb3"]},
    {"Name": "vltri", "Characters": ["0xe2", "0x8a", "0xb2"]},
    {"Name": "vnsub", "Characters": ["0xe2", "0x8a", "0x82", "0xe2", "0x83", "0x92"]},
    {"Name": "vnsup", "Characters": ["0xe2", "0x8a", "0x83", "0xe2", "0x83", "0x92"]},
    {"Name": "vopf", "Characters": ["0xf0", "0x9d", "0x95", "0xa7"]},
    {"Name": "vprop", "Characters": ["0xe2", "0x88", "0x9d"]},
    {"Name": "vrtri", "Characters": ["0xe2", "0x8a", "0xb3"]},
    {"Name": "vscr", "Characters": ["0xf0", "0x9d", "0x93", "0x8b"]},
    {"Name": "vsubnE", "Characters": ["0xe2", "0xab", "0x8b", "0xef", "0xb8", "0x80"]},
    {"Name": "vsubne", "Characters": ["0xe2", "0x8a", "0x8a", "0xef", "0xb8", "0x80"]},
    {"Name": "vsupnE", "Characters": ["0xe2", "0xab", "0x8c", "0xef", "0xb8", "0x80"]},
    {"Name": "vsupne", "Characters": ["0xe2", "0x8a", "0x8b", "0xef", "0xb8", "0x80"]},
    {"Name": "vzigzag", "Characters": ["0xe2", "0xa6", "0x9a"]},
    {"Name": "wcirc", "Characters": ["0xc5", "0xb5"]},
    {"Name": "wedbar", "Characters": ["0xe2", "0xa9", "0x9f"]},
    {"Name": "wedge", "Characters": ["0xe2", "0x88", "0xa7"]},
    {"Name": "wedgeq", "Characters": ["0xe2", "0x89", "0x99"]},
    {"Name": "weierp", "Characters": ["0xe2", "0x84", "0x98"]},
    {"Name": "wfr", "Characters": ["0xf0", "0x9d", "0x94", "0xb4"]},
    {"Name": "wopf", "Characters": ["0xf0", "0x9d", "0x95", "0xa8"]},
    {"Name": "wp", "Characters": ["0xe2", "0x84", "0x98"]},
    {"Name": "wr", "Characters": ["0xe2", "0x89", "0x80"]},
    {"Name": "wreath", "Characters": ["0xe2", "0x89", "0x80"]},
    {"Name": "wscr", "Characters": ["0xf0", "0x9d", "0x93", "0x8c"]},
    {"Name": "xcap", "Characters": ["0xe2", "0x8b", "0x82"]},
    {"Name": "xcirc", "Characters": ["0xe2", "0x97", "0xaf"]},
    {"Name": "xcup", "Characters": ["0xe2", "0x8b", "0x83"]},
    {"Name": "xdtri", "Characters": ["0xe2", "0x96", "0xbd"]},
    {"Name": "xfr", "Characters": ["0xf0", "0x9d", "0x94", "0xb5"]},
    {"Name": "xhArr", "Characters": ["0xe2", "0x9f", "0xba"]},
    {"Name": "xharr", "Characters": ["0xe2", "0x9f", "0xb7"]},
    {"Name": "xi", "Characters": ["0xce", "0xbe"]},
    {"Name": "xlArr", "Characters": ["0xe2", "0x9f", "0xb8"]},
    {"Name": "xlarr", "Characters": ["0xe2", "0x9f", "0xb5"]},
    {"Name": "xmap", "Characters": ["0xe2", "0x9f", "0xbc"]},
    {"Name": "xnis", "Characters": ["0xe2", "0x8b", "0xbb"]},
    {"Name": "xodot", "Characters": ["0xe2", "0xa8", "0x80"]},
    {"Name": "xopf", "Characters": ["0xf0", "0x9d", "0x95", "0xa9"]},
    {"Name": "xoplus", "Characters": ["0xe2", "0xa8", "0x81"]},
    {"Name": "xotime", "Characters": ["0xe2", "0xa8", "0x82"]},
    {"Name": "xrArr", "Characters": ["0xe2", "0x9f", "0xb9"]},
    {"Name": "xrarr", "Characters": ["0xe2", "0x9f", "0xb6"]},
    {"Name": "xscr", "Characters": ["0xf0", "0x9d", "0x93", "0x8d"]},
    {"Name": "xsqcup", "Characters": ["0xe2", "0xa8", "0x86"]},
    {"Name": "xuplus", "Characters": ["0xe2", "0xa8", "0x84"]},
    {"Name": "xutri", "Characters": ["0xe2", "0x96", "0xb3"]},
    {"Name": "xvee", "Characters": ["0xe2", "0x8b", "0x81"]},
    {"Name": "xwedge", "Characters": ["0xe2", "0x8b", "0x80"]},
    {"Name": "yacute", "Characters": ["0xc3", "0xbd"]},
    {"Name": "yacy", "Characters": ["0xd1", "0x8f"]},
    {"Name": "ycirc", "Characters": ["0xc5", "0xb7"]},
    {"Name": "ycy", "Characters": ["0xd1", "0x8b"]},
    {"Name": "yen", "Characters": ["0xc2", "0xa5"]},
    {"Name": "yfr", "Characters": ["0xf0", "0x9d", "0x94", "0xb6"]},
    {"Name": "yicy", "Characters": ["0xd1", "0x97"]},
    {"Name": "yopf", "Characters": ["0xf0", "0x9d", "0x95", "0xaa"]},
    {"Name": "yscr", "Characters": ["0xf0", "0x9d", "0x93", "0x8e"]},
    {"Name": "yucy", "Characters": ["0xd1", "0x8e"]},
    {"Name": "yuml", "Characters": ["0xc3", "0xbf"]},
    {"Name": "zacute", "Characters": ["0xc5", "0xba"]},
    {"Name": "zcaron", "Characters": ["0xc5", "0xbe"]},
    {"Name": "zcy", "Characters": ["0xd0", "0xb7"]},
    {"Name": "zdot", "Characters": ["0xc5", "0xbc"]},
    {"Name": "zeetrf", "Characters": ["0xe2", "0x84", "0xa8"]},
    {"Name": "zeta", "Characters": ["0xce", "0xb6"]},
    {"Name": "zfr", "Characters": ["0xf0", "0x9d", "0x94", "0xb7"]},
    {"Name": "zhcy", "Characters": ["0xd0", "0xb6"]},
    {"Name": "zigrarr", "Characters": ["0xe2", "0x87", "0x9d"]},
    {"Name": "zopf", "Characters": ["0xf0", "0x9d", "0x95", "0xab"]},
    {"Name": "zscr", "Characters": ["0xf0", "0x9d", "0x93", "0x8f"]},
    {"Name": "zwj", "Characters": ["0xe2", "0x80", "0x8d"]},
    {"Name": "zwnj", "Characters": ["0xe2", "0x80", "0x8c"]}
  ]
}
</file>

<file path="_tools/main.go">
package main

import (
	"fmt"
	"os"
)

func main() {

	var args []string
	cmd := "-h"
	if len(os.Args) > 1 {
		cmd = os.Args[1]
	}
	if len(os.Args) > 2 {
		args = os.Args[2:]
	}

	switch cmd {
	case "oss-fuzz-corpus":
		ossFuzzCorpusSubCommand(args)
	case "unicode-case-folding-map":
		unicodeCaseFoldingMapSubCommand(args)
	case "emb-structs":
		embStructsSubCommand(args)
	case "-h":
		fallthrough
	default:
		fmt.Fprintf(os.Stderr, `Usage: _tools <subcommand> [options]
subcommands:
  oss-fuzz-corpus
  unicode-case-folding-map
  emb-structs
`)
		os.Exit(1)
	}
}

func usage(u func(), err error) {
	u()
	if err != nil {
		fmt.Fprint(os.Stderr, err)
	}
	os.Exit(1)
}
</file>

<file path="_tools/unicode-case-folding-map.json">
{
  "data": [
    {
      "From": "0x41",
      "To": [
        "97"
      ]
    },
    {
      "From": "0x42",
      "To": [
        "98"
      ]
    },
    {
      "From": "0x43",
      "To": [
        "99"
      ]
    },
    {
      "From": "0x44",
      "To": [
        "100"
      ]
    },
    {
      "From": "0x45",
      "To": [
        "101"
      ]
    },
    {
      "From": "0x46",
      "To": [
        "102"
      ]
    },
    {
      "From": "0x47",
      "To": [
        "103"
      ]
    },
    {
      "From": "0x48",
      "To": [
        "104"
      ]
    },
    {
      "From": "0x49",
      "To": [
        "105"
      ]
    },
    {
      "From": "0x4a",
      "To": [
        "106"
      ]
    },
    {
      "From": "0x4b",
      "To": [
        "107"
      ]
    },
    {
      "From": "0x4c",
      "To": [
        "108"
      ]
    },
    {
      "From": "0x4d",
      "To": [
        "109"
      ]
    },
    {
      "From": "0x4e",
      "To": [
        "110"
      ]
    },
    {
      "From": "0x4f",
      "To": [
        "111"
      ]
    },
    {
      "From": "0x50",
      "To": [
        "112"
      ]
    },
    {
      "From": "0x51",
      "To": [
        "113"
      ]
    },
    {
      "From": "0x52",
      "To": [
        "114"
      ]
    },
    {
      "From": "0x53",
      "To": [
        "115"
      ]
    },
    {
      "From": "0x54",
      "To": [
        "116"
      ]
    },
    {
      "From": "0x55",
      "To": [
        "117"
      ]
    },
    {
      "From": "0x56",
      "To": [
        "118"
      ]
    },
    {
      "From": "0x57",
      "To": [
        "119"
      ]
    },
    {
      "From": "0x58",
      "To": [
        "120"
      ]
    },
    {
      "From": "0x59",
      "To": [
        "121"
      ]
    },
    {
      "From": "0x5a",
      "To": [
        "122"
      ]
    },
    {
      "From": "0xb5",
      "To": [
        "956"
      ]
    },
    {
      "From": "0xc0",
      "To": [
        "224"
      ]
    },
    {
      "From": "0xc1",
      "To": [
        "225"
      ]
    },
    {
      "From": "0xc2",
      "To": [
        "226"
      ]
    },
    {
      "From": "0xc3",
      "To": [
        "227"
      ]
    },
    {
      "From": "0xc4",
      "To": [
        "228"
      ]
    },
    {
      "From": "0xc5",
      "To": [
        "229"
      ]
    },
    {
      "From": "0xc6",
      "To": [
        "230"
      ]
    },
    {
      "From": "0xc7",
      "To": [
        "231"
      ]
    },
    {
      "From": "0xc8",
      "To": [
        "232"
      ]
    },
    {
      "From": "0xc9",
      "To": [
        "233"
      ]
    },
    {
      "From": "0xca",
      "To": [
        "234"
      ]
    },
    {
      "From": "0xcb",
      "To": [
        "235"
      ]
    },
    {
      "From": "0xcc",
      "To": [
        "236"
      ]
    },
    {
      "From": "0xcd",
      "To": [
        "237"
      ]
    },
    {
      "From": "0xce",
      "To": [
        "238"
      ]
    },
    {
      "From": "0xcf",
      "To": [
        "239"
      ]
    },
    {
      "From": "0xd0",
      "To": [
        "240"
      ]
    },
    {
      "From": "0xd1",
      "To": [
        "241"
      ]
    },
    {
      "From": "0xd2",
      "To": [
        "242"
      ]
    },
    {
      "From": "0xd3",
      "To": [
        "243"
      ]
    },
    {
      "From": "0xd4",
      "To": [
        "244"
      ]
    },
    {
      "From": "0xd5",
      "To": [
        "245"
      ]
    },
    {
      "From": "0xd6",
      "To": [
        "246"
      ]
    },
    {
      "From": "0xd8",
      "To": [
        "248"
      ]
    },
    {
      "From": "0xd9",
      "To": [
        "249"
      ]
    },
    {
      "From": "0xda",
      "To": [
        "250"
      ]
    },
    {
      "From": "0xdb",
      "To": [
        "251"
      ]
    },
    {
      "From": "0xdc",
      "To": [
        "252"
      ]
    },
    {
      "From": "0xdd",
      "To": [
        "253"
      ]
    },
    {
      "From": "0xde",
      "To": [
        "254"
      ]
    },
    {
      "From": "0xdf",
      "To": [
        "115",
        "115"
      ]
    },
    {
      "From": "0x100",
      "To": [
        "257"
      ]
    },
    {
      "From": "0x102",
      "To": [
        "259"
      ]
    },
    {
      "From": "0x104",
      "To": [
        "261"
      ]
    },
    {
      "From": "0x106",
      "To": [
        "263"
      ]
    },
    {
      "From": "0x108",
      "To": [
        "265"
      ]
    },
    {
      "From": "0x10a",
      "To": [
        "267"
      ]
    },
    {
      "From": "0x10c",
      "To": [
        "269"
      ]
    },
    {
      "From": "0x10e",
      "To": [
        "271"
      ]
    },
    {
      "From": "0x110",
      "To": [
        "273"
      ]
    },
    {
      "From": "0x112",
      "To": [
        "275"
      ]
    },
    {
      "From": "0x114",
      "To": [
        "277"
      ]
    },
    {
      "From": "0x116",
      "To": [
        "279"
      ]
    },
    {
      "From": "0x118",
      "To": [
        "281"
      ]
    },
    {
      "From": "0x11a",
      "To": [
        "283"
      ]
    },
    {
      "From": "0x11c",
      "To": [
        "285"
      ]
    },
    {
      "From": "0x11e",
      "To": [
        "287"
      ]
    },
    {
      "From": "0x120",
      "To": [
        "289"
      ]
    },
    {
      "From": "0x122",
      "To": [
        "291"
      ]
    },
    {
      "From": "0x124",
      "To": [
        "293"
      ]
    },
    {
      "From": "0x126",
      "To": [
        "295"
      ]
    },
    {
      "From": "0x128",
      "To": [
        "297"
      ]
    },
    {
      "From": "0x12a",
      "To": [
        "299"
      ]
    },
    {
      "From": "0x12c",
      "To": [
        "301"
      ]
    },
    {
      "From": "0x12e",
      "To": [
        "303"
      ]
    },
    {
      "From": "0x130",
      "To": [
        "105",
        "775"
      ]
    },
    {
      "From": "0x132",
      "To": [
        "307"
      ]
    },
    {
      "From": "0x134",
      "To": [
        "309"
      ]
    },
    {
      "From": "0x136",
      "To": [
        "311"
      ]
    },
    {
      "From": "0x139",
      "To": [
        "314"
      ]
    },
    {
      "From": "0x13b",
      "To": [
        "316"
      ]
    },
    {
      "From": "0x13d",
      "To": [
        "318"
      ]
    },
    {
      "From": "0x13f",
      "To": [
        "320"
      ]
    },
    {
      "From": "0x141",
      "To": [
        "322"
      ]
    },
    {
      "From": "0x143",
      "To": [
        "324"
      ]
    },
    {
      "From": "0x145",
      "To": [
        "326"
      ]
    },
    {
      "From": "0x147",
      "To": [
        "328"
      ]
    },
    {
      "From": "0x149",
      "To": [
        "700",
        "110"
      ]
    },
    {
      "From": "0x14a",
      "To": [
        "331"
      ]
    },
    {
      "From": "0x14c",
      "To": [
        "333"
      ]
    },
    {
      "From": "0x14e",
      "To": [
        "335"
      ]
    },
    {
      "From": "0x150",
      "To": [
        "337"
      ]
    },
    {
      "From": "0x152",
      "To": [
        "339"
      ]
    },
    {
      "From": "0x154",
      "To": [
        "341"
      ]
    },
    {
      "From": "0x156",
      "To": [
        "343"
      ]
    },
    {
      "From": "0x158",
      "To": [
        "345"
      ]
    },
    {
      "From": "0x15a",
      "To": [
        "347"
      ]
    },
    {
      "From": "0x15c",
      "To": [
        "349"
      ]
    },
    {
      "From": "0x15e",
      "To": [
        "351"
      ]
    },
    {
      "From": "0x160",
      "To": [
        "353"
      ]
    },
    {
      "From": "0x162",
      "To": [
        "355"
      ]
    },
    {
      "From": "0x164",
      "To": [
        "357"
      ]
    },
    {
      "From": "0x166",
      "To": [
        "359"
      ]
    },
    {
      "From": "0x168",
      "To": [
        "361"
      ]
    },
    {
      "From": "0x16a",
      "To": [
        "363"
      ]
    },
    {
      "From": "0x16c",
      "To": [
        "365"
      ]
    },
    {
      "From": "0x16e",
      "To": [
        "367"
      ]
    },
    {
      "From": "0x170",
      "To": [
        "369"
      ]
    },
    {
      "From": "0x172",
      "To": [
        "371"
      ]
    },
    {
      "From": "0x174",
      "To": [
        "373"
      ]
    },
    {
      "From": "0x176",
      "To": [
        "375"
      ]
    },
    {
      "From": "0x178",
      "To": [
        "255"
      ]
    },
    {
      "From": "0x179",
      "To": [
        "378"
      ]
    },
    {
      "From": "0x17b",
      "To": [
        "380"
      ]
    },
    {
      "From": "0x17d",
      "To": [
        "382"
      ]
    },
    {
      "From": "0x17f",
      "To": [
        "115"
      ]
    },
    {
      "From": "0x181",
      "To": [
        "595"
      ]
    },
    {
      "From": "0x182",
      "To": [
        "387"
      ]
    },
    {
      "From": "0x184",
      "To": [
        "389"
      ]
    },
    {
      "From": "0x186",
      "To": [
        "596"
      ]
    },
    {
      "From": "0x187",
      "To": [
        "392"
      ]
    },
    {
      "From": "0x189",
      "To": [
        "598"
      ]
    },
    {
      "From": "0x18a",
      "To": [
        "599"
      ]
    },
    {
      "From": "0x18b",
      "To": [
        "396"
      ]
    },
    {
      "From": "0x18e",
      "To": [
        "477"
      ]
    },
    {
      "From": "0x18f",
      "To": [
        "601"
      ]
    },
    {
      "From": "0x190",
      "To": [
        "603"
      ]
    },
    {
      "From": "0x191",
      "To": [
        "402"
      ]
    },
    {
      "From": "0x193",
      "To": [
        "608"
      ]
    },
    {
      "From": "0x194",
      "To": [
        "611"
      ]
    },
    {
      "From": "0x196",
      "To": [
        "617"
      ]
    },
    {
      "From": "0x197",
      "To": [
        "616"
      ]
    },
    {
      "From": "0x198",
      "To": [
        "409"
      ]
    },
    {
      "From": "0x19c",
      "To": [
        "623"
      ]
    },
    {
      "From": "0x19d",
      "To": [
        "626"
      ]
    },
    {
      "From": "0x19f",
      "To": [
        "629"
      ]
    },
    {
      "From": "0x1a0",
      "To": [
        "417"
      ]
    },
    {
      "From": "0x1a2",
      "To": [
        "419"
      ]
    },
    {
      "From": "0x1a4",
      "To": [
        "421"
      ]
    },
    {
      "From": "0x1a6",
      "To": [
        "640"
      ]
    },
    {
      "From": "0x1a7",
      "To": [
        "424"
      ]
    },
    {
      "From": "0x1a9",
      "To": [
        "643"
      ]
    },
    {
      "From": "0x1ac",
      "To": [
        "429"
      ]
    },
    {
      "From": "0x1ae",
      "To": [
        "648"
      ]
    },
    {
      "From": "0x1af",
      "To": [
        "432"
      ]
    },
    {
      "From": "0x1b1",
      "To": [
        "650"
      ]
    },
    {
      "From": "0x1b2",
      "To": [
        "651"
      ]
    },
    {
      "From": "0x1b3",
      "To": [
        "436"
      ]
    },
    {
      "From": "0x1b5",
      "To": [
        "438"
      ]
    },
    {
      "From": "0x1b7",
      "To": [
        "658"
      ]
    },
    {
      "From": "0x1b8",
      "To": [
        "441"
      ]
    },
    {
      "From": "0x1bc",
      "To": [
        "445"
      ]
    },
    {
      "From": "0x1c4",
      "To": [
        "454"
      ]
    },
    {
      "From": "0x1c5",
      "To": [
        "454"
      ]
    },
    {
      "From": "0x1c7",
      "To": [
        "457"
      ]
    },
    {
      "From": "0x1c8",
      "To": [
        "457"
      ]
    },
    {
      "From": "0x1ca",
      "To": [
        "460"
      ]
    },
    {
      "From": "0x1cb",
      "To": [
        "460"
      ]
    },
    {
      "From": "0x1cd",
      "To": [
        "462"
      ]
    },
    {
      "From": "0x1cf",
      "To": [
        "464"
      ]
    },
    {
      "From": "0x1d1",
      "To": [
        "466"
      ]
    },
    {
      "From": "0x1d3",
      "To": [
        "468"
      ]
    },
    {
      "From": "0x1d5",
      "To": [
        "470"
      ]
    },
    {
      "From": "0x1d7",
      "To": [
        "472"
      ]
    },
    {
      "From": "0x1d9",
      "To": [
        "474"
      ]
    },
    {
      "From": "0x1db",
      "To": [
        "476"
      ]
    },
    {
      "From": "0x1de",
      "To": [
        "479"
      ]
    },
    {
      "From": "0x1e0",
      "To": [
        "481"
      ]
    },
    {
      "From": "0x1e2",
      "To": [
        "483"
      ]
    },
    {
      "From": "0x1e4",
      "To": [
        "485"
      ]
    },
    {
      "From": "0x1e6",
      "To": [
        "487"
      ]
    },
    {
      "From": "0x1e8",
      "To": [
        "489"
      ]
    },
    {
      "From": "0x1ea",
      "To": [
        "491"
      ]
    },
    {
      "From": "0x1ec",
      "To": [
        "493"
      ]
    },
    {
      "From": "0x1ee",
      "To": [
        "495"
      ]
    },
    {
      "From": "0x1f0",
      "To": [
        "106",
        "780"
      ]
    },
    {
      "From": "0x1f1",
      "To": [
        "499"
      ]
    },
    {
      "From": "0x1f2",
      "To": [
        "499"
      ]
    },
    {
      "From": "0x1f4",
      "To": [
        "501"
      ]
    },
    {
      "From": "0x1f6",
      "To": [
        "405"
      ]
    },
    {
      "From": "0x1f7",
      "To": [
        "447"
      ]
    },
    {
      "From": "0x1f8",
      "To": [
        "505"
      ]
    },
    {
      "From": "0x1fa",
      "To": [
        "507"
      ]
    },
    {
      "From": "0x1fc",
      "To": [
        "509"
      ]
    },
    {
      "From": "0x1fe",
      "To": [
        "511"
      ]
    },
    {
      "From": "0x200",
      "To": [
        "513"
      ]
    },
    {
      "From": "0x202",
      "To": [
        "515"
      ]
    },
    {
      "From": "0x204",
      "To": [
        "517"
      ]
    },
    {
      "From": "0x206",
      "To": [
        "519"
      ]
    },
    {
      "From": "0x208",
      "To": [
        "521"
      ]
    },
    {
      "From": "0x20a",
      "To": [
        "523"
      ]
    },
    {
      "From": "0x20c",
      "To": [
        "525"
      ]
    },
    {
      "From": "0x20e",
      "To": [
        "527"
      ]
    },
    {
      "From": "0x210",
      "To": [
        "529"
      ]
    },
    {
      "From": "0x212",
      "To": [
        "531"
      ]
    },
    {
      "From": "0x214",
      "To": [
        "533"
      ]
    },
    {
      "From": "0x216",
      "To": [
        "535"
      ]
    },
    {
      "From": "0x218",
      "To": [
        "537"
      ]
    },
    {
      "From": "0x21a",
      "To": [
        "539"
      ]
    },
    {
      "From": "0x21c",
      "To": [
        "541"
      ]
    },
    {
      "From": "0x21e",
      "To": [
        "543"
      ]
    },
    {
      "From": "0x220",
      "To": [
        "414"
      ]
    },
    {
      "From": "0x222",
      "To": [
        "547"
      ]
    },
    {
      "From": "0x224",
      "To": [
        "549"
      ]
    },
    {
      "From": "0x226",
      "To": [
        "551"
      ]
    },
    {
      "From": "0x228",
      "To": [
        "553"
      ]
    },
    {
      "From": "0x22a",
      "To": [
        "555"
      ]
    },
    {
      "From": "0x22c",
      "To": [
        "557"
      ]
    },
    {
      "From": "0x22e",
      "To": [
        "559"
      ]
    },
    {
      "From": "0x230",
      "To": [
        "561"
      ]
    },
    {
      "From": "0x232",
      "To": [
        "563"
      ]
    },
    {
      "From": "0x23a",
      "To": [
        "11365"
      ]
    },
    {
      "From": "0x23b",
      "To": [
        "572"
      ]
    },
    {
      "From": "0x23d",
      "To": [
        "410"
      ]
    },
    {
      "From": "0x23e",
      "To": [
        "11366"
      ]
    },
    {
      "From": "0x241",
      "To": [
        "578"
      ]
    },
    {
      "From": "0x243",
      "To": [
        "384"
      ]
    },
    {
      "From": "0x244",
      "To": [
        "649"
      ]
    },
    {
      "From": "0x245",
      "To": [
        "652"
      ]
    },
    {
      "From": "0x246",
      "To": [
        "583"
      ]
    },
    {
      "From": "0x248",
      "To": [
        "585"
      ]
    },
    {
      "From": "0x24a",
      "To": [
        "587"
      ]
    },
    {
      "From": "0x24c",
      "To": [
        "589"
      ]
    },
    {
      "From": "0x24e",
      "To": [
        "591"
      ]
    },
    {
      "From": "0x345",
      "To": [
        "953"
      ]
    },
    {
      "From": "0x370",
      "To": [
        "881"
      ]
    },
    {
      "From": "0x372",
      "To": [
        "883"
      ]
    },
    {
      "From": "0x376",
      "To": [
        "887"
      ]
    },
    {
      "From": "0x37f",
      "To": [
        "1011"
      ]
    },
    {
      "From": "0x386",
      "To": [
        "940"
      ]
    },
    {
      "From": "0x388",
      "To": [
        "941"
      ]
    },
    {
      "From": "0x389",
      "To": [
        "942"
      ]
    },
    {
      "From": "0x38a",
      "To": [
        "943"
      ]
    },
    {
      "From": "0x38c",
      "To": [
        "972"
      ]
    },
    {
      "From": "0x38e",
      "To": [
        "973"
      ]
    },
    {
      "From": "0x38f",
      "To": [
        "974"
      ]
    },
    {
      "From": "0x390",
      "To": [
        "953",
        "776",
        "769"
      ]
    },
    {
      "From": "0x391",
      "To": [
        "945"
      ]
    },
    {
      "From": "0x392",
      "To": [
        "946"
      ]
    },
    {
      "From": "0x393",
      "To": [
        "947"
      ]
    },
    {
      "From": "0x394",
      "To": [
        "948"
      ]
    },
    {
      "From": "0x395",
      "To": [
        "949"
      ]
    },
    {
      "From": "0x396",
      "To": [
        "950"
      ]
    },
    {
      "From": "0x397",
      "To": [
        "951"
      ]
    },
    {
      "From": "0x398",
      "To": [
        "952"
      ]
    },
    {
      "From": "0x399",
      "To": [
        "953"
      ]
    },
    {
      "From": "0x39a",
      "To": [
        "954"
      ]
    },
    {
      "From": "0x39b",
      "To": [
        "955"
      ]
    },
    {
      "From": "0x39c",
      "To": [
        "956"
      ]
    },
    {
      "From": "0x39d",
      "To": [
        "957"
      ]
    },
    {
      "From": "0x39e",
      "To": [
        "958"
      ]
    },
    {
      "From": "0x39f",
      "To": [
        "959"
      ]
    },
    {
      "From": "0x3a0",
      "To": [
        "960"
      ]
    },
    {
      "From": "0x3a1",
      "To": [
        "961"
      ]
    },
    {
      "From": "0x3a3",
      "To": [
        "963"
      ]
    },
    {
      "From": "0x3a4",
      "To": [
        "964"
      ]
    },
    {
      "From": "0x3a5",
      "To": [
        "965"
      ]
    },
    {
      "From": "0x3a6",
      "To": [
        "966"
      ]
    },
    {
      "From": "0x3a7",
      "To": [
        "967"
      ]
    },
    {
      "From": "0x3a8",
      "To": [
        "968"
      ]
    },
    {
      "From": "0x3a9",
      "To": [
        "969"
      ]
    },
    {
      "From": "0x3aa",
      "To": [
        "970"
      ]
    },
    {
      "From": "0x3ab",
      "To": [
        "971"
      ]
    },
    {
      "From": "0x3b0",
      "To": [
        "965",
        "776",
        "769"
      ]
    },
    {
      "From": "0x3c2",
      "To": [
        "963"
      ]
    },
    {
      "From": "0x3cf",
      "To": [
        "983"
      ]
    },
    {
      "From": "0x3d0",
      "To": [
        "946"
      ]
    },
    {
      "From": "0x3d1",
      "To": [
        "952"
      ]
    },
    {
      "From": "0x3d5",
      "To": [
        "966"
      ]
    },
    {
      "From": "0x3d6",
      "To": [
        "960"
      ]
    },
    {
      "From": "0x3d8",
      "To": [
        "985"
      ]
    },
    {
      "From": "0x3da",
      "To": [
        "987"
      ]
    },
    {
      "From": "0x3dc",
      "To": [
        "989"
      ]
    },
    {
      "From": "0x3de",
      "To": [
        "991"
      ]
    },
    {
      "From": "0x3e0",
      "To": [
        "993"
      ]
    },
    {
      "From": "0x3e2",
      "To": [
        "995"
      ]
    },
    {
      "From": "0x3e4",
      "To": [
        "997"
      ]
    },
    {
      "From": "0x3e6",
      "To": [
        "999"
      ]
    },
    {
      "From": "0x3e8",
      "To": [
        "1001"
      ]
    },
    {
      "From": "0x3ea",
      "To": [
        "1003"
      ]
    },
    {
      "From": "0x3ec",
      "To": [
        "1005"
      ]
    },
    {
      "From": "0x3ee",
      "To": [
        "1007"
      ]
    },
    {
      "From": "0x3f0",
      "To": [
        "954"
      ]
    },
    {
      "From": "0x3f1",
      "To": [
        "961"
      ]
    },
    {
      "From": "0x3f4",
      "To": [
        "952"
      ]
    },
    {
      "From": "0x3f5",
      "To": [
        "949"
      ]
    },
    {
      "From": "0x3f7",
      "To": [
        "1016"
      ]
    },
    {
      "From": "0x3f9",
      "To": [
        "1010"
      ]
    },
    {
      "From": "0x3fa",
      "To": [
        "1019"
      ]
    },
    {
      "From": "0x3fd",
      "To": [
        "891"
      ]
    },
    {
      "From": "0x3fe",
      "To": [
        "892"
      ]
    },
    {
      "From": "0x3ff",
      "To": [
        "893"
      ]
    },
    {
      "From": "0x400",
      "To": [
        "1104"
      ]
    },
    {
      "From": "0x401",
      "To": [
        "1105"
      ]
    },
    {
      "From": "0x402",
      "To": [
        "1106"
      ]
    },
    {
      "From": "0x403",
      "To": [
        "1107"
      ]
    },
    {
      "From": "0x404",
      "To": [
        "1108"
      ]
    },
    {
      "From": "0x405",
      "To": [
        "1109"
      ]
    },
    {
      "From": "0x406",
      "To": [
        "1110"
      ]
    },
    {
      "From": "0x407",
      "To": [
        "1111"
      ]
    },
    {
      "From": "0x408",
      "To": [
        "1112"
      ]
    },
    {
      "From": "0x409",
      "To": [
        "1113"
      ]
    },
    {
      "From": "0x40a",
      "To": [
        "1114"
      ]
    },
    {
      "From": "0x40b",
      "To": [
        "1115"
      ]
    },
    {
      "From": "0x40c",
      "To": [
        "1116"
      ]
    },
    {
      "From": "0x40d",
      "To": [
        "1117"
      ]
    },
    {
      "From": "0x40e",
      "To": [
        "1118"
      ]
    },
    {
      "From": "0x40f",
      "To": [
        "1119"
      ]
    },
    {
      "From": "0x410",
      "To": [
        "1072"
      ]
    },
    {
      "From": "0x411",
      "To": [
        "1073"
      ]
    },
    {
      "From": "0x412",
      "To": [
        "1074"
      ]
    },
    {
      "From": "0x413",
      "To": [
        "1075"
      ]
    },
    {
      "From": "0x414",
      "To": [
        "1076"
      ]
    },
    {
      "From": "0x415",
      "To": [
        "1077"
      ]
    },
    {
      "From": "0x416",
      "To": [
        "1078"
      ]
    },
    {
      "From": "0x417",
      "To": [
        "1079"
      ]
    },
    {
      "From": "0x418",
      "To": [
        "1080"
      ]
    },
    {
      "From": "0x419",
      "To": [
        "1081"
      ]
    },
    {
      "From": "0x41a",
      "To": [
        "1082"
      ]
    },
    {
      "From": "0x41b",
      "To": [
        "1083"
      ]
    },
    {
      "From": "0x41c",
      "To": [
        "1084"
      ]
    },
    {
      "From": "0x41d",
      "To": [
        "1085"
      ]
    },
    {
      "From": "0x41e",
      "To": [
        "1086"
      ]
    },
    {
      "From": "0x41f",
      "To": [
        "1087"
      ]
    },
    {
      "From": "0x420",
      "To": [
        "1088"
      ]
    },
    {
      "From": "0x421",
      "To": [
        "1089"
      ]
    },
    {
      "From": "0x422",
      "To": [
        "1090"
      ]
    },
    {
      "From": "0x423",
      "To": [
        "1091"
      ]
    },
    {
      "From": "0x424",
      "To": [
        "1092"
      ]
    },
    {
      "From": "0x425",
      "To": [
        "1093"
      ]
    },
    {
      "From": "0x426",
      "To": [
        "1094"
      ]
    },
    {
      "From": "0x427",
      "To": [
        "1095"
      ]
    },
    {
      "From": "0x428",
      "To": [
        "1096"
      ]
    },
    {
      "From": "0x429",
      "To": [
        "1097"
      ]
    },
    {
      "From": "0x42a",
      "To": [
        "1098"
      ]
    },
    {
      "From": "0x42b",
      "To": [
        "1099"
      ]
    },
    {
      "From": "0x42c",
      "To": [
        "1100"
      ]
    },
    {
      "From": "0x42d",
      "To": [
        "1101"
      ]
    },
    {
      "From": "0x42e",
      "To": [
        "1102"
      ]
    },
    {
      "From": "0x42f",
      "To": [
        "1103"
      ]
    },
    {
      "From": "0x460",
      "To": [
        "1121"
      ]
    },
    {
      "From": "0x462",
      "To": [
        "1123"
      ]
    },
    {
      "From": "0x464",
      "To": [
        "1125"
      ]
    },
    {
      "From": "0x466",
      "To": [
        "1127"
      ]
    },
    {
      "From": "0x468",
      "To": [
        "1129"
      ]
    },
    {
      "From": "0x46a",
      "To": [
        "1131"
      ]
    },
    {
      "From": "0x46c",
      "To": [
        "1133"
      ]
    },
    {
      "From": "0x46e",
      "To": [
        "1135"
      ]
    },
    {
      "From": "0x470",
      "To": [
        "1137"
      ]
    },
    {
      "From": "0x472",
      "To": [
        "1139"
      ]
    },
    {
      "From": "0x474",
      "To": [
        "1141"
      ]
    },
    {
      "From": "0x476",
      "To": [
        "1143"
      ]
    },
    {
      "From": "0x478",
      "To": [
        "1145"
      ]
    },
    {
      "From": "0x47a",
      "To": [
        "1147"
      ]
    },
    {
      "From": "0x47c",
      "To": [
        "1149"
      ]
    },
    {
      "From": "0x47e",
      "To": [
        "1151"
      ]
    },
    {
      "From": "0x480",
      "To": [
        "1153"
      ]
    },
    {
      "From": "0x48a",
      "To": [
        "1163"
      ]
    },
    {
      "From": "0x48c",
      "To": [
        "1165"
      ]
    },
    {
      "From": "0x48e",
      "To": [
        "1167"
      ]
    },
    {
      "From": "0x490",
      "To": [
        "1169"
      ]
    },
    {
      "From": "0x492",
      "To": [
        "1171"
      ]
    },
    {
      "From": "0x494",
      "To": [
        "1173"
      ]
    },
    {
      "From": "0x496",
      "To": [
        "1175"
      ]
    },
    {
      "From": "0x498",
      "To": [
        "1177"
      ]
    },
    {
      "From": "0x49a",
      "To": [
        "1179"
      ]
    },
    {
      "From": "0x49c",
      "To": [
        "1181"
      ]
    },
    {
      "From": "0x49e",
      "To": [
        "1183"
      ]
    },
    {
      "From": "0x4a0",
      "To": [
        "1185"
      ]
    },
    {
      "From": "0x4a2",
      "To": [
        "1187"
      ]
    },
    {
      "From": "0x4a4",
      "To": [
        "1189"
      ]
    },
    {
      "From": "0x4a6",
      "To": [
        "1191"
      ]
    },
    {
      "From": "0x4a8",
      "To": [
        "1193"
      ]
    },
    {
      "From": "0x4aa",
      "To": [
        "1195"
      ]
    },
    {
      "From": "0x4ac",
      "To": [
        "1197"
      ]
    },
    {
      "From": "0x4ae",
      "To": [
        "1199"
      ]
    },
    {
      "From": "0x4b0",
      "To": [
        "1201"
      ]
    },
    {
      "From": "0x4b2",
      "To": [
        "1203"
      ]
    },
    {
      "From": "0x4b4",
      "To": [
        "1205"
      ]
    },
    {
      "From": "0x4b6",
      "To": [
        "1207"
      ]
    },
    {
      "From": "0x4b8",
      "To": [
        "1209"
      ]
    },
    {
      "From": "0x4ba",
      "To": [
        "1211"
      ]
    },
    {
      "From": "0x4bc",
      "To": [
        "1213"
      ]
    },
    {
      "From": "0x4be",
      "To": [
        "1215"
      ]
    },
    {
      "From": "0x4c0",
      "To": [
        "1231"
      ]
    },
    {
      "From": "0x4c1",
      "To": [
        "1218"
      ]
    },
    {
      "From": "0x4c3",
      "To": [
        "1220"
      ]
    },
    {
      "From": "0x4c5",
      "To": [
        "1222"
      ]
    },
    {
      "From": "0x4c7",
      "To": [
        "1224"
      ]
    },
    {
      "From": "0x4c9",
      "To": [
        "1226"
      ]
    },
    {
      "From": "0x4cb",
      "To": [
        "1228"
      ]
    },
    {
      "From": "0x4cd",
      "To": [
        "1230"
      ]
    },
    {
      "From": "0x4d0",
      "To": [
        "1233"
      ]
    },
    {
      "From": "0x4d2",
      "To": [
        "1235"
      ]
    },
    {
      "From": "0x4d4",
      "To": [
        "1237"
      ]
    },
    {
      "From": "0x4d6",
      "To": [
        "1239"
      ]
    },
    {
      "From": "0x4d8",
      "To": [
        "1241"
      ]
    },
    {
      "From": "0x4da",
      "To": [
        "1243"
      ]
    },
    {
      "From": "0x4dc",
      "To": [
        "1245"
      ]
    },
    {
      "From": "0x4de",
      "To": [
        "1247"
      ]
    },
    {
      "From": "0x4e0",
      "To": [
        "1249"
      ]
    },
    {
      "From": "0x4e2",
      "To": [
        "1251"
      ]
    },
    {
      "From": "0x4e4",
      "To": [
        "1253"
      ]
    },
    {
      "From": "0x4e6",
      "To": [
        "1255"
      ]
    },
    {
      "From": "0x4e8",
      "To": [
        "1257"
      ]
    },
    {
      "From": "0x4ea",
      "To": [
        "1259"
      ]
    },
    {
      "From": "0x4ec",
      "To": [
        "1261"
      ]
    },
    {
      "From": "0x4ee",
      "To": [
        "1263"
      ]
    },
    {
      "From": "0x4f0",
      "To": [
        "1265"
      ]
    },
    {
      "From": "0x4f2",
      "To": [
        "1267"
      ]
    },
    {
      "From": "0x4f4",
      "To": [
        "1269"
      ]
    },
    {
      "From": "0x4f6",
      "To": [
        "1271"
      ]
    },
    {
      "From": "0x4f8",
      "To": [
        "1273"
      ]
    },
    {
      "From": "0x4fa",
      "To": [
        "1275"
      ]
    },
    {
      "From": "0x4fc",
      "To": [
        "1277"
      ]
    },
    {
      "From": "0x4fe",
      "To": [
        "1279"
      ]
    },
    {
      "From": "0x500",
      "To": [
        "1281"
      ]
    },
    {
      "From": "0x502",
      "To": [
        "1283"
      ]
    },
    {
      "From": "0x504",
      "To": [
        "1285"
      ]
    },
    {
      "From": "0x506",
      "To": [
        "1287"
      ]
    },
    {
      "From": "0x508",
      "To": [
        "1289"
      ]
    },
    {
      "From": "0x50a",
      "To": [
        "1291"
      ]
    },
    {
      "From": "0x50c",
      "To": [
        "1293"
      ]
    },
    {
      "From": "0x50e",
      "To": [
        "1295"
      ]
    },
    {
      "From": "0x510",
      "To": [
        "1297"
      ]
    },
    {
      "From": "0x512",
      "To": [
        "1299"
      ]
    },
    {
      "From": "0x514",
      "To": [
        "1301"
      ]
    },
    {
      "From": "0x516",
      "To": [
        "1303"
      ]
    },
    {
      "From": "0x518",
      "To": [
        "1305"
      ]
    },
    {
      "From": "0x51a",
      "To": [
        "1307"
      ]
    },
    {
      "From": "0x51c",
      "To": [
        "1309"
      ]
    },
    {
      "From": "0x51e",
      "To": [
        "1311"
      ]
    },
    {
      "From": "0x520",
      "To": [
        "1313"
      ]
    },
    {
      "From": "0x522",
      "To": [
        "1315"
      ]
    },
    {
      "From": "0x524",
      "To": [
        "1317"
      ]
    },
    {
      "From": "0x526",
      "To": [
        "1319"
      ]
    },
    {
      "From": "0x528",
      "To": [
        "1321"
      ]
    },
    {
      "From": "0x52a",
      "To": [
        "1323"
      ]
    },
    {
      "From": "0x52c",
      "To": [
        "1325"
      ]
    },
    {
      "From": "0x52e",
      "To": [
        "1327"
      ]
    },
    {
      "From": "0x531",
      "To": [
        "1377"
      ]
    },
    {
      "From": "0x532",
      "To": [
        "1378"
      ]
    },
    {
      "From": "0x533",
      "To": [
        "1379"
      ]
    },
    {
      "From": "0x534",
      "To": [
        "1380"
      ]
    },
    {
      "From": "0x535",
      "To": [
        "1381"
      ]
    },
    {
      "From": "0x536",
      "To": [
        "1382"
      ]
    },
    {
      "From": "0x537",
      "To": [
        "1383"
      ]
    },
    {
      "From": "0x538",
      "To": [
        "1384"
      ]
    },
    {
      "From": "0x539",
      "To": [
        "1385"
      ]
    },
    {
      "From": "0x53a",
      "To": [
        "1386"
      ]
    },
    {
      "From": "0x53b",
      "To": [
        "1387"
      ]
    },
    {
      "From": "0x53c",
      "To": [
        "1388"
      ]
    },
    {
      "From": "0x53d",
      "To": [
        "1389"
      ]
    },
    {
      "From": "0x53e",
      "To": [
        "1390"
      ]
    },
    {
      "From": "0x53f",
      "To": [
        "1391"
      ]
    },
    {
      "From": "0x540",
      "To": [
        "1392"
      ]
    },
    {
      "From": "0x541",
      "To": [
        "1393"
      ]
    },
    {
      "From": "0x542",
      "To": [
        "1394"
      ]
    },
    {
      "From": "0x543",
      "To": [
        "1395"
      ]
    },
    {
      "From": "0x544",
      "To": [
        "1396"
      ]
    },
    {
      "From": "0x545",
      "To": [
        "1397"
      ]
    },
    {
      "From": "0x546",
      "To": [
        "1398"
      ]
    },
    {
      "From": "0x547",
      "To": [
        "1399"
      ]
    },
    {
      "From": "0x548",
      "To": [
        "1400"
      ]
    },
    {
      "From": "0x549",
      "To": [
        "1401"
      ]
    },
    {
      "From": "0x54a",
      "To": [
        "1402"
      ]
    },
    {
      "From": "0x54b",
      "To": [
        "1403"
      ]
    },
    {
      "From": "0x54c",
      "To": [
        "1404"
      ]
    },
    {
      "From": "0x54d",
      "To": [
        "1405"
      ]
    },
    {
      "From": "0x54e",
      "To": [
        "1406"
      ]
    },
    {
      "From": "0x54f",
      "To": [
        "1407"
      ]
    },
    {
      "From": "0x550",
      "To": [
        "1408"
      ]
    },
    {
      "From": "0x551",
      "To": [
        "1409"
      ]
    },
    {
      "From": "0x552",
      "To": [
        "1410"
      ]
    },
    {
      "From": "0x553",
      "To": [
        "1411"
      ]
    },
    {
      "From": "0x554",
      "To": [
        "1412"
      ]
    },
    {
      "From": "0x555",
      "To": [
        "1413"
      ]
    },
    {
      "From": "0x556",
      "To": [
        "1414"
      ]
    },
    {
      "From": "0x587",
      "To": [
        "1381",
        "1410"
      ]
    },
    {
      "From": "0x10a0",
      "To": [
        "11520"
      ]
    },
    {
      "From": "0x10a1",
      "To": [
        "11521"
      ]
    },
    {
      "From": "0x10a2",
      "To": [
        "11522"
      ]
    },
    {
      "From": "0x10a3",
      "To": [
        "11523"
      ]
    },
    {
      "From": "0x10a4",
      "To": [
        "11524"
      ]
    },
    {
      "From": "0x10a5",
      "To": [
        "11525"
      ]
    },
    {
      "From": "0x10a6",
      "To": [
        "11526"
      ]
    },
    {
      "From": "0x10a7",
      "To": [
        "11527"
      ]
    },
    {
      "From": "0x10a8",
      "To": [
        "11528"
      ]
    },
    {
      "From": "0x10a9",
      "To": [
        "11529"
      ]
    },
    {
      "From": "0x10aa",
      "To": [
        "11530"
      ]
    },
    {
      "From": "0x10ab",
      "To": [
        "11531"
      ]
    },
    {
      "From": "0x10ac",
      "To": [
        "11532"
      ]
    },
    {
      "From": "0x10ad",
      "To": [
        "11533"
      ]
    },
    {
      "From": "0x10ae",
      "To": [
        "11534"
      ]
    },
    {
      "From": "0x10af",
      "To": [
        "11535"
      ]
    },
    {
      "From": "0x10b0",
      "To": [
        "11536"
      ]
    },
    {
      "From": "0x10b1",
      "To": [
        "11537"
      ]
    },
    {
      "From": "0x10b2",
      "To": [
        "11538"
      ]
    },
    {
      "From": "0x10b3",
      "To": [
        "11539"
      ]
    },
    {
      "From": "0x10b4",
      "To": [
        "11540"
      ]
    },
    {
      "From": "0x10b5",
      "To": [
        "11541"
      ]
    },
    {
      "From": "0x10b6",
      "To": [
        "11542"
      ]
    },
    {
      "From": "0x10b7",
      "To": [
        "11543"
      ]
    },
    {
      "From": "0x10b8",
      "To": [
        "11544"
      ]
    },
    {
      "From": "0x10b9",
      "To": [
        "11545"
      ]
    },
    {
      "From": "0x10ba",
      "To": [
        "11546"
      ]
    },
    {
      "From": "0x10bb",
      "To": [
        "11547"
      ]
    },
    {
      "From": "0x10bc",
      "To": [
        "11548"
      ]
    },
    {
      "From": "0x10bd",
      "To": [
        "11549"
      ]
    },
    {
      "From": "0x10be",
      "To": [
        "11550"
      ]
    },
    {
      "From": "0x10bf",
      "To": [
        "11551"
      ]
    },
    {
      "From": "0x10c0",
      "To": [
        "11552"
      ]
    },
    {
      "From": "0x10c1",
      "To": [
        "11553"
      ]
    },
    {
      "From": "0x10c2",
      "To": [
        "11554"
      ]
    },
    {
      "From": "0x10c3",
      "To": [
        "11555"
      ]
    },
    {
      "From": "0x10c4",
      "To": [
        "11556"
      ]
    },
    {
      "From": "0x10c5",
      "To": [
        "11557"
      ]
    },
    {
      "From": "0x10c7",
      "To": [
        "11559"
      ]
    },
    {
      "From": "0x10cd",
      "To": [
        "11565"
      ]
    },
    {
      "From": "0x13f8",
      "To": [
        "5104"
      ]
    },
    {
      "From": "0x13f9",
      "To": [
        "5105"
      ]
    },
    {
      "From": "0x13fa",
      "To": [
        "5106"
      ]
    },
    {
      "From": "0x13fb",
      "To": [
        "5107"
      ]
    },
    {
      "From": "0x13fc",
      "To": [
        "5108"
      ]
    },
    {
      "From": "0x13fd",
      "To": [
        "5109"
      ]
    },
    {
      "From": "0x1c80",
      "To": [
        "1074"
      ]
    },
    {
      "From": "0x1c81",
      "To": [
        "1076"
      ]
    },
    {
      "From": "0x1c82",
      "To": [
        "1086"
      ]
    },
    {
      "From": "0x1c83",
      "To": [
        "1089"
      ]
    },
    {
      "From": "0x1c84",
      "To": [
        "1090"
      ]
    },
    {
      "From": "0x1c85",
      "To": [
        "1090"
      ]
    },
    {
      "From": "0x1c86",
      "To": [
        "1098"
      ]
    },
    {
      "From": "0x1c87",
      "To": [
        "1123"
      ]
    },
    {
      "From": "0x1c88",
      "To": [
        "42571"
      ]
    },
    {
      "From": "0x1c90",
      "To": [
        "4304"
      ]
    },
    {
      "From": "0x1c91",
      "To": [
        "4305"
      ]
    },
    {
      "From": "0x1c92",
      "To": [
        "4306"
      ]
    },
    {
      "From": "0x1c93",
      "To": [
        "4307"
      ]
    },
    {
      "From": "0x1c94",
      "To": [
        "4308"
      ]
    },
    {
      "From": "0x1c95",
      "To": [
        "4309"
      ]
    },
    {
      "From": "0x1c96",
      "To": [
        "4310"
      ]
    },
    {
      "From": "0x1c97",
      "To": [
        "4311"
      ]
    },
    {
      "From": "0x1c98",
      "To": [
        "4312"
      ]
    },
    {
      "From": "0x1c99",
      "To": [
        "4313"
      ]
    },
    {
      "From": "0x1c9a",
      "To": [
        "4314"
      ]
    },
    {
      "From": "0x1c9b",
      "To": [
        "4315"
      ]
    },
    {
      "From": "0x1c9c",
      "To": [
        "4316"
      ]
    },
    {
      "From": "0x1c9d",
      "To": [
        "4317"
      ]
    },
    {
      "From": "0x1c9e",
      "To": [
        "4318"
      ]
    },
    {
      "From": "0x1c9f",
      "To": [
        "4319"
      ]
    },
    {
      "From": "0x1ca0",
      "To": [
        "4320"
      ]
    },
    {
      "From": "0x1ca1",
      "To": [
        "4321"
      ]
    },
    {
      "From": "0x1ca2",
      "To": [
        "4322"
      ]
    },
    {
      "From": "0x1ca3",
      "To": [
        "4323"
      ]
    },
    {
      "From": "0x1ca4",
      "To": [
        "4324"
      ]
    },
    {
      "From": "0x1ca5",
      "To": [
        "4325"
      ]
    },
    {
      "From": "0x1ca6",
      "To": [
        "4326"
      ]
    },
    {
      "From": "0x1ca7",
      "To": [
        "4327"
      ]
    },
    {
      "From": "0x1ca8",
      "To": [
        "4328"
      ]
    },
    {
      "From": "0x1ca9",
      "To": [
        "4329"
      ]
    },
    {
      "From": "0x1caa",
      "To": [
        "4330"
      ]
    },
    {
      "From": "0x1cab",
      "To": [
        "4331"
      ]
    },
    {
      "From": "0x1cac",
      "To": [
        "4332"
      ]
    },
    {
      "From": "0x1cad",
      "To": [
        "4333"
      ]
    },
    {
      "From": "0x1cae",
      "To": [
        "4334"
      ]
    },
    {
      "From": "0x1caf",
      "To": [
        "4335"
      ]
    },
    {
      "From": "0x1cb0",
      "To": [
        "4336"
      ]
    },
    {
      "From": "0x1cb1",
      "To": [
        "4337"
      ]
    },
    {
      "From": "0x1cb2",
      "To": [
        "4338"
      ]
    },
    {
      "From": "0x1cb3",
      "To": [
        "4339"
      ]
    },
    {
      "From": "0x1cb4",
      "To": [
        "4340"
      ]
    },
    {
      "From": "0x1cb5",
      "To": [
        "4341"
      ]
    },
    {
      "From": "0x1cb6",
      "To": [
        "4342"
      ]
    },
    {
      "From": "0x1cb7",
      "To": [
        "4343"
      ]
    },
    {
      "From": "0x1cb8",
      "To": [
        "4344"
      ]
    },
    {
      "From": "0x1cb9",
      "To": [
        "4345"
      ]
    },
    {
      "From": "0x1cba",
      "To": [
        "4346"
      ]
    },
    {
      "From": "0x1cbd",
      "To": [
        "4349"
      ]
    },
    {
      "From": "0x1cbe",
      "To": [
        "4350"
      ]
    },
    {
      "From": "0x1cbf",
      "To": [
        "4351"
      ]
    },
    {
      "From": "0x1e00",
      "To": [
        "7681"
      ]
    },
    {
      "From": "0x1e02",
      "To": [
        "7683"
      ]
    },
    {
      "From": "0x1e04",
      "To": [
        "7685"
      ]
    },
    {
      "From": "0x1e06",
      "To": [
        "7687"
      ]
    },
    {
      "From": "0x1e08",
      "To": [
        "7689"
      ]
    },
    {
      "From": "0x1e0a",
      "To": [
        "7691"
      ]
    },
    {
      "From": "0x1e0c",
      "To": [
        "7693"
      ]
    },
    {
      "From": "0x1e0e",
      "To": [
        "7695"
      ]
    },
    {
      "From": "0x1e10",
      "To": [
        "7697"
      ]
    },
    {
      "From": "0x1e12",
      "To": [
        "7699"
      ]
    },
    {
      "From": "0x1e14",
      "To": [
        "7701"
      ]
    },
    {
      "From": "0x1e16",
      "To": [
        "7703"
      ]
    },
    {
      "From": "0x1e18",
      "To": [
        "7705"
      ]
    },
    {
      "From": "0x1e1a",
      "To": [
        "7707"
      ]
    },
    {
      "From": "0x1e1c",
      "To": [
        "7709"
      ]
    },
    {
      "From": "0x1e1e",
      "To": [
        "7711"
      ]
    },
    {
      "From": "0x1e20",
      "To": [
        "7713"
      ]
    },
    {
      "From": "0x1e22",
      "To": [
        "7715"
      ]
    },
    {
      "From": "0x1e24",
      "To": [
        "7717"
      ]
    },
    {
      "From": "0x1e26",
      "To": [
        "7719"
      ]
    },
    {
      "From": "0x1e28",
      "To": [
        "7721"
      ]
    },
    {
      "From": "0x1e2a",
      "To": [
        "7723"
      ]
    },
    {
      "From": "0x1e2c",
      "To": [
        "7725"
      ]
    },
    {
      "From": "0x1e2e",
      "To": [
        "7727"
      ]
    },
    {
      "From": "0x1e30",
      "To": [
        "7729"
      ]
    },
    {
      "From": "0x1e32",
      "To": [
        "7731"
      ]
    },
    {
      "From": "0x1e34",
      "To": [
        "7733"
      ]
    },
    {
      "From": "0x1e36",
      "To": [
        "7735"
      ]
    },
    {
      "From": "0x1e38",
      "To": [
        "7737"
      ]
    },
    {
      "From": "0x1e3a",
      "To": [
        "7739"
      ]
    },
    {
      "From": "0x1e3c",
      "To": [
        "7741"
      ]
    },
    {
      "From": "0x1e3e",
      "To": [
        "7743"
      ]
    },
    {
      "From": "0x1e40",
      "To": [
        "7745"
      ]
    },
    {
      "From": "0x1e42",
      "To": [
        "7747"
      ]
    },
    {
      "From": "0x1e44",
      "To": [
        "7749"
      ]
    },
    {
      "From": "0x1e46",
      "To": [
        "7751"
      ]
    },
    {
      "From": "0x1e48",
      "To": [
        "7753"
      ]
    },
    {
      "From": "0x1e4a",
      "To": [
        "7755"
      ]
    },
    {
      "From": "0x1e4c",
      "To": [
        "7757"
      ]
    },
    {
      "From": "0x1e4e",
      "To": [
        "7759"
      ]
    },
    {
      "From": "0x1e50",
      "To": [
        "7761"
      ]
    },
    {
      "From": "0x1e52",
      "To": [
        "7763"
      ]
    },
    {
      "From": "0x1e54",
      "To": [
        "7765"
      ]
    },
    {
      "From": "0x1e56",
      "To": [
        "7767"
      ]
    },
    {
      "From": "0x1e58",
      "To": [
        "7769"
      ]
    },
    {
      "From": "0x1e5a",
      "To": [
        "7771"
      ]
    },
    {
      "From": "0x1e5c",
      "To": [
        "7773"
      ]
    },
    {
      "From": "0x1e5e",
      "To": [
        "7775"
      ]
    },
    {
      "From": "0x1e60",
      "To": [
        "7777"
      ]
    },
    {
      "From": "0x1e62",
      "To": [
        "7779"
      ]
    },
    {
      "From": "0x1e64",
      "To": [
        "7781"
      ]
    },
    {
      "From": "0x1e66",
      "To": [
        "7783"
      ]
    },
    {
      "From": "0x1e68",
      "To": [
        "7785"
      ]
    },
    {
      "From": "0x1e6a",
      "To": [
        "7787"
      ]
    },
    {
      "From": "0x1e6c",
      "To": [
        "7789"
      ]
    },
    {
      "From": "0x1e6e",
      "To": [
        "7791"
      ]
    },
    {
      "From": "0x1e70",
      "To": [
        "7793"
      ]
    },
    {
      "From": "0x1e72",
      "To": [
        "7795"
      ]
    },
    {
      "From": "0x1e74",
      "To": [
        "7797"
      ]
    },
    {
      "From": "0x1e76",
      "To": [
        "7799"
      ]
    },
    {
      "From": "0x1e78",
      "To": [
        "7801"
      ]
    },
    {
      "From": "0x1e7a",
      "To": [
        "7803"
      ]
    },
    {
      "From": "0x1e7c",
      "To": [
        "7805"
      ]
    },
    {
      "From": "0x1e7e",
      "To": [
        "7807"
      ]
    },
    {
      "From": "0x1e80",
      "To": [
        "7809"
      ]
    },
    {
      "From": "0x1e82",
      "To": [
        "7811"
      ]
    },
    {
      "From": "0x1e84",
      "To": [
        "7813"
      ]
    },
    {
      "From": "0x1e86",
      "To": [
        "7815"
      ]
    },
    {
      "From": "0x1e88",
      "To": [
        "7817"
      ]
    },
    {
      "From": "0x1e8a",
      "To": [
        "7819"
      ]
    },
    {
      "From": "0x1e8c",
      "To": [
        "7821"
      ]
    },
    {
      "From": "0x1e8e",
      "To": [
        "7823"
      ]
    },
    {
      "From": "0x1e90",
      "To": [
        "7825"
      ]
    },
    {
      "From": "0x1e92",
      "To": [
        "7827"
      ]
    },
    {
      "From": "0x1e94",
      "To": [
        "7829"
      ]
    },
    {
      "From": "0x1e96",
      "To": [
        "104",
        "817"
      ]
    },
    {
      "From": "0x1e97",
      "To": [
        "116",
        "776"
      ]
    },
    {
      "From": "0x1e98",
      "To": [
        "119",
        "778"
      ]
    },
    {
      "From": "0x1e99",
      "To": [
        "121",
        "778"
      ]
    },
    {
      "From": "0x1e9a",
      "To": [
        "97",
        "702"
      ]
    },
    {
      "From": "0x1e9b",
      "To": [
        "7777"
      ]
    },
    {
      "From": "0x1e9e",
      "To": [
        "115",
        "115"
      ]
    },
    {
      "From": "0x1ea0",
      "To": [
        "7841"
      ]
    },
    {
      "From": "0x1ea2",
      "To": [
        "7843"
      ]
    },
    {
      "From": "0x1ea4",
      "To": [
        "7845"
      ]
    },
    {
      "From": "0x1ea6",
      "To": [
        "7847"
      ]
    },
    {
      "From": "0x1ea8",
      "To": [
        "7849"
      ]
    },
    {
      "From": "0x1eaa",
      "To": [
        "7851"
      ]
    },
    {
      "From": "0x1eac",
      "To": [
        "7853"
      ]
    },
    {
      "From": "0x1eae",
      "To": [
        "7855"
      ]
    },
    {
      "From": "0x1eb0",
      "To": [
        "7857"
      ]
    },
    {
      "From": "0x1eb2",
      "To": [
        "7859"
      ]
    },
    {
      "From": "0x1eb4",
      "To": [
        "7861"
      ]
    },
    {
      "From": "0x1eb6",
      "To": [
        "7863"
      ]
    },
    {
      "From": "0x1eb8",
      "To": [
        "7865"
      ]
    },
    {
      "From": "0x1eba",
      "To": [
        "7867"
      ]
    },
    {
      "From": "0x1ebc",
      "To": [
        "7869"
      ]
    },
    {
      "From": "0x1ebe",
      "To": [
        "7871"
      ]
    },
    {
      "From": "0x1ec0",
      "To": [
        "7873"
      ]
    },
    {
      "From": "0x1ec2",
      "To": [
        "7875"
      ]
    },
    {
      "From": "0x1ec4",
      "To": [
        "7877"
      ]
    },
    {
      "From": "0x1ec6",
      "To": [
        "7879"
      ]
    },
    {
      "From": "0x1ec8",
      "To": [
        "7881"
      ]
    },
    {
      "From": "0x1eca",
      "To": [
        "7883"
      ]
    },
    {
      "From": "0x1ecc",
      "To": [
        "7885"
      ]
    },
    {
      "From": "0x1ece",
      "To": [
        "7887"
      ]
    },
    {
      "From": "0x1ed0",
      "To": [
        "7889"
      ]
    },
    {
      "From": "0x1ed2",
      "To": [
        "7891"
      ]
    },
    {
      "From": "0x1ed4",
      "To": [
        "7893"
      ]
    },
    {
      "From": "0x1ed6",
      "To": [
        "7895"
      ]
    },
    {
      "From": "0x1ed8",
      "To": [
        "7897"
      ]
    },
    {
      "From": "0x1eda",
      "To": [
        "7899"
      ]
    },
    {
      "From": "0x1edc",
      "To": [
        "7901"
      ]
    },
    {
      "From": "0x1ede",
      "To": [
        "7903"
      ]
    },
    {
      "From": "0x1ee0",
      "To": [
        "7905"
      ]
    },
    {
      "From": "0x1ee2",
      "To": [
        "7907"
      ]
    },
    {
      "From": "0x1ee4",
      "To": [
        "7909"
      ]
    },
    {
      "From": "0x1ee6",
      "To": [
        "7911"
      ]
    },
    {
      "From": "0x1ee8",
      "To": [
        "7913"
      ]
    },
    {
      "From": "0x1eea",
      "To": [
        "7915"
      ]
    },
    {
      "From": "0x1eec",
      "To": [
        "7917"
      ]
    },
    {
      "From": "0x1eee",
      "To": [
        "7919"
      ]
    },
    {
      "From": "0x1ef0",
      "To": [
        "7921"
      ]
    },
    {
      "From": "0x1ef2",
      "To": [
        "7923"
      ]
    },
    {
      "From": "0x1ef4",
      "To": [
        "7925"
      ]
    },
    {
      "From": "0x1ef6",
      "To": [
        "7927"
      ]
    },
    {
      "From": "0x1ef8",
      "To": [
        "7929"
      ]
    },
    {
      "From": "0x1efa",
      "To": [
        "7931"
      ]
    },
    {
      "From": "0x1efc",
      "To": [
        "7933"
      ]
    },
    {
      "From": "0x1efe",
      "To": [
        "7935"
      ]
    },
    {
      "From": "0x1f08",
      "To": [
        "7936"
      ]
    },
    {
      "From": "0x1f09",
      "To": [
        "7937"
      ]
    },
    {
      "From": "0x1f0a",
      "To": [
        "7938"
      ]
    },
    {
      "From": "0x1f0b",
      "To": [
        "7939"
      ]
    },
    {
      "From": "0x1f0c",
      "To": [
        "7940"
      ]
    },
    {
      "From": "0x1f0d",
      "To": [
        "7941"
      ]
    },
    {
      "From": "0x1f0e",
      "To": [
        "7942"
      ]
    },
    {
      "From": "0x1f0f",
      "To": [
        "7943"
      ]
    },
    {
      "From": "0x1f18",
      "To": [
        "7952"
      ]
    },
    {
      "From": "0x1f19",
      "To": [
        "7953"
      ]
    },
    {
      "From": "0x1f1a",
      "To": [
        "7954"
      ]
    },
    {
      "From": "0x1f1b",
      "To": [
        "7955"
      ]
    },
    {
      "From": "0x1f1c",
      "To": [
        "7956"
      ]
    },
    {
      "From": "0x1f1d",
      "To": [
        "7957"
      ]
    },
    {
      "From": "0x1f28",
      "To": [
        "7968"
      ]
    },
    {
      "From": "0x1f29",
      "To": [
        "7969"
      ]
    },
    {
      "From": "0x1f2a",
      "To": [
        "7970"
      ]
    },
    {
      "From": "0x1f2b",
      "To": [
        "7971"
      ]
    },
    {
      "From": "0x1f2c",
      "To": [
        "7972"
      ]
    },
    {
      "From": "0x1f2d",
      "To": [
        "7973"
      ]
    },
    {
      "From": "0x1f2e",
      "To": [
        "7974"
      ]
    },
    {
      "From": "0x1f2f",
      "To": [
        "7975"
      ]
    },
    {
      "From": "0x1f38",
      "To": [
        "7984"
      ]
    },
    {
      "From": "0x1f39",
      "To": [
        "7985"
      ]
    },
    {
      "From": "0x1f3a",
      "To": [
        "7986"
      ]
    },
    {
      "From": "0x1f3b",
      "To": [
        "7987"
      ]
    },
    {
      "From": "0x1f3c",
      "To": [
        "7988"
      ]
    },
    {
      "From": "0x1f3d",
      "To": [
        "7989"
      ]
    },
    {
      "From": "0x1f3e",
      "To": [
        "7990"
      ]
    },
    {
      "From": "0x1f3f",
      "To": [
        "7991"
      ]
    },
    {
      "From": "0x1f48",
      "To": [
        "8000"
      ]
    },
    {
      "From": "0x1f49",
      "To": [
        "8001"
      ]
    },
    {
      "From": "0x1f4a",
      "To": [
        "8002"
      ]
    },
    {
      "From": "0x1f4b",
      "To": [
        "8003"
      ]
    },
    {
      "From": "0x1f4c",
      "To": [
        "8004"
      ]
    },
    {
      "From": "0x1f4d",
      "To": [
        "8005"
      ]
    },
    {
      "From": "0x1f50",
      "To": [
        "965",
        "787"
      ]
    },
    {
      "From": "0x1f52",
      "To": [
        "965",
        "787",
        "768"
      ]
    },
    {
      "From": "0x1f54",
      "To": [
        "965",
        "787",
        "769"
      ]
    },
    {
      "From": "0x1f56",
      "To": [
        "965",
        "787",
        "834"
      ]
    },
    {
      "From": "0x1f59",
      "To": [
        "8017"
      ]
    },
    {
      "From": "0x1f5b",
      "To": [
        "8019"
      ]
    },
    {
      "From": "0x1f5d",
      "To": [
        "8021"
      ]
    },
    {
      "From": "0x1f5f",
      "To": [
        "8023"
      ]
    },
    {
      "From": "0x1f68",
      "To": [
        "8032"
      ]
    },
    {
      "From": "0x1f69",
      "To": [
        "8033"
      ]
    },
    {
      "From": "0x1f6a",
      "To": [
        "8034"
      ]
    },
    {
      "From": "0x1f6b",
      "To": [
        "8035"
      ]
    },
    {
      "From": "0x1f6c",
      "To": [
        "8036"
      ]
    },
    {
      "From": "0x1f6d",
      "To": [
        "8037"
      ]
    },
    {
      "From": "0x1f6e",
      "To": [
        "8038"
      ]
    },
    {
      "From": "0x1f6f",
      "To": [
        "8039"
      ]
    },
    {
      "From": "0x1f80",
      "To": [
        "7936",
        "953"
      ]
    },
    {
      "From": "0x1f81",
      "To": [
        "7937",
        "953"
      ]
    },
    {
      "From": "0x1f82",
      "To": [
        "7938",
        "953"
      ]
    },
    {
      "From": "0x1f83",
      "To": [
        "7939",
        "953"
      ]
    },
    {
      "From": "0x1f84",
      "To": [
        "7940",
        "953"
      ]
    },
    {
      "From": "0x1f85",
      "To": [
        "7941",
        "953"
      ]
    },
    {
      "From": "0x1f86",
      "To": [
        "7942",
        "953"
      ]
    },
    {
      "From": "0x1f87",
      "To": [
        "7943",
        "953"
      ]
    },
    {
      "From": "0x1f88",
      "To": [
        "7936",
        "953"
      ]
    },
    {
      "From": "0x1f89",
      "To": [
        "7937",
        "953"
      ]
    },
    {
      "From": "0x1f8a",
      "To": [
        "7938",
        "953"
      ]
    },
    {
      "From": "0x1f8b",
      "To": [
        "7939",
        "953"
      ]
    },
    {
      "From": "0x1f8c",
      "To": [
        "7940",
        "953"
      ]
    },
    {
      "From": "0x1f8d",
      "To": [
        "7941",
        "953"
      ]
    },
    {
      "From": "0x1f8e",
      "To": [
        "7942",
        "953"
      ]
    },
    {
      "From": "0x1f8f",
      "To": [
        "7943",
        "953"
      ]
    },
    {
      "From": "0x1f90",
      "To": [
        "7968",
        "953"
      ]
    },
    {
      "From": "0x1f91",
      "To": [
        "7969",
        "953"
      ]
    },
    {
      "From": "0x1f92",
      "To": [
        "7970",
        "953"
      ]
    },
    {
      "From": "0x1f93",
      "To": [
        "7971",
        "953"
      ]
    },
    {
      "From": "0x1f94",
      "To": [
        "7972",
        "953"
      ]
    },
    {
      "From": "0x1f95",
      "To": [
        "7973",
        "953"
      ]
    },
    {
      "From": "0x1f96",
      "To": [
        "7974",
        "953"
      ]
    },
    {
      "From": "0x1f97",
      "To": [
        "7975",
        "953"
      ]
    },
    {
      "From": "0x1f98",
      "To": [
        "7968",
        "953"
      ]
    },
    {
      "From": "0x1f99",
      "To": [
        "7969",
        "953"
      ]
    },
    {
      "From": "0x1f9a",
      "To": [
        "7970",
        "953"
      ]
    },
    {
      "From": "0x1f9b",
      "To": [
        "7971",
        "953"
      ]
    },
    {
      "From": "0x1f9c",
      "To": [
        "7972",
        "953"
      ]
    },
    {
      "From": "0x1f9d",
      "To": [
        "7973",
        "953"
      ]
    },
    {
      "From": "0x1f9e",
      "To": [
        "7974",
        "953"
      ]
    },
    {
      "From": "0x1f9f",
      "To": [
        "7975",
        "953"
      ]
    },
    {
      "From": "0x1fa0",
      "To": [
        "8032",
        "953"
      ]
    },
    {
      "From": "0x1fa1",
      "To": [
        "8033",
        "953"
      ]
    },
    {
      "From": "0x1fa2",
      "To": [
        "8034",
        "953"
      ]
    },
    {
      "From": "0x1fa3",
      "To": [
        "8035",
        "953"
      ]
    },
    {
      "From": "0x1fa4",
      "To": [
        "8036",
        "953"
      ]
    },
    {
      "From": "0x1fa5",
      "To": [
        "8037",
        "953"
      ]
    },
    {
      "From": "0x1fa6",
      "To": [
        "8038",
        "953"
      ]
    },
    {
      "From": "0x1fa7",
      "To": [
        "8039",
        "953"
      ]
    },
    {
      "From": "0x1fa8",
      "To": [
        "8032",
        "953"
      ]
    },
    {
      "From": "0x1fa9",
      "To": [
        "8033",
        "953"
      ]
    },
    {
      "From": "0x1faa",
      "To": [
        "8034",
        "953"
      ]
    },
    {
      "From": "0x1fab",
      "To": [
        "8035",
        "953"
      ]
    },
    {
      "From": "0x1fac",
      "To": [
        "8036",
        "953"
      ]
    },
    {
      "From": "0x1fad",
      "To": [
        "8037",
        "953"
      ]
    },
    {
      "From": "0x1fae",
      "To": [
        "8038",
        "953"
      ]
    },
    {
      "From": "0x1faf",
      "To": [
        "8039",
        "953"
      ]
    },
    {
      "From": "0x1fb2",
      "To": [
        "8048",
        "953"
      ]
    },
    {
      "From": "0x1fb3",
      "To": [
        "945",
        "953"
      ]
    },
    {
      "From": "0x1fb4",
      "To": [
        "940",
        "953"
      ]
    },
    {
      "From": "0x1fb6",
      "To": [
        "945",
        "834"
      ]
    },
    {
      "From": "0x1fb7",
      "To": [
        "945",
        "834",
        "953"
      ]
    },
    {
      "From": "0x1fb8",
      "To": [
        "8112"
      ]
    },
    {
      "From": "0x1fb9",
      "To": [
        "8113"
      ]
    },
    {
      "From": "0x1fba",
      "To": [
        "8048"
      ]
    },
    {
      "From": "0x1fbb",
      "To": [
        "8049"
      ]
    },
    {
      "From": "0x1fbc",
      "To": [
        "945",
        "953"
      ]
    },
    {
      "From": "0x1fbe",
      "To": [
        "953"
      ]
    },
    {
      "From": "0x1fc2",
      "To": [
        "8052",
        "953"
      ]
    },
    {
      "From": "0x1fc3",
      "To": [
        "951",
        "953"
      ]
    },
    {
      "From": "0x1fc4",
      "To": [
        "942",
        "953"
      ]
    },
    {
      "From": "0x1fc6",
      "To": [
        "951",
        "834"
      ]
    },
    {
      "From": "0x1fc7",
      "To": [
        "951",
        "834",
        "953"
      ]
    },
    {
      "From": "0x1fc8",
      "To": [
        "8050"
      ]
    },
    {
      "From": "0x1fc9",
      "To": [
        "8051"
      ]
    },
    {
      "From": "0x1fca",
      "To": [
        "8052"
      ]
    },
    {
      "From": "0x1fcb",
      "To": [
        "8053"
      ]
    },
    {
      "From": "0x1fcc",
      "To": [
        "951",
        "953"
      ]
    },
    {
      "From": "0x1fd2",
      "To": [
        "953",
        "776",
        "768"
      ]
    },
    {
      "From": "0x1fd3",
      "To": [
        "953",
        "776",
        "769"
      ]
    },
    {
      "From": "0x1fd6",
      "To": [
        "953",
        "834"
      ]
    },
    {
      "From": "0x1fd7",
      "To": [
        "953",
        "776",
        "834"
      ]
    },
    {
      "From": "0x1fd8",
      "To": [
        "8144"
      ]
    },
    {
      "From": "0x1fd9",
      "To": [
        "8145"
      ]
    },
    {
      "From": "0x1fda",
      "To": [
        "8054"
      ]
    },
    {
      "From": "0x1fdb",
      "To": [
        "8055"
      ]
    },
    {
      "From": "0x1fe2",
      "To": [
        "965",
        "776",
        "768"
      ]
    },
    {
      "From": "0x1fe3",
      "To": [
        "965",
        "776",
        "769"
      ]
    },
    {
      "From": "0x1fe4",
      "To": [
        "961",
        "787"
      ]
    },
    {
      "From": "0x1fe6",
      "To": [
        "965",
        "834"
      ]
    },
    {
      "From": "0x1fe7",
      "To": [
        "965",
        "776",
        "834"
      ]
    },
    {
      "From": "0x1fe8",
      "To": [
        "8160"
      ]
    },
    {
      "From": "0x1fe9",
      "To": [
        "8161"
      ]
    },
    {
      "From": "0x1fea",
      "To": [
        "8058"
      ]
    },
    {
      "From": "0x1feb",
      "To": [
        "8059"
      ]
    },
    {
      "From": "0x1fec",
      "To": [
        "8165"
      ]
    },
    {
      "From": "0x1ff2",
      "To": [
        "8060",
        "953"
      ]
    },
    {
      "From": "0x1ff3",
      "To": [
        "969",
        "953"
      ]
    },
    {
      "From": "0x1ff4",
      "To": [
        "974",
        "953"
      ]
    },
    {
      "From": "0x1ff6",
      "To": [
        "969",
        "834"
      ]
    },
    {
      "From": "0x1ff7",
      "To": [
        "969",
        "834",
        "953"
      ]
    },
    {
      "From": "0x1ff8",
      "To": [
        "8056"
      ]
    },
    {
      "From": "0x1ff9",
      "To": [
        "8057"
      ]
    },
    {
      "From": "0x1ffa",
      "To": [
        "8060"
      ]
    },
    {
      "From": "0x1ffb",
      "To": [
        "8061"
      ]
    },
    {
      "From": "0x1ffc",
      "To": [
        "969",
        "953"
      ]
    },
    {
      "From": "0x2126",
      "To": [
        "969"
      ]
    },
    {
      "From": "0x212a",
      "To": [
        "107"
      ]
    },
    {
      "From": "0x212b",
      "To": [
        "229"
      ]
    },
    {
      "From": "0x2132",
      "To": [
        "8526"
      ]
    },
    {
      "From": "0x2160",
      "To": [
        "8560"
      ]
    },
    {
      "From": "0x2161",
      "To": [
        "8561"
      ]
    },
    {
      "From": "0x2162",
      "To": [
        "8562"
      ]
    },
    {
      "From": "0x2163",
      "To": [
        "8563"
      ]
    },
    {
      "From": "0x2164",
      "To": [
        "8564"
      ]
    },
    {
      "From": "0x2165",
      "To": [
        "8565"
      ]
    },
    {
      "From": "0x2166",
      "To": [
        "8566"
      ]
    },
    {
      "From": "0x2167",
      "To": [
        "8567"
      ]
    },
    {
      "From": "0x2168",
      "To": [
        "8568"
      ]
    },
    {
      "From": "0x2169",
      "To": [
        "8569"
      ]
    },
    {
      "From": "0x216a",
      "To": [
        "8570"
      ]
    },
    {
      "From": "0x216b",
      "To": [
        "8571"
      ]
    },
    {
      "From": "0x216c",
      "To": [
        "8572"
      ]
    },
    {
      "From": "0x216d",
      "To": [
        "8573"
      ]
    },
    {
      "From": "0x216e",
      "To": [
        "8574"
      ]
    },
    {
      "From": "0x216f",
      "To": [
        "8575"
      ]
    },
    {
      "From": "0x2183",
      "To": [
        "8580"
      ]
    },
    {
      "From": "0x24b6",
      "To": [
        "9424"
      ]
    },
    {
      "From": "0x24b7",
      "To": [
        "9425"
      ]
    },
    {
      "From": "0x24b8",
      "To": [
        "9426"
      ]
    },
    {
      "From": "0x24b9",
      "To": [
        "9427"
      ]
    },
    {
      "From": "0x24ba",
      "To": [
        "9428"
      ]
    },
    {
      "From": "0x24bb",
      "To": [
        "9429"
      ]
    },
    {
      "From": "0x24bc",
      "To": [
        "9430"
      ]
    },
    {
      "From": "0x24bd",
      "To": [
        "9431"
      ]
    },
    {
      "From": "0x24be",
      "To": [
        "9432"
      ]
    },
    {
      "From": "0x24bf",
      "To": [
        "9433"
      ]
    },
    {
      "From": "0x24c0",
      "To": [
        "9434"
      ]
    },
    {
      "From": "0x24c1",
      "To": [
        "9435"
      ]
    },
    {
      "From": "0x24c2",
      "To": [
        "9436"
      ]
    },
    {
      "From": "0x24c3",
      "To": [
        "9437"
      ]
    },
    {
      "From": "0x24c4",
      "To": [
        "9438"
      ]
    },
    {
      "From": "0x24c5",
      "To": [
        "9439"
      ]
    },
    {
      "From": "0x24c6",
      "To": [
        "9440"
      ]
    },
    {
      "From": "0x24c7",
      "To": [
        "9441"
      ]
    },
    {
      "From": "0x24c8",
      "To": [
        "9442"
      ]
    },
    {
      "From": "0x24c9",
      "To": [
        "9443"
      ]
    },
    {
      "From": "0x24ca",
      "To": [
        "9444"
      ]
    },
    {
      "From": "0x24cb",
      "To": [
        "9445"
      ]
    },
    {
      "From": "0x24cc",
      "To": [
        "9446"
      ]
    },
    {
      "From": "0x24cd",
      "To": [
        "9447"
      ]
    },
    {
      "From": "0x24ce",
      "To": [
        "9448"
      ]
    },
    {
      "From": "0x24cf",
      "To": [
        "9449"
      ]
    },
    {
      "From": "0x2c00",
      "To": [
        "11312"
      ]
    },
    {
      "From": "0x2c01",
      "To": [
        "11313"
      ]
    },
    {
      "From": "0x2c02",
      "To": [
        "11314"
      ]
    },
    {
      "From": "0x2c03",
      "To": [
        "11315"
      ]
    },
    {
      "From": "0x2c04",
      "To": [
        "11316"
      ]
    },
    {
      "From": "0x2c05",
      "To": [
        "11317"
      ]
    },
    {
      "From": "0x2c06",
      "To": [
        "11318"
      ]
    },
    {
      "From": "0x2c07",
      "To": [
        "11319"
      ]
    },
    {
      "From": "0x2c08",
      "To": [
        "11320"
      ]
    },
    {
      "From": "0x2c09",
      "To": [
        "11321"
      ]
    },
    {
      "From": "0x2c0a",
      "To": [
        "11322"
      ]
    },
    {
      "From": "0x2c0b",
      "To": [
        "11323"
      ]
    },
    {
      "From": "0x2c0c",
      "To": [
        "11324"
      ]
    },
    {
      "From": "0x2c0d",
      "To": [
        "11325"
      ]
    },
    {
      "From": "0x2c0e",
      "To": [
        "11326"
      ]
    },
    {
      "From": "0x2c0f",
      "To": [
        "11327"
      ]
    },
    {
      "From": "0x2c10",
      "To": [
        "11328"
      ]
    },
    {
      "From": "0x2c11",
      "To": [
        "11329"
      ]
    },
    {
      "From": "0x2c12",
      "To": [
        "11330"
      ]
    },
    {
      "From": "0x2c13",
      "To": [
        "11331"
      ]
    },
    {
      "From": "0x2c14",
      "To": [
        "11332"
      ]
    },
    {
      "From": "0x2c15",
      "To": [
        "11333"
      ]
    },
    {
      "From": "0x2c16",
      "To": [
        "11334"
      ]
    },
    {
      "From": "0x2c17",
      "To": [
        "11335"
      ]
    },
    {
      "From": "0x2c18",
      "To": [
        "11336"
      ]
    },
    {
      "From": "0x2c19",
      "To": [
        "11337"
      ]
    },
    {
      "From": "0x2c1a",
      "To": [
        "11338"
      ]
    },
    {
      "From": "0x2c1b",
      "To": [
        "11339"
      ]
    },
    {
      "From": "0x2c1c",
      "To": [
        "11340"
      ]
    },
    {
      "From": "0x2c1d",
      "To": [
        "11341"
      ]
    },
    {
      "From": "0x2c1e",
      "To": [
        "11342"
      ]
    },
    {
      "From": "0x2c1f",
      "To": [
        "11343"
      ]
    },
    {
      "From": "0x2c20",
      "To": [
        "11344"
      ]
    },
    {
      "From": "0x2c21",
      "To": [
        "11345"
      ]
    },
    {
      "From": "0x2c22",
      "To": [
        "11346"
      ]
    },
    {
      "From": "0x2c23",
      "To": [
        "11347"
      ]
    },
    {
      "From": "0x2c24",
      "To": [
        "11348"
      ]
    },
    {
      "From": "0x2c25",
      "To": [
        "11349"
      ]
    },
    {
      "From": "0x2c26",
      "To": [
        "11350"
      ]
    },
    {
      "From": "0x2c27",
      "To": [
        "11351"
      ]
    },
    {
      "From": "0x2c28",
      "To": [
        "11352"
      ]
    },
    {
      "From": "0x2c29",
      "To": [
        "11353"
      ]
    },
    {
      "From": "0x2c2a",
      "To": [
        "11354"
      ]
    },
    {
      "From": "0x2c2b",
      "To": [
        "11355"
      ]
    },
    {
      "From": "0x2c2c",
      "To": [
        "11356"
      ]
    },
    {
      "From": "0x2c2d",
      "To": [
        "11357"
      ]
    },
    {
      "From": "0x2c2e",
      "To": [
        "11358"
      ]
    },
    {
      "From": "0x2c2f",
      "To": [
        "11359"
      ]
    },
    {
      "From": "0x2c60",
      "To": [
        "11361"
      ]
    },
    {
      "From": "0x2c62",
      "To": [
        "619"
      ]
    },
    {
      "From": "0x2c63",
      "To": [
        "7549"
      ]
    },
    {
      "From": "0x2c64",
      "To": [
        "637"
      ]
    },
    {
      "From": "0x2c67",
      "To": [
        "11368"
      ]
    },
    {
      "From": "0x2c69",
      "To": [
        "11370"
      ]
    },
    {
      "From": "0x2c6b",
      "To": [
        "11372"
      ]
    },
    {
      "From": "0x2c6d",
      "To": [
        "593"
      ]
    },
    {
      "From": "0x2c6e",
      "To": [
        "625"
      ]
    },
    {
      "From": "0x2c6f",
      "To": [
        "592"
      ]
    },
    {
      "From": "0x2c70",
      "To": [
        "594"
      ]
    },
    {
      "From": "0x2c72",
      "To": [
        "11379"
      ]
    },
    {
      "From": "0x2c75",
      "To": [
        "11382"
      ]
    },
    {
      "From": "0x2c7e",
      "To": [
        "575"
      ]
    },
    {
      "From": "0x2c7f",
      "To": [
        "576"
      ]
    },
    {
      "From": "0x2c80",
      "To": [
        "11393"
      ]
    },
    {
      "From": "0x2c82",
      "To": [
        "11395"
      ]
    },
    {
      "From": "0x2c84",
      "To": [
        "11397"
      ]
    },
    {
      "From": "0x2c86",
      "To": [
        "11399"
      ]
    },
    {
      "From": "0x2c88",
      "To": [
        "11401"
      ]
    },
    {
      "From": "0x2c8a",
      "To": [
        "11403"
      ]
    },
    {
      "From": "0x2c8c",
      "To": [
        "11405"
      ]
    },
    {
      "From": "0x2c8e",
      "To": [
        "11407"
      ]
    },
    {
      "From": "0x2c90",
      "To": [
        "11409"
      ]
    },
    {
      "From": "0x2c92",
      "To": [
        "11411"
      ]
    },
    {
      "From": "0x2c94",
      "To": [
        "11413"
      ]
    },
    {
      "From": "0x2c96",
      "To": [
        "11415"
      ]
    },
    {
      "From": "0x2c98",
      "To": [
        "11417"
      ]
    },
    {
      "From": "0x2c9a",
      "To": [
        "11419"
      ]
    },
    {
      "From": "0x2c9c",
      "To": [
        "11421"
      ]
    },
    {
      "From": "0x2c9e",
      "To": [
        "11423"
      ]
    },
    {
      "From": "0x2ca0",
      "To": [
        "11425"
      ]
    },
    {
      "From": "0x2ca2",
      "To": [
        "11427"
      ]
    },
    {
      "From": "0x2ca4",
      "To": [
        "11429"
      ]
    },
    {
      "From": "0x2ca6",
      "To": [
        "11431"
      ]
    },
    {
      "From": "0x2ca8",
      "To": [
        "11433"
      ]
    },
    {
      "From": "0x2caa",
      "To": [
        "11435"
      ]
    },
    {
      "From": "0x2cac",
      "To": [
        "11437"
      ]
    },
    {
      "From": "0x2cae",
      "To": [
        "11439"
      ]
    },
    {
      "From": "0x2cb0",
      "To": [
        "11441"
      ]
    },
    {
      "From": "0x2cb2",
      "To": [
        "11443"
      ]
    },
    {
      "From": "0x2cb4",
      "To": [
        "11445"
      ]
    },
    {
      "From": "0x2cb6",
      "To": [
        "11447"
      ]
    },
    {
      "From": "0x2cb8",
      "To": [
        "11449"
      ]
    },
    {
      "From": "0x2cba",
      "To": [
        "11451"
      ]
    },
    {
      "From": "0x2cbc",
      "To": [
        "11453"
      ]
    },
    {
      "From": "0x2cbe",
      "To": [
        "11455"
      ]
    },
    {
      "From": "0x2cc0",
      "To": [
        "11457"
      ]
    },
    {
      "From": "0x2cc2",
      "To": [
        "11459"
      ]
    },
    {
      "From": "0x2cc4",
      "To": [
        "11461"
      ]
    },
    {
      "From": "0x2cc6",
      "To": [
        "11463"
      ]
    },
    {
      "From": "0x2cc8",
      "To": [
        "11465"
      ]
    },
    {
      "From": "0x2cca",
      "To": [
        "11467"
      ]
    },
    {
      "From": "0x2ccc",
      "To": [
        "11469"
      ]
    },
    {
      "From": "0x2cce",
      "To": [
        "11471"
      ]
    },
    {
      "From": "0x2cd0",
      "To": [
        "11473"
      ]
    },
    {
      "From": "0x2cd2",
      "To": [
        "11475"
      ]
    },
    {
      "From": "0x2cd4",
      "To": [
        "11477"
      ]
    },
    {
      "From": "0x2cd6",
      "To": [
        "11479"
      ]
    },
    {
      "From": "0x2cd8",
      "To": [
        "11481"
      ]
    },
    {
      "From": "0x2cda",
      "To": [
        "11483"
      ]
    },
    {
      "From": "0x2cdc",
      "To": [
        "11485"
      ]
    },
    {
      "From": "0x2cde",
      "To": [
        "11487"
      ]
    },
    {
      "From": "0x2ce0",
      "To": [
        "11489"
      ]
    },
    {
      "From": "0x2ce2",
      "To": [
        "11491"
      ]
    },
    {
      "From": "0x2ceb",
      "To": [
        "11500"
      ]
    },
    {
      "From": "0x2ced",
      "To": [
        "11502"
      ]
    },
    {
      "From": "0x2cf2",
      "To": [
        "11507"
      ]
    },
    {
      "From": "0xa640",
      "To": [
        "42561"
      ]
    },
    {
      "From": "0xa642",
      "To": [
        "42563"
      ]
    },
    {
      "From": "0xa644",
      "To": [
        "42565"
      ]
    },
    {
      "From": "0xa646",
      "To": [
        "42567"
      ]
    },
    {
      "From": "0xa648",
      "To": [
        "42569"
      ]
    },
    {
      "From": "0xa64a",
      "To": [
        "42571"
      ]
    },
    {
      "From": "0xa64c",
      "To": [
        "42573"
      ]
    },
    {
      "From": "0xa64e",
      "To": [
        "42575"
      ]
    },
    {
      "From": "0xa650",
      "To": [
        "42577"
      ]
    },
    {
      "From": "0xa652",
      "To": [
        "42579"
      ]
    },
    {
      "From": "0xa654",
      "To": [
        "42581"
      ]
    },
    {
      "From": "0xa656",
      "To": [
        "42583"
      ]
    },
    {
      "From": "0xa658",
      "To": [
        "42585"
      ]
    },
    {
      "From": "0xa65a",
      "To": [
        "42587"
      ]
    },
    {
      "From": "0xa65c",
      "To": [
        "42589"
      ]
    },
    {
      "From": "0xa65e",
      "To": [
        "42591"
      ]
    },
    {
      "From": "0xa660",
      "To": [
        "42593"
      ]
    },
    {
      "From": "0xa662",
      "To": [
        "42595"
      ]
    },
    {
      "From": "0xa664",
      "To": [
        "42597"
      ]
    },
    {
      "From": "0xa666",
      "To": [
        "42599"
      ]
    },
    {
      "From": "0xa668",
      "To": [
        "42601"
      ]
    },
    {
      "From": "0xa66a",
      "To": [
        "42603"
      ]
    },
    {
      "From": "0xa66c",
      "To": [
        "42605"
      ]
    },
    {
      "From": "0xa680",
      "To": [
        "42625"
      ]
    },
    {
      "From": "0xa682",
      "To": [
        "42627"
      ]
    },
    {
      "From": "0xa684",
      "To": [
        "42629"
      ]
    },
    {
      "From": "0xa686",
      "To": [
        "42631"
      ]
    },
    {
      "From": "0xa688",
      "To": [
        "42633"
      ]
    },
    {
      "From": "0xa68a",
      "To": [
        "42635"
      ]
    },
    {
      "From": "0xa68c",
      "To": [
        "42637"
      ]
    },
    {
      "From": "0xa68e",
      "To": [
        "42639"
      ]
    },
    {
      "From": "0xa690",
      "To": [
        "42641"
      ]
    },
    {
      "From": "0xa692",
      "To": [
        "42643"
      ]
    },
    {
      "From": "0xa694",
      "To": [
        "42645"
      ]
    },
    {
      "From": "0xa696",
      "To": [
        "42647"
      ]
    },
    {
      "From": "0xa698",
      "To": [
        "42649"
      ]
    },
    {
      "From": "0xa69a",
      "To": [
        "42651"
      ]
    },
    {
      "From": "0xa722",
      "To": [
        "42787"
      ]
    },
    {
      "From": "0xa724",
      "To": [
        "42789"
      ]
    },
    {
      "From": "0xa726",
      "To": [
        "42791"
      ]
    },
    {
      "From": "0xa728",
      "To": [
        "42793"
      ]
    },
    {
      "From": "0xa72a",
      "To": [
        "42795"
      ]
    },
    {
      "From": "0xa72c",
      "To": [
        "42797"
      ]
    },
    {
      "From": "0xa72e",
      "To": [
        "42799"
      ]
    },
    {
      "From": "0xa732",
      "To": [
        "42803"
      ]
    },
    {
      "From": "0xa734",
      "To": [
        "42805"
      ]
    },
    {
      "From": "0xa736",
      "To": [
        "42807"
      ]
    },
    {
      "From": "0xa738",
      "To": [
        "42809"
      ]
    },
    {
      "From": "0xa73a",
      "To": [
        "42811"
      ]
    },
    {
      "From": "0xa73c",
      "To": [
        "42813"
      ]
    },
    {
      "From": "0xa73e",
      "To": [
        "42815"
      ]
    },
    {
      "From": "0xa740",
      "To": [
        "42817"
      ]
    },
    {
      "From": "0xa742",
      "To": [
        "42819"
      ]
    },
    {
      "From": "0xa744",
      "To": [
        "42821"
      ]
    },
    {
      "From": "0xa746",
      "To": [
        "42823"
      ]
    },
    {
      "From": "0xa748",
      "To": [
        "42825"
      ]
    },
    {
      "From": "0xa74a",
      "To": [
        "42827"
      ]
    },
    {
      "From": "0xa74c",
      "To": [
        "42829"
      ]
    },
    {
      "From": "0xa74e",
      "To": [
        "42831"
      ]
    },
    {
      "From": "0xa750",
      "To": [
        "42833"
      ]
    },
    {
      "From": "0xa752",
      "To": [
        "42835"
      ]
    },
    {
      "From": "0xa754",
      "To": [
        "42837"
      ]
    },
    {
      "From": "0xa756",
      "To": [
        "42839"
      ]
    },
    {
      "From": "0xa758",
      "To": [
        "42841"
      ]
    },
    {
      "From": "0xa75a",
      "To": [
        "42843"
      ]
    },
    {
      "From": "0xa75c",
      "To": [
        "42845"
      ]
    },
    {
      "From": "0xa75e",
      "To": [
        "42847"
      ]
    },
    {
      "From": "0xa760",
      "To": [
        "42849"
      ]
    },
    {
      "From": "0xa762",
      "To": [
        "42851"
      ]
    },
    {
      "From": "0xa764",
      "To": [
        "42853"
      ]
    },
    {
      "From": "0xa766",
      "To": [
        "42855"
      ]
    },
    {
      "From": "0xa768",
      "To": [
        "42857"
      ]
    },
    {
      "From": "0xa76a",
      "To": [
        "42859"
      ]
    },
    {
      "From": "0xa76c",
      "To": [
        "42861"
      ]
    },
    {
      "From": "0xa76e",
      "To": [
        "42863"
      ]
    },
    {
      "From": "0xa779",
      "To": [
        "42874"
      ]
    },
    {
      "From": "0xa77b",
      "To": [
        "42876"
      ]
    },
    {
      "From": "0xa77d",
      "To": [
        "7545"
      ]
    },
    {
      "From": "0xa77e",
      "To": [
        "42879"
      ]
    },
    {
      "From": "0xa780",
      "To": [
        "42881"
      ]
    },
    {
      "From": "0xa782",
      "To": [
        "42883"
      ]
    },
    {
      "From": "0xa784",
      "To": [
        "42885"
      ]
    },
    {
      "From": "0xa786",
      "To": [
        "42887"
      ]
    },
    {
      "From": "0xa78b",
      "To": [
        "42892"
      ]
    },
    {
      "From": "0xa78d",
      "To": [
        "613"
      ]
    },
    {
      "From": "0xa790",
      "To": [
        "42897"
      ]
    },
    {
      "From": "0xa792",
      "To": [
        "42899"
      ]
    },
    {
      "From": "0xa796",
      "To": [
        "42903"
      ]
    },
    {
      "From": "0xa798",
      "To": [
        "42905"
      ]
    },
    {
      "From": "0xa79a",
      "To": [
        "42907"
      ]
    },
    {
      "From": "0xa79c",
      "To": [
        "42909"
      ]
    },
    {
      "From": "0xa79e",
      "To": [
        "42911"
      ]
    },
    {
      "From": "0xa7a0",
      "To": [
        "42913"
      ]
    },
    {
      "From": "0xa7a2",
      "To": [
        "42915"
      ]
    },
    {
      "From": "0xa7a4",
      "To": [
        "42917"
      ]
    },
    {
      "From": "0xa7a6",
      "To": [
        "42919"
      ]
    },
    {
      "From": "0xa7a8",
      "To": [
        "42921"
      ]
    },
    {
      "From": "0xa7aa",
      "To": [
        "614"
      ]
    },
    {
      "From": "0xa7ab",
      "To": [
        "604"
      ]
    },
    {
      "From": "0xa7ac",
      "To": [
        "609"
      ]
    },
    {
      "From": "0xa7ad",
      "To": [
        "620"
      ]
    },
    {
      "From": "0xa7ae",
      "To": [
        "618"
      ]
    },
    {
      "From": "0xa7b0",
      "To": [
        "670"
      ]
    },
    {
      "From": "0xa7b1",
      "To": [
        "647"
      ]
    },
    {
      "From": "0xa7b2",
      "To": [
        "669"
      ]
    },
    {
      "From": "0xa7b3",
      "To": [
        "43859"
      ]
    },
    {
      "From": "0xa7b4",
      "To": [
        "42933"
      ]
    },
    {
      "From": "0xa7b6",
      "To": [
        "42935"
      ]
    },
    {
      "From": "0xa7b8",
      "To": [
        "42937"
      ]
    },
    {
      "From": "0xa7ba",
      "To": [
        "42939"
      ]
    },
    {
      "From": "0xa7bc",
      "To": [
        "42941"
      ]
    },
    {
      "From": "0xa7be",
      "To": [
        "42943"
      ]
    },
    {
      "From": "0xa7c0",
      "To": [
        "42945"
      ]
    },
    {
      "From": "0xa7c2",
      "To": [
        "42947"
      ]
    },
    {
      "From": "0xa7c4",
      "To": [
        "42900"
      ]
    },
    {
      "From": "0xa7c5",
      "To": [
        "642"
      ]
    },
    {
      "From": "0xa7c6",
      "To": [
        "7566"
      ]
    },
    {
      "From": "0xa7c7",
      "To": [
        "42952"
      ]
    },
    {
      "From": "0xa7c9",
      "To": [
        "42954"
      ]
    },
    {
      "From": "0xa7d0",
      "To": [
        "42961"
      ]
    },
    {
      "From": "0xa7d6",
      "To": [
        "42967"
      ]
    },
    {
      "From": "0xa7d8",
      "To": [
        "42969"
      ]
    },
    {
      "From": "0xa7f5",
      "To": [
        "42998"
      ]
    },
    {
      "From": "0xab70",
      "To": [
        "5024"
      ]
    },
    {
      "From": "0xab71",
      "To": [
        "5025"
      ]
    },
    {
      "From": "0xab72",
      "To": [
        "5026"
      ]
    },
    {
      "From": "0xab73",
      "To": [
        "5027"
      ]
    },
    {
      "From": "0xab74",
      "To": [
        "5028"
      ]
    },
    {
      "From": "0xab75",
      "To": [
        "5029"
      ]
    },
    {
      "From": "0xab76",
      "To": [
        "5030"
      ]
    },
    {
      "From": "0xab77",
      "To": [
        "5031"
      ]
    },
    {
      "From": "0xab78",
      "To": [
        "5032"
      ]
    },
    {
      "From": "0xab79",
      "To": [
        "5033"
      ]
    },
    {
      "From": "0xab7a",
      "To": [
        "5034"
      ]
    },
    {
      "From": "0xab7b",
      "To": [
        "5035"
      ]
    },
    {
      "From": "0xab7c",
      "To": [
        "5036"
      ]
    },
    {
      "From": "0xab7d",
      "To": [
        "5037"
      ]
    },
    {
      "From": "0xab7e",
      "To": [
        "5038"
      ]
    },
    {
      "From": "0xab7f",
      "To": [
        "5039"
      ]
    },
    {
      "From": "0xab80",
      "To": [
        "5040"
      ]
    },
    {
      "From": "0xab81",
      "To": [
        "5041"
      ]
    },
    {
      "From": "0xab82",
      "To": [
        "5042"
      ]
    },
    {
      "From": "0xab83",
      "To": [
        "5043"
      ]
    },
    {
      "From": "0xab84",
      "To": [
        "5044"
      ]
    },
    {
      "From": "0xab85",
      "To": [
        "5045"
      ]
    },
    {
      "From": "0xab86",
      "To": [
        "5046"
      ]
    },
    {
      "From": "0xab87",
      "To": [
        "5047"
      ]
    },
    {
      "From": "0xab88",
      "To": [
        "5048"
      ]
    },
    {
      "From": "0xab89",
      "To": [
        "5049"
      ]
    },
    {
      "From": "0xab8a",
      "To": [
        "5050"
      ]
    },
    {
      "From": "0xab8b",
      "To": [
        "5051"
      ]
    },
    {
      "From": "0xab8c",
      "To": [
        "5052"
      ]
    },
    {
      "From": "0xab8d",
      "To": [
        "5053"
      ]
    },
    {
      "From": "0xab8e",
      "To": [
        "5054"
      ]
    },
    {
      "From": "0xab8f",
      "To": [
        "5055"
      ]
    },
    {
      "From": "0xab90",
      "To": [
        "5056"
      ]
    },
    {
      "From": "0xab91",
      "To": [
        "5057"
      ]
    },
    {
      "From": "0xab92",
      "To": [
        "5058"
      ]
    },
    {
      "From": "0xab93",
      "To": [
        "5059"
      ]
    },
    {
      "From": "0xab94",
      "To": [
        "5060"
      ]
    },
    {
      "From": "0xab95",
      "To": [
        "5061"
      ]
    },
    {
      "From": "0xab96",
      "To": [
        "5062"
      ]
    },
    {
      "From": "0xab97",
      "To": [
        "5063"
      ]
    },
    {
      "From": "0xab98",
      "To": [
        "5064"
      ]
    },
    {
      "From": "0xab99",
      "To": [
        "5065"
      ]
    },
    {
      "From": "0xab9a",
      "To": [
        "5066"
      ]
    },
    {
      "From": "0xab9b",
      "To": [
        "5067"
      ]
    },
    {
      "From": "0xab9c",
      "To": [
        "5068"
      ]
    },
    {
      "From": "0xab9d",
      "To": [
        "5069"
      ]
    },
    {
      "From": "0xab9e",
      "To": [
        "5070"
      ]
    },
    {
      "From": "0xab9f",
      "To": [
        "5071"
      ]
    },
    {
      "From": "0xaba0",
      "To": [
        "5072"
      ]
    },
    {
      "From": "0xaba1",
      "To": [
        "5073"
      ]
    },
    {
      "From": "0xaba2",
      "To": [
        "5074"
      ]
    },
    {
      "From": "0xaba3",
      "To": [
        "5075"
      ]
    },
    {
      "From": "0xaba4",
      "To": [
        "5076"
      ]
    },
    {
      "From": "0xaba5",
      "To": [
        "5077"
      ]
    },
    {
      "From": "0xaba6",
      "To": [
        "5078"
      ]
    },
    {
      "From": "0xaba7",
      "To": [
        "5079"
      ]
    },
    {
      "From": "0xaba8",
      "To": [
        "5080"
      ]
    },
    {
      "From": "0xaba9",
      "To": [
        "5081"
      ]
    },
    {
      "From": "0xabaa",
      "To": [
        "5082"
      ]
    },
    {
      "From": "0xabab",
      "To": [
        "5083"
      ]
    },
    {
      "From": "0xabac",
      "To": [
        "5084"
      ]
    },
    {
      "From": "0xabad",
      "To": [
        "5085"
      ]
    },
    {
      "From": "0xabae",
      "To": [
        "5086"
      ]
    },
    {
      "From": "0xabaf",
      "To": [
        "5087"
      ]
    },
    {
      "From": "0xabb0",
      "To": [
        "5088"
      ]
    },
    {
      "From": "0xabb1",
      "To": [
        "5089"
      ]
    },
    {
      "From": "0xabb2",
      "To": [
        "5090"
      ]
    },
    {
      "From": "0xabb3",
      "To": [
        "5091"
      ]
    },
    {
      "From": "0xabb4",
      "To": [
        "5092"
      ]
    },
    {
      "From": "0xabb5",
      "To": [
        "5093"
      ]
    },
    {
      "From": "0xabb6",
      "To": [
        "5094"
      ]
    },
    {
      "From": "0xabb7",
      "To": [
        "5095"
      ]
    },
    {
      "From": "0xabb8",
      "To": [
        "5096"
      ]
    },
    {
      "From": "0xabb9",
      "To": [
        "5097"
      ]
    },
    {
      "From": "0xabba",
      "To": [
        "5098"
      ]
    },
    {
      "From": "0xabbb",
      "To": [
        "5099"
      ]
    },
    {
      "From": "0xabbc",
      "To": [
        "5100"
      ]
    },
    {
      "From": "0xabbd",
      "To": [
        "5101"
      ]
    },
    {
      "From": "0xabbe",
      "To": [
        "5102"
      ]
    },
    {
      "From": "0xabbf",
      "To": [
        "5103"
      ]
    },
    {
      "From": "0xfb00",
      "To": [
        "102",
        "102"
      ]
    },
    {
      "From": "0xfb01",
      "To": [
        "102",
        "105"
      ]
    },
    {
      "From": "0xfb02",
      "To": [
        "102",
        "108"
      ]
    },
    {
      "From": "0xfb03",
      "To": [
        "102",
        "102",
        "105"
      ]
    },
    {
      "From": "0xfb04",
      "To": [
        "102",
        "102",
        "108"
      ]
    },
    {
      "From": "0xfb05",
      "To": [
        "115",
        "116"
      ]
    },
    {
      "From": "0xfb06",
      "To": [
        "115",
        "116"
      ]
    },
    {
      "From": "0xfb13",
      "To": [
        "1396",
        "1398"
      ]
    },
    {
      "From": "0xfb14",
      "To": [
        "1396",
        "1381"
      ]
    },
    {
      "From": "0xfb15",
      "To": [
        "1396",
        "1387"
      ]
    },
    {
      "From": "0xfb16",
      "To": [
        "1406",
        "1398"
      ]
    },
    {
      "From": "0xfb17",
      "To": [
        "1396",
        "1389"
      ]
    },
    {
      "From": "0xff21",
      "To": [
        "65345"
      ]
    },
    {
      "From": "0xff22",
      "To": [
        "65346"
      ]
    },
    {
      "From": "0xff23",
      "To": [
        "65347"
      ]
    },
    {
      "From": "0xff24",
      "To": [
        "65348"
      ]
    },
    {
      "From": "0xff25",
      "To": [
        "65349"
      ]
    },
    {
      "From": "0xff26",
      "To": [
        "65350"
      ]
    },
    {
      "From": "0xff27",
      "To": [
        "65351"
      ]
    },
    {
      "From": "0xff28",
      "To": [
        "65352"
      ]
    },
    {
      "From": "0xff29",
      "To": [
        "65353"
      ]
    },
    {
      "From": "0xff2a",
      "To": [
        "65354"
      ]
    },
    {
      "From": "0xff2b",
      "To": [
        "65355"
      ]
    },
    {
      "From": "0xff2c",
      "To": [
        "65356"
      ]
    },
    {
      "From": "0xff2d",
      "To": [
        "65357"
      ]
    },
    {
      "From": "0xff2e",
      "To": [
        "65358"
      ]
    },
    {
      "From": "0xff2f",
      "To": [
        "65359"
      ]
    },
    {
      "From": "0xff30",
      "To": [
        "65360"
      ]
    },
    {
      "From": "0xff31",
      "To": [
        "65361"
      ]
    },
    {
      "From": "0xff32",
      "To": [
        "65362"
      ]
    },
    {
      "From": "0xff33",
      "To": [
        "65363"
      ]
    },
    {
      "From": "0xff34",
      "To": [
        "65364"
      ]
    },
    {
      "From": "0xff35",
      "To": [
        "65365"
      ]
    },
    {
      "From": "0xff36",
      "To": [
        "65366"
      ]
    },
    {
      "From": "0xff37",
      "To": [
        "65367"
      ]
    },
    {
      "From": "0xff38",
      "To": [
        "65368"
      ]
    },
    {
      "From": "0xff39",
      "To": [
        "65369"
      ]
    },
    {
      "From": "0xff3a",
      "To": [
        "65370"
      ]
    },
    {
      "From": "0x10400",
      "To": [
        "66600"
      ]
    },
    {
      "From": "0x10401",
      "To": [
        "66601"
      ]
    },
    {
      "From": "0x10402",
      "To": [
        "66602"
      ]
    },
    {
      "From": "0x10403",
      "To": [
        "66603"
      ]
    },
    {
      "From": "0x10404",
      "To": [
        "66604"
      ]
    },
    {
      "From": "0x10405",
      "To": [
        "66605"
      ]
    },
    {
      "From": "0x10406",
      "To": [
        "66606"
      ]
    },
    {
      "From": "0x10407",
      "To": [
        "66607"
      ]
    },
    {
      "From": "0x10408",
      "To": [
        "66608"
      ]
    },
    {
      "From": "0x10409",
      "To": [
        "66609"
      ]
    },
    {
      "From": "0x1040a",
      "To": [
        "66610"
      ]
    },
    {
      "From": "0x1040b",
      "To": [
        "66611"
      ]
    },
    {
      "From": "0x1040c",
      "To": [
        "66612"
      ]
    },
    {
      "From": "0x1040d",
      "To": [
        "66613"
      ]
    },
    {
      "From": "0x1040e",
      "To": [
        "66614"
      ]
    },
    {
      "From": "0x1040f",
      "To": [
        "66615"
      ]
    },
    {
      "From": "0x10410",
      "To": [
        "66616"
      ]
    },
    {
      "From": "0x10411",
      "To": [
        "66617"
      ]
    },
    {
      "From": "0x10412",
      "To": [
        "66618"
      ]
    },
    {
      "From": "0x10413",
      "To": [
        "66619"
      ]
    },
    {
      "From": "0x10414",
      "To": [
        "66620"
      ]
    },
    {
      "From": "0x10415",
      "To": [
        "66621"
      ]
    },
    {
      "From": "0x10416",
      "To": [
        "66622"
      ]
    },
    {
      "From": "0x10417",
      "To": [
        "66623"
      ]
    },
    {
      "From": "0x10418",
      "To": [
        "66624"
      ]
    },
    {
      "From": "0x10419",
      "To": [
        "66625"
      ]
    },
    {
      "From": "0x1041a",
      "To": [
        "66626"
      ]
    },
    {
      "From": "0x1041b",
      "To": [
        "66627"
      ]
    },
    {
      "From": "0x1041c",
      "To": [
        "66628"
      ]
    },
    {
      "From": "0x1041d",
      "To": [
        "66629"
      ]
    },
    {
      "From": "0x1041e",
      "To": [
        "66630"
      ]
    },
    {
      "From": "0x1041f",
      "To": [
        "66631"
      ]
    },
    {
      "From": "0x10420",
      "To": [
        "66632"
      ]
    },
    {
      "From": "0x10421",
      "To": [
        "66633"
      ]
    },
    {
      "From": "0x10422",
      "To": [
        "66634"
      ]
    },
    {
      "From": "0x10423",
      "To": [
        "66635"
      ]
    },
    {
      "From": "0x10424",
      "To": [
        "66636"
      ]
    },
    {
      "From": "0x10425",
      "To": [
        "66637"
      ]
    },
    {
      "From": "0x10426",
      "To": [
        "66638"
      ]
    },
    {
      "From": "0x10427",
      "To": [
        "66639"
      ]
    },
    {
      "From": "0x104b0",
      "To": [
        "66776"
      ]
    },
    {
      "From": "0x104b1",
      "To": [
        "66777"
      ]
    },
    {
      "From": "0x104b2",
      "To": [
        "66778"
      ]
    },
    {
      "From": "0x104b3",
      "To": [
        "66779"
      ]
    },
    {
      "From": "0x104b4",
      "To": [
        "66780"
      ]
    },
    {
      "From": "0x104b5",
      "To": [
        "66781"
      ]
    },
    {
      "From": "0x104b6",
      "To": [
        "66782"
      ]
    },
    {
      "From": "0x104b7",
      "To": [
        "66783"
      ]
    },
    {
      "From": "0x104b8",
      "To": [
        "66784"
      ]
    },
    {
      "From": "0x104b9",
      "To": [
        "66785"
      ]
    },
    {
      "From": "0x104ba",
      "To": [
        "66786"
      ]
    },
    {
      "From": "0x104bb",
      "To": [
        "66787"
      ]
    },
    {
      "From": "0x104bc",
      "To": [
        "66788"
      ]
    },
    {
      "From": "0x104bd",
      "To": [
        "66789"
      ]
    },
    {
      "From": "0x104be",
      "To": [
        "66790"
      ]
    },
    {
      "From": "0x104bf",
      "To": [
        "66791"
      ]
    },
    {
      "From": "0x104c0",
      "To": [
        "66792"
      ]
    },
    {
      "From": "0x104c1",
      "To": [
        "66793"
      ]
    },
    {
      "From": "0x104c2",
      "To": [
        "66794"
      ]
    },
    {
      "From": "0x104c3",
      "To": [
        "66795"
      ]
    },
    {
      "From": "0x104c4",
      "To": [
        "66796"
      ]
    },
    {
      "From": "0x104c5",
      "To": [
        "66797"
      ]
    },
    {
      "From": "0x104c6",
      "To": [
        "66798"
      ]
    },
    {
      "From": "0x104c7",
      "To": [
        "66799"
      ]
    },
    {
      "From": "0x104c8",
      "To": [
        "66800"
      ]
    },
    {
      "From": "0x104c9",
      "To": [
        "66801"
      ]
    },
    {
      "From": "0x104ca",
      "To": [
        "66802"
      ]
    },
    {
      "From": "0x104cb",
      "To": [
        "66803"
      ]
    },
    {
      "From": "0x104cc",
      "To": [
        "66804"
      ]
    },
    {
      "From": "0x104cd",
      "To": [
        "66805"
      ]
    },
    {
      "From": "0x104ce",
      "To": [
        "66806"
      ]
    },
    {
      "From": "0x104cf",
      "To": [
        "66807"
      ]
    },
    {
      "From": "0x104d0",
      "To": [
        "66808"
      ]
    },
    {
      "From": "0x104d1",
      "To": [
        "66809"
      ]
    },
    {
      "From": "0x104d2",
      "To": [
        "66810"
      ]
    },
    {
      "From": "0x104d3",
      "To": [
        "66811"
      ]
    },
    {
      "From": "0x10570",
      "To": [
        "66967"
      ]
    },
    {
      "From": "0x10571",
      "To": [
        "66968"
      ]
    },
    {
      "From": "0x10572",
      "To": [
        "66969"
      ]
    },
    {
      "From": "0x10573",
      "To": [
        "66970"
      ]
    },
    {
      "From": "0x10574",
      "To": [
        "66971"
      ]
    },
    {
      "From": "0x10575",
      "To": [
        "66972"
      ]
    },
    {
      "From": "0x10576",
      "To": [
        "66973"
      ]
    },
    {
      "From": "0x10577",
      "To": [
        "66974"
      ]
    },
    {
      "From": "0x10578",
      "To": [
        "66975"
      ]
    },
    {
      "From": "0x10579",
      "To": [
        "66976"
      ]
    },
    {
      "From": "0x1057a",
      "To": [
        "66977"
      ]
    },
    {
      "From": "0x1057c",
      "To": [
        "66979"
      ]
    },
    {
      "From": "0x1057d",
      "To": [
        "66980"
      ]
    },
    {
      "From": "0x1057e",
      "To": [
        "66981"
      ]
    },
    {
      "From": "0x1057f",
      "To": [
        "66982"
      ]
    },
    {
      "From": "0x10580",
      "To": [
        "66983"
      ]
    },
    {
      "From": "0x10581",
      "To": [
        "66984"
      ]
    },
    {
      "From": "0x10582",
      "To": [
        "66985"
      ]
    },
    {
      "From": "0x10583",
      "To": [
        "66986"
      ]
    },
    {
      "From": "0x10584",
      "To": [
        "66987"
      ]
    },
    {
      "From": "0x10585",
      "To": [
        "66988"
      ]
    },
    {
      "From": "0x10586",
      "To": [
        "66989"
      ]
    },
    {
      "From": "0x10587",
      "To": [
        "66990"
      ]
    },
    {
      "From": "0x10588",
      "To": [
        "66991"
      ]
    },
    {
      "From": "0x10589",
      "To": [
        "66992"
      ]
    },
    {
      "From": "0x1058a",
      "To": [
        "66993"
      ]
    },
    {
      "From": "0x1058c",
      "To": [
        "66995"
      ]
    },
    {
      "From": "0x1058d",
      "To": [
        "66996"
      ]
    },
    {
      "From": "0x1058e",
      "To": [
        "66997"
      ]
    },
    {
      "From": "0x1058f",
      "To": [
        "66998"
      ]
    },
    {
      "From": "0x10590",
      "To": [
        "66999"
      ]
    },
    {
      "From": "0x10591",
      "To": [
        "67000"
      ]
    },
    {
      "From": "0x10592",
      "To": [
        "67001"
      ]
    },
    {
      "From": "0x10594",
      "To": [
        "67003"
      ]
    },
    {
      "From": "0x10595",
      "To": [
        "67004"
      ]
    },
    {
      "From": "0x10c80",
      "To": [
        "68800"
      ]
    },
    {
      "From": "0x10c81",
      "To": [
        "68801"
      ]
    },
    {
      "From": "0x10c82",
      "To": [
        "68802"
      ]
    },
    {
      "From": "0x10c83",
      "To": [
        "68803"
      ]
    },
    {
      "From": "0x10c84",
      "To": [
        "68804"
      ]
    },
    {
      "From": "0x10c85",
      "To": [
        "68805"
      ]
    },
    {
      "From": "0x10c86",
      "To": [
        "68806"
      ]
    },
    {
      "From": "0x10c87",
      "To": [
        "68807"
      ]
    },
    {
      "From": "0x10c88",
      "To": [
        "68808"
      ]
    },
    {
      "From": "0x10c89",
      "To": [
        "68809"
      ]
    },
    {
      "From": "0x10c8a",
      "To": [
        "68810"
      ]
    },
    {
      "From": "0x10c8b",
      "To": [
        "68811"
      ]
    },
    {
      "From": "0x10c8c",
      "To": [
        "68812"
      ]
    },
    {
      "From": "0x10c8d",
      "To": [
        "68813"
      ]
    },
    {
      "From": "0x10c8e",
      "To": [
        "68814"
      ]
    },
    {
      "From": "0x10c8f",
      "To": [
        "68815"
      ]
    },
    {
      "From": "0x10c90",
      "To": [
        "68816"
      ]
    },
    {
      "From": "0x10c91",
      "To": [
        "68817"
      ]
    },
    {
      "From": "0x10c92",
      "To": [
        "68818"
      ]
    },
    {
      "From": "0x10c93",
      "To": [
        "68819"
      ]
    },
    {
      "From": "0x10c94",
      "To": [
        "68820"
      ]
    },
    {
      "From": "0x10c95",
      "To": [
        "68821"
      ]
    },
    {
      "From": "0x10c96",
      "To": [
        "68822"
      ]
    },
    {
      "From": "0x10c97",
      "To": [
        "68823"
      ]
    },
    {
      "From": "0x10c98",
      "To": [
        "68824"
      ]
    },
    {
      "From": "0x10c99",
      "To": [
        "68825"
      ]
    },
    {
      "From": "0x10c9a",
      "To": [
        "68826"
      ]
    },
    {
      "From": "0x10c9b",
      "To": [
        "68827"
      ]
    },
    {
      "From": "0x10c9c",
      "To": [
        "68828"
      ]
    },
    {
      "From": "0x10c9d",
      "To": [
        "68829"
      ]
    },
    {
      "From": "0x10c9e",
      "To": [
        "68830"
      ]
    },
    {
      "From": "0x10c9f",
      "To": [
        "68831"
      ]
    },
    {
      "From": "0x10ca0",
      "To": [
        "68832"
      ]
    },
    {
      "From": "0x10ca1",
      "To": [
        "68833"
      ]
    },
    {
      "From": "0x10ca2",
      "To": [
        "68834"
      ]
    },
    {
      "From": "0x10ca3",
      "To": [
        "68835"
      ]
    },
    {
      "From": "0x10ca4",
      "To": [
        "68836"
      ]
    },
    {
      "From": "0x10ca5",
      "To": [
        "68837"
      ]
    },
    {
      "From": "0x10ca6",
      "To": [
        "68838"
      ]
    },
    {
      "From": "0x10ca7",
      "To": [
        "68839"
      ]
    },
    {
      "From": "0x10ca8",
      "To": [
        "68840"
      ]
    },
    {
      "From": "0x10ca9",
      "To": [
        "68841"
      ]
    },
    {
      "From": "0x10caa",
      "To": [
        "68842"
      ]
    },
    {
      "From": "0x10cab",
      "To": [
        "68843"
      ]
    },
    {
      "From": "0x10cac",
      "To": [
        "68844"
      ]
    },
    {
      "From": "0x10cad",
      "To": [
        "68845"
      ]
    },
    {
      "From": "0x10cae",
      "To": [
        "68846"
      ]
    },
    {
      "From": "0x10caf",
      "To": [
        "68847"
      ]
    },
    {
      "From": "0x10cb0",
      "To": [
        "68848"
      ]
    },
    {
      "From": "0x10cb1",
      "To": [
        "68849"
      ]
    },
    {
      "From": "0x10cb2",
      "To": [
        "68850"
      ]
    },
    {
      "From": "0x118a0",
      "To": [
        "71872"
      ]
    },
    {
      "From": "0x118a1",
      "To": [
        "71873"
      ]
    },
    {
      "From": "0x118a2",
      "To": [
        "71874"
      ]
    },
    {
      "From": "0x118a3",
      "To": [
        "71875"
      ]
    },
    {
      "From": "0x118a4",
      "To": [
        "71876"
      ]
    },
    {
      "From": "0x118a5",
      "To": [
        "71877"
      ]
    },
    {
      "From": "0x118a6",
      "To": [
        "71878"
      ]
    },
    {
      "From": "0x118a7",
      "To": [
        "71879"
      ]
    },
    {
      "From": "0x118a8",
      "To": [
        "71880"
      ]
    },
    {
      "From": "0x118a9",
      "To": [
        "71881"
      ]
    },
    {
      "From": "0x118aa",
      "To": [
        "71882"
      ]
    },
    {
      "From": "0x118ab",
      "To": [
        "71883"
      ]
    },
    {
      "From": "0x118ac",
      "To": [
        "71884"
      ]
    },
    {
      "From": "0x118ad",
      "To": [
        "71885"
      ]
    },
    {
      "From": "0x118ae",
      "To": [
        "71886"
      ]
    },
    {
      "From": "0x118af",
      "To": [
        "71887"
      ]
    },
    {
      "From": "0x118b0",
      "To": [
        "71888"
      ]
    },
    {
      "From": "0x118b1",
      "To": [
        "71889"
      ]
    },
    {
      "From": "0x118b2",
      "To": [
        "71890"
      ]
    },
    {
      "From": "0x118b3",
      "To": [
        "71891"
      ]
    },
    {
      "From": "0x118b4",
      "To": [
        "71892"
      ]
    },
    {
      "From": "0x118b5",
      "To": [
        "71893"
      ]
    },
    {
      "From": "0x118b6",
      "To": [
        "71894"
      ]
    },
    {
      "From": "0x118b7",
      "To": [
        "71895"
      ]
    },
    {
      "From": "0x118b8",
      "To": [
        "71896"
      ]
    },
    {
      "From": "0x118b9",
      "To": [
        "71897"
      ]
    },
    {
      "From": "0x118ba",
      "To": [
        "71898"
      ]
    },
    {
      "From": "0x118bb",
      "To": [
        "71899"
      ]
    },
    {
      "From": "0x118bc",
      "To": [
        "71900"
      ]
    },
    {
      "From": "0x118bd",
      "To": [
        "71901"
      ]
    },
    {
      "From": "0x118be",
      "To": [
        "71902"
      ]
    },
    {
      "From": "0x118bf",
      "To": [
        "71903"
      ]
    },
    {
      "From": "0x16e40",
      "To": [
        "93792"
      ]
    },
    {
      "From": "0x16e41",
      "To": [
        "93793"
      ]
    },
    {
      "From": "0x16e42",
      "To": [
        "93794"
      ]
    },
    {
      "From": "0x16e43",
      "To": [
        "93795"
      ]
    },
    {
      "From": "0x16e44",
      "To": [
        "93796"
      ]
    },
    {
      "From": "0x16e45",
      "To": [
        "93797"
      ]
    },
    {
      "From": "0x16e46",
      "To": [
        "93798"
      ]
    },
    {
      "From": "0x16e47",
      "To": [
        "93799"
      ]
    },
    {
      "From": "0x16e48",
      "To": [
        "93800"
      ]
    },
    {
      "From": "0x16e49",
      "To": [
        "93801"
      ]
    },
    {
      "From": "0x16e4a",
      "To": [
        "93802"
      ]
    },
    {
      "From": "0x16e4b",
      "To": [
        "93803"
      ]
    },
    {
      "From": "0x16e4c",
      "To": [
        "93804"
      ]
    },
    {
      "From": "0x16e4d",
      "To": [
        "93805"
      ]
    },
    {
      "From": "0x16e4e",
      "To": [
        "93806"
      ]
    },
    {
      "From": "0x16e4f",
      "To": [
        "93807"
      ]
    },
    {
      "From": "0x16e50",
      "To": [
        "93808"
      ]
    },
    {
      "From": "0x16e51",
      "To": [
        "93809"
      ]
    },
    {
      "From": "0x16e52",
      "To": [
        "93810"
      ]
    },
    {
      "From": "0x16e53",
      "To": [
        "93811"
      ]
    },
    {
      "From": "0x16e54",
      "To": [
        "93812"
      ]
    },
    {
      "From": "0x16e55",
      "To": [
        "93813"
      ]
    },
    {
      "From": "0x16e56",
      "To": [
        "93814"
      ]
    },
    {
      "From": "0x16e57",
      "To": [
        "93815"
      ]
    },
    {
      "From": "0x16e58",
      "To": [
        "93816"
      ]
    },
    {
      "From": "0x16e59",
      "To": [
        "93817"
      ]
    },
    {
      "From": "0x16e5a",
      "To": [
        "93818"
      ]
    },
    {
      "From": "0x16e5b",
      "To": [
        "93819"
      ]
    },
    {
      "From": "0x16e5c",
      "To": [
        "93820"
      ]
    },
    {
      "From": "0x16e5d",
      "To": [
        "93821"
      ]
    },
    {
      "From": "0x16e5e",
      "To": [
        "93822"
      ]
    },
    {
      "From": "0x16e5f",
      "To": [
        "93823"
      ]
    },
    {
      "From": "0x1e900",
      "To": [
        "125218"
      ]
    },
    {
      "From": "0x1e901",
      "To": [
        "125219"
      ]
    },
    {
      "From": "0x1e902",
      "To": [
        "125220"
      ]
    },
    {
      "From": "0x1e903",
      "To": [
        "125221"
      ]
    },
    {
      "From": "0x1e904",
      "To": [
        "125222"
      ]
    },
    {
      "From": "0x1e905",
      "To": [
        "125223"
      ]
    },
    {
      "From": "0x1e906",
      "To": [
        "125224"
      ]
    },
    {
      "From": "0x1e907",
      "To": [
        "125225"
      ]
    },
    {
      "From": "0x1e908",
      "To": [
        "125226"
      ]
    },
    {
      "From": "0x1e909",
      "To": [
        "125227"
      ]
    },
    {
      "From": "0x1e90a",
      "To": [
        "125228"
      ]
    },
    {
      "From": "0x1e90b",
      "To": [
        "125229"
      ]
    },
    {
      "From": "0x1e90c",
      "To": [
        "125230"
      ]
    },
    {
      "From": "0x1e90d",
      "To": [
        "125231"
      ]
    },
    {
      "From": "0x1e90e",
      "To": [
        "125232"
      ]
    },
    {
      "From": "0x1e90f",
      "To": [
        "125233"
      ]
    },
    {
      "From": "0x1e910",
      "To": [
        "125234"
      ]
    },
    {
      "From": "0x1e911",
      "To": [
        "125235"
      ]
    },
    {
      "From": "0x1e912",
      "To": [
        "125236"
      ]
    },
    {
      "From": "0x1e913",
      "To": [
        "125237"
      ]
    },
    {
      "From": "0x1e914",
      "To": [
        "125238"
      ]
    },
    {
      "From": "0x1e915",
      "To": [
        "125239"
      ]
    },
    {
      "From": "0x1e916",
      "To": [
        "125240"
      ]
    },
    {
      "From": "0x1e917",
      "To": [
        "125241"
      ]
    },
    {
      "From": "0x1e918",
      "To": [
        "125242"
      ]
    },
    {
      "From": "0x1e919",
      "To": [
        "125243"
      ]
    },
    {
      "From": "0x1e91a",
      "To": [
        "125244"
      ]
    },
    {
      "From": "0x1e91b",
      "To": [
        "125245"
      ]
    },
    {
      "From": "0x1e91c",
      "To": [
        "125246"
      ]
    },
    {
      "From": "0x1e91d",
      "To": [
        "125247"
      ]
    },
    {
      "From": "0x1e91e",
      "To": [
        "125248"
      ]
    },
    {
      "From": "0x1e91f",
      "To": [
        "125249"
      ]
    },
    {
      "From": "0x1e920",
      "To": [
        "125250"
      ]
    },
    {
      "From": "0x1e921",
      "To": [
        "125251"
      ]
    }
  ],
  "prefix": "unicodeCaseFolding",
  "types": {
    "From": "rune",
    "To": "[]rune"
  }
}
</file>

<file path=".github/ISSUE_TEMPLATE/general-issue-template.md">
---
name: General issue template
about: must use this template
title: ''
labels: ''
assignees: ''

---

goldmark has [https://github.com/yuin/goldmark/discussions](Discussions) in github.
You should post only issues here. Feature requests and questions should be posted at discussions.

- [ ] goldmark is fully compliant with the CommonMark. Before submitting issue, you **must** read [CommonMark spec](https://spec.commonmark.org/0.29/) and confirm your output is different from [CommonMark online demo](https://spec.commonmark.org/dingus/).
    - [ ] **Extensions(Autolink without `<` `>`, Table, etc) are not part of CommonMark spec.** You should confirm your output is different from other official renderers correspond with an extension.
- [ ] **goldmark is not dedicated for Hugo**. If you are Hugo user and your issue was raised by your experience in Hugo, **you should consider create issue at Hugo repository at first** .

Please answer the following before submitting your issue:

1. What version of goldmark are you using? : 
2. What version of Go are you using? : 
3. What operating system and processor architecture are you using? :
4. What did you do? :
5. What did you expect to see? :
6. What did you see instead? :
7. Did you confirm your output is different from [CommonMark online demo](https://spec.commonmark.org/dingus/) or other official renderer correspond with an extension?:
</file>

<file path=".github/workflows/stale.yaml">
name: Close inactive issues
on:
  schedule:
    - cron: "30 9 * * *"
jobs:
  close-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - uses: actions/stale@v5
        with:
          days-before-issue-stale: 30
          days-before-issue-close: 14
          stale-issue-label: "stale"
          stale-issue-message: "This issue is stale because it has been open for 30 days with no activity."
          close-issue-message: "This issue was closed because it has been inactive for 14 days since being marked as stale."
          exempt-issue-labels: "pinned,security"
          days-before-pr-stale: 180
          days-before-pr-close: 14
          stale-pr-label: "stale"
          stale-pr-message: "This PR is stale because it has been open for 180 days with no activity."
          close-pr-message: "This PR was closed because it has been inactive for 14 days since being marked as stale."
          exempt-pr-labels: "pinned,security"
          repo-token: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path="extension/_test/definition_list.txt">
1
//- - - - - - - - -//
Apple
:   Pomaceous fruit of plants of the genus Malus in 
the family Rosaceae.

Orange
:   The fruit of an evergreen tree of the genus Citrus.
//- - - - - - - - -//
<dl>
<dt>Apple</dt>
<dd>Pomaceous fruit of plants of the genus Malus in
the family Rosaceae.</dd>
<dt>Orange</dt>
<dd>The fruit of an evergreen tree of the genus Citrus.</dd>
</dl>
//= = = = = = = = = = = = = = = = = = = = = = = =//



2
//- - - - - - - - -//
Apple
:   Pomaceous fruit of plants of the genus Malus in 
    the family Rosaceae.
:   An American computer company.

Orange
:   The fruit of an evergreen tree of the genus Citrus.
//- - - - - - - - -//
<dl>
<dt>Apple</dt>
<dd>Pomaceous fruit of plants of the genus Malus in
the family Rosaceae.</dd>
<dd>An American computer company.</dd>
<dt>Orange</dt>
<dd>The fruit of an evergreen tree of the genus Citrus.</dd>
</dl>
//= = = = = = = = = = = = = = = = = = = = = = = =//



3
//- - - - - - - - -//
Term 1
Term 2
:   Definition a

Term 3
:   Definition b
//- - - - - - - - -//
<dl>
<dt>Term 1</dt>
<dt>Term 2</dt>
<dd>Definition a</dd>
<dt>Term 3</dt>
<dd>Definition b</dd>
</dl>
//= = = = = = = = = = = = = = = = = = = = = = = =//



4
//- - - - - - - - -//
Apple

:   Pomaceous fruit of plants of the genus Malus in 
    the family Rosaceae.

Orange

:    The fruit of an evergreen tree of the genus Citrus.
//- - - - - - - - -//
<dl>
<dt>Apple</dt>
<dd>
<p>Pomaceous fruit of plants of the genus Malus in
the family Rosaceae.</p>
</dd>
<dt>Orange</dt>
<dd>
<p>The fruit of an evergreen tree of the genus Citrus.</p>
</dd>
</dl>
//= = = = = = = = = = = = = = = = = = = = = = = =//


5
//- - - - - - - - -//
Term 1

:   This is a definition with two paragraphs. Lorem ipsum 
    dolor sit amet, consectetuer adipiscing elit. Aliquam 
    hendrerit mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus.

:   Second definition for term 1, also wrapped in a paragraph
    because of the blank line preceding it.

Term 2

:   This definition has a code block, a blockquote and a list.

        code block.

    > block quote
    > on two lines.

    1.  first list item
    2.  second list item
//- - - - - - - - -//
<dl>
<dt>Term 1</dt>
<dd>
<p>This is a definition with two paragraphs. Lorem ipsum
dolor sit amet, consectetuer adipiscing elit. Aliquam
hendrerit mi posuere lectus.</p>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet
vitae, risus.</p>
</dd>
<dd>
<p>Second definition for term 1, also wrapped in a paragraph
because of the blank line preceding it.</p>
</dd>
<dt>Term 2</dt>
<dd>
<p>This definition has a code block, a blockquote and a list.</p>
<pre><code>code block.
</code></pre>
<blockquote>
<p>block quote
on two lines.</p>
</blockquote>
<ol>
<li>first list item</li>
<li>second list item</li>
</ol>
</dd>
</dl>
//= = = = = = = = = = = = = = = = = = = = = = = =//


6: Definition lists indented with tabs
//- - - - - - - - -//
0
:	```
		0
//- - - - - - - - -//
<dl>
<dt>0</dt>
<dd><pre><code>	0
</code></pre>
</dd>
</dl>
//= = = = = = = = = = = = = = = = = = = = = = = =//
</file>

<file path="extension/_test/table.txt">
1
//- - - - - - - - -//
| foo | bar |
| --- | --- |
| baz | bim |
//- - - - - - - - -//
<table>
<thead>
<tr>
<th>foo</th>
<th>bar</th>
</tr>
</thead>
<tbody>
<tr>
<td>baz</td>
<td>bim</td>
</tr>
</tbody>
</table>
//= = = = = = = = = = = = = = = = = = = = = = = =//



2
//- - - - - - - - -//
| abc | defghi |
:-: | -----------:
bar | baz
//- - - - - - - - -//
<table>
<thead>
<tr>
<th align="center">abc</th>
<th align="right">defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">bar</td>
<td align="right">baz</td>
</tr>
</tbody>
</table>
//= = = = = = = = = = = = = = = = = = = = = = = =//



3
//- - - - - - - - -//
| f\|oo  |
| ------ |
| b `\|` az |
| b **\|** im |
//- - - - - - - - -//
<table>
<thead>
<tr>
<th>f|oo</th>
</tr>
</thead>
<tbody>
<tr>
<td>b <code>|</code> az</td>
</tr>
<tr>
<td>b <strong>|</strong> im</td>
</tr>
</tbody>
</table>
//= = = = = = = = = = = = = = = = = = = = = = = =//



4
//- - - - - - - - -//
| abc | def |
| --- | --- |
| bar | baz |
> bar
//- - - - - - - - -//
<table>
<thead>
<tr>
<th>abc</th>
<th>def</th>
</tr>
</thead>
<tbody>
<tr>
<td>bar</td>
<td>baz</td>
</tr>
</tbody>
</table>
<blockquote>
<p>bar</p>
</blockquote>
//= = = = = = = = = = = = = = = = = = = = = = = =//



5
//- - - - - - - - -//
| abc | def |
| --- | --- |
| bar | baz |
bar

bar
//- - - - - - - - -//
<table>
<thead>
<tr>
<th>abc</th>
<th>def</th>
</tr>
</thead>
<tbody>
<tr>
<td>bar</td>
<td>baz</td>
</tr>
<tr>
<td>bar</td>
<td></td>
</tr>
</tbody>
</table>
<p>bar</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



6
//- - - - - - - - -//
| abc | def |
| --- |
| bar |
//- - - - - - - - -//
<p>| abc | def |
| --- |
| bar |</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



7
//- - - - - - - - -//
| abc | def |
| --- | --- |
| bar |
| bar | baz | boo |
//- - - - - - - - -//
<table>
<thead>
<tr>
<th>abc</th>
<th>def</th>
</tr>
</thead>
<tbody>
<tr>
<td>bar</td>
<td></td>
</tr>
<tr>
<td>bar</td>
<td>baz</td>
</tr>
</tbody>
</table>
//= = = = = = = = = = = = = = = = = = = = = = = =//



8
//- - - - - - - - -//
| abc | def |
| --- | --- |
//- - - - - - - - -//
<table>
<thead>
<tr>
<th>abc</th>
<th>def</th>
</tr>
</thead>
</table>
//= = = = = = = = = = = = = = = = = = = = = = = =//



9
//- - - - - - - - -//
Foo|Bar
---|---
`Yoyo`|Dyne
//- - - - - - - - -//
<table>
<thead>
<tr>
<th>Foo</th>
<th>Bar</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Yoyo</code></td>
<td>Dyne</td>
</tr>
</tbody>
</table>
//= = = = = = = = = = = = = = = = = = = = = = = =//


10
//- - - - - - - - -//
foo|bar
---|---
`\` | second column
//- - - - - - - - -//
<table>
<thead>
<tr>
<th>foo</th>
<th>bar</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code></td>
<td>second column</td>
</tr>
</tbody>
</table>
//= = = = = = = = = = = = = = = = = = = = = = = =//


11: Tables can interrupt paragraph
//- - - - - - - - -//
**xxx**
| hello |   hi  |
| :----: | :----:|
//- - - - - - - - -//
<p><strong>xxx</strong></p>
<table>
<thead>
<tr>
<th align="center">hello</th>
<th align="center">hi</th>
</tr>
</thead>
</table>
//= = = = = = = = = = = = = = = = = = = = = = = =//

12: A delimiter can not start with more than 3 spaces
//- - - - - - - - -//
Foo
    ---
//- - - - - - - - -//
<p>Foo
---</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

13: A delimiter can not start with more than 3 spaces(w/ tabs)
    OPTIONS: {"enableEscape": true}
//- - - - - - - - -//
- aaa

  Foo
\t\t---
//- - - - - - - - -//
<ul>
<li>
<p>aaa</p>
<p>Foo
---</p>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//
</file>

<file path="extension/_test/tasklist.txt">
1
//- - - - - - - - -//
- [ ] foo
- [x] bar
//- - - - - - - - -//
<ul>
<li><input disabled="" type="checkbox"> foo</li>
<li><input checked="" disabled="" type="checkbox"> bar</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//



2
//- - - - - - - - -//
- [x] foo
  - [ ] bar
  - [x] baz
- [ ] bim
//- - - - - - - - -//
<ul>
<li><input checked="" disabled="" type="checkbox"> foo
<ul>
<li><input disabled="" type="checkbox"> bar</li>
<li><input checked="" disabled="" type="checkbox"> baz</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> bim</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//



3
//- - - - - - - - -//
- test[x]=[x]
//- - - - - - - - -//
<ul>
<li>test[x]=[x]</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//


4
//- - - - - - - - -//
+ [x] [x]
//- - - - - - - - -//
<ul>
<li><input checked="" disabled="" type="checkbox"> [x]</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//
</file>

<file path="extension/_test/typographer.txt">
1
//- - - - - - - - -//
This should 'be' replaced
//- - - - - - - - -//
<p>This should &lsquo;be&rsquo; replaced</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

2
//- - - - - - - - -//
This should "be" replaced
//- - - - - - - - -//
<p>This should &ldquo;be&rdquo; replaced</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

3
//- - - - - - - - -//
**--** *---* a...<< b>>
//- - - - - - - - -//
<p><strong>&ndash;</strong> <em>&mdash;</em> a&hellip;&laquo; b&raquo;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

4
//- - - - - - - - -//
Some say '90s, others say 90's, but I can't say which is best.
//- - - - - - - - -//
<p>Some say &rsquo;90s, others say 90&rsquo;s, but I can&rsquo;t say which is best.</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

5: contractions
//- - - - - - - - -//
Alice's, I'm ,Don't, You'd

I've, I'll, You're

[Cat][]'s Pajamas

Yahoo!'s

[Cat]: http://example.com
//- - - - - - - - -//
<p>Alice&rsquo;s, I&rsquo;m ,Don&rsquo;t, You&rsquo;d</p>
<p>I&rsquo;ve, I&rsquo;ll, You&rsquo;re</p>
<p><a href="http://example.com">Cat</a>&rsquo;s Pajamas</p>
<p>Yahoo!&rsquo;s</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

6: "" after digits are an inch
//- - - - - - - - -//
My height is 5'6"".
//- - - - - - - - -//
<p>My height is 5'6&quot;&quot;.</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

7: quote followed by ,.?! and spaces maybe a closer
//- - - - - - - - -//
reported "issue 1 (IE-only)", "issue 2", 'issue3 (FF-only)', 'issue4'
//- - - - - - - - -//
<p>reported &ldquo;issue 1 (IE-only)&rdquo;, &ldquo;issue 2&rdquo;, &lsquo;issue3 (FF-only)&rsquo;, &lsquo;issue4&rsquo;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

8: handle inches in qoutes
//- - - - - - - - -//
"Monitor 21"" and "Monitor""
//- - - - - - - - -//
<p>&ldquo;Monitor 21&quot;&rdquo; and &ldquo;Monitor&rdquo;&quot;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

9: Closing quotation marks within italics
//- - - - - - - - -//
*"At first, things were not clear."*
//- - - - - - - - -//
<p><em>&ldquo;At first, things were not clear.&rdquo;</em></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

10: Closing quotation marks within boldfacing
//- - - - - - - - -//
**"At first, things were not clear."**
//- - - - - - - - -//
<p><strong>&ldquo;At first, things were not clear.&rdquo;</strong></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

11: Closing quotation marks within boldfacing and italics
//- - - - - - - - -//
***"At first, things were not clear."***
//- - - - - - - - -//
<p><em><strong>&ldquo;At first, things were not clear.&rdquo;</strong></em></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

12: Closing quotation marks within boldfacing and italics
//- - - - - - - - -//
***"At first, things were not clear."***
//- - - - - - - - -//
<p><em><strong>&ldquo;At first, things were not clear.&rdquo;</strong></em></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

13: Plural possessives
//- - - - - - - - -//
John's dog is named Sam. The Smiths' dog is named Rover.
//- - - - - - - - -//
<p>John&rsquo;s dog is named Sam. The Smiths&rsquo; dog is named Rover.</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

14: Links within quotation marks and parenthetical phrases
//- - - - - - - - -//
This is not difficult (see "[Introduction to Hugo Templating](https://gohugo.io/templates/introduction/)").
//- - - - - - - - -//
<p>This is not difficult (see &ldquo;<a href="https://gohugo.io/templates/introduction/">Introduction to Hugo Templating</a>&rdquo;).</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

15: Quotation marks within links
//- - - - - - - - -//
Apple's early Cairo font gave us ["moof" and the "dogcow."](https://www.macworld.com/article/2926184/we-miss-you-clarus-the-dogcow.html)
//- - - - - - - - -//
<p>Apple&rsquo;s early Cairo font gave us <a href="https://www.macworld.com/article/2926184/we-miss-you-clarus-the-dogcow.html">&ldquo;moof&rdquo; and the &ldquo;dogcow.&rdquo;</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

16: Single closing quotation marks with slang/informalities
//- - - - - - - - -//
"I'm not doin' that," Bill said with emphasis.
//- - - - - - - - -//
<p>&ldquo;I&rsquo;m not doin&rsquo; that,&rdquo; Bill said with emphasis.</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

17: Closing single quotation marks in quotations-within-quotations
//- - - - - - - - -//
Janet said, "When everything is 'breaking news,' nothing is 'breaking news.'"
//- - - - - - - - -//
<p>Janet said, &ldquo;When everything is &lsquo;breaking news,&rsquo; nothing is &lsquo;breaking news.&rsquo;&rdquo;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

18: Opening single quotation marks for abbreviations
//- - - - - - - - -//
We're talking about the internet --- 'net for short. Let's rock 'n roll!
//- - - - - - - - -//
<p>We&rsquo;re talking about the internet &mdash; &rsquo;net for short. Let&rsquo;s rock &rsquo;n roll!</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

19: Quotes in alt text
//- - - - - - - - -//
![Nice & day, **isn't** it?](https://example.com/image.jpg)
//- - - - - - - - -//
<p><img src="https://example.com/image.jpg" alt="Nice &amp; day, isn&rsquo;t it?"></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//
</file>

<file path="extension/ast/footnote.go">
package ast

import (
	"fmt"

	gast "github.com/yuin/goldmark/ast"
)

// A FootnoteLink struct represents a link to a footnote of Markdown
// (PHP Markdown Extra) text.
type FootnoteLink struct {
	gast.BaseInline
	Index    int
	RefCount int
	RefIndex int
}

// Dump implements Node.Dump.
func (n *FootnoteLink) Dump(source []byte, level int) {
	m := map[string]string{}
	m["Index"] = fmt.Sprintf("%v", n.Index)
	m["RefCount"] = fmt.Sprintf("%v", n.RefCount)
	m["RefIndex"] = fmt.Sprintf("%v", n.RefIndex)
	gast.DumpHelper(n, source, level, m, nil)
}

// KindFootnoteLink is a NodeKind of the FootnoteLink node.
var KindFootnoteLink = gast.NewNodeKind("FootnoteLink")

// Kind implements Node.Kind.
func (n *FootnoteLink) Kind() gast.NodeKind {
	return KindFootnoteLink
}

// NewFootnoteLink returns a new FootnoteLink node.
func NewFootnoteLink(index int) *FootnoteLink {
	return &FootnoteLink{
		Index:    index,
		RefCount: 0,
		RefIndex: 0,
	}
}

// A FootnoteBacklink struct represents a link to a footnote of Markdown
// (PHP Markdown Extra) text.
type FootnoteBacklink struct {
	gast.BaseInline
	Index    int
	RefCount int
	RefIndex int
}

// Dump implements Node.Dump.
func (n *FootnoteBacklink) Dump(source []byte, level int) {
	m := map[string]string{}
	m["Index"] = fmt.Sprintf("%v", n.Index)
	m["RefCount"] = fmt.Sprintf("%v", n.RefCount)
	m["RefIndex"] = fmt.Sprintf("%v", n.RefIndex)
	gast.DumpHelper(n, source, level, m, nil)
}

// KindFootnoteBacklink is a NodeKind of the FootnoteBacklink node.
var KindFootnoteBacklink = gast.NewNodeKind("FootnoteBacklink")

// Kind implements Node.Kind.
func (n *FootnoteBacklink) Kind() gast.NodeKind {
	return KindFootnoteBacklink
}

// NewFootnoteBacklink returns a new FootnoteBacklink node.
func NewFootnoteBacklink(index int) *FootnoteBacklink {
	return &FootnoteBacklink{
		Index:    index,
		RefCount: 0,
		RefIndex: 0,
	}
}

// A Footnote struct represents a footnote of Markdown
// (PHP Markdown Extra) text.
type Footnote struct {
	gast.BaseBlock
	Ref   []byte
	Index int
}

// Dump implements Node.Dump.
func (n *Footnote) Dump(source []byte, level int) {
	m := map[string]string{}
	m["Index"] = fmt.Sprintf("%v", n.Index)
	m["Ref"] = string(n.Ref)
	gast.DumpHelper(n, source, level, m, nil)
}

// KindFootnote is a NodeKind of the Footnote node.
var KindFootnote = gast.NewNodeKind("Footnote")

// Kind implements Node.Kind.
func (n *Footnote) Kind() gast.NodeKind {
	return KindFootnote
}

// NewFootnote returns a new Footnote node.
func NewFootnote(ref []byte) *Footnote {
	return &Footnote{
		Ref:   ref,
		Index: -1,
	}
}

// A FootnoteList struct represents footnotes of Markdown
// (PHP Markdown Extra) text.
type FootnoteList struct {
	gast.BaseBlock
	Count int
}

// Dump implements Node.Dump.
func (n *FootnoteList) Dump(source []byte, level int) {
	m := map[string]string{}
	m["Count"] = fmt.Sprintf("%v", n.Count)
	gast.DumpHelper(n, source, level, m, nil)
}

// KindFootnoteList is a NodeKind of the FootnoteList node.
var KindFootnoteList = gast.NewNodeKind("FootnoteList")

// Kind implements Node.Kind.
func (n *FootnoteList) Kind() gast.NodeKind {
	return KindFootnoteList
}

// NewFootnoteList returns a new FootnoteList node.
func NewFootnoteList() *FootnoteList {
	return &FootnoteList{
		Count: 0,
	}
}
</file>

<file path="extension/ast/table.go">
package ast

import (
	"fmt"
	"strings"

	gast "github.com/yuin/goldmark/ast"
)

// Alignment is a text alignment of table cells.
type Alignment int

const (
	// AlignLeft indicates text should be left justified.
	AlignLeft Alignment = iota + 1

	// AlignRight indicates text should be right justified.
	AlignRight

	// AlignCenter indicates text should be centered.
	AlignCenter

	// AlignNone indicates text should be aligned by default manner.
	AlignNone
)

func (a Alignment) String() string {
	switch a {
	case AlignLeft:
		return "left"
	case AlignRight:
		return "right"
	case AlignCenter:
		return "center"
	case AlignNone:
		return "none"
	}
	return ""
}

// A Table struct represents a table of Markdown(GFM) text.
type Table struct {
	gast.BaseBlock

	// Alignments returns alignments of the columns.
	Alignments []Alignment
}

// Dump implements Node.Dump.
func (n *Table) Dump(source []byte, level int) {
	gast.DumpHelper(n, source, level, nil, func(level int) {
		indent := strings.Repeat("    ", level)
		fmt.Printf("%sAlignments {\n", indent)
		for i, alignment := range n.Alignments {
			indent2 := strings.Repeat("    ", level+1)
			fmt.Printf("%s%s", indent2, alignment.String())
			if i != len(n.Alignments)-1 {
				fmt.Println("")
			}
		}
		fmt.Printf("\n%s}\n", indent)
	})
}

// KindTable is a NodeKind of the Table node.
var KindTable = gast.NewNodeKind("Table")

// Kind implements Node.Kind.
func (n *Table) Kind() gast.NodeKind {
	return KindTable
}

// NewTable returns a new Table node.
func NewTable() *Table {
	return &Table{
		Alignments: []Alignment{},
	}
}

// A TableRow struct represents a table row of Markdown(GFM) text.
type TableRow struct {
	gast.BaseBlock
	Alignments []Alignment
}

// Dump implements Node.Dump.
func (n *TableRow) Dump(source []byte, level int) {
	gast.DumpHelper(n, source, level, nil, nil)
}

// KindTableRow is a NodeKind of the TableRow node.
var KindTableRow = gast.NewNodeKind("TableRow")

// Kind implements Node.Kind.
func (n *TableRow) Kind() gast.NodeKind {
	return KindTableRow
}

// NewTableRow returns a new TableRow node.
func NewTableRow(alignments []Alignment) *TableRow {
	return &TableRow{Alignments: alignments}
}

// A TableHeader struct represents a table header of Markdown(GFM) text.
type TableHeader struct {
	gast.BaseBlock
	Alignments []Alignment
}

// KindTableHeader is a NodeKind of the TableHeader node.
var KindTableHeader = gast.NewNodeKind("TableHeader")

// Kind implements Node.Kind.
func (n *TableHeader) Kind() gast.NodeKind {
	return KindTableHeader
}

// Dump implements Node.Dump.
func (n *TableHeader) Dump(source []byte, level int) {
	gast.DumpHelper(n, source, level, nil, nil)
}

// NewTableHeader returns a new TableHeader node.
func NewTableHeader(row *TableRow) *TableHeader {
	n := &TableHeader{}
	for c := row.FirstChild(); c != nil; {
		next := c.NextSibling()
		n.AppendChild(n, c)
		c = next
	}
	return n
}

// A TableCell struct represents a table cell of a Markdown(GFM) text.
type TableCell struct {
	gast.BaseBlock
	Alignment Alignment
}

// Dump implements Node.Dump.
func (n *TableCell) Dump(source []byte, level int) {
	gast.DumpHelper(n, source, level, nil, nil)
}

// KindTableCell is a NodeKind of the TableCell node.
var KindTableCell = gast.NewNodeKind("TableCell")

// Kind implements Node.Kind.
func (n *TableCell) Kind() gast.NodeKind {
	return KindTableCell
}

// NewTableCell returns a new TableCell node.
func NewTableCell() *TableCell {
	return &TableCell{
		Alignment: AlignNone,
	}
}
</file>

<file path="extension/definition_list.go">
package extension

import (
	"github.com/yuin/goldmark"
	gast "github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/extension/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type definitionListParser struct {
}

var defaultDefinitionListParser = &definitionListParser{}

// NewDefinitionListParser return a new parser.BlockParser that
// can parse PHP Markdown Extra Definition lists.
func NewDefinitionListParser() parser.BlockParser {
	return defaultDefinitionListParser
}

func (b *definitionListParser) Trigger() []byte {
	return []byte{':'}
}

func (b *definitionListParser) Open(parent gast.Node, reader text.Reader, pc parser.Context) (gast.Node, parser.State) {
	if _, ok := parent.(*ast.DefinitionList); ok {
		return nil, parser.NoChildren
	}
	line, _ := reader.PeekLine()
	pos := pc.BlockOffset()
	indent := pc.BlockIndent()
	if pos < 0 || line[pos] != ':' || indent != 0 {
		return nil, parser.NoChildren
	}

	last := parent.LastChild()
	// need 1 or more spaces after ':'
	w, _ := util.IndentWidth(line[pos+1:], pos+1)
	if w < 1 {
		return nil, parser.NoChildren
	}
	if w >= 8 { // starts with indented code
		w = 5
	}
	w += pos + 1 /* 1 = ':' */

	para, lastIsParagraph := last.(*gast.Paragraph)
	var list *ast.DefinitionList
	status := parser.HasChildren
	var ok bool
	if lastIsParagraph {
		list, ok = last.PreviousSibling().(*ast.DefinitionList)
		if ok { // is not first item
			list.Offset = w
			list.TemporaryParagraph = para
		} else { // is first item
			list = ast.NewDefinitionList(w, para)
			status |= parser.RequireParagraph
		}
	} else if list, ok = last.(*ast.DefinitionList); ok { // multiple description
		list.Offset = w
		list.TemporaryParagraph = nil
	} else {
		return nil, parser.NoChildren
	}

	return list, status
}

func (b *definitionListParser) Continue(node gast.Node, reader text.Reader, pc parser.Context) parser.State {
	line, _ := reader.PeekLine()
	if util.IsBlank(line) {
		return parser.Continue | parser.HasChildren
	}
	list, _ := node.(*ast.DefinitionList)
	w, _ := util.IndentWidth(line, reader.LineOffset())
	if w < list.Offset {
		return parser.Close
	}
	pos, padding := util.IndentPosition(line, reader.LineOffset(), list.Offset)
	reader.AdvanceAndSetPadding(pos, padding)
	return parser.Continue | parser.HasChildren
}

func (b *definitionListParser) Close(node gast.Node, reader text.Reader, pc parser.Context) {
	// nothing to do
}

func (b *definitionListParser) CanInterruptParagraph() bool {
	return true
}

func (b *definitionListParser) CanAcceptIndentedLine() bool {
	return false
}

type definitionDescriptionParser struct {
}

var defaultDefinitionDescriptionParser = &definitionDescriptionParser{}

// NewDefinitionDescriptionParser return a new parser.BlockParser that
// can parse definition description starts with ':'.
func NewDefinitionDescriptionParser() parser.BlockParser {
	return defaultDefinitionDescriptionParser
}

func (b *definitionDescriptionParser) Trigger() []byte {
	return []byte{':'}
}

func (b *definitionDescriptionParser) Open(
	parent gast.Node, reader text.Reader, pc parser.Context) (gast.Node, parser.State) {
	line, _ := reader.PeekLine()
	pos := pc.BlockOffset()
	indent := pc.BlockIndent()
	if pos < 0 || line[pos] != ':' || indent != 0 {
		return nil, parser.NoChildren
	}
	list, _ := parent.(*ast.DefinitionList)
	if list == nil {
		return nil, parser.NoChildren
	}
	para := list.TemporaryParagraph
	list.TemporaryParagraph = nil
	if para != nil {
		lines := para.Lines()
		l := lines.Len()
		for i := 0; i < l; i++ {
			term := ast.NewDefinitionTerm()
			segment := lines.At(i)
			term.Lines().Append(segment.TrimRightSpace(reader.Source()))
			list.AppendChild(list, term)
		}
		para.Parent().RemoveChild(para.Parent(), para)
	}
	cpos, padding := util.IndentPosition(line[pos+1:], pos+1, list.Offset-pos-1)
	reader.AdvanceAndSetPadding(cpos+1, padding)

	return ast.NewDefinitionDescription(), parser.HasChildren
}

func (b *definitionDescriptionParser) Continue(node gast.Node, reader text.Reader, pc parser.Context) parser.State {
	// definitionListParser detects end of the description.
	// so this method will never be called.
	return parser.Continue | parser.HasChildren
}

func (b *definitionDescriptionParser) Close(node gast.Node, reader text.Reader, pc parser.Context) {
	desc := node.(*ast.DefinitionDescription)
	desc.IsTight = !desc.HasBlankPreviousLines()
	if desc.IsTight {
		for gc := desc.FirstChild(); gc != nil; gc = gc.NextSibling() {
			paragraph, ok := gc.(*gast.Paragraph)
			if ok {
				textBlock := gast.NewTextBlock()
				textBlock.SetLines(paragraph.Lines())
				desc.ReplaceChild(desc, paragraph, textBlock)
			}
		}
	}
}

func (b *definitionDescriptionParser) CanInterruptParagraph() bool {
	return true
}

func (b *definitionDescriptionParser) CanAcceptIndentedLine() bool {
	return false
}

// DefinitionListHTMLRenderer is a renderer.NodeRenderer implementation that
// renders DefinitionList nodes.
type DefinitionListHTMLRenderer struct {
	html.Config
}

// NewDefinitionListHTMLRenderer returns a new DefinitionListHTMLRenderer.
func NewDefinitionListHTMLRenderer(opts ...html.Option) renderer.NodeRenderer {
	r := &DefinitionListHTMLRenderer{
		Config: html.NewConfig(),
	}
	for _, opt := range opts {
		opt.SetHTMLOption(&r.Config)
	}
	return r
}

// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.
func (r *DefinitionListHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	reg.Register(ast.KindDefinitionList, r.renderDefinitionList)
	reg.Register(ast.KindDefinitionTerm, r.renderDefinitionTerm)
	reg.Register(ast.KindDefinitionDescription, r.renderDefinitionDescription)
}

// DefinitionListAttributeFilter defines attribute names which dl elements can have.
var DefinitionListAttributeFilter = html.GlobalAttributeFilter

func (r *DefinitionListHTMLRenderer) renderDefinitionList(
	w util.BufWriter, source []byte, n gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		if n.Attributes() != nil {
			_, _ = w.WriteString("<dl")
			html.RenderAttributes(w, n, DefinitionListAttributeFilter)
			_, _ = w.WriteString(">\n")
		} else {
			_, _ = w.WriteString("<dl>\n")
		}
	} else {
		_, _ = w.WriteString("</dl>\n")
	}
	return gast.WalkContinue, nil
}

// DefinitionTermAttributeFilter defines attribute names which dd elements can have.
var DefinitionTermAttributeFilter = html.GlobalAttributeFilter

func (r *DefinitionListHTMLRenderer) renderDefinitionTerm(
	w util.BufWriter, source []byte, n gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		if n.Attributes() != nil {
			_, _ = w.WriteString("<dt")
			html.RenderAttributes(w, n, DefinitionTermAttributeFilter)
			_ = w.WriteByte('>')
		} else {
			_, _ = w.WriteString("<dt>")
		}
	} else {
		_, _ = w.WriteString("</dt>\n")
	}
	return gast.WalkContinue, nil
}

// DefinitionDescriptionAttributeFilter defines attribute names which dd elements can have.
var DefinitionDescriptionAttributeFilter = html.GlobalAttributeFilter

func (r *DefinitionListHTMLRenderer) renderDefinitionDescription(
	w util.BufWriter, source []byte, node gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		n := node.(*ast.DefinitionDescription)
		_, _ = w.WriteString("<dd")
		if n.Attributes() != nil {
			html.RenderAttributes(w, n, DefinitionDescriptionAttributeFilter)
		}
		if n.IsTight {
			_, _ = w.WriteString(">")
		} else {
			_, _ = w.WriteString(">\n")
		}
	} else {
		_, _ = w.WriteString("</dd>\n")
	}
	return gast.WalkContinue, nil
}

type definitionList struct {
}

// DefinitionList is an extension that allow you to use PHP Markdown Extra Definition lists.
var DefinitionList = &definitionList{}

func (e *definitionList) Extend(m goldmark.Markdown) {
	m.Parser().AddOptions(parser.WithBlockParsers(
		util.Prioritized(NewDefinitionListParser(), 101),
		util.Prioritized(NewDefinitionDescriptionParser(), 102),
	))
	m.Renderer().AddOptions(renderer.WithNodeRenderers(
		util.Prioritized(NewDefinitionListHTMLRenderer(), 500),
	))
}
</file>

<file path="extension/footnote_test.go">
package extension

import (
	"testing"

	"github.com/yuin/goldmark"
	gast "github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

func TestFootnote(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			Footnote,
		),
	)
	testutil.DoTestCaseFile(markdown, "_test/footnote.txt", t, testutil.ParseCliCaseArg()...)
}

type footnoteID struct {
}

func (a *footnoteID) Transform(node *gast.Document, reader text.Reader, pc parser.Context) {
	node.Meta()["footnote-prefix"] = "article12-"
}

func TestFootnoteOptions(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewFootnote(
				WithFootnoteIDPrefix("article12-"),
				WithFootnoteLinkClass("link-class"),
				WithFootnoteBacklinkClass("backlink-class"),
				WithFootnoteLinkTitle("link-title-%%-^^"),
				WithFootnoteBacklinkTitle("backlink-title"),
				WithFootnoteBacklinkHTML("^"),
			),
		),
	)

	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          1,
			Description: "Footnote with options",
			Markdown: `That's some text with a footnote.[^1]

Same footnote.[^1]

Another one.[^2]

[^1]: And that's the footnote.
[^2]: Another footnote.
`,
			Expected: `<p>That's some text with a footnote.<sup id="article12-fnref:1"><a href="#article12-fn:1" class="link-class" title="link-title-2-1" role="doc-noteref">1</a></sup></p>
<p>Same footnote.<sup id="article12-fnref1:1"><a href="#article12-fn:1" class="link-class" title="link-title-2-1" role="doc-noteref">1</a></sup></p>
<p>Another one.<sup id="article12-fnref:2"><a href="#article12-fn:2" class="link-class" title="link-title-1-2" role="doc-noteref">2</a></sup></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="article12-fn:1">
<p>And that's the footnote.&#160;<a href="#article12-fnref:1" class="backlink-class" title="backlink-title" role="doc-backlink">^</a>&#160;<a href="#article12-fnref1:1" class="backlink-class" title="backlink-title" role="doc-backlink">^</a></p>
</li>
<li id="article12-fn:2">
<p>Another footnote.&#160;<a href="#article12-fnref:2" class="backlink-class" title="backlink-title" role="doc-backlink">^</a></p>
</li>
</ol>
</div>`,
		},
		t,
	)

	markdown = goldmark.New(
		goldmark.WithParserOptions(
			parser.WithASTTransformers(
				util.Prioritized(&footnoteID{}, 100),
			),
		),
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewFootnote(
				WithFootnoteIDPrefixFunction(func(n gast.Node) []byte {
					v, ok := n.OwnerDocument().Meta()["footnote-prefix"]
					if ok {
						return util.StringToReadOnlyBytes(v.(string))
					}
					return nil
				}),
				WithFootnoteLinkClass([]byte("link-class")),
				WithFootnoteBacklinkClass([]byte("backlink-class")),
				WithFootnoteLinkTitle([]byte("link-title-%%-^^")),
				WithFootnoteBacklinkTitle([]byte("backlink-title")),
				WithFootnoteBacklinkHTML([]byte("^")),
			),
		),
	)

	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          2,
			Description: "Footnote with an id prefix function",
			Markdown: `That's some text with a footnote.[^1]

Same footnote.[^1]

Another one.[^2]

[^1]: And that's the footnote.
[^2]: Another footnote.
`,
			Expected: `<p>That's some text with a footnote.<sup id="article12-fnref:1"><a href="#article12-fn:1" class="link-class" title="link-title-2-1" role="doc-noteref">1</a></sup></p>
<p>Same footnote.<sup id="article12-fnref1:1"><a href="#article12-fn:1" class="link-class" title="link-title-2-1" role="doc-noteref">1</a></sup></p>
<p>Another one.<sup id="article12-fnref:2"><a href="#article12-fn:2" class="link-class" title="link-title-1-2" role="doc-noteref">2</a></sup></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="article12-fn:1">
<p>And that's the footnote.&#160;<a href="#article12-fnref:1" class="backlink-class" title="backlink-title" role="doc-backlink">^</a>&#160;<a href="#article12-fnref1:1" class="backlink-class" title="backlink-title" role="doc-backlink">^</a></p>
</li>
<li id="article12-fn:2">
<p>Another footnote.&#160;<a href="#article12-fnref:2" class="backlink-class" title="backlink-title" role="doc-backlink">^</a></p>
</li>
</ol>
</div>`,
		},
		t,
	)
}
</file>

<file path="extension/linkify_test.go">
package extension

import (
	"regexp"
	"testing"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
)

func TestLinkify(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			Linkify,
		),
	)
	testutil.DoTestCaseFile(markdown, "_test/linkify.txt", t, testutil.ParseCliCaseArg()...)
}

func TestLinkifyWithAllowedProtocols(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithXHTML(),
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewLinkify(
				WithLinkifyAllowedProtocols([]string{
					"ssh:",
				}),
				WithLinkifyURLRegexp(
					regexp.MustCompile(`\w+://[^\s]+`),
				),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:       1,
			Markdown: `hoge ssh://user@hoge.com. http://example.com/`,
			Expected: `<p>hoge <a href="ssh://user@hoge.com">ssh://user@hoge.com</a>. http://example.com/</p>`,
		},
		t,
	)
}

func TestLinkifyWithWWWRegexp(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithXHTML(),
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewLinkify(
				WithLinkifyWWWRegexp(
					regexp.MustCompile(`www\.example\.com`),
				),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:       1,
			Markdown: `www.google.com www.example.com`,
			Expected: `<p>www.google.com <a href="http://www.example.com">www.example.com</a></p>`,
		},
		t,
	)
}

func TestLinkifyWithEmailRegexp(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithXHTML(),
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewLinkify(
				WithLinkifyEmailRegexp(
					regexp.MustCompile(`user@example\.com`),
				),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:       1,
			Markdown: `hoge@example.com user@example.com`,
			Expected: `<p>hoge@example.com <a href="mailto:user@example.com">user@example.com</a></p>`,
		},
		t,
	)
}
</file>

<file path="extension/package.go">
// Package extension is a collection of builtin extensions.
package extension
</file>

<file path="extension/table_test.go">
package extension

import (
	"testing"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/ast"
	east "github.com/yuin/goldmark/extension/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

func TestTable(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
			html.WithXHTML(),
		),
		goldmark.WithExtensions(
			Table,
		),
	)
	testutil.DoTestCaseFile(markdown, "_test/table.txt", t, testutil.ParseCliCaseArg()...)
}

func TestTableWithAlignDefault(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithXHTML(),
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewTable(
				WithTableCellAlignMethod(TableCellAlignDefault),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          1,
			Description: "Cell with TableCellAlignDefault and XHTML should be rendered as an align attribute",
			Markdown: `
| abc | defghi |
:-: | -----------:
bar | baz
`,
			Expected: `<table>
<thead>
<tr>
<th align="center">abc</th>
<th align="right">defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">bar</td>
<td align="right">baz</td>
</tr>
</tbody>
</table>`,
		},
		t,
	)

	markdown = goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewTable(
				WithTableCellAlignMethod(TableCellAlignDefault),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          2,
			Description: "Cell with TableCellAlignDefault and HTML5 should be rendered as a style attribute",
			Markdown: `
| abc | defghi |
:-: | -----------:
bar | baz
`,
			Expected: `<table>
<thead>
<tr>
<th style="text-align:center">abc</th>
<th style="text-align:right">defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bar</td>
<td style="text-align:right">baz</td>
</tr>
</tbody>
</table>`,
		},
		t,
	)
}

func TestTableWithAlignAttribute(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithXHTML(),
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewTable(
				WithTableCellAlignMethod(TableCellAlignAttribute),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          1,
			Description: "Cell with TableCellAlignAttribute and XHTML should be rendered as an align attribute",
			Markdown: `
| abc | defghi |
:-: | -----------:
bar | baz
`,
			Expected: `<table>
<thead>
<tr>
<th align="center">abc</th>
<th align="right">defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">bar</td>
<td align="right">baz</td>
</tr>
</tbody>
</table>`,
		},
		t,
	)

	markdown = goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewTable(
				WithTableCellAlignMethod(TableCellAlignAttribute),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          2,
			Description: "Cell with TableCellAlignAttribute and HTML5 should be rendered as an align attribute",
			Markdown: `
| abc | defghi |
:-: | -----------:
bar | baz
`,
			Expected: `<table>
<thead>
<tr>
<th align="center">abc</th>
<th align="right">defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">bar</td>
<td align="right">baz</td>
</tr>
</tbody>
</table>`,
		},
		t,
	)
}

type tableStyleTransformer struct {
}

func (a *tableStyleTransformer) Transform(node *ast.Document, reader text.Reader, pc parser.Context) {
	cell := node.FirstChild().FirstChild().FirstChild().(*east.TableCell)
	cell.SetAttributeString("style", []byte("font-size:1em"))
}

func TestTableWithAlignStyle(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithXHTML(),
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewTable(
				WithTableCellAlignMethod(TableCellAlignStyle),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          1,
			Description: "Cell with TableCellAlignStyle and XHTML should be rendered as a style attribute",
			Markdown: `
| abc | defghi |
:-: | -----------:
bar | baz
`,
			Expected: `<table>
<thead>
<tr>
<th style="text-align:center">abc</th>
<th style="text-align:right">defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bar</td>
<td style="text-align:right">baz</td>
</tr>
</tbody>
</table>`,
		},
		t,
	)

	markdown = goldmark.New(
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewTable(
				WithTableCellAlignMethod(TableCellAlignStyle),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          2,
			Description: "Cell with TableCellAlignStyle and HTML5 should be rendered as a style attribute",
			Markdown: `
| abc | defghi |
:-: | -----------:
bar | baz
`,
			Expected: `<table>
<thead>
<tr>
<th style="text-align:center">abc</th>
<th style="text-align:right">defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bar</td>
<td style="text-align:right">baz</td>
</tr>
</tbody>
</table>`,
		},
		t,
	)

	markdown = goldmark.New(
		goldmark.WithParserOptions(
			parser.WithASTTransformers(
				util.Prioritized(&tableStyleTransformer{}, 0),
			),
		),
		goldmark.WithRendererOptions(
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewTable(
				WithTableCellAlignMethod(TableCellAlignStyle),
			),
		),
	)

	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          3,
			Description: "Styled cell should not be broken the style by the alignments",
			Markdown: `
| abc | defghi |
:-: | -----------:
bar | baz
`,
			Expected: `<table>
<thead>
<tr>
<th style="font-size:1em;text-align:center">abc</th>
<th style="text-align:right">defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bar</td>
<td style="text-align:right">baz</td>
</tr>
</tbody>
</table>`,
		},
		t,
	)
}

func TestTableWithAlignNone(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithXHTML(),
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewTable(
				WithTableCellAlignMethod(TableCellAlignNone),
			),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          1,
			Description: "Cell with TableCellAlignStyle and XHTML should not be rendered",
			Markdown: `
| abc | defghi |
:-: | -----------:
bar | baz
`,
			Expected: `<table>
<thead>
<tr>
<th>abc</th>
<th>defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td>bar</td>
<td>baz</td>
</tr>
</tbody>
</table>`,
		},
		t,
	)
}

func TestTableFuzzedPanics(t *testing.T) {
	markdown := goldmark.New(
		goldmark.WithRendererOptions(
			html.WithXHTML(),
			html.WithUnsafe(),
		),
		goldmark.WithExtensions(
			NewTable(),
		),
	)
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          1,
			Description: "This should not panic",
			Markdown:    "* 0\n-|\n\t0",
			Expected: `<ul>
<li>
<table>
<thead>
<tr>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>`,
		},
		t,
	)
}
</file>

<file path="fuzz/oss_fuzz_test.go">
package fuzz

import (
	"testing"
)

func FuzzOss(f *testing.F) {
	fuzz(f)
}
</file>

<file path="parser/attribute.go">
package parser

import (
	"bytes"
	"io"
	"strconv"

	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

var attrNameID = []byte("id")
var attrNameClass = []byte("class")

// An Attribute is an attribute of the markdown elements.
type Attribute struct {
	Name  []byte
	Value interface{}
}

// An Attributes is a collection of attributes.
type Attributes []Attribute

// Find returns a (value, true) if an attribute correspond with given name is found, otherwise (nil, false).
func (as Attributes) Find(name []byte) (interface{}, bool) {
	for _, a := range as {
		if bytes.Equal(a.Name, name) {
			return a.Value, true
		}
	}
	return nil, false
}

func (as Attributes) findUpdate(name []byte, cb func(v interface{}) interface{}) bool {
	for i, a := range as {
		if bytes.Equal(a.Name, name) {
			as[i].Value = cb(a.Value)
			return true
		}
	}
	return false
}

// ParseAttributes parses attributes into a map.
// ParseAttributes returns a parsed attributes and true if could parse
// attributes, otherwise nil and false.
func ParseAttributes(reader text.Reader) (Attributes, bool) {
	savedLine, savedPosition := reader.Position()
	reader.SkipSpaces()
	if reader.Peek() != '{' {
		reader.SetPosition(savedLine, savedPosition)
		return nil, false
	}
	reader.Advance(1)
	attrs := Attributes{}
	for {
		if reader.Peek() == '}' {
			reader.Advance(1)
			return attrs, true
		}
		attr, ok := parseAttribute(reader)
		if !ok {
			reader.SetPosition(savedLine, savedPosition)
			return nil, false
		}
		if bytes.Equal(attr.Name, attrNameClass) {
			if !attrs.findUpdate(attrNameClass, func(v interface{}) interface{} {
				ret := make([]byte, 0, len(v.([]byte))+1+len(attr.Value.([]byte)))
				ret = append(ret, v.([]byte)...)
				return append(append(ret, ' '), attr.Value.([]byte)...)
			}) {
				attrs = append(attrs, attr)
			}
		} else {
			attrs = append(attrs, attr)
		}
		reader.SkipSpaces()
		if reader.Peek() == ',' {
			reader.Advance(1)
			reader.SkipSpaces()
		}
	}
}

func parseAttribute(reader text.Reader) (Attribute, bool) {
	reader.SkipSpaces()
	c := reader.Peek()
	if c == '#' || c == '.' {
		reader.Advance(1)
		line, _ := reader.PeekLine()
		i := 0
		// HTML5 allows any kind of characters as id, but XHTML restricts characters for id.
		// CommonMark is basically defined for XHTML(even though it is legacy).
		// So we restrict id characters.
		for ; i < len(line) && !util.IsSpace(line[i]) &&
			(!util.IsPunct(line[i]) || line[i] == '_' ||
				line[i] == '-' || line[i] == ':' || line[i] == '.'); i++ {
		}
		name := attrNameClass
		if c == '#' {
			name = attrNameID
		}
		reader.Advance(i)
		return Attribute{Name: name, Value: line[0:i]}, true
	}
	line, _ := reader.PeekLine()
	if len(line) == 0 {
		return Attribute{}, false
	}
	c = line[0]
	if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
		c == '_' || c == ':') {
		return Attribute{}, false
	}
	i := 0
	for ; i < len(line); i++ {
		c = line[i]
		if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
			(c >= '0' && c <= '9') ||
			c == '_' || c == ':' || c == '.' || c == '-') {
			break
		}
	}
	name := line[:i]
	reader.Advance(i)
	reader.SkipSpaces()
	c = reader.Peek()
	if c != '=' {
		return Attribute{}, false
	}
	reader.Advance(1)
	reader.SkipSpaces()
	value, ok := parseAttributeValue(reader)
	if !ok {
		return Attribute{}, false
	}
	if bytes.Equal(name, attrNameClass) {
		if _, ok = value.([]byte); !ok {
			return Attribute{}, false
		}
	}
	return Attribute{Name: name, Value: value}, true
}

func parseAttributeValue(reader text.Reader) (interface{}, bool) {
	reader.SkipSpaces()
	c := reader.Peek()
	var value interface{}
	var ok bool
	switch c {
	case text.EOF:
		return Attribute{}, false
	case '{':
		value, ok = ParseAttributes(reader)
	case '[':
		value, ok = parseAttributeArray(reader)
	case '"':
		value, ok = parseAttributeString(reader)
	default:
		if c == '-' || c == '+' || util.IsNumeric(c) {
			value, ok = parseAttributeNumber(reader)
		} else {
			value, ok = parseAttributeOthers(reader)
		}
	}
	if !ok {
		return nil, false
	}
	return value, true
}

func parseAttributeArray(reader text.Reader) ([]interface{}, bool) {
	reader.Advance(1) // skip [
	ret := []interface{}{}
	for i := 0; ; i++ {
		c := reader.Peek()
		comma := false
		if i != 0 && c == ',' {
			reader.Advance(1)
			comma = true
		}
		if c == ']' {
			if !comma {
				reader.Advance(1)
				return ret, true
			}
			return nil, false
		}
		reader.SkipSpaces()
		value, ok := parseAttributeValue(reader)
		if !ok {
			return nil, false
		}
		ret = append(ret, value)
		reader.SkipSpaces()
	}
}

func parseAttributeString(reader text.Reader) ([]byte, bool) {
	reader.Advance(1) // skip "
	line, _ := reader.PeekLine()
	i := 0
	l := len(line)
	var buf bytes.Buffer
	for i < l {
		c := line[i]
		if c == '\\' && i != l-1 {
			n := line[i+1]
			switch n {
			case '"', '/', '\\':
				buf.WriteByte(n)
				i += 2
			case 'b':
				buf.WriteString("\b")
				i += 2
			case 'f':
				buf.WriteString("\f")
				i += 2
			case 'n':
				buf.WriteString("\n")
				i += 2
			case 'r':
				buf.WriteString("\r")
				i += 2
			case 't':
				buf.WriteString("\t")
				i += 2
			default:
				buf.WriteByte('\\')
				i++
			}
			continue
		}
		if c == '"' {
			reader.Advance(i + 1)
			return buf.Bytes(), true
		}
		buf.WriteByte(c)
		i++
	}
	return nil, false
}

func scanAttributeDecimal(reader text.Reader, w io.ByteWriter) {
	for {
		c := reader.Peek()
		if util.IsNumeric(c) {
			_ = w.WriteByte(c)
		} else {
			return
		}
		reader.Advance(1)
	}
}

func parseAttributeNumber(reader text.Reader) (float64, bool) {
	sign := 1
	c := reader.Peek()
	if c == '-' {
		sign = -1
		reader.Advance(1)
	} else if c == '+' {
		reader.Advance(1)
	}
	var buf bytes.Buffer
	if !util.IsNumeric(reader.Peek()) {
		return 0, false
	}
	scanAttributeDecimal(reader, &buf)
	if buf.Len() == 0 {
		return 0, false
	}
	c = reader.Peek()
	if c == '.' {
		buf.WriteByte(c)
		reader.Advance(1)
		scanAttributeDecimal(reader, &buf)
	}
	c = reader.Peek()
	if c == 'e' || c == 'E' {
		buf.WriteByte(c)
		reader.Advance(1)
		c = reader.Peek()
		if c == '-' || c == '+' {
			buf.WriteByte(c)
			reader.Advance(1)
		}
		scanAttributeDecimal(reader, &buf)
	}
	f, err := strconv.ParseFloat(buf.String(), 64)
	if err != nil {
		return 0, false
	}
	return float64(sign) * f, true
}

var bytesTrue = []byte("true")
var bytesFalse = []byte("false")
var bytesNull = []byte("null")

func parseAttributeOthers(reader text.Reader) (interface{}, bool) {
	line, _ := reader.PeekLine()
	c := line[0]
	if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
		c == '_' || c == ':') {
		return nil, false
	}
	i := 0
	for ; i < len(line); i++ {
		c := line[i]
		if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
			(c >= '0' && c <= '9') ||
			c == '_' || c == ':' || c == '.' || c == '-') {
			break
		}
	}
	value := line[:i]
	reader.Advance(i)
	if bytes.Equal(value, bytesTrue) {
		return true, true
	}
	if bytes.Equal(value, bytesFalse) {
		return false, true
	}
	if bytes.Equal(value, bytesNull) {
		return nil, true
	}
	return value, true
}
</file>

<file path="parser/atx_heading.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

// A HeadingConfig struct is a data structure that holds configuration of the renderers related to headings.
type HeadingConfig struct {
	AutoHeadingID bool
	Attribute     bool
}

// SetOption implements SetOptioner.
func (b *HeadingConfig) SetOption(name OptionName, _ interface{}) {
	switch name {
	case optAutoHeadingID:
		b.AutoHeadingID = true
	case optAttribute:
		b.Attribute = true
	}
}

// A HeadingOption interface sets options for heading parsers.
type HeadingOption interface {
	Option
	SetHeadingOption(*HeadingConfig)
}

// AutoHeadingID is an option name that enables auto IDs for headings.
const optAutoHeadingID OptionName = "AutoHeadingID"

type withAutoHeadingID struct {
}

func (o *withAutoHeadingID) SetParserOption(c *Config) {
	c.Options[optAutoHeadingID] = true
}

func (o *withAutoHeadingID) SetHeadingOption(p *HeadingConfig) {
	p.AutoHeadingID = true
}

// WithAutoHeadingID is a functional option that enables custom heading ids and
// auto generated heading ids.
func WithAutoHeadingID() HeadingOption {
	return &withAutoHeadingID{}
}

type withHeadingAttribute struct {
	Option
}

func (o *withHeadingAttribute) SetHeadingOption(p *HeadingConfig) {
	p.Attribute = true
}

// WithHeadingAttribute is a functional option that enables custom heading attributes.
func WithHeadingAttribute() HeadingOption {
	return &withHeadingAttribute{WithAttribute()}
}

type atxHeadingParser struct {
	HeadingConfig
}

// NewATXHeadingParser return a new BlockParser that can parse ATX headings.
func NewATXHeadingParser(opts ...HeadingOption) BlockParser {
	p := &atxHeadingParser{}
	for _, o := range opts {
		o.SetHeadingOption(&p.HeadingConfig)
	}
	return p
}

func (b *atxHeadingParser) Trigger() []byte {
	return []byte{'#'}
}

func (b *atxHeadingParser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	line, segment := reader.PeekLine()
	pos := pc.BlockOffset()
	if pos < 0 {
		return nil, NoChildren
	}
	i := pos
	for ; i < len(line) && line[i] == '#'; i++ {
	}
	level := i - pos
	if i == pos || level > 6 {
		return nil, NoChildren
	}
	if i == len(line) { // alone '#' (without a new line character)
		return ast.NewHeading(level), NoChildren
	}
	l := util.TrimLeftSpaceLength(line[i:])
	if l == 0 {
		return nil, NoChildren
	}
	start := i + l
	if start >= len(line) {
		start = len(line) - 1
	}
	origstart := start
	stop := len(line) - util.TrimRightSpaceLength(line)

	node := ast.NewHeading(level)
	parsed := false
	if b.Attribute { // handles special case like ### heading ### {#id}
		start--
		closureClose := -1
		closureOpen := -1
		for j := start; j < stop; {
			c := line[j]
			if util.IsEscapedPunctuation(line, j) {
				j += 2
			} else if util.IsSpace(c) && j < stop-1 && line[j+1] == '#' {
				closureOpen = j + 1
				k := j + 1
				for ; k < stop && line[k] == '#'; k++ {
				}
				closureClose = k
				break
			} else {
				j++
			}
		}
		if closureClose > 0 {
			reader.Advance(closureClose)
			attrs, ok := ParseAttributes(reader)
			rest, _ := reader.PeekLine()
			parsed = ok && util.IsBlank(rest)
			if parsed {
				for _, attr := range attrs {
					node.SetAttribute(attr.Name, attr.Value)
				}
				node.Lines().Append(text.NewSegment(
					segment.Start+start+1-segment.Padding,
					segment.Start+closureOpen-segment.Padding))
			}
		}
	}
	if !parsed {
		start = origstart
		stop := len(line) - util.TrimRightSpaceLength(line)
		if stop <= start { // empty headings like '##[space]'
			stop = start
		} else {
			i = stop - 1
			for ; line[i] == '#' && i >= start; i-- {
			}
			if i != stop-1 && !util.IsSpace(line[i]) {
				i = stop - 1
			}
			i++
			stop = i
		}

		if len(util.TrimRight(line[start:stop], []byte{'#'})) != 0 { // empty heading like '### ###'
			node.Lines().Append(text.NewSegment(segment.Start+start-segment.Padding, segment.Start+stop-segment.Padding))
		}
	}
	return node, NoChildren
}

func (b *atxHeadingParser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	return Close
}

func (b *atxHeadingParser) Close(node ast.Node, reader text.Reader, pc Context) {
	if b.Attribute {
		_, ok := node.AttributeString("id")
		if !ok {
			parseLastLineAttributes(node, reader, pc)
		}
	}

	if b.AutoHeadingID {
		id, ok := node.AttributeString("id")
		if !ok {
			generateAutoHeadingID(node.(*ast.Heading), reader, pc)
		} else {
			pc.IDs().Put(id.([]byte))
		}
	}
}

func (b *atxHeadingParser) CanInterruptParagraph() bool {
	return true
}

func (b *atxHeadingParser) CanAcceptIndentedLine() bool {
	return false
}

func generateAutoHeadingID(node *ast.Heading, reader text.Reader, pc Context) {
	var line []byte
	lastIndex := node.Lines().Len() - 1
	if lastIndex > -1 {
		lastLine := node.Lines().At(lastIndex)
		line = lastLine.Value(reader.Source())
	}
	headingID := pc.IDs().Generate(line, ast.KindHeading)
	node.SetAttribute(attrNameID, headingID)
}

func parseLastLineAttributes(node ast.Node, reader text.Reader, pc Context) {
	lastIndex := node.Lines().Len() - 1
	if lastIndex < 0 { // empty headings
		return
	}
	lastLine := node.Lines().At(lastIndex)
	line := lastLine.Value(reader.Source())
	lr := text.NewReader(line)
	var attrs Attributes
	var ok bool
	var start text.Segment
	var sl int
	var end text.Segment
	for {
		c := lr.Peek()
		if c == text.EOF {
			break
		}
		if c == '\\' {
			lr.Advance(1)
			if lr.Peek() == '{' {
				lr.Advance(1)
			}
			continue
		}
		if c == '{' {
			sl, start = lr.Position()
			attrs, ok = ParseAttributes(lr)
			_, end = lr.Position()
			lr.SetPosition(sl, start)
		}
		lr.Advance(1)
	}
	if ok && util.IsBlank(line[end.Start:]) {
		for _, attr := range attrs {
			node.SetAttribute(attr.Name, attr.Value)
		}
		lastLine.Stop = lastLine.Start + start.Start
		node.Lines().Set(lastIndex, lastLine)
	}
}
</file>

<file path="parser/blockquote.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type blockquoteParser struct {
}

var defaultBlockquoteParser = &blockquoteParser{}

// NewBlockquoteParser returns a new BlockParser that
// parses blockquotes.
func NewBlockquoteParser() BlockParser {
	return defaultBlockquoteParser
}

func (b *blockquoteParser) process(reader text.Reader) bool {
	line, _ := reader.PeekLine()
	w, pos := util.IndentWidth(line, reader.LineOffset())
	if w > 3 || pos >= len(line) || line[pos] != '>' {
		return false
	}
	pos++
	if pos >= len(line) || line[pos] == '\n' {
		reader.Advance(pos)
		return true
	}
	reader.Advance(pos)
	if line[pos] == ' ' || line[pos] == '\t' {
		padding := 0
		if line[pos] == '\t' {
			padding = util.TabWidth(reader.LineOffset()) - 1
		}
		reader.AdvanceAndSetPadding(1, padding)
	}
	return true
}

func (b *blockquoteParser) Trigger() []byte {
	return []byte{'>'}
}

func (b *blockquoteParser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	if b.process(reader) {
		return ast.NewBlockquote(), HasChildren
	}
	return nil, NoChildren
}

func (b *blockquoteParser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	if b.process(reader) {
		return Continue | HasChildren
	}
	return Close
}

func (b *blockquoteParser) Close(node ast.Node, reader text.Reader, pc Context) {
	// nothing to do
}

func (b *blockquoteParser) CanInterruptParagraph() bool {
	return true
}

func (b *blockquoteParser) CanAcceptIndentedLine() bool {
	return false
}
</file>

<file path="parser/list.go">
package parser

import (
	"strconv"

	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type listItemType int

const (
	notList listItemType = iota
	bulletList
	orderedList
)

var skipListParserKey = NewContextKey()
var emptyListItemWithBlankLines = NewContextKey()
var listItemFlagValue interface{} = true

// Same as
// `^(([ ]*)([\-\*\+]))(\s+.*)?\n?$`.FindSubmatchIndex or
// `^(([ ]*)(\d{1,9}[\.\)]))(\s+.*)?\n?$`.FindSubmatchIndex.
func parseListItem(line []byte) ([6]int, listItemType) {
	i := 0
	l := len(line)
	ret := [6]int{}
	for ; i < l && line[i] == ' '; i++ {
		c := line[i]
		if c == '\t' {
			return ret, notList
		}
	}
	if i > 3 {
		return ret, notList
	}
	ret[0] = 0
	ret[1] = i
	ret[2] = i
	var typ listItemType
	if i < l && (line[i] == '-' || line[i] == '*' || line[i] == '+') {
		i++
		ret[3] = i
		typ = bulletList
	} else if i < l {
		for ; i < l && util.IsNumeric(line[i]); i++ {
		}
		ret[3] = i
		if ret[3] == ret[2] || ret[3]-ret[2] > 9 {
			return ret, notList
		}
		if i < l && (line[i] == '.' || line[i] == ')') {
			i++
			ret[3] = i
		} else {
			return ret, notList
		}
		typ = orderedList
	} else {
		return ret, notList
	}
	if i < l && line[i] != '\n' {
		w, _ := util.IndentWidth(line[i:], 0)
		if w == 0 {
			return ret, notList
		}
	}
	if i >= l {
		ret[4] = -1
		ret[5] = -1
		return ret, typ
	}
	ret[4] = i
	ret[5] = len(line)
	if line[ret[5]-1] == '\n' && line[i] != '\n' {
		ret[5]--
	}
	return ret, typ
}

func matchesListItem(source []byte, strict bool) ([6]int, listItemType) {
	m, typ := parseListItem(source)
	if typ != notList && (!strict || strict && m[1] < 4) {
		return m, typ
	}
	return m, notList
}

func calcListOffset(source []byte, match [6]int) int {
	var offset int
	if match[4] < 0 || util.IsBlank(source[match[4]:]) { // list item starts with a blank line
		offset = 1
	} else {
		offset, _ = util.IndentWidth(source[match[4]:], match[4])
		if offset > 4 { // offseted codeblock
			offset = 1
		}
	}
	return offset
}

func lastOffset(node ast.Node) int {
	lastChild := node.LastChild()
	if lastChild != nil {
		return lastChild.(*ast.ListItem).Offset
	}
	return 0
}

type listParser struct {
}

var defaultListParser = &listParser{}

// NewListParser returns a new BlockParser that
// parses lists.
// This parser must take precedence over the ListItemParser.
func NewListParser() BlockParser {
	return defaultListParser
}

func (b *listParser) Trigger() []byte {
	return []byte{'-', '+', '*', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
}

func (b *listParser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	last := pc.LastOpenedBlock().Node
	if _, lok := last.(*ast.List); lok || pc.Get(skipListParserKey) != nil {
		pc.Set(skipListParserKey, nil)
		return nil, NoChildren
	}
	line, _ := reader.PeekLine()
	match, typ := matchesListItem(line, true)
	if typ == notList {
		return nil, NoChildren
	}
	start := -1
	if typ == orderedList {
		number := line[match[2] : match[3]-1]
		start, _ = strconv.Atoi(string(number))
	}

	if ast.IsParagraph(last) && last.Parent() == parent {
		// we allow only lists starting with 1 to interrupt paragraphs.
		if typ == orderedList && start != 1 {
			return nil, NoChildren
		}
		//an empty list item cannot interrupt a paragraph:
		if match[4] < 0 || util.IsBlank(line[match[4]:match[5]]) {
			return nil, NoChildren
		}
	}

	marker := line[match[3]-1]
	node := ast.NewList(marker)
	if start > -1 {
		node.Start = start
	}
	pc.Set(emptyListItemWithBlankLines, nil)
	return node, HasChildren
}

func (b *listParser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	list := node.(*ast.List)
	line, _ := reader.PeekLine()
	if util.IsBlank(line) {
		if node.LastChild().ChildCount() == 0 {
			pc.Set(emptyListItemWithBlankLines, listItemFlagValue)
		}
		return Continue | HasChildren
	}

	// "offset" means a width that bar indicates.
	//    -  aaaaaaaa
	// |----|
	//
	// If the indent is less than the last offset like
	// - a
	//  - b          <--- current line
	// it maybe a new child of the list.
	//
	// Empty list items can have multiple blanklines
	//
	// -             <--- 1st item is an empty thus "offset" is unknown
	//
	//
	//   -           <--- current line
	//
	// -> 1 list with 2 blank items
	//
	// So if the last item is an empty, it maybe a new child of the list.
	//
	offset := lastOffset(node)
	lastIsEmpty := node.LastChild().ChildCount() == 0
	indent, _ := util.IndentWidth(line, reader.LineOffset())

	if indent < offset || lastIsEmpty {
		if indent < 4 {
			match, typ := matchesListItem(line, false) // may have a leading spaces more than 3
			if typ != notList && match[1]-offset < 4 {
				marker := line[match[3]-1]
				if !list.CanContinue(marker, typ == orderedList) {
					return Close
				}
				// Thematic Breaks take precedence over lists
				if isThematicBreak(line[match[3]-1:], 0) {
					isHeading := false
					last := pc.LastOpenedBlock().Node
					if ast.IsParagraph(last) {
						c, ok := matchesSetextHeadingBar(line[match[3]-1:])
						if ok && c == '-' {
							isHeading = true
						}
					}
					if !isHeading {
						return Close
					}
				}
				return Continue | HasChildren
			}
		}
		if !lastIsEmpty {
			return Close
		}
	}

	if lastIsEmpty && indent < offset {
		return Close
	}

	// Non empty items can not exist next to an empty list item
	// with blank lines. So we need to close the current list
	//
	// -
	//
	//   foo
	//
	// -> 1 list with 1 blank items and 1 paragraph
	if pc.Get(emptyListItemWithBlankLines) != nil {
		return Close
	}
	return Continue | HasChildren
}

func (b *listParser) Close(node ast.Node, reader text.Reader, pc Context) {
	list := node.(*ast.List)

	for c := node.FirstChild(); c != nil && list.IsTight; c = c.NextSibling() {
		if c.FirstChild() != nil && c.FirstChild() != c.LastChild() {
			for c1 := c.FirstChild().NextSibling(); c1 != nil; c1 = c1.NextSibling() {
				if c1.HasBlankPreviousLines() {
					list.IsTight = false
					break
				}
			}
		}
		if c != node.FirstChild() {
			if c.HasBlankPreviousLines() {
				list.IsTight = false
			}
		}
	}

	if list.IsTight {
		for child := node.FirstChild(); child != nil; child = child.NextSibling() {
			for gc := child.FirstChild(); gc != nil; {
				paragraph, ok := gc.(*ast.Paragraph)
				gc = gc.NextSibling()
				if ok {
					textBlock := ast.NewTextBlock()
					textBlock.SetLines(paragraph.Lines())
					child.ReplaceChild(child, paragraph, textBlock)
				}
			}
		}
	}
}

func (b *listParser) CanInterruptParagraph() bool {
	return true
}

func (b *listParser) CanAcceptIndentedLine() bool {
	return false
}
</file>

<file path="parser/setext_headings.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

var temporaryParagraphKey = NewContextKey()

type setextHeadingParser struct {
	HeadingConfig
}

func matchesSetextHeadingBar(line []byte) (byte, bool) {
	start := 0
	end := len(line)
	space := util.TrimLeftLength(line, []byte{' '})
	if space > 3 {
		return 0, false
	}
	start += space
	level1 := util.TrimLeftLength(line[start:end], []byte{'='})
	c := byte('=')
	var level2 int
	if level1 == 0 {
		level2 = util.TrimLeftLength(line[start:end], []byte{'-'})
		c = '-'
	}
	if util.IsSpace(line[end-1]) {
		end -= util.TrimRightSpaceLength(line[start:end])
	}
	if !((level1 > 0 && start+level1 == end) || (level2 > 0 && start+level2 == end)) {
		return 0, false
	}
	return c, true
}

// NewSetextHeadingParser return a new BlockParser that can parse Setext headings.
func NewSetextHeadingParser(opts ...HeadingOption) BlockParser {
	p := &setextHeadingParser{}
	for _, o := range opts {
		o.SetHeadingOption(&p.HeadingConfig)
	}
	return p
}

func (b *setextHeadingParser) Trigger() []byte {
	return []byte{'-', '='}
}

func (b *setextHeadingParser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	last := pc.LastOpenedBlock().Node
	if last == nil {
		return nil, NoChildren
	}
	paragraph, ok := last.(*ast.Paragraph)
	if !ok || paragraph.Parent() != parent {
		return nil, NoChildren
	}
	line, segment := reader.PeekLine()
	c, ok := matchesSetextHeadingBar(line)
	if !ok {
		return nil, NoChildren
	}
	level := 1
	if c == '-' {
		level = 2
	}
	node := ast.NewHeading(level)
	node.Lines().Append(segment)
	pc.Set(temporaryParagraphKey, last)
	return node, NoChildren | RequireParagraph
}

func (b *setextHeadingParser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	return Close
}

func (b *setextHeadingParser) Close(node ast.Node, reader text.Reader, pc Context) {
	heading := node.(*ast.Heading)
	segment := node.Lines().At(0)
	heading.Lines().Clear()
	tmp := pc.Get(temporaryParagraphKey).(*ast.Paragraph)
	pc.Set(temporaryParagraphKey, nil)
	if tmp.Lines().Len() == 0 {
		next := heading.NextSibling()
		segment = segment.TrimLeftSpace(reader.Source())
		if next == nil || !ast.IsParagraph(next) {
			para := ast.NewParagraph()
			para.Lines().Append(segment)
			heading.Parent().InsertAfter(heading.Parent(), heading, para)
		} else {
			next.Lines().Unshift(segment)
		}
		heading.Parent().RemoveChild(heading.Parent(), heading)
	} else {
		heading.SetLines(tmp.Lines())
		heading.SetBlankPreviousLines(tmp.HasBlankPreviousLines())
		tp := tmp.Parent()
		if tp != nil {
			tp.RemoveChild(tp, tmp)
		}
	}

	if b.Attribute {
		parseLastLineAttributes(node, reader, pc)
	}

	if b.AutoHeadingID {
		id, ok := node.AttributeString("id")
		if !ok {
			generateAutoHeadingID(heading, reader, pc)
		} else {
			pc.IDs().Put(id.([]byte))
		}
	}
}

func (b *setextHeadingParser) CanInterruptParagraph() bool {
	return true
}

func (b *setextHeadingParser) CanAcceptIndentedLine() bool {
	return false
}
</file>

<file path="parser/thematic_break.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type thematicBreakPraser struct {
}

var defaultThematicBreakPraser = &thematicBreakPraser{}

// NewThematicBreakParser returns a new BlockParser that
// parses thematic breaks.
func NewThematicBreakParser() BlockParser {
	return defaultThematicBreakPraser
}

func isThematicBreak(line []byte, offset int) bool {
	w, pos := util.IndentWidth(line, offset)
	if w > 3 {
		return false
	}
	mark := byte(0)
	count := 0
	for i := pos; i < len(line); i++ {
		c := line[i]
		if util.IsSpace(c) {
			continue
		}
		if mark == 0 {
			mark = c
			count = 1
			if mark == '*' || mark == '-' || mark == '_' {
				continue
			}
			return false
		}
		if c != mark {
			return false
		}
		count++
	}
	return count > 2
}

func (b *thematicBreakPraser) Trigger() []byte {
	return []byte{'-', '*', '_'}
}

func (b *thematicBreakPraser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	line, _ := reader.PeekLine()
	if isThematicBreak(line, reader.LineOffset()) {
		reader.AdvanceToEOL()
		return ast.NewThematicBreak(), NoChildren
	}
	return nil, NoChildren
}

func (b *thematicBreakPraser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	return Close
}

func (b *thematicBreakPraser) Close(node ast.Node, reader text.Reader, pc Context) {
	// nothing to do
}

func (b *thematicBreakPraser) CanInterruptParagraph() bool {
	return true
}

func (b *thematicBreakPraser) CanAcceptIndentedLine() bool {
	return false
}
</file>

<file path="renderer/renderer.go">
// Package renderer renders the given AST to certain formats.
package renderer

import (
	"bufio"
	"io"
	"sync"

	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/util"
)

// A Config struct is a data structure that holds configuration of the Renderer.
type Config struct {
	Options       map[OptionName]interface{}
	NodeRenderers util.PrioritizedSlice
}

// NewConfig returns a new Config.
func NewConfig() *Config {
	return &Config{
		Options:       map[OptionName]interface{}{},
		NodeRenderers: util.PrioritizedSlice{},
	}
}

// An OptionName is a name of the option.
type OptionName string

// An Option interface is a functional option type for the Renderer.
type Option interface {
	SetConfig(*Config)
}

type withNodeRenderers struct {
	value []util.PrioritizedValue
}

func (o *withNodeRenderers) SetConfig(c *Config) {
	c.NodeRenderers = append(c.NodeRenderers, o.value...)
}

// WithNodeRenderers is a functional option that allow you to add
// NodeRenderers to the renderer.
func WithNodeRenderers(ps ...util.PrioritizedValue) Option {
	return &withNodeRenderers{ps}
}

type withOption struct {
	name  OptionName
	value interface{}
}

func (o *withOption) SetConfig(c *Config) {
	c.Options[o.name] = o.value
}

// WithOption is a functional option that allow you to set
// an arbitrary option to the parser.
func WithOption(name OptionName, value interface{}) Option {
	return &withOption{name, value}
}

// A SetOptioner interface sets given option to the object.
type SetOptioner interface {
	// SetOption sets given option to the object.
	// Unacceptable options may be passed.
	// Thus implementations must ignore unacceptable options.
	SetOption(name OptionName, value interface{})
}

// NodeRendererFunc is a function that renders a given node.
type NodeRendererFunc func(writer util.BufWriter, source []byte, n ast.Node, entering bool) (ast.WalkStatus, error)

// A NodeRenderer interface offers NodeRendererFuncs.
type NodeRenderer interface {
	// RendererFuncs registers NodeRendererFuncs to given NodeRendererFuncRegisterer.
	RegisterFuncs(NodeRendererFuncRegisterer)
}

// A NodeRendererFuncRegisterer registers given NodeRendererFunc to this object.
type NodeRendererFuncRegisterer interface {
	// Register registers given NodeRendererFunc to this object.
	Register(ast.NodeKind, NodeRendererFunc)
}

// A Renderer interface renders given AST node to given
// writer with given Renderer.
type Renderer interface {
	Render(w io.Writer, source []byte, n ast.Node) error

	// AddOptions adds given option to this renderer.
	AddOptions(...Option)
}

type renderer struct {
	config               *Config
	options              map[OptionName]interface{}
	nodeRendererFuncsTmp map[ast.NodeKind]NodeRendererFunc
	maxKind              int
	nodeRendererFuncs    []NodeRendererFunc
	initSync             sync.Once
}

// NewRenderer returns a new Renderer with given options.
func NewRenderer(options ...Option) Renderer {
	config := NewConfig()
	for _, opt := range options {
		opt.SetConfig(config)
	}

	r := &renderer{
		options:              map[OptionName]interface{}{},
		config:               config,
		nodeRendererFuncsTmp: map[ast.NodeKind]NodeRendererFunc{},
	}

	return r
}

func (r *renderer) AddOptions(opts ...Option) {
	for _, opt := range opts {
		opt.SetConfig(r.config)
	}
}

func (r *renderer) Register(kind ast.NodeKind, v NodeRendererFunc) {
	r.nodeRendererFuncsTmp[kind] = v
	if int(kind) > r.maxKind {
		r.maxKind = int(kind)
	}
}

// Render renders the given AST node to the given writer with the given Renderer.
func (r *renderer) Render(w io.Writer, source []byte, n ast.Node) error {
	r.initSync.Do(func() {
		r.options = r.config.Options
		r.config.NodeRenderers.Sort()
		l := len(r.config.NodeRenderers)
		for i := l - 1; i >= 0; i-- {
			v := r.config.NodeRenderers[i]
			nr, _ := v.Value.(NodeRenderer)
			if se, ok := v.Value.(SetOptioner); ok {
				for oname, ovalue := range r.options {
					se.SetOption(oname, ovalue)
				}
			}
			nr.RegisterFuncs(r)
		}
		r.nodeRendererFuncs = make([]NodeRendererFunc, r.maxKind+1)
		for kind, nr := range r.nodeRendererFuncsTmp {
			r.nodeRendererFuncs[kind] = nr
		}
		r.config = nil
		r.nodeRendererFuncsTmp = nil
	})
	writer, ok := w.(util.BufWriter)
	if !ok {
		writer = bufio.NewWriter(w)
	}
	err := ast.Walk(n, func(n ast.Node, entering bool) (ast.WalkStatus, error) {
		s := ast.WalkStatus(ast.WalkContinue)
		var err error
		f := r.nodeRendererFuncs[n.Kind()]
		if f != nil {
			s, err = f(writer, source, n, entering)
		}
		return s, err
	})
	if err != nil {
		return err
	}
	return writer.Flush()
}
</file>

<file path="testutil/testutil.go">
// Package testutil provides utilities for unit tests.
package testutil

import (
	"bufio"
	"bytes"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"runtime/debug"
	"strconv"
	"strings"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/util"
)

// TestingT is a subset of the functionality provided by testing.T.
type TestingT interface {
	Logf(string, ...interface{})
	Skipf(string, ...interface{})
	Errorf(string, ...interface{})
	FailNow()
}

// MarkdownTestCase represents a test case.
type MarkdownTestCase struct {
	No          int
	Description string
	Options     MarkdownTestCaseOptions
	Markdown    string
	Expected    string
}

func source(t *MarkdownTestCase) string {
	ret := t.Markdown
	if t.Options.Trim {
		ret = strings.TrimSpace(ret)
	}
	if t.Options.EnableEscape {
		return string(applyEscapeSequence([]byte(ret)))
	}
	return ret
}

func expected(t *MarkdownTestCase) string {
	ret := t.Expected
	if t.Options.Trim {
		ret = strings.TrimSpace(ret)
	}
	if t.Options.EnableEscape {
		return string(applyEscapeSequence([]byte(ret)))
	}
	return ret
}

// MarkdownTestCaseOptions represents options for each test case.
type MarkdownTestCaseOptions struct {
	EnableEscape bool
	Trim         bool
}

const attributeSeparator = "//- - - - - - - - -//"
const caseSeparator = "//= = = = = = = = = = = = = = = = = = = = = = = =//"

var optionsRegexp = regexp.MustCompile(`(?i)\s*options:(.*)`)

// ParseCliCaseArg parses -case command line args.
func ParseCliCaseArg() []int {
	ret := []int{}
	for _, a := range os.Args {
		if strings.HasPrefix(a, "case=") {
			parts := strings.Split(a, "=")
			for _, cas := range strings.Split(parts[1], ",") {
				value, err := strconv.Atoi(strings.TrimSpace(cas))
				if err == nil {
					ret = append(ret, value)
				}
			}
		}
	}
	return ret
}

// DoTestCaseFile runs test cases in a given file.
func DoTestCaseFile(m goldmark.Markdown, filename string, t TestingT, no ...int) {
	fp, err := os.Open(filename)
	if err != nil {
		panic(err)
	}
	defer func() {
		_ = fp.Close()
	}()

	scanner := bufio.NewScanner(fp)
	c := MarkdownTestCase{
		No:          -1,
		Description: "",
		Options:     MarkdownTestCaseOptions{},
		Markdown:    "",
		Expected:    "",
	}
	cases := []MarkdownTestCase{}
	line := 0
	for scanner.Scan() {
		line++
		if util.IsBlank([]byte(scanner.Text())) {
			continue
		}
		header := scanner.Text()
		c.Description = ""
		if strings.Contains(header, ":") {
			parts := strings.Split(header, ":")
			c.No, err = strconv.Atoi(strings.TrimSpace(parts[0]))
			c.Description = strings.Join(parts[1:], ":")
		} else {
			c.No, err = strconv.Atoi(scanner.Text())
		}
		if err != nil {
			panic(fmt.Sprintf("%s: invalid case No at line %d", filename, line))
		}
		if !scanner.Scan() {
			panic(fmt.Sprintf("%s: invalid case at line %d", filename, line))
		}
		line++
		matches := optionsRegexp.FindAllStringSubmatch(scanner.Text(), -1)
		if len(matches) != 0 {
			err = json.Unmarshal([]byte(matches[0][1]), &c.Options)
			if err != nil {
				panic(fmt.Sprintf("%s: invalid options at line %d", filename, line))
			}
			scanner.Scan()
			line++
		}
		if scanner.Text() != attributeSeparator {
			panic(fmt.Sprintf("%s: invalid separator '%s' at line %d", filename, scanner.Text(), line))
		}
		buf := []string{}
		for scanner.Scan() {
			line++
			text := scanner.Text()
			if text == attributeSeparator {
				break
			}
			buf = append(buf, text)
		}
		c.Markdown = strings.Join(buf, "\n")
		buf = []string{}
		for scanner.Scan() {
			line++
			text := scanner.Text()
			if text == caseSeparator {
				break
			}
			buf = append(buf, text)
		}
		c.Expected = strings.Join(buf, "\n")
		if len(c.Expected) != 0 {
			c.Expected = c.Expected + "\n"
		}
		shouldAdd := len(no) == 0
		if !shouldAdd {
			for _, n := range no {
				if n == c.No {
					shouldAdd = true
					break
				}
			}
		}
		if shouldAdd {
			cases = append(cases, c)
		}
	}
	DoTestCases(m, cases, t)
}

// DoTestCases runs a set of test cases.
func DoTestCases(m goldmark.Markdown, cases []MarkdownTestCase, t TestingT, opts ...parser.ParseOption) {
	for _, testCase := range cases {
		DoTestCase(m, testCase, t, opts...)
	}
}

// DoTestCase runs a test case.
func DoTestCase(m goldmark.Markdown, testCase MarkdownTestCase, t TestingT, opts ...parser.ParseOption) {
	var ok bool
	var out bytes.Buffer
	defer func() {
		description := ""
		if len(testCase.Description) != 0 {
			description = ": " + testCase.Description
		}
		if err := recover(); err != nil {
			format := `============= case %d%s ================
Markdown:
-----------
%s

Expected:
----------
%s

Actual
---------
%v
%s
`
			t.Errorf(format, testCase.No, description, source(&testCase), expected(&testCase), err, debug.Stack())
		} else if !ok {
			format := `============= case %d%s ================
Markdown:
-----------
%s

Expected:
----------
%s

Actual
---------
%s

Diff
---------
%s
`
			t.Errorf(format, testCase.No, description, source(&testCase), expected(&testCase), out.Bytes(),
				DiffPretty([]byte(expected(&testCase)), out.Bytes()))
		}
	}()

	if err := m.Convert([]byte(source(&testCase)), &out, opts...); err != nil {
		panic(err)
	}
	ok = bytes.Equal(bytes.TrimSpace(out.Bytes()), bytes.TrimSpace([]byte(expected(&testCase))))
}

type diffType int

const (
	diffRemoved diffType = iota
	diffAdded
	diffNone
)

type diff struct {
	Type  diffType
	Lines [][]byte
}

func simpleDiff(v1, v2 []byte) []diff {
	return simpleDiffAux(
		bytes.Split(v1, []byte("\n")),
		bytes.Split(v2, []byte("\n")))
}

func simpleDiffAux(v1lines, v2lines [][]byte) []diff {
	v1index := map[string][]int{}
	for i, line := range v1lines {
		key := util.BytesToReadOnlyString(line)
		if _, ok := v1index[key]; !ok {
			v1index[key] = []int{}
		}
		v1index[key] = append(v1index[key], i)
	}
	overlap := map[int]int{}
	v1start := 0
	v2start := 0
	length := 0
	for v2pos, line := range v2lines {
		newOverlap := map[int]int{}
		key := util.BytesToReadOnlyString(line)
		if _, ok := v1index[key]; !ok {
			v1index[key] = []int{}
		}
		for _, v1pos := range v1index[key] {
			value := 0
			if v1pos != 0 {
				if v, ok := overlap[v1pos-1]; ok {
					value = v
				}
			}
			newOverlap[v1pos] = value + 1
			if newOverlap[v1pos] > length {
				length = newOverlap[v1pos]
				v1start = v1pos - length + 1
				v2start = v2pos - length + 1
			}
		}
		overlap = newOverlap
	}
	if length == 0 {
		diffs := []diff{}
		if len(v1lines) != 0 {
			diffs = append(diffs, diff{diffRemoved, v1lines})
		}
		if len(v2lines) != 0 {
			diffs = append(diffs, diff{diffAdded, v2lines})
		}
		return diffs
	}
	diffs := simpleDiffAux(v1lines[:v1start], v2lines[:v2start])
	diffs = append(diffs, diff{diffNone, v2lines[v2start : v2start+length]})
	diffs = append(diffs, simpleDiffAux(v1lines[v1start+length:],
		v2lines[v2start+length:])...)
	return diffs
}

// DiffPretty returns pretty formatted diff between given bytes.
func DiffPretty(v1, v2 []byte) []byte {
	var b bytes.Buffer
	diffs := simpleDiff(v1, v2)
	for _, diff := range diffs {
		c := " "
		switch diff.Type {
		case diffAdded:
			c = "+"
		case diffRemoved:
			c = "-"
		case diffNone:
			c = " "
		}
		for _, line := range diff.Lines {
			if c != " " {
				b.WriteString(fmt.Sprintf("%s | %s\n", c, util.VisualizeSpaces(line)))
			} else {
				b.WriteString(fmt.Sprintf("%s | %s\n", c, line))
			}
		}
	}
	return b.Bytes()
}

func applyEscapeSequence(b []byte) []byte {
	result := make([]byte, 0, len(b))
	for i := 0; i < len(b); i++ {
		if b[i] == '\\' && i != len(b)-1 {
			switch b[i+1] {
			case 'a':
				result = append(result, '\a')
				i++
				continue
			case 'b':
				result = append(result, '\b')
				i++
				continue
			case 'f':
				result = append(result, '\f')
				i++
				continue
			case 'n':
				result = append(result, '\n')
				i++
				continue
			case 'r':
				result = append(result, '\r')
				i++
				continue
			case 't':
				result = append(result, '\t')
				i++
				continue
			case 'v':
				result = append(result, '\v')
				i++
				continue
			case '\\':
				result = append(result, '\\')
				i++
				continue
			case 'x':
				if len(b) >= i+3 && util.IsHexDecimal(b[i+2]) && util.IsHexDecimal(b[i+3]) {
					v, _ := hex.DecodeString(string(b[i+2 : i+4]))
					result = append(result, v[0])
					i += 3
					continue
				}
			case 'u', 'U':
				if len(b) > i+2 {
					num := []byte{}
					for j := i + 2; j < len(b); j++ {
						if util.IsHexDecimal(b[j]) {
							num = append(num, b[j])
							continue
						}
						break
					}
					if len(num) >= 4 && len(num) < 8 {
						v, _ := strconv.ParseInt(string(num[:4]), 16, 32)
						result = append(result, []byte(string(rune(v)))...)
						i += 5
						continue
					}
					if len(num) >= 8 {
						v, _ := strconv.ParseInt(string(num[:8]), 16, 32)
						result = append(result, []byte(string(rune(v)))...)
						i += 9
						continue
					}
				}
			}
		}
		result = append(result, b[i])
	}
	return result
}
</file>

<file path="text/package.go">
// Package text provides functionalities to manipulate texts.
package text
</file>

<file path="text/reader_test.go">
package text

import (
	"regexp"
	"testing"
)

func TestFindSubMatchReader(t *testing.T) {
	s := "微笑"
	r := NewReader([]byte(":" + s + ":"))
	reg := regexp.MustCompile(`:(\p{L}+):`)
	match := r.FindSubMatch(reg)
	if len(match) != 2 || string(match[1]) != s {
		t.Fatal("no match cjk")
	}
}
</file>

<file path="util/html5entities.gen.go">
// Code generated by _tools; DO NOT EDIT.
package util
const _html5entitiesLength = 2124
const _html5entitiesName string = "AEligAMPAacuteAcircAcyAfrAgraveAlphaAmacrAndAogonAopfApplyFunctionAringAscrAssignAtildeAumlBackslashBarvBarwedBcyBecauseBernoullisBetaBfrBopfBreveBscrBumpeqCHcyCOPYCacuteCapCapitalDifferentialDCayleysCcaronCcedilCcircCconintCdotCedillaCenterDotCfrChiCircleDotCircleMinusCirclePlusCircleTimesClockwiseContourIntegralCloseCurlyDoubleQuoteCloseCurlyQuoteColonColoneCongruentConintContourIntegralCopfCoproductCounterClockwiseContourIntegralCrossCscrCupCupCapDDDDotrahdDJcyDScyDZcyDaggerDarrDashvDcaronDcyDelDeltaDfrDiacriticalAcuteDiacriticalDotDiacriticalDoubleAcuteDiacriticalGraveDiacriticalTildeDiamondDifferentialDDopfDotDotDotDotEqualDoubleContourIntegralDoubleDotDoubleDownArrowDoubleLeftArrowDoubleLeftRightArrowDoubleLeftTeeDoubleLongLeftArrowDoubleLongLeftRightArrowDoubleLongRightArrowDoubleRightArrowDoubleRightTeeDoubleUpArrowDoubleUpDownArrowDoubleVerticalBarDownArrowDownArrowBarDownArrowUpArrowDownBreveDownLeftRightVectorDownLeftTeeVectorDownLeftVectorDownLeftVectorBarDownRightTeeVectorDownRightVectorDownRightVectorBarDownTeeDownTeeArrowDownarrowDscrDstrokENGETHEacuteEcaronEcircEcyEdotEfrEgraveElementEmacrEmptySmallSquareEmptyVerySmallSquareEogonEopfEpsilonEqualEqualTildeEquilibriumEscrEsimEtaEumlExistsExponentialEFcyFfrFilledSmallSquareFilledVerySmallSquareFopfForAllFouriertrfFscrGJcyGTGammaGammadGbreveGcedilGcircGcyGdotGfrGgGopfGreaterEqualGreaterEqualLessGreaterFullEqualGreaterGreaterGreaterLessGreaterSlantEqualGreaterTildeGscrGtHARDcyHacekHatHcircHfrHilbertSpaceHopfHorizontalLineHscrHstrokHumpDownHumpHumpEqualIEcyIJligIOcyIacuteIcircIcyIdotIfrIgraveImImacrImaginaryIImpliesIntIntegralIntersectionInvisibleCommaInvisibleTimesIogonIopfIotaIscrItildeIukcyIumlJcircJcyJfrJopfJscrJsercyJukcyKHcyKJcyKappaKcedilKcyKfrKopfKscrLJcyLTLacuteLambdaLangLaplacetrfLarrLcaronLcedilLcyLeftAngleBracketLeftArrowLeftArrowBarLeftArrowRightArrowLeftCeilingLeftDoubleBracketLeftDownTeeVectorLeftDownVectorLeftDownVectorBarLeftFloorLeftRightArrowLeftRightVectorLeftTeeLeftTeeArrowLeftTeeVectorLeftTriangleLeftTriangleBarLeftTriangleEqualLeftUpDownVectorLeftUpTeeVectorLeftUpVectorLeftUpVectorBarLeftVectorLeftVectorBarLeftarrowLeftrightarrowLessEqualGreaterLessFullEqualLessGreaterLessLessLessSlantEqualLessTildeLfrLlLleftarrowLmidotLongLeftArrowLongLeftRightArrowLongRightArrowLongleftarrowLongleftrightarrowLongrightarrowLopfLowerLeftArrowLowerRightArrowLscrLshLstrokLtMapMcyMediumSpaceMellintrfMfrMinusPlusMopfMscrMuNJcyNacuteNcaronNcedilNcyNegativeMediumSpaceNegativeThickSpaceNegativeThinSpaceNegativeVeryThinSpaceNestedGreaterGreaterNestedLessLessNewLineNfrNoBreakNonBreakingSpaceNopfNotNotCongruentNotCupCapNotDoubleVerticalBarNotElementNotEqualNotEqualTildeNotExistsNotGreaterNotGreaterEqualNotGreaterFullEqualNotGreaterGreaterNotGreaterLessNotGreaterSlantEqualNotGreaterTildeNotHumpDownHumpNotHumpEqualNotLeftTriangleNotLeftTriangleBarNotLeftTriangleEqualNotLessNotLessEqualNotLessGreaterNotLessLessNotLessSlantEqualNotLessTildeNotNestedGreaterGreaterNotNestedLessLessNotPrecedesNotPrecedesEqualNotPrecedesSlantEqualNotReverseElementNotRightTriangleNotRightTriangleBarNotRightTriangleEqualNotSquareSubsetNotSquareSubsetEqualNotSquareSupersetNotSquareSupersetEqualNotSubsetNotSubsetEqualNotSucceedsNotSucceedsEqualNotSucceedsSlantEqualNotSucceedsTildeNotSupersetNotSupersetEqualNotTildeNotTildeEqualNotTildeFullEqualNotTildeTildeNotVerticalBarNscrNtildeNuOEligOacuteOcircOcyOdblacOfrOgraveOmacrOmegaOmicronOopfOpenCurlyDoubleQuoteOpenCurlyQuoteOrOscrOslashOtildeOtimesOumlOverBarOverBraceOverBracketOverParenthesisPartialDPcyPfrPhiPiPlusMinusPoincareplanePopfPrPrecedesPrecedesEqualPrecedesSlantEqualPrecedesTildePrimeProductProportionProportionalPscrPsiQUOTQfrQopfQscrRBarrREGRacuteRangRarrRarrtlRcaronRcedilRcyReReverseElementReverseEquilibriumReverseUpEquilibriumRfrRhoRightAngleBracketRightArrowRightArrowBarRightArrowLeftArrowRightCeilingRightDoubleBracketRightDownTeeVectorRightDownVectorRightDownVectorBarRightFloorRightTeeRightTeeArrowRightTeeVectorRightTriangleRightTriangleBarRightTriangleEqualRightUpDownVectorRightUpTeeVectorRightUpVectorRightUpVectorBarRightVectorRightVectorBarRightarrowRopfRoundImpliesRrightarrowRscrRshRuleDelayedSHCHcySHcySOFTcySacuteScScaronScedilScircScySfrShortDownArrowShortLeftArrowShortRightArrowShortUpArrowSigmaSmallCircleSopfSqrtSquareSquareIntersectionSquareSubsetSquareSubsetEqualSquareSupersetSquareSupersetEqualSquareUnionSscrStarSubSubsetSubsetEqualSucceedsSucceedsEqualSucceedsSlantEqualSucceedsTildeSuchThatSumSupSupersetSupersetEqualSupsetTHORNTRADETSHcyTScyTabTauTcaronTcedilTcyTfrThereforeThetaThickSpaceThinSpaceTildeTildeEqualTildeFullEqualTildeTildeTopfTripleDotTscrTstrokUacuteUarrUarrocirUbrcyUbreveUcircUcyUdblacUfrUgraveUmacrUnderBarUnderBraceUnderBracketUnderParenthesisUnionUnionPlusUogonUopfUpArrowUpArrowBarUpArrowDownArrowUpDownArrowUpEquilibriumUpTeeUpTeeArrowUparrowUpdownarrowUpperLeftArrowUpperRightArrowUpsiUpsilonUringUscrUtildeUumlVDashVbarVcyVdashVdashlVeeVerbarVertVerticalBarVerticalLineVerticalSeparatorVerticalTildeVeryThinSpaceVfrVopfVscrVvdashWcircWedgeWfrWopfWscrXfrXiXopfXscrYAcyYIcyYUcyYacuteYcircYcyYfrYopfYscrYumlZHcyZacuteZcaronZcyZdotZeroWidthSpaceZetaZfrZopfZscraacuteabreveacacEacdacircacuteacyaeligafafragravealefsymalephalphaamacramalgampandandandanddandslopeandvangangeangleangmsdangmsdaaangmsdabangmsdacangmsdadangmsdaeangmsdafangmsdagangmsdahangrtangrtvbangrtvbdangsphangstangzarraogonaopfapapEapacirapeapidaposapproxapproxeqaringascrastasympasympeqatildeaumlawconintawintbNotbackcongbackepsilonbackprimebacksimbacksimeqbarveebarwedbarwedgebbrkbbrktbrkbcongbcybdquobecausbecausebemptyvbepsibernoubetabethbetweenbfrbigcapbigcircbigcupbigodotbigoplusbigotimesbigsqcupbigstarbigtriangledownbigtriangleupbiguplusbigveebigwedgebkarowblacklozengeblacksquareblacktriangleblacktriangledownblacktriangleleftblacktrianglerightblankblk12blk14blk34blockbnebnequivbnotbopfbotbottombowtieboxDLboxDRboxDlboxDrboxHboxHDboxHUboxHdboxHuboxULboxURboxUlboxUrboxVboxVHboxVLboxVRboxVhboxVlboxVrboxboxboxdLboxdRboxdlboxdrboxhboxhDboxhUboxhdboxhuboxminusboxplusboxtimesboxuLboxuRboxulboxurboxvboxvHboxvLboxvRboxvhboxvlboxvrbprimebrevebrvbarbscrbsemibsimbsimebsolbsolbbsolhsubbullbulletbumpbumpEbumpebumpeqcacutecapcapandcapbrcupcapcapcapcupcapdotcapscaretcaronccapsccaronccedilccircccupsccupssmcdotcedilcemptyvcentcenterdotcfrchcycheckcheckmarkchicircirEcirccirceqcirclearrowleftcirclearrowrightcircledRcircledScircledastcircledcirccircleddashcirecirfnintcirmidcirscirclubsclubsuitcoloncolonecoloneqcommacommatcompcompfncomplementcomplexescongcongdotconintcopfcoprodcopycopysrcrarrcrosscscrcsubcsubecsupcsupectdotcudarrlcudarrrcueprcuesccularrcularrpcupcupbrcapcupcapcupcupcupdotcuporcupscurarrcurarrmcurlyeqpreccurlyeqsucccurlyveecurlywedgecurrencurvearrowleftcurvearrowrightcuveecuwedcwconintcwintcylctydArrdHardaggerdalethdarrdashdashvdbkarowdblacdcarondcyddddaggerddarrddotseqdegdeltademptyvdfishtdfrdharldharrdiamdiamonddiamondsuitdiamsdiedigammadisindivdividedivideontimesdivonxdjcydlcorndlcropdollardopfdotdoteqdoteqdotdotminusdotplusdotsquaredoublebarwedgedownarrowdowndownarrowsdownharpoonleftdownharpoonrightdrbkarowdrcorndrcropdscrdscydsoldstrokdtdotdtridtrifduarrduhardwangledzcydzigrarreDDoteDoteacuteeasterecaronecirecircecolonecyedoteeefDotefregegraveegsegsdotelelintersellelselsdotemacremptyemptysetemptyvemspemsp13emsp14engenspeogoneopfepareparsleplusepsiepsilonepsiveqcirceqcoloneqsimeqslantgtreqslantlessequalsequestequivequivDDeqvparslerDoterarrescresdotesimetaetheumleuroexclexistexpectationexponentialefallingdotseqfcyfemaleffiligffligfflligffrfiligfjligflatflligfltnsfnoffopfforallforkforkvfpartintfrac12frac13frac14frac15frac16frac18frac23frac25frac34frac35frac38frac45frac56frac58frac78fraslfrownfscrgEgElgacutegammagammadgapgbrevegcircgcygdotgegelgeqgeqqgeqslantgesgesccgesdotgesdotogesdotolgeslgeslesgfrggggggimelgjcyglglEglagljgnEgnapgnapproxgnegneqgneqqgnsimgopfgravegscrgsimgsimegsimlgtgtccgtcirgtdotgtlPargtquestgtrapproxgtrarrgtrdotgtreqlessgtreqqlessgtrlessgtrsimgvertneqqgvnEhArrhairsphalfhamilthardcyharrharrcirharrwhbarhcircheartsheartsuithellipherconhfrhksearowhkswarowhoarrhomththookleftarrowhookrightarrowhopfhorbarhscrhslashhstrokhybullhypheniacuteicicircicyiecyiexcliffifrigraveiiiiiintiiintiinfiniiotaijligimacrimageimaglineimagpartimathimofimpedinincareinfininfintieinodotintintcalintegersintercalintlarhkintprodiocyiogoniopfiotaiprodiquestiscrisinisinEisindotisinsisinsvisinvititildeiukcyiumljcircjcyjfrjmathjopfjscrjsercyjukcykappakappavkcedilkcykfrkgreenkhcykjcykopfkscrlAarrlArrlAtaillBarrlElEglHarlacutelaemptyvlagranlambdalanglangdlanglelaplaquolarrlarrblarrbfslarrfslarrhklarrlplarrpllarrsimlarrtllatlataillatelateslbarrlbbrklbracelbracklbrkelbrksldlbrkslulcaronlcedillceillcublcyldcaldquoldquorldrdharldrusharldshleleftarrowleftarrowtailleftharpoondownleftharpoonupleftleftarrowsleftrightarrowleftrightarrowsleftrightharpoonsleftrightsquigarrowleftthreetimeslegleqleqqleqslantleslescclesdotlesdotolesdotorlesglesgeslessapproxlessdotlesseqgtrlesseqqgtrlessgtrlesssimlfishtlfloorlfrlglgElhardlharulharullhblkljcyllllarrllcornerllhardlltrilmidotlmoustlmoustachelnElnaplnapproxlnelneqlneqqlnsimloangloarrlobrklongleftarrowlongleftrightarrowlongmapstolongrightarrowlooparrowleftlooparrowrightloparlopflopluslotimeslowastlowbarlozlozengelozflparlparltlrarrlrcornerlrharlrhardlrmlrtrilsaquolscrlshlsimlsimelsimglsqblsquolsquorlstrokltltccltcirltdotlthreeltimesltlarrltquestltrParltriltrieltriflurdsharluruharlvertneqqlvnEmDDotmacrmalemaltmaltesemapmapstomapstodownmapstoleftmapstoupmarkermcommamcymdashmeasuredanglemfrmhomicromidmidastmidcirmiddotminusminusbminusdminusdumlcpmldrmnplusmodelsmopfmpmscrmstposmumultimapmumapnGgnGtnGtvnLeftarrownLeftrightarrownLlnLtnLtvnRightarrownVDashnVdashnablanacutenangnapnapEnapidnaposnapproxnaturnaturalnaturalsnbspnbumpnbumpencapncaronncedilncongncongdotncupncyndashneneArrnearhknearrnearrownedotnequivnesearnesimnexistnexistsnfrngEngengeqngeqqngeqslantngesngsimngtngtrnhArrnharrnhparninisnisdnivnjcynlArrnlEnlarrnldrnlenleftarrownleftrightarrownleqnleqqnleqslantnlesnlessnlsimnltnltrinltrienmidnopfnotnotinnotinEnotindotnotinvanotinvbnotinvcnotninotnivanotnivbnotnivcnparnparallelnparslnpartnpolintnprnprcuenprenprecnpreceqnrArrnrarrnrarrcnrarrwnrightarrownrtrinrtrienscnsccuenscenscrnshortmidnshortparallelnsimnsimensimeqnsmidnsparnsqsubensqsupensubnsubEnsubensubsetnsubseteqnsubseteqqnsuccnsucceqnsupnsupEnsupensupsetnsupseteqnsupseteqqntglntildentlgntriangleleftntrianglelefteqntrianglerightntrianglerighteqnunumnumeronumspnvDashnvHarrnvapnvdashnvgenvgtnvinfinnvlArrnvlenvltnvltrienvrArrnvrtrienvsimnwArrnwarhknwarrnwarrownwnearoSoacuteoastocirocircocyodashodblacodivodotodsoldoeligofcirofrogonograveogtohbarohmointolarrolcirolcrossolineoltomacromegaomicronomidominusoopfoparoperpoplusororarrordorderorderofordfordmorigoforororslopeorvoscroslashosolotildeotimesotimesasoumlovbarparparaparallelparsimparslpartpcypercntperiodpermilperppertenkpfrphiphivphmmatphonepipitchforkpivplanckplanckhplankvplusplusacirplusbpluscirplusdoplusdupluseplusmnplussimplustwopmpointintpopfpoundprprEprapprcuepreprecprecapproxpreccurlyeqpreceqprecnapproxprecneqqprecnsimprecsimprimeprimesprnEprnapprnsimprodprofalarproflineprofsurfpropproptoprsimprurelpscrpsipuncspqfrqintqopfqprimeqscrquaternionsquatintquestquesteqquotrAarrrArrrAtailrBarrrHarraceracuteradicraemptyvrangrangdrangerangleraquorarrrarraprarrbrarrbfsrarrcrarrfsrarrhkrarrlprarrplrarrsimrarrtlrarrwratailratiorationalsrbarrrbbrkrbracerbrackrbrkerbrksldrbrkslurcaronrcedilrceilrcubrcyrdcardldharrdquordquorrdshrealrealinerealpartrealsrectregrfishtrfloorrfrrhardrharurharulrhorhovrightarrowrightarrowtailrightharpoondownrightharpoonuprightleftarrowsrightleftharpoonsrightrightarrowsrightsquigarrowrightthreetimesringrisingdotseqrlarrrlharrlmrmoustrmoustachernmidroangroarrrobrkroparropfroplusrotimesrparrpargtrppolintrrarrrsaquorscrrshrsqbrsquorsquorrthreertimesrtrirtriertrifrtriltriruluharrxsacutesbquoscscEscapscaronsccuescescedilscircscnEscnapscnsimscpolintscsimscysdotsdotbsdoteseArrsearhksearrsearrowsectsemiseswarsetminussetmnsextsfrsfrownsharpshchcyshcyshortmidshortparallelshysigmasigmafsigmavsimsimdotsimesimeqsimgsimgEsimlsimlEsimnesimplussimrarrslarrsmallsetminussmashpsmeparslsmidsmilesmtsmtesmtessoftcysolsolbsolbarsopfspadesspadesuitsparsqcapsqcapssqcupsqcupssqsubsqsubesqsubsetsqsubseteqsqsupsqsupesqsupsetsqsupseteqsqusquaresquarfsqufsrarrsscrssetmnssmilesstarfstarstarfstraightepsilonstraightphistrnssubsubEsubdotsubesubedotsubmultsubnEsubnesubplussubrarrsubsetsubseteqsubseteqqsubsetneqsubsetneqqsubsimsubsubsubsupsuccsuccapproxsucccurlyeqsucceqsuccnapproxsuccneqqsuccnsimsuccsimsumsungsupsup1sup2sup3supEsupdotsupdsubsupesupedotsuphsolsuphsubsuplarrsupmultsupnEsupnesupplussupsetsupseteqsupseteqqsupsetneqsupsetneqqsupsimsupsubsupsupswArrswarhkswarrswarrowswnwarszligtargettautbrktcarontcediltcytdottelrectfrthere4thereforethetathetasymthetavthickapproxthicksimthinspthkapthksimthorntildetimestimesbtimesbartimesdtinttoeatoptopbottopcirtopftopforktosatprimetradetriangletriangledowntrianglelefttrianglelefteqtriangleqtrianglerighttrianglerighteqtridottrietriminustriplustrisbtritimetrpeziumtscrtscytshcytstroktwixttwoheadleftarrowtwoheadrightarrowuArruHaruacuteuarrubrcyubreveucircucyudarrudblacudharufishtufrugraveuharluharruhblkulcornulcornerulcropultriumacrumluogonuopfuparrowupdownarrowupharpoonleftupharpoonrightuplusupsiupsihupsilonupuparrowsurcornurcornerurcropuringurtriuscrutdotutildeutriutrifuuarruumluwanglevArrvBarvBarvvDashvangrtvarepsilonvarkappavarnothingvarphivarpivarproptovarrvarrhovarsigmavarsubsetneqvarsubsetneqqvarsupsetneqvarsupsetneqqvarthetavartriangleleftvartrianglerightvcyvdashveeveebarveeeqvellipverbarvertvfrvltrivnsubvnsupvopfvpropvrtrivscrvsubnEvsubnevsupnEvsupnevzigzagwcircwedbarwedgewedgeqweierpwfrwopfwpwrwreathwscrxcapxcircxcupxdtrixfrxhArrxharrxixlArrxlarrxmapxnisxodotxopfxoplusxotimexrArrxrarrxscrxsqcupxuplusxutrixveexwedgeyacuteyacyycircycyyenyfryicyyopfyscryucyyumlzacutezcaronzcyzdotzeetrfzetazfrzhcyzigrarrzopfzscrzwjzwnj"
const _html5entitiesNameIndex  = "\x05\x03\x06\x05\x03\x03\x06\x05\x05\x03\x05\x04\x0d\x05\x04\x06\x06\x04\x09\x04\x06\x03\x07\x0a\x04\x03\x04\x05\x04\x06\x04\x04\x06\x03\x14\x07\x06\x06\x05\x07\x04\x07\x09\x03\x03\x09\x0b\x0a\x0b\x18\x15\x0f\x05\x06\x09\x06\x0f\x04\x09\x1f\x05\x04\x03\x06\x02\x08\x04\x04\x04\x06\x04\x05\x06\x03\x03\x05\x03\x10\x0e\x16\x10\x10\x07\x0d\x04\x03\x06\x08\x15\x09\x0f\x0f\x14\x0d\x13\x18\x14\x10\x0e\x0d\x11\x11\x09\x0c\x10\x09\x13\x11\x0e\x11\x12\x0f\x12\x07\x0c\x09\x04\x06\x03\x03\x06\x06\x05\x03\x04\x03\x06\x07\x05\x10\x14\x05\x04\x07\x05\x0a\x0b\x04\x04\x03\x04\x06\x0c\x03\x03\x11\x15\x04\x06\x0a\x04\x04\x02\x05\x06\x06\x06\x05\x03\x04\x03\x02\x04\x0c\x10\x10\x0e\x0b\x11\x0c\x04\x02\x06\x05\x03\x05\x03\x0c\x04\x0e\x04\x06\x0c\x09\x04\x05\x04\x06\x05\x03\x04\x03\x06\x02\x05\x0a\x07\x03\x08\x0c\x0e\x0e\x05\x04\x04\x04\x06\x05\x04\x05\x03\x03\x04\x04\x06\x05\x04\x04\x05\x06\x03\x03\x04\x04\x04\x02\x06\x06\x04\x0a\x04\x06\x06\x03\x10\x09\x0c\x13\x0b\x11\x11\x0e\x11\x09\x0e\x0f\x07\x0c\x0d\x0c\x0f\x11\x10\x0f\x0c\x0f\x0a\x0d\x09\x0e\x10\x0d\x0b\x08\x0e\x09\x03\x02\x0a\x06\x0d\x12\x0e\x0d\x12\x0e\x04\x0e\x0f\x04\x03\x06\x02\x03\x03\x0b\x09\x03\x09\x04\x04\x02\x04\x06\x06\x06\x03\x13\x12\x11\x15\x14\x0e\x07\x03\x07\x10\x04\x03\x0c\x09\x14\x0a\x08\x0d\x09\x0a\x0f\x13\x11\x0e\x14\x0f\x0f\x0c\x0f\x12\x14\x07\x0c\x0e\x0b\x11\x0c\x17\x11\x0b\x10\x15\x11\x10\x13\x15\x0f\x14\x11\x16\x09\x0e\x0b\x10\x15\x10\x0b\x10\x08\x0d\x11\x0d\x0e\x04\x06\x02\x05\x06\x05\x03\x06\x03\x06\x05\x05\x07\x04\x14\x0e\x02\x04\x06\x06\x06\x04\x07\x09\x0b\x0f\x08\x03\x03\x03\x02\x09\x0d\x04\x02\x08\x0d\x12\x0d\x05\x07\x0a\x0c\x04\x03\x04\x03\x04\x04\x05\x03\x06\x04\x04\x06\x06\x06\x03\x02\x0e\x12\x14\x03\x03\x11\x0a\x0d\x13\x0c\x12\x12\x0f\x12\x0a\x08\x0d\x0e\x0d\x10\x12\x11\x10\x0d\x10\x0b\x0e\x0a\x04\x0c\x0b\x04\x03\x0b\x06\x04\x06\x06\x02\x06\x06\x05\x03\x03\x0e\x0e\x0f\x0c\x05\x0b\x04\x04\x06\x12\x0c\x11\x0e\x13\x0b\x04\x04\x03\x06\x0b\x08\x0d\x12\x0d\x08\x03\x03\x08\x0d\x06\x05\x05\x05\x04\x03\x03\x06\x06\x03\x03\x09\x05\x0a\x09\x05\x0a\x0e\x0a\x04\x09\x04\x06\x06\x04\x08\x05\x06\x05\x03\x06\x03\x06\x05\x08\x0a\x0c\x10\x05\x09\x05\x04\x07\x0a\x10\x0b\x0d\x05\x0a\x07\x0b\x0e\x0f\x04\x07\x05\x04\x06\x04\x05\x04\x03\x05\x06\x03\x06\x04\x0b\x0c\x11\x0d\x0d\x03\x04\x04\x06\x05\x05\x03\x04\x04\x03\x02\x04\x04\x04\x04\x04\x06\x05\x03\x03\x04\x04\x04\x04\x06\x06\x03\x04\x0e\x04\x03\x04\x04\x06\x06\x02\x03\x03\x05\x05\x03\x05\x02\x03\x06\x07\x05\x05\x05\x05\x03\x03\x06\x04\x08\x04\x03\x04\x05\x06\x08\x08\x08\x08\x08\x08\x08\x08\x05\x07\x08\x06\x05\x07\x05\x04\x02\x03\x06\x03\x04\x04\x06\x08\x05\x04\x03\x05\x07\x06\x04\x08\x05\x04\x08\x0b\x09\x07\x09\x06\x06\x08\x04\x08\x05\x03\x05\x06\x07\x07\x05\x06\x04\x04\x07\x03\x06\x07\x06\x07\x08\x09\x08\x07\x0f\x0d\x08\x06\x08\x06\x0c\x0b\x0d\x11\x11\x12\x05\x05\x05\x05\x05\x03\x07\x04\x04\x03\x06\x06\x05\x05\x05\x05\x04\x05\x05\x05\x05\x05\x05\x05\x05\x04\x05\x05\x05\x05\x05\x05\x06\x05\x05\x05\x05\x04\x05\x05\x05\x05\x08\x07\x08\x05\x05\x05\x05\x04\x05\x05\x05\x05\x05\x05\x06\x05\x06\x04\x05\x04\x05\x04\x05\x08\x04\x06\x04\x05\x05\x06\x06\x03\x06\x08\x06\x06\x06\x04\x05\x05\x05\x06\x06\x05\x05\x07\x04\x05\x07\x04\x09\x03\x04\x05\x09\x03\x03\x04\x04\x06\x0f\x10\x08\x08\x0a\x0b\x0b\x04\x08\x06\x07\x05\x08\x05\x06\x07\x05\x06\x04\x06\x0a\x09\x04\x07\x06\x04\x06\x04\x06\x05\x05\x04\x04\x05\x04\x05\x05\x07\x07\x05\x05\x06\x07\x03\x08\x06\x06\x06\x05\x04\x06\x07\x0b\x0b\x08\x0a\x06\x0e\x0f\x05\x05\x08\x05\x06\x04\x04\x06\x06\x04\x04\x05\x07\x05\x06\x03\x02\x07\x05\x07\x03\x05\x07\x06\x03\x05\x05\x04\x07\x0b\x05\x03\x07\x05\x03\x06\x0d\x06\x04\x06\x06\x06\x04\x03\x05\x08\x08\x07\x09\x0e\x09\x0e\x0f\x10\x08\x06\x06\x04\x04\x04\x06\x05\x04\x05\x05\x05\x07\x04\x08\x05\x04\x06\x06\x06\x04\x05\x06\x03\x04\x02\x05\x03\x02\x06\x03\x06\x02\x08\x03\x03\x06\x05\x05\x08\x06\x04\x06\x06\x03\x04\x05\x04\x04\x06\x05\x04\x07\x05\x06\x07\x05\x0a\x0b\x06\x06\x05\x07\x08\x05\x05\x04\x05\x04\x03\x03\x04\x04\x04\x05\x0b\x0c\x0d\x03\x06\x06\x05\x06\x03\x05\x05\x04\x05\x05\x04\x04\x06\x04\x05\x08\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x05\x05\x04\x02\x03\x06\x05\x06\x03\x06\x05\x03\x04\x02\x03\x03\x04\x08\x03\x05\x06\x07\x08\x04\x06\x03\x02\x03\x05\x04\x02\x03\x03\x03\x03\x04\x08\x03\x04\x05\x05\x04\x05\x04\x04\x05\x05\x02\x04\x05\x05\x06\x07\x09\x06\x06\x09\x0a\x07\x06\x09\x04\x04\x06\x04\x06\x06\x04\x07\x05\x04\x05\x06\x09\x06\x06\x03\x08\x08\x05\x06\x0d\x0e\x04\x06\x04\x06\x06\x06\x06\x06\x02\x05\x03\x04\x05\x03\x03\x06\x02\x06\x05\x06\x05\x05\x05\x05\x08\x08\x05\x04\x05\x02\x06\x05\x08\x06\x03\x06\x08\x08\x08\x07\x04\x05\x04\x04\x05\x06\x04\x04\x05\x07\x05\x06\x05\x02\x06\x05\x04\x05\x03\x03\x05\x04\x04\x06\x05\x05\x06\x06\x03\x03\x06\x04\x04\x04\x04\x05\x04\x06\x05\x02\x03\x04\x06\x08\x06\x06\x04\x05\x06\x03\x05\x04\x05\x07\x06\x06\x06\x06\x07\x06\x03\x06\x04\x05\x05\x05\x06\x06\x05\x07\x07\x06\x06\x05\x04\x03\x04\x05\x06\x07\x08\x04\x02\x09\x0d\x0f\x0d\x0e\x0e\x0f\x11\x13\x0e\x03\x03\x04\x08\x03\x05\x06\x07\x08\x04\x06\x0a\x07\x09\x0a\x07\x07\x06\x06\x03\x02\x03\x05\x05\x06\x05\x04\x02\x05\x08\x06\x05\x06\x06\x0a\x03\x04\x08\x03\x04\x05\x05\x05\x05\x05\x0d\x12\x0a\x0e\x0d\x0e\x05\x04\x06\x07\x06\x06\x03\x07\x04\x04\x06\x05\x08\x05\x06\x03\x05\x06\x04\x03\x04\x05\x05\x04\x05\x06\x06\x02\x04\x05\x05\x06\x06\x06\x07\x06\x04\x05\x05\x08\x07\x09\x04\x05\x04\x04\x04\x07\x03\x06\x0a\x0a\x08\x06\x06\x03\x05\x0d\x03\x03\x05\x03\x06\x06\x06\x05\x06\x06\x07\x04\x04\x06\x06\x04\x02\x04\x06\x02\x08\x05\x03\x03\x04\x0a\x0f\x03\x03\x04\x0b\x06\x06\x05\x06\x04\x03\x04\x05\x05\x07\x05\x07\x08\x04\x05\x06\x04\x06\x06\x05\x08\x04\x03\x05\x02\x05\x06\x05\x07\x05\x06\x06\x05\x06\x07\x03\x03\x03\x04\x05\x09\x04\x05\x03\x04\x05\x05\x05\x02\x03\x04\x03\x04\x05\x03\x05\x04\x03\x0a\x0f\x04\x05\x09\x04\x05\x05\x03\x05\x06\x04\x04\x03\x05\x06\x08\x07\x07\x07\x05\x07\x07\x07\x04\x09\x06\x05\x07\x03\x06\x04\x05\x07\x05\x05\x06\x06\x0b\x05\x06\x03\x06\x04\x04\x09\x0e\x04\x05\x06\x05\x05\x07\x07\x04\x05\x05\x07\x09\x0a\x05\x07\x04\x05\x05\x07\x09\x0a\x04\x06\x04\x0d\x0f\x0e\x10\x02\x03\x06\x05\x06\x06\x04\x06\x04\x04\x07\x06\x04\x04\x07\x06\x07\x05\x05\x06\x05\x07\x06\x02\x06\x04\x04\x05\x03\x05\x06\x04\x04\x06\x05\x05\x03\x04\x06\x03\x05\x03\x04\x05\x05\x07\x05\x03\x05\x05\x07\x04\x06\x04\x04\x05\x05\x02\x05\x03\x05\x07\x04\x04\x06\x04\x07\x03\x04\x06\x04\x06\x06\x08\x04\x05\x03\x04\x08\x06\x05\x04\x03\x06\x06\x06\x04\x07\x03\x03\x04\x06\x05\x02\x09\x03\x06\x07\x06\x04\x08\x05\x07\x06\x06\x05\x06\x07\x07\x02\x08\x04\x05\x02\x03\x04\x05\x03\x04\x0a\x0b\x06\x0b\x08\x08\x07\x05\x06\x04\x05\x06\x04\x08\x08\x08\x04\x06\x05\x06\x04\x03\x06\x03\x04\x04\x06\x04\x0b\x07\x05\x07\x04\x05\x04\x06\x05\x04\x04\x06\x05\x08\x04\x05\x05\x06\x05\x04\x06\x05\x07\x05\x06\x06\x06\x06\x07\x06\x05\x06\x05\x09\x05\x05\x06\x06\x05\x07\x07\x06\x06\x05\x04\x03\x04\x07\x05\x06\x04\x04\x07\x08\x05\x04\x03\x06\x06\x03\x05\x05\x06\x03\x04\x0a\x0e\x10\x0e\x0f\x11\x10\x0f\x0f\x04\x0c\x05\x05\x03\x06\x0a\x05\x05\x05\x05\x05\x04\x06\x07\x04\x06\x08\x05\x06\x04\x03\x04\x05\x06\x06\x06\x04\x05\x05\x08\x07\x02\x06\x05\x02\x03\x04\x06\x05\x03\x06\x05\x04\x05\x06\x08\x05\x03\x04\x05\x05\x05\x06\x05\x07\x04\x04\x06\x08\x05\x04\x03\x06\x05\x06\x04\x08\x0d\x03\x05\x06\x06\x03\x06\x04\x05\x04\x05\x04\x05\x05\x07\x07\x05\x0d\x06\x08\x04\x05\x03\x04\x05\x06\x03\x04\x06\x04\x06\x09\x04\x05\x06\x05\x06\x05\x06\x08\x0a\x05\x06\x08\x0a\x03\x06\x06\x04\x05\x04\x06\x06\x06\x04\x05\x0f\x0b\x05\x03\x04\x06\x04\x07\x07\x05\x05\x07\x07\x06\x08\x09\x09\x0a\x06\x06\x06\x04\x0a\x0b\x06\x0b\x08\x08\x07\x03\x04\x03\x04\x04\x04\x04\x06\x07\x04\x07\x07\x07\x07\x07\x05\x05\x07\x06\x08\x09\x09\x0a\x06\x06\x06\x05\x06\x05\x07\x06\x05\x06\x03\x04\x06\x06\x03\x04\x06\x03\x06\x09\x05\x08\x06\x0b\x08\x06\x05\x06\x05\x05\x05\x06\x08\x06\x04\x04\x03\x06\x06\x04\x07\x04\x06\x05\x08\x0c\x0c\x0e\x09\x0d\x0f\x06\x04\x08\x07\x05\x07\x08\x04\x04\x05\x06\x05\x10\x11\x04\x04\x06\x04\x05\x06\x05\x03\x05\x06\x05\x06\x03\x06\x05\x05\x05\x06\x08\x06\x05\x05\x03\x05\x04\x07\x0b\x0d\x0e\x05\x04\x05\x07\x0a\x06\x08\x06\x05\x05\x04\x05\x06\x04\x05\x05\x04\x07\x04\x04\x05\x05\x06\x0a\x08\x0a\x06\x05\x09\x04\x06\x08\x0c\x0d\x0c\x0d\x08\x0f\x10\x03\x05\x03\x06\x05\x06\x06\x04\x03\x05\x05\x05\x04\x05\x05\x04\x06\x06\x06\x06\x07\x05\x06\x05\x06\x06\x03\x04\x02\x02\x06\x04\x04\x05\x04\x05\x03\x05\x05\x02\x05\x05\x04\x04\x05\x04\x06\x06\x05\x05\x04\x06\x06\x05\x04\x06\x06\x04\x05\x03\x03\x03\x04\x04\x04\x04\x04\x06\x06\x03\x04\x06\x04\x03\x04\x07\x04\x04\x03\x04"
var _html5entitiesCodePoints = [...]int{198, 38, 193, 194, 1040, 120068, 192, 913, 256, 10835, 260, 120120, 8289, 197, 119964, 8788, 195, 196, 8726, 10983, 8966, 1041, 8757, 8492, 914, 120069, 120121, 728, 8492, 8782, 1063, 169, 262, 8914, 8517, 8493, 268, 199, 264, 8752, 266, 184, 183, 8493, 935, 8857, 8854, 8853, 8855, 8754, 8221, 8217, 8759, 10868, 8801, 8751, 8750, 8450, 8720, 8755, 10799, 119966, 8915, 8781, 8517, 10513, 1026, 1029, 1039, 8225, 8609, 10980, 270, 1044, 8711, 916, 120071, 180, 729, 733, 96, 732, 8900, 8518, 120123, 168, 8412, 8784, 8751, 168, 8659, 8656, 8660, 10980, 10232, 10234, 10233, 8658, 8872, 8657, 8661, 8741, 8595, 10515, 8693, 785, 10576, 10590, 8637, 10582, 10591, 8641, 10583, 8868, 8615, 8659, 119967, 272, 330, 208, 201, 282, 202, 1069, 278, 120072, 200, 8712, 274, 9723, 9643, 280, 120124, 917, 10869, 8770, 8652, 8496, 10867, 919, 203, 8707, 8519, 1060, 120073, 9724, 9642, 120125, 8704, 8497, 8497, 1027, 62, 915, 988, 286, 290, 284, 1043, 288, 120074, 8921, 120126, 8805, 8923, 8807, 10914, 8823, 10878, 8819, 119970, 8811, 1066, 711, 94, 292, 8460, 8459, 8461, 9472, 8459, 294, 8782, 8783, 1045, 306, 1025, 205, 206, 1048, 304, 8465, 204, 8465, 298, 8520, 8658, 8748, 8747, 8898, 8291, 8290, 302, 120128, 921, 8464, 296, 1030, 207, 308, 1049, 120077, 120129, 119973, 1032, 1028, 1061, 1036, 922, 310, 1050, 120078, 120130, 119974, 1033, 60, 313, 923, 10218, 8466, 8606, 317, 315, 1051, 10216, 8592, 8676, 8646, 8968, 10214, 10593, 8643, 10585, 8970, 8596, 10574, 8867, 8612, 10586, 8882, 10703, 8884, 10577, 10592, 8639, 10584, 8636, 10578, 8656, 8660, 8922, 8806, 8822, 10913, 10877, 8818, 120079, 8920, 8666, 319, 10229, 10231, 10230, 10232, 10234, 10233, 120131, 8601, 8600, 8466, 8624, 321, 8810, 10501, 1052, 8287, 8499, 120080, 8723, 120132, 8499, 924, 1034, 323, 327, 325, 1053, 8203, 8203, 8203, 8203, 8811, 8810, 10, 120081, 8288, 160, 8469, 10988, 8802, 8813, 8742, 8713, 8800, 877, 24, 8708, 8815, 8817, 880, 24, 881, 24, 8825, 1087, 24, 8821, 878, 24, 878, 24, 8938, 1070, 24, 8940, 8814, 8816, 8824, 881, 24, 1087, 24, 8820, 1091, 24, 1091, 24, 8832, 1092, 24, 8928, 8716, 8939, 1070, 24, 8941, 884, 24, 8930, 884, 24, 8931, 883, 402, 8840, 8833, 1092, 24, 8929, 883, 24, 883, 402, 8841, 8769, 8772, 8775, 8777, 8740, 119977, 209, 925, 338, 211, 212, 1054, 336, 120082, 210, 332, 937, 927, 120134, 8220, 8216, 10836, 119978, 216, 213, 10807, 214, 8254, 9182, 9140, 9180, 8706, 1055, 120083, 934, 928, 177, 8460, 8473, 10939, 8826, 10927, 8828, 8830, 8243, 8719, 8759, 8733, 119979, 936, 34, 120084, 8474, 119980, 10512, 174, 340, 10219, 8608, 10518, 344, 342, 1056, 8476, 8715, 8651, 10607, 8476, 929, 10217, 8594, 8677, 8644, 8969, 10215, 10589, 8642, 10581, 8971, 8866, 8614, 10587, 8883, 10704, 8885, 10575, 10588, 8638, 10580, 8640, 10579, 8658, 8477, 10608, 8667, 8475, 8625, 10740, 1065, 1064, 1068, 346, 10940, 352, 350, 348, 1057, 120086, 8595, 8592, 8594, 8593, 931, 8728, 120138, 8730, 9633, 8851, 8847, 8849, 8848, 8850, 8852, 119982, 8902, 8912, 8912, 8838, 8827, 10928, 8829, 8831, 8715, 8721, 8913, 8835, 8839, 8913, 222, 8482, 1035, 1062, 9, 932, 356, 354, 1058, 120087, 8756, 920, 828, 202, 8201, 8764, 8771, 8773, 8776, 120139, 8411, 119983, 358, 218, 8607, 10569, 1038, 364, 219, 1059, 368, 120088, 217, 362, 95, 9183, 9141, 9181, 8899, 8846, 370, 120140, 8593, 10514, 8645, 8597, 10606, 8869, 8613, 8657, 8661, 8598, 8599, 978, 933, 366, 119984, 360, 220, 8875, 10987, 1042, 8873, 10982, 8897, 8214, 8214, 8739, 124, 10072, 8768, 8202, 120089, 120141, 119985, 8874, 372, 8896, 120090, 120142, 119986, 120091, 926, 120143, 119987, 1071, 1031, 1070, 221, 374, 1067, 120092, 120144, 119988, 376, 1046, 377, 381, 1047, 379, 8203, 918, 8488, 8484, 119989, 225, 259, 8766, 876, 19, 8767, 226, 180, 1072, 230, 8289, 120094, 224, 8501, 8501, 945, 257, 10815, 38, 8743, 10837, 10844, 10840, 10842, 8736, 10660, 8736, 8737, 10664, 10665, 10666, 10667, 10668, 10669, 10670, 10671, 8735, 8894, 10653, 8738, 197, 9084, 261, 120146, 8776, 10864, 10863, 8778, 8779, 39, 8776, 8778, 229, 119990, 42, 8776, 8781, 227, 228, 8755, 10769, 10989, 8780, 1014, 8245, 8765, 8909, 8893, 8965, 8965, 9141, 9142, 8780, 1073, 8222, 8757, 8757, 10672, 1014, 8492, 946, 8502, 8812, 120095, 8898, 9711, 8899, 10752, 10753, 10754, 10758, 9733, 9661, 9651, 10756, 8897, 8896, 10509, 10731, 9642, 9652, 9662, 9666, 9656, 9251, 9618, 9617, 9619, 9608, 6, 421, 880, 421, 8976, 120147, 8869, 8869, 8904, 9559, 9556, 9558, 9555, 9552, 9574, 9577, 9572, 9575, 9565, 9562, 9564, 9561, 9553, 9580, 9571, 9568, 9579, 9570, 9567, 10697, 9557, 9554, 9488, 9484, 9472, 9573, 9576, 9516, 9524, 8863, 8862, 8864, 9563, 9560, 9496, 9492, 9474, 9578, 9569, 9566, 9532, 9508, 9500, 8245, 728, 166, 119991, 8271, 8765, 8909, 92, 10693, 10184, 8226, 8226, 8782, 10926, 8783, 8783, 263, 8745, 10820, 10825, 10827, 10823, 10816, 874, 5024, 8257, 711, 10829, 269, 231, 265, 10828, 10832, 267, 184, 10674, 162, 183, 120096, 1095, 10003, 10003, 967, 9675, 10691, 710, 8791, 8634, 8635, 174, 9416, 8859, 8858, 8861, 8791, 10768, 10991, 10690, 9827, 9827, 58, 8788, 8788, 44, 64, 8705, 8728, 8705, 8450, 8773, 10861, 8750, 120148, 8720, 169, 8471, 8629, 10007, 119992, 10959, 10961, 10960, 10962, 8943, 10552, 10549, 8926, 8927, 8630, 10557, 8746, 10824, 10822, 10826, 8845, 10821, 874, 5024, 8631, 10556, 8926, 8927, 8910, 8911, 164, 8630, 8631, 8910, 8911, 8754, 8753, 9005, 8659, 10597, 8224, 8504, 8595, 8208, 8867, 10511, 733, 271, 1076, 8518, 8225, 8650, 10871, 176, 948, 10673, 10623, 120097, 8643, 8642, 8900, 8900, 9830, 9830, 168, 989, 8946, 247, 247, 8903, 8903, 1106, 8990, 8973, 36, 120149, 729, 8784, 8785, 8760, 8724, 8865, 8966, 8595, 8650, 8643, 8642, 10512, 8991, 8972, 119993, 1109, 10742, 273, 8945, 9663, 9662, 8693, 10607, 10662, 1119, 10239, 10871, 8785, 233, 10862, 283, 8790, 234, 8789, 1101, 279, 8519, 8786, 120098, 10906, 232, 10902, 10904, 10905, 9191, 8467, 10901, 10903, 275, 8709, 8709, 8709, 8195, 8196, 8197, 331, 8194, 281, 120150, 8917, 10723, 10865, 949, 949, 1013, 8790, 8789, 8770, 10902, 10901, 61, 8799, 8801, 10872, 10725, 8787, 10609, 8495, 8784, 8770, 951, 240, 235, 8364, 33, 8707, 8496, 8519, 8786, 1092, 9792, 64259, 64256, 64260, 120099, 64257, 10, 06, 9837, 64258, 9649, 402, 120151, 8704, 8916, 10969, 10765, 189, 8531, 188, 8533, 8537, 8539, 8532, 8534, 190, 8535, 8540, 8536, 8538, 8541, 8542, 8260, 8994, 119995, 8807, 10892, 501, 947, 989, 10886, 287, 285, 1075, 289, 8805, 8923, 8805, 8807, 10878, 10878, 10921, 10880, 10882, 10884, 892, 5024, 10900, 120100, 8811, 8921, 8503, 1107, 8823, 10898, 10917, 10916, 8809, 10890, 10890, 10888, 10888, 8809, 8935, 120152, 96, 8458, 8819, 10894, 10896, 62, 10919, 10874, 8919, 10645, 10876, 10886, 10616, 8919, 8923, 10892, 8823, 8819, 880, 5024, 880, 5024, 8660, 8202, 189, 8459, 1098, 8596, 10568, 8621, 8463, 293, 9829, 9829, 8230, 8889, 120101, 10533, 10534, 8703, 8763, 8617, 8618, 120153, 8213, 119997, 8463, 295, 8259, 8208, 237, 8291, 238, 1080, 1077, 161, 8660, 120102, 236, 8520, 10764, 8749, 10716, 8489, 307, 299, 8465, 8464, 8465, 305, 8887, 437, 8712, 8453, 8734, 10717, 305, 8747, 8890, 8484, 8890, 10775, 10812, 1105, 303, 120154, 953, 10812, 191, 119998, 8712, 8953, 8949, 8948, 8947, 8712, 8290, 297, 1110, 239, 309, 1081, 120103, 567, 120155, 119999, 1112, 1108, 954, 1008, 311, 1082, 120104, 312, 1093, 1116, 120156, 120000, 8666, 8656, 10523, 10510, 8806, 10891, 10594, 314, 10676, 8466, 955, 10216, 10641, 10216, 10885, 171, 8592, 8676, 10527, 10525, 8617, 8619, 10553, 10611, 8610, 10923, 10521, 10925, 1092, 5024, 10508, 10098, 123, 91, 10635, 10639, 10637, 318, 316, 8968, 123, 1083, 10550, 8220, 8222, 10599, 10571, 8626, 8804, 8592, 8610, 8637, 8636, 8647, 8596, 8646, 8651, 8621, 8907, 8922, 8804, 8806, 10877, 10877, 10920, 10879, 10881, 10883, 892, 5024, 10899, 10885, 8918, 8922, 10891, 8822, 8818, 10620, 8970, 120105, 8822, 10897, 8637, 8636, 10602, 9604, 1113, 8810, 8647, 8990, 10603, 9722, 320, 9136, 9136, 8808, 10889, 10889, 10887, 10887, 8808, 8934, 10220, 8701, 10214, 10229, 10231, 10236, 10230, 8619, 8620, 10629, 120157, 10797, 10804, 8727, 95, 9674, 9674, 10731, 40, 10643, 8646, 8991, 8651, 10605, 8206, 8895, 8249, 120001, 8624, 8818, 10893, 10895, 91, 8216, 8218, 322, 60, 10918, 10873, 8918, 8907, 8905, 10614, 10875, 10646, 9667, 8884, 9666, 10570, 10598, 880, 5024, 880, 5024, 8762, 175, 9794, 10016, 10016, 8614, 8614, 8615, 8612, 8613, 9646, 10793, 1084, 8212, 8737, 120106, 8487, 181, 8739, 42, 10992, 183, 8722, 8863, 8760, 10794, 10971, 8230, 8723, 8871, 120158, 8723, 120002, 8766, 956, 8888, 8888, 892, 24, 881, 402, 881, 24, 8653, 8654, 892, 24, 881, 402, 881, 24, 8655, 8879, 8878, 8711, 324, 873, 402, 8777, 1086, 24, 877, 24, 329, 8777, 9838, 9838, 8469, 160, 878, 24, 878, 24, 10819, 328, 326, 8775, 1086, 24, 10818, 1085, 8211, 8800, 8663, 10532, 8599, 8599, 878, 24, 8802, 10536, 877, 24, 8708, 8708, 120107, 880, 24, 8817, 8817, 880, 24, 1087, 24, 1087, 24, 8821, 8815, 8815, 8654, 8622, 10994, 8715, 8956, 8954, 8715, 1114, 8653, 880, 24, 8602, 8229, 8816, 8602, 8622, 8816, 880, 24, 1087, 24, 1087, 24, 8814, 8820, 8814, 8938, 8940, 8740, 120159, 172, 8713, 895, 24, 894, 24, 8713, 8951, 8950, 8716, 8716, 8958, 8957, 8742, 8742, 1100, 421, 870, 24, 10772, 8832, 8928, 1092, 24, 8832, 1092, 24, 8655, 8603, 1054, 24, 860, 24, 8603, 8939, 8941, 8833, 8929, 1092, 24, 120003, 8740, 8742, 8769, 8772, 8772, 8740, 8742, 8930, 8931, 8836, 1094, 24, 8840, 883, 402, 8840, 1094, 24, 8833, 1092, 24, 8837, 1095, 24, 8841, 883, 402, 8841, 1095, 24, 8825, 241, 8824, 8938, 8940, 8939, 8941, 957, 35, 8470, 8199, 8877, 10500, 878, 402, 8876, 880, 402, 6, 402, 10718, 10498, 880, 402, 6, 402, 888, 402, 10499, 888, 402, 876, 402, 8662, 10531, 8598, 8598, 10535, 9416, 243, 8859, 8858, 244, 1086, 8861, 337, 10808, 8857, 10684, 339, 10687, 120108, 731, 242, 10689, 10677, 937, 8750, 8634, 10686, 10683, 8254, 10688, 333, 969, 959, 10678, 8854, 120160, 10679, 10681, 8853, 8744, 8635, 10845, 8500, 8500, 170, 186, 8886, 10838, 10839, 10843, 8500, 248, 8856, 245, 8855, 10806, 246, 9021, 8741, 182, 8741, 10995, 11005, 8706, 1087, 37, 46, 8240, 8869, 8241, 120109, 966, 981, 8499, 9742, 960, 8916, 982, 8463, 8462, 8463, 43, 10787, 8862, 10786, 8724, 10789, 10866, 177, 10790, 10791, 177, 10773, 120161, 163, 8826, 10931, 10935, 8828, 10927, 8826, 10935, 8828, 10927, 10937, 10933, 8936, 8830, 8242, 8473, 10933, 10937, 8936, 8719, 9006, 8978, 8979, 8733, 8733, 8830, 8880, 120005, 968, 8200, 120110, 10764, 120162, 8279, 120006, 8461, 10774, 63, 8799, 34, 8667, 8658, 10524, 10511, 10596, 876, 17, 341, 8730, 10675, 10217, 10642, 10661, 10217, 187, 8594, 10613, 8677, 10528, 10547, 10526, 8618, 8620, 10565, 10612, 8611, 8605, 10522, 8758, 8474, 10509, 10099, 125, 93, 10636, 10638, 10640, 345, 343, 8969, 125, 1088, 10551, 10601, 8221, 8221, 8627, 8476, 8475, 8476, 8477, 9645, 174, 10621, 8971, 120111, 8641, 8640, 10604, 961, 1009, 8594, 8611, 8641, 8640, 8644, 8652, 8649, 8605, 8908, 730, 8787, 8644, 8652, 8207, 9137, 9137, 10990, 10221, 8702, 10215, 10630, 120163, 10798, 10805, 41, 10644, 10770, 8649, 8250, 120007, 8625, 93, 8217, 8217, 8908, 8906, 9657, 8885, 9656, 10702, 10600, 8478, 347, 8218, 8827, 10932, 10936, 353, 8829, 10928, 351, 349, 10934, 10938, 8937, 10771, 8831, 1089, 8901, 8865, 10854, 8664, 10533, 8600, 8600, 167, 59, 10537, 8726, 8726, 10038, 120112, 8994, 9839, 1097, 1096, 8739, 8741, 173, 963, 962, 962, 8764, 10858, 8771, 8771, 10910, 10912, 10909, 10911, 8774, 10788, 10610, 8592, 8726, 10803, 10724, 8739, 8995, 10922, 10924, 1092, 5024, 1100, 47, 10692, 9023, 120164, 9824, 9824, 8741, 8851, 885, 5024, 8852, 885, 5024, 8847, 8849, 8847, 8849, 8848, 8850, 8848, 8850, 9633, 9633, 9642, 9642, 8594, 120008, 8726, 8995, 8902, 9734, 9733, 1013, 981, 175, 8834, 10949, 10941, 8838, 10947, 10945, 10955, 8842, 10943, 10617, 8834, 8838, 10949, 8842, 10955, 10951, 10965, 10963, 8827, 10936, 8829, 10928, 10938, 10934, 8937, 8831, 8721, 9834, 8835, 185, 178, 179, 10950, 10942, 10968, 8839, 10948, 10185, 10967, 10619, 10946, 10956, 8843, 10944, 8835, 8839, 10950, 8843, 10956, 10952, 10964, 10966, 8665, 10534, 8601, 8601, 10538, 223, 8982, 964, 9140, 357, 355, 1090, 8411, 8981, 120113, 8756, 8756, 952, 977, 977, 8776, 8764, 8201, 8776, 8764, 254, 732, 215, 8864, 10801, 10800, 8749, 10536, 8868, 9014, 10993, 120165, 10970, 10537, 8244, 8482, 9653, 9663, 9667, 8884, 8796, 9657, 8885, 9708, 8796, 10810, 10809, 10701, 10811, 9186, 120009, 1094, 1115, 359, 8812, 8606, 8608, 8657, 10595, 250, 8593, 1118, 365, 251, 1091, 8645, 369, 10606, 10622, 120114, 249, 8639, 8638, 9600, 8988, 8988, 8975, 9720, 363, 168, 371, 120166, 8593, 8597, 8639, 8638, 8846, 965, 978, 965, 8648, 8989, 8989, 8974, 367, 9721, 120010, 8944, 361, 9653, 9652, 8648, 252, 10663, 8661, 10984, 10985, 8872, 10652, 1013, 1008, 8709, 981, 982, 8733, 8597, 1009, 962, 884, 5024, 1095, 5024, 884, 5024, 1095, 5024, 977, 8882, 8883, 1074, 8866, 8744, 8891, 8794, 8942, 124, 124, 120115, 8882, 883, 402, 883, 402, 120167, 8733, 8883, 120011, 1095, 5024, 884, 5024, 1095, 5024, 884, 5024, 10650, 373, 10847, 8743, 8793, 8472, 120116, 120168, 8472, 8768, 8768, 120012, 8898, 9711, 8899, 9661, 120117, 10234, 10231, 958, 10232, 10229, 10236, 8955, 10752, 120169, 10753, 10754, 10233, 10230, 120013, 10758, 10756, 9651, 8897, 8896, 253, 1103, 375, 1099, 165, 120118, 1111, 120170, 120014, 1102, 255, 378, 382, 1079, 380, 8488, 950, 120119, 1078, 8669, 120171, 120015, 8205, 8204}
var _html5entitiesCodePointsIndex  = "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x02\x02\x01\x02\x01\x02\x02\x01\x02\x01\x01\x01\x01\x02\x02\x01\x02\x02\x01\x02\x01\x01\x01\x02\x01\x02\x01\x02\x01\x02\x01\x01\x02\x01\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x01\x01\x02\x02\x02\x01\x01\x01\x01\x01\x02\x01\x02\x02\x01\x01\x01\x01\x01\x01\x02\x02\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x02\x01\x01\x01\x02\x01\x01\x02\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x02\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x01\x01\x01\x02\x01\x02\x01\x01\x02\x02\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x02\x02\x01\x01\x02\x02\x02\x01\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x01\x01\x01\x01\x02\x02\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01"
var _html5entitiesCharacters = [...]byte{0xc3, 0x86, 0x26, 0xc3, 0x81, 0xc3, 0x82, 0xd0, 0x90, 0xf0, 0x9d, 0x94, 0x84, 0xc3, 0x80, 0xce, 0x91, 0xc4, 0x80, 0xe2, 0xa9, 0x93, 0xc4, 0x84, 0xf0, 0x9d, 0x94, 0xb8, 0xe2, 0x81, 0xa1, 0xc3, 0x85, 0xf0, 0x9d, 0x92, 0x9c, 0xe2, 0x89, 0x94, 0xc3, 0x83, 0xc3, 0x84, 0xe2, 0x88, 0x96, 0xe2, 0xab, 0xa7, 0xe2, 0x8c, 0x86, 0xd0, 0x91, 0xe2, 0x88, 0xb5, 0xe2, 0x84, 0xac, 0xce, 0x92, 0xf0, 0x9d, 0x94, 0x85, 0xf0, 0x9d, 0x94, 0xb9, 0xcb, 0x98, 0xe2, 0x84, 0xac, 0xe2, 0x89, 0x8e, 0xd0, 0xa7, 0xc2, 0xa9, 0xc4, 0x86, 0xe2, 0x8b, 0x92, 0xe2, 0x85, 0x85, 0xe2, 0x84, 0xad, 0xc4, 0x8c, 0xc3, 0x87, 0xc4, 0x88, 0xe2, 0x88, 0xb0, 0xc4, 0x8a, 0xc2, 0xb8, 0xc2, 0xb7, 0xe2, 0x84, 0xad, 0xce, 0xa7, 0xe2, 0x8a, 0x99, 0xe2, 0x8a, 0x96, 0xe2, 0x8a, 0x95, 0xe2, 0x8a, 0x97, 0xe2, 0x88, 0xb2, 0xe2, 0x80, 0x9d, 0xe2, 0x80, 0x99, 0xe2, 0x88, 0xb7, 0xe2, 0xa9, 0xb4, 0xe2, 0x89, 0xa1, 0xe2, 0x88, 0xaf, 0xe2, 0x88, 0xae, 0xe2, 0x84, 0x82, 0xe2, 0x88, 0x90, 0xe2, 0x88, 0xb3, 0xe2, 0xa8, 0xaf, 0xf0, 0x9d, 0x92, 0x9e, 0xe2, 0x8b, 0x93, 0xe2, 0x89, 0x8d, 0xe2, 0x85, 0x85, 0xe2, 0xa4, 0x91, 0xd0, 0x82, 0xd0, 0x85, 0xd0, 0x8f, 0xe2, 0x80, 0xa1, 0xe2, 0x86, 0xa1, 0xe2, 0xab, 0xa4, 0xc4, 0x8e, 0xd0, 0x94, 0xe2, 0x88, 0x87, 0xce, 0x94, 0xf0, 0x9d, 0x94, 0x87, 0xc2, 0xb4, 0xcb, 0x99, 0xcb, 0x9d, 0x60, 0xcb, 0x9c, 0xe2, 0x8b, 0x84, 0xe2, 0x85, 0x86, 0xf0, 0x9d, 0x94, 0xbb, 0xc2, 0xa8, 0xe2, 0x83, 0x9c, 0xe2, 0x89, 0x90, 0xe2, 0x88, 0xaf, 0xc2, 0xa8, 0xe2, 0x87, 0x93, 0xe2, 0x87, 0x90, 0xe2, 0x87, 0x94, 0xe2, 0xab, 0xa4, 0xe2, 0x9f, 0xb8, 0xe2, 0x9f, 0xba, 0xe2, 0x9f, 0xb9, 0xe2, 0x87, 0x92, 0xe2, 0x8a, 0xa8, 0xe2, 0x87, 0x91, 0xe2, 0x87, 0x95, 0xe2, 0x88, 0xa5, 0xe2, 0x86, 0x93, 0xe2, 0xa4, 0x93, 0xe2, 0x87, 0xb5, 0xcc, 0x91, 0xe2, 0xa5, 0x90, 0xe2, 0xa5, 0x9e, 0xe2, 0x86, 0xbd, 0xe2, 0xa5, 0x96, 0xe2, 0xa5, 0x9f, 0xe2, 0x87, 0x81, 0xe2, 0xa5, 0x97, 0xe2, 0x8a, 0xa4, 0xe2, 0x86, 0xa7, 0xe2, 0x87, 0x93, 0xf0, 0x9d, 0x92, 0x9f, 0xc4, 0x90, 0xc5, 0x8a, 0xc3, 0x90, 0xc3, 0x89, 0xc4, 0x9a, 0xc3, 0x8a, 0xd0, 0xad, 0xc4, 0x96, 0xf0, 0x9d, 0x94, 0x88, 0xc3, 0x88, 0xe2, 0x88, 0x88, 0xc4, 0x92, 0xe2, 0x97, 0xbb, 0xe2, 0x96, 0xab, 0xc4, 0x98, 0xf0, 0x9d, 0x94, 0xbc, 0xce, 0x95, 0xe2, 0xa9, 0xb5, 0xe2, 0x89, 0x82, 0xe2, 0x87, 0x8c, 0xe2, 0x84, 0xb0, 0xe2, 0xa9, 0xb3, 0xce, 0x97, 0xc3, 0x8b, 0xe2, 0x88, 0x83, 0xe2, 0x85, 0x87, 0xd0, 0xa4, 0xf0, 0x9d, 0x94, 0x89, 0xe2, 0x97, 0xbc, 0xe2, 0x96, 0xaa, 0xf0, 0x9d, 0x94, 0xbd, 0xe2, 0x88, 0x80, 0xe2, 0x84, 0xb1, 0xe2, 0x84, 0xb1, 0xd0, 0x83, 0x3e, 0xce, 0x93, 0xcf, 0x9c, 0xc4, 0x9e, 0xc4, 0xa2, 0xc4, 0x9c, 0xd0, 0x93, 0xc4, 0xa0, 0xf0, 0x9d, 0x94, 0x8a, 0xe2, 0x8b, 0x99, 0xf0, 0x9d, 0x94, 0xbe, 0xe2, 0x89, 0xa5, 0xe2, 0x8b, 0x9b, 0xe2, 0x89, 0xa7, 0xe2, 0xaa, 0xa2, 0xe2, 0x89, 0xb7, 0xe2, 0xa9, 0xbe, 0xe2, 0x89, 0xb3, 0xf0, 0x9d, 0x92, 0xa2, 0xe2, 0x89, 0xab, 0xd0, 0xaa, 0xcb, 0x87, 0x5e, 0xc4, 0xa4, 0xe2, 0x84, 0x8c, 0xe2, 0x84, 0x8b, 0xe2, 0x84, 0x8d, 0xe2, 0x94, 0x80, 0xe2, 0x84, 0x8b, 0xc4, 0xa6, 0xe2, 0x89, 0x8e, 0xe2, 0x89, 0x8f, 0xd0, 0x95, 0xc4, 0xb2, 0xd0, 0x81, 0xc3, 0x8d, 0xc3, 0x8e, 0xd0, 0x98, 0xc4, 0xb0, 0xe2, 0x84, 0x91, 0xc3, 0x8c, 0xe2, 0x84, 0x91, 0xc4, 0xaa, 0xe2, 0x85, 0x88, 0xe2, 0x87, 0x92, 0xe2, 0x88, 0xac, 0xe2, 0x88, 0xab, 0xe2, 0x8b, 0x82, 0xe2, 0x81, 0xa3, 0xe2, 0x81, 0xa2, 0xc4, 0xae, 0xf0, 0x9d, 0x95, 0x80, 0xce, 0x99, 0xe2, 0x84, 0x90, 0xc4, 0xa8, 0xd0, 0x86, 0xc3, 0x8f, 0xc4, 0xb4, 0xd0, 0x99, 0xf0, 0x9d, 0x94, 0x8d, 0xf0, 0x9d, 0x95, 0x81, 0xf0, 0x9d, 0x92, 0xa5, 0xd0, 0x88, 0xd0, 0x84, 0xd0, 0xa5, 0xd0, 0x8c, 0xce, 0x9a, 0xc4, 0xb6, 0xd0, 0x9a, 0xf0, 0x9d, 0x94, 0x8e, 0xf0, 0x9d, 0x95, 0x82, 0xf0, 0x9d, 0x92, 0xa6, 0xd0, 0x89, 0x3c, 0xc4, 0xb9, 0xce, 0x9b, 0xe2, 0x9f, 0xaa, 0xe2, 0x84, 0x92, 0xe2, 0x86, 0x9e, 0xc4, 0xbd, 0xc4, 0xbb, 0xd0, 0x9b, 0xe2, 0x9f, 0xa8, 0xe2, 0x86, 0x90, 0xe2, 0x87, 0xa4, 0xe2, 0x87, 0x86, 0xe2, 0x8c, 0x88, 0xe2, 0x9f, 0xa6, 0xe2, 0xa5, 0xa1, 0xe2, 0x87, 0x83, 0xe2, 0xa5, 0x99, 0xe2, 0x8c, 0x8a, 0xe2, 0x86, 0x94, 0xe2, 0xa5, 0x8e, 0xe2, 0x8a, 0xa3, 0xe2, 0x86, 0xa4, 0xe2, 0xa5, 0x9a, 0xe2, 0x8a, 0xb2, 0xe2, 0xa7, 0x8f, 0xe2, 0x8a, 0xb4, 0xe2, 0xa5, 0x91, 0xe2, 0xa5, 0xa0, 0xe2, 0x86, 0xbf, 0xe2, 0xa5, 0x98, 0xe2, 0x86, 0xbc, 0xe2, 0xa5, 0x92, 0xe2, 0x87, 0x90, 0xe2, 0x87, 0x94, 0xe2, 0x8b, 0x9a, 0xe2, 0x89, 0xa6, 0xe2, 0x89, 0xb6, 0xe2, 0xaa, 0xa1, 0xe2, 0xa9, 0xbd, 0xe2, 0x89, 0xb2, 0xf0, 0x9d, 0x94, 0x8f, 0xe2, 0x8b, 0x98, 0xe2, 0x87, 0x9a, 0xc4, 0xbf, 0xe2, 0x9f, 0xb5, 0xe2, 0x9f, 0xb7, 0xe2, 0x9f, 0xb6, 0xe2, 0x9f, 0xb8, 0xe2, 0x9f, 0xba, 0xe2, 0x9f, 0xb9, 0xf0, 0x9d, 0x95, 0x83, 0xe2, 0x86, 0x99, 0xe2, 0x86, 0x98, 0xe2, 0x84, 0x92, 0xe2, 0x86, 0xb0, 0xc5, 0x81, 0xe2, 0x89, 0xaa, 0xe2, 0xa4, 0x85, 0xd0, 0x9c, 0xe2, 0x81, 0x9f, 0xe2, 0x84, 0xb3, 0xf0, 0x9d, 0x94, 0x90, 0xe2, 0x88, 0x93, 0xf0, 0x9d, 0x95, 0x84, 0xe2, 0x84, 0xb3, 0xce, 0x9c, 0xd0, 0x8a, 0xc5, 0x83, 0xc5, 0x87, 0xc5, 0x85, 0xd0, 0x9d, 0xe2, 0x80, 0x8b, 0xe2, 0x80, 0x8b, 0xe2, 0x80, 0x8b, 0xe2, 0x80, 0x8b, 0xe2, 0x89, 0xab, 0xe2, 0x89, 0xaa, 0xa, 0xf0, 0x9d, 0x94, 0x91, 0xe2, 0x81, 0xa0, 0xc2, 0xa0, 0xe2, 0x84, 0x95, 0xe2, 0xab, 0xac, 0xe2, 0x89, 0xa2, 0xe2, 0x89, 0xad, 0xe2, 0x88, 0xa6, 0xe2, 0x88, 0x89, 0xe2, 0x89, 0xa0, 0xe2, 0x89, 0x82, 0xcc, 0xb8, 0xe2, 0x88, 0x84, 0xe2, 0x89, 0xaf, 0xe2, 0x89, 0xb1, 0xe2, 0x89, 0xa7, 0xcc, 0xb8, 0xe2, 0x89, 0xab, 0xcc, 0xb8, 0xe2, 0x89, 0xb9, 0xe2, 0xa9, 0xbe, 0xcc, 0xb8, 0xe2, 0x89, 0xb5, 0xe2, 0x89, 0x8e, 0xcc, 0xb8, 0xe2, 0x89, 0x8f, 0xcc, 0xb8, 0xe2, 0x8b, 0xaa, 0xe2, 0xa7, 0x8f, 0xcc, 0xb8, 0xe2, 0x8b, 0xac, 0xe2, 0x89, 0xae, 0xe2, 0x89, 0xb0, 0xe2, 0x89, 0xb8, 0xe2, 0x89, 0xaa, 0xcc, 0xb8, 0xe2, 0xa9, 0xbd, 0xcc, 0xb8, 0xe2, 0x89, 0xb4, 0xe2, 0xaa, 0xa2, 0xcc, 0xb8, 0xe2, 0xaa, 0xa1, 0xcc, 0xb8, 0xe2, 0x8a, 0x80, 0xe2, 0xaa, 0xaf, 0xcc, 0xb8, 0xe2, 0x8b, 0xa0, 0xe2, 0x88, 0x8c, 0xe2, 0x8b, 0xab, 0xe2, 0xa7, 0x90, 0xcc, 0xb8, 0xe2, 0x8b, 0xad, 0xe2, 0x8a, 0x8f, 0xcc, 0xb8, 0xe2, 0x8b, 0xa2, 0xe2, 0x8a, 0x90, 0xcc, 0xb8, 0xe2, 0x8b, 0xa3, 0xe2, 0x8a, 0x82, 0xe2, 0x83, 0x92, 0xe2, 0x8a, 0x88, 0xe2, 0x8a, 0x81, 0xe2, 0xaa, 0xb0, 0xcc, 0xb8, 0xe2, 0x8b, 0xa1, 0xe2, 0x89, 0xbf, 0xcc, 0xb8, 0xe2, 0x8a, 0x83, 0xe2, 0x83, 0x92, 0xe2, 0x8a, 0x89, 0xe2, 0x89, 0x81, 0xe2, 0x89, 0x84, 0xe2, 0x89, 0x87, 0xe2, 0x89, 0x89, 0xe2, 0x88, 0xa4, 0xf0, 0x9d, 0x92, 0xa9, 0xc3, 0x91, 0xce, 0x9d, 0xc5, 0x92, 0xc3, 0x93, 0xc3, 0x94, 0xd0, 0x9e, 0xc5, 0x90, 0xf0, 0x9d, 0x94, 0x92, 0xc3, 0x92, 0xc5, 0x8c, 0xce, 0xa9, 0xce, 0x9f, 0xf0, 0x9d, 0x95, 0x86, 0xe2, 0x80, 0x9c, 0xe2, 0x80, 0x98, 0xe2, 0xa9, 0x94, 0xf0, 0x9d, 0x92, 0xaa, 0xc3, 0x98, 0xc3, 0x95, 0xe2, 0xa8, 0xb7, 0xc3, 0x96, 0xe2, 0x80, 0xbe, 0xe2, 0x8f, 0x9e, 0xe2, 0x8e, 0xb4, 0xe2, 0x8f, 0x9c, 0xe2, 0x88, 0x82, 0xd0, 0x9f, 0xf0, 0x9d, 0x94, 0x93, 0xce, 0xa6, 0xce, 0xa0, 0xc2, 0xb1, 0xe2, 0x84, 0x8c, 0xe2, 0x84, 0x99, 0xe2, 0xaa, 0xbb, 0xe2, 0x89, 0xba, 0xe2, 0xaa, 0xaf, 0xe2, 0x89, 0xbc, 0xe2, 0x89, 0xbe, 0xe2, 0x80, 0xb3, 0xe2, 0x88, 0x8f, 0xe2, 0x88, 0xb7, 0xe2, 0x88, 0x9d, 0xf0, 0x9d, 0x92, 0xab, 0xce, 0xa8, 0x22, 0xf0, 0x9d, 0x94, 0x94, 0xe2, 0x84, 0x9a, 0xf0, 0x9d, 0x92, 0xac, 0xe2, 0xa4, 0x90, 0xc2, 0xae, 0xc5, 0x94, 0xe2, 0x9f, 0xab, 0xe2, 0x86, 0xa0, 0xe2, 0xa4, 0x96, 0xc5, 0x98, 0xc5, 0x96, 0xd0, 0xa0, 0xe2, 0x84, 0x9c, 0xe2, 0x88, 0x8b, 0xe2, 0x87, 0x8b, 0xe2, 0xa5, 0xaf, 0xe2, 0x84, 0x9c, 0xce, 0xa1, 0xe2, 0x9f, 0xa9, 0xe2, 0x86, 0x92, 0xe2, 0x87, 0xa5, 0xe2, 0x87, 0x84, 0xe2, 0x8c, 0x89, 0xe2, 0x9f, 0xa7, 0xe2, 0xa5, 0x9d, 0xe2, 0x87, 0x82, 0xe2, 0xa5, 0x95, 0xe2, 0x8c, 0x8b, 0xe2, 0x8a, 0xa2, 0xe2, 0x86, 0xa6, 0xe2, 0xa5, 0x9b, 0xe2, 0x8a, 0xb3, 0xe2, 0xa7, 0x90, 0xe2, 0x8a, 0xb5, 0xe2, 0xa5, 0x8f, 0xe2, 0xa5, 0x9c, 0xe2, 0x86, 0xbe, 0xe2, 0xa5, 0x94, 0xe2, 0x87, 0x80, 0xe2, 0xa5, 0x93, 0xe2, 0x87, 0x92, 0xe2, 0x84, 0x9d, 0xe2, 0xa5, 0xb0, 0xe2, 0x87, 0x9b, 0xe2, 0x84, 0x9b, 0xe2, 0x86, 0xb1, 0xe2, 0xa7, 0xb4, 0xd0, 0xa9, 0xd0, 0xa8, 0xd0, 0xac, 0xc5, 0x9a, 0xe2, 0xaa, 0xbc, 0xc5, 0xa0, 0xc5, 0x9e, 0xc5, 0x9c, 0xd0, 0xa1, 0xf0, 0x9d, 0x94, 0x96, 0xe2, 0x86, 0x93, 0xe2, 0x86, 0x90, 0xe2, 0x86, 0x92, 0xe2, 0x86, 0x91, 0xce, 0xa3, 0xe2, 0x88, 0x98, 0xf0, 0x9d, 0x95, 0x8a, 0xe2, 0x88, 0x9a, 0xe2, 0x96, 0xa1, 0xe2, 0x8a, 0x93, 0xe2, 0x8a, 0x8f, 0xe2, 0x8a, 0x91, 0xe2, 0x8a, 0x90, 0xe2, 0x8a, 0x92, 0xe2, 0x8a, 0x94, 0xf0, 0x9d, 0x92, 0xae, 0xe2, 0x8b, 0x86, 0xe2, 0x8b, 0x90, 0xe2, 0x8b, 0x90, 0xe2, 0x8a, 0x86, 0xe2, 0x89, 0xbb, 0xe2, 0xaa, 0xb0, 0xe2, 0x89, 0xbd, 0xe2, 0x89, 0xbf, 0xe2, 0x88, 0x8b, 0xe2, 0x88, 0x91, 0xe2, 0x8b, 0x91, 0xe2, 0x8a, 0x83, 0xe2, 0x8a, 0x87, 0xe2, 0x8b, 0x91, 0xc3, 0x9e, 0xe2, 0x84, 0xa2, 0xd0, 0x8b, 0xd0, 0xa6, 0x9, 0xce, 0xa4, 0xc5, 0xa4, 0xc5, 0xa2, 0xd0, 0xa2, 0xf0, 0x9d, 0x94, 0x97, 0xe2, 0x88, 0xb4, 0xce, 0x98, 0xe2, 0x81, 0x9f, 0xe2, 0x80, 0x8a, 0xe2, 0x80, 0x89, 0xe2, 0x88, 0xbc, 0xe2, 0x89, 0x83, 0xe2, 0x89, 0x85, 0xe2, 0x89, 0x88, 0xf0, 0x9d, 0x95, 0x8b, 0xe2, 0x83, 0x9b, 0xf0, 0x9d, 0x92, 0xaf, 0xc5, 0xa6, 0xc3, 0x9a, 0xe2, 0x86, 0x9f, 0xe2, 0xa5, 0x89, 0xd0, 0x8e, 0xc5, 0xac, 0xc3, 0x9b, 0xd0, 0xa3, 0xc5, 0xb0, 0xf0, 0x9d, 0x94, 0x98, 0xc3, 0x99, 0xc5, 0xaa, 0x5f, 0xe2, 0x8f, 0x9f, 0xe2, 0x8e, 0xb5, 0xe2, 0x8f, 0x9d, 0xe2, 0x8b, 0x83, 0xe2, 0x8a, 0x8e, 0xc5, 0xb2, 0xf0, 0x9d, 0x95, 0x8c, 0xe2, 0x86, 0x91, 0xe2, 0xa4, 0x92, 0xe2, 0x87, 0x85, 0xe2, 0x86, 0x95, 0xe2, 0xa5, 0xae, 0xe2, 0x8a, 0xa5, 0xe2, 0x86, 0xa5, 0xe2, 0x87, 0x91, 0xe2, 0x87, 0x95, 0xe2, 0x86, 0x96, 0xe2, 0x86, 0x97, 0xcf, 0x92, 0xce, 0xa5, 0xc5, 0xae, 0xf0, 0x9d, 0x92, 0xb0, 0xc5, 0xa8, 0xc3, 0x9c, 0xe2, 0x8a, 0xab, 0xe2, 0xab, 0xab, 0xd0, 0x92, 0xe2, 0x8a, 0xa9, 0xe2, 0xab, 0xa6, 0xe2, 0x8b, 0x81, 0xe2, 0x80, 0x96, 0xe2, 0x80, 0x96, 0xe2, 0x88, 0xa3, 0x7c, 0xe2, 0x9d, 0x98, 0xe2, 0x89, 0x80, 0xe2, 0x80, 0x8a, 0xf0, 0x9d, 0x94, 0x99, 0xf0, 0x9d, 0x95, 0x8d, 0xf0, 0x9d, 0x92, 0xb1, 0xe2, 0x8a, 0xaa, 0xc5, 0xb4, 0xe2, 0x8b, 0x80, 0xf0, 0x9d, 0x94, 0x9a, 0xf0, 0x9d, 0x95, 0x8e, 0xf0, 0x9d, 0x92, 0xb2, 0xf0, 0x9d, 0x94, 0x9b, 0xce, 0x9e, 0xf0, 0x9d, 0x95, 0x8f, 0xf0, 0x9d, 0x92, 0xb3, 0xd0, 0xaf, 0xd0, 0x87, 0xd0, 0xae, 0xc3, 0x9d, 0xc5, 0xb6, 0xd0, 0xab, 0xf0, 0x9d, 0x94, 0x9c, 0xf0, 0x9d, 0x95, 0x90, 0xf0, 0x9d, 0x92, 0xb4, 0xc5, 0xb8, 0xd0, 0x96, 0xc5, 0xb9, 0xc5, 0xbd, 0xd0, 0x97, 0xc5, 0xbb, 0xe2, 0x80, 0x8b, 0xce, 0x96, 0xe2, 0x84, 0xa8, 0xe2, 0x84, 0xa4, 0xf0, 0x9d, 0x92, 0xb5, 0xc3, 0xa1, 0xc4, 0x83, 0xe2, 0x88, 0xbe, 0xe2, 0x88, 0xbe, 0xcc, 0xb3, 0xe2, 0x88, 0xbf, 0xc3, 0xa2, 0xc2, 0xb4, 0xd0, 0xb0, 0xc3, 0xa6, 0xe2, 0x81, 0xa1, 0xf0, 0x9d, 0x94, 0x9e, 0xc3, 0xa0, 0xe2, 0x84, 0xb5, 0xe2, 0x84, 0xb5, 0xce, 0xb1, 0xc4, 0x81, 0xe2, 0xa8, 0xbf, 0x26, 0xe2, 0x88, 0xa7, 0xe2, 0xa9, 0x95, 0xe2, 0xa9, 0x9c, 0xe2, 0xa9, 0x98, 0xe2, 0xa9, 0x9a, 0xe2, 0x88, 0xa0, 0xe2, 0xa6, 0xa4, 0xe2, 0x88, 0xa0, 0xe2, 0x88, 0xa1, 0xe2, 0xa6, 0xa8, 0xe2, 0xa6, 0xa9, 0xe2, 0xa6, 0xaa, 0xe2, 0xa6, 0xab, 0xe2, 0xa6, 0xac, 0xe2, 0xa6, 0xad, 0xe2, 0xa6, 0xae, 0xe2, 0xa6, 0xaf, 0xe2, 0x88, 0x9f, 0xe2, 0x8a, 0xbe, 0xe2, 0xa6, 0x9d, 0xe2, 0x88, 0xa2, 0xc3, 0x85, 0xe2, 0x8d, 0xbc, 0xc4, 0x85, 0xf0, 0x9d, 0x95, 0x92, 0xe2, 0x89, 0x88, 0xe2, 0xa9, 0xb0, 0xe2, 0xa9, 0xaf, 0xe2, 0x89, 0x8a, 0xe2, 0x89, 0x8b, 0x27, 0xe2, 0x89, 0x88, 0xe2, 0x89, 0x8a, 0xc3, 0xa5, 0xf0, 0x9d, 0x92, 0xb6, 0x2a, 0xe2, 0x89, 0x88, 0xe2, 0x89, 0x8d, 0xc3, 0xa3, 0xc3, 0xa4, 0xe2, 0x88, 0xb3, 0xe2, 0xa8, 0x91, 0xe2, 0xab, 0xad, 0xe2, 0x89, 0x8c, 0xcf, 0xb6, 0xe2, 0x80, 0xb5, 0xe2, 0x88, 0xbd, 0xe2, 0x8b, 0x8d, 0xe2, 0x8a, 0xbd, 0xe2, 0x8c, 0x85, 0xe2, 0x8c, 0x85, 0xe2, 0x8e, 0xb5, 0xe2, 0x8e, 0xb6, 0xe2, 0x89, 0x8c, 0xd0, 0xb1, 0xe2, 0x80, 0x9e, 0xe2, 0x88, 0xb5, 0xe2, 0x88, 0xb5, 0xe2, 0xa6, 0xb0, 0xcf, 0xb6, 0xe2, 0x84, 0xac, 0xce, 0xb2, 0xe2, 0x84, 0xb6, 0xe2, 0x89, 0xac, 0xf0, 0x9d, 0x94, 0x9f, 0xe2, 0x8b, 0x82, 0xe2, 0x97, 0xaf, 0xe2, 0x8b, 0x83, 0xe2, 0xa8, 0x80, 0xe2, 0xa8, 0x81, 0xe2, 0xa8, 0x82, 0xe2, 0xa8, 0x86, 0xe2, 0x98, 0x85, 0xe2, 0x96, 0xbd, 0xe2, 0x96, 0xb3, 0xe2, 0xa8, 0x84, 0xe2, 0x8b, 0x81, 0xe2, 0x8b, 0x80, 0xe2, 0xa4, 0x8d, 0xe2, 0xa7, 0xab, 0xe2, 0x96, 0xaa, 0xe2, 0x96, 0xb4, 0xe2, 0x96, 0xbe, 0xe2, 0x97, 0x82, 0xe2, 0x96, 0xb8, 0xe2, 0x90, 0xa3, 0xe2, 0x96, 0x92, 0xe2, 0x96, 0x91, 0xe2, 0x96, 0x93, 0xe2, 0x96, 0x88, 0x3d, 0xe2, 0x83, 0xa5, 0xe2, 0x89, 0xa1, 0xe2, 0x83, 0xa5, 0xe2, 0x8c, 0x90, 0xf0, 0x9d, 0x95, 0x93, 0xe2, 0x8a, 0xa5, 0xe2, 0x8a, 0xa5, 0xe2, 0x8b, 0x88, 0xe2, 0x95, 0x97, 0xe2, 0x95, 0x94, 0xe2, 0x95, 0x96, 0xe2, 0x95, 0x93, 0xe2, 0x95, 0x90, 0xe2, 0x95, 0xa6, 0xe2, 0x95, 0xa9, 0xe2, 0x95, 0xa4, 0xe2, 0x95, 0xa7, 0xe2, 0x95, 0x9d, 0xe2, 0x95, 0x9a, 0xe2, 0x95, 0x9c, 0xe2, 0x95, 0x99, 0xe2, 0x95, 0x91, 0xe2, 0x95, 0xac, 0xe2, 0x95, 0xa3, 0xe2, 0x95, 0xa0, 0xe2, 0x95, 0xab, 0xe2, 0x95, 0xa2, 0xe2, 0x95, 0x9f, 0xe2, 0xa7, 0x89, 0xe2, 0x95, 0x95, 0xe2, 0x95, 0x92, 0xe2, 0x94, 0x90, 0xe2, 0x94, 0x8c, 0xe2, 0x94, 0x80, 0xe2, 0x95, 0xa5, 0xe2, 0x95, 0xa8, 0xe2, 0x94, 0xac, 0xe2, 0x94, 0xb4, 0xe2, 0x8a, 0x9f, 0xe2, 0x8a, 0x9e, 0xe2, 0x8a, 0xa0, 0xe2, 0x95, 0x9b, 0xe2, 0x95, 0x98, 0xe2, 0x94, 0x98, 0xe2, 0x94, 0x94, 0xe2, 0x94, 0x82, 0xe2, 0x95, 0xaa, 0xe2, 0x95, 0xa1, 0xe2, 0x95, 0x9e, 0xe2, 0x94, 0xbc, 0xe2, 0x94, 0xa4, 0xe2, 0x94, 0x9c, 0xe2, 0x80, 0xb5, 0xcb, 0x98, 0xc2, 0xa6, 0xf0, 0x9d, 0x92, 0xb7, 0xe2, 0x81, 0x8f, 0xe2, 0x88, 0xbd, 0xe2, 0x8b, 0x8d, 0x5c, 0xe2, 0xa7, 0x85, 0xe2, 0x9f, 0x88, 0xe2, 0x80, 0xa2, 0xe2, 0x80, 0xa2, 0xe2, 0x89, 0x8e, 0xe2, 0xaa, 0xae, 0xe2, 0x89, 0x8f, 0xe2, 0x89, 0x8f, 0xc4, 0x87, 0xe2, 0x88, 0xa9, 0xe2, 0xa9, 0x84, 0xe2, 0xa9, 0x89, 0xe2, 0xa9, 0x8b, 0xe2, 0xa9, 0x87, 0xe2, 0xa9, 0x80, 0xe2, 0x88, 0xa9, 0xef, 0xb8, 0x80, 0xe2, 0x81, 0x81, 0xcb, 0x87, 0xe2, 0xa9, 0x8d, 0xc4, 0x8d, 0xc3, 0xa7, 0xc4, 0x89, 0xe2, 0xa9, 0x8c, 0xe2, 0xa9, 0x90, 0xc4, 0x8b, 0xc2, 0xb8, 0xe2, 0xa6, 0xb2, 0xc2, 0xa2, 0xc2, 0xb7, 0xf0, 0x9d, 0x94, 0xa0, 0xd1, 0x87, 0xe2, 0x9c, 0x93, 0xe2, 0x9c, 0x93, 0xcf, 0x87, 0xe2, 0x97, 0x8b, 0xe2, 0xa7, 0x83, 0xcb, 0x86, 0xe2, 0x89, 0x97, 0xe2, 0x86, 0xba, 0xe2, 0x86, 0xbb, 0xc2, 0xae, 0xe2, 0x93, 0x88, 0xe2, 0x8a, 0x9b, 0xe2, 0x8a, 0x9a, 0xe2, 0x8a, 0x9d, 0xe2, 0x89, 0x97, 0xe2, 0xa8, 0x90, 0xe2, 0xab, 0xaf, 0xe2, 0xa7, 0x82, 0xe2, 0x99, 0xa3, 0xe2, 0x99, 0xa3, 0x3a, 0xe2, 0x89, 0x94, 0xe2, 0x89, 0x94, 0x2c, 0x40, 0xe2, 0x88, 0x81, 0xe2, 0x88, 0x98, 0xe2, 0x88, 0x81, 0xe2, 0x84, 0x82, 0xe2, 0x89, 0x85, 0xe2, 0xa9, 0xad, 0xe2, 0x88, 0xae, 0xf0, 0x9d, 0x95, 0x94, 0xe2, 0x88, 0x90, 0xc2, 0xa9, 0xe2, 0x84, 0x97, 0xe2, 0x86, 0xb5, 0xe2, 0x9c, 0x97, 0xf0, 0x9d, 0x92, 0xb8, 0xe2, 0xab, 0x8f, 0xe2, 0xab, 0x91, 0xe2, 0xab, 0x90, 0xe2, 0xab, 0x92, 0xe2, 0x8b, 0xaf, 0xe2, 0xa4, 0xb8, 0xe2, 0xa4, 0xb5, 0xe2, 0x8b, 0x9e, 0xe2, 0x8b, 0x9f, 0xe2, 0x86, 0xb6, 0xe2, 0xa4, 0xbd, 0xe2, 0x88, 0xaa, 0xe2, 0xa9, 0x88, 0xe2, 0xa9, 0x86, 0xe2, 0xa9, 0x8a, 0xe2, 0x8a, 0x8d, 0xe2, 0xa9, 0x85, 0xe2, 0x88, 0xaa, 0xef, 0xb8, 0x80, 0xe2, 0x86, 0xb7, 0xe2, 0xa4, 0xbc, 0xe2, 0x8b, 0x9e, 0xe2, 0x8b, 0x9f, 0xe2, 0x8b, 0x8e, 0xe2, 0x8b, 0x8f, 0xc2, 0xa4, 0xe2, 0x86, 0xb6, 0xe2, 0x86, 0xb7, 0xe2, 0x8b, 0x8e, 0xe2, 0x8b, 0x8f, 0xe2, 0x88, 0xb2, 0xe2, 0x88, 0xb1, 0xe2, 0x8c, 0xad, 0xe2, 0x87, 0x93, 0xe2, 0xa5, 0xa5, 0xe2, 0x80, 0xa0, 0xe2, 0x84, 0xb8, 0xe2, 0x86, 0x93, 0xe2, 0x80, 0x90, 0xe2, 0x8a, 0xa3, 0xe2, 0xa4, 0x8f, 0xcb, 0x9d, 0xc4, 0x8f, 0xd0, 0xb4, 0xe2, 0x85, 0x86, 0xe2, 0x80, 0xa1, 0xe2, 0x87, 0x8a, 0xe2, 0xa9, 0xb7, 0xc2, 0xb0, 0xce, 0xb4, 0xe2, 0xa6, 0xb1, 0xe2, 0xa5, 0xbf, 0xf0, 0x9d, 0x94, 0xa1, 0xe2, 0x87, 0x83, 0xe2, 0x87, 0x82, 0xe2, 0x8b, 0x84, 0xe2, 0x8b, 0x84, 0xe2, 0x99, 0xa6, 0xe2, 0x99, 0xa6, 0xc2, 0xa8, 0xcf, 0x9d, 0xe2, 0x8b, 0xb2, 0xc3, 0xb7, 0xc3, 0xb7, 0xe2, 0x8b, 0x87, 0xe2, 0x8b, 0x87, 0xd1, 0x92, 0xe2, 0x8c, 0x9e, 0xe2, 0x8c, 0x8d, 0x24, 0xf0, 0x9d, 0x95, 0x95, 0xcb, 0x99, 0xe2, 0x89, 0x90, 0xe2, 0x89, 0x91, 0xe2, 0x88, 0xb8, 0xe2, 0x88, 0x94, 0xe2, 0x8a, 0xa1, 0xe2, 0x8c, 0x86, 0xe2, 0x86, 0x93, 0xe2, 0x87, 0x8a, 0xe2, 0x87, 0x83, 0xe2, 0x87, 0x82, 0xe2, 0xa4, 0x90, 0xe2, 0x8c, 0x9f, 0xe2, 0x8c, 0x8c, 0xf0, 0x9d, 0x92, 0xb9, 0xd1, 0x95, 0xe2, 0xa7, 0xb6, 0xc4, 0x91, 0xe2, 0x8b, 0xb1, 0xe2, 0x96, 0xbf, 0xe2, 0x96, 0xbe, 0xe2, 0x87, 0xb5, 0xe2, 0xa5, 0xaf, 0xe2, 0xa6, 0xa6, 0xd1, 0x9f, 0xe2, 0x9f, 0xbf, 0xe2, 0xa9, 0xb7, 0xe2, 0x89, 0x91, 0xc3, 0xa9, 0xe2, 0xa9, 0xae, 0xc4, 0x9b, 0xe2, 0x89, 0x96, 0xc3, 0xaa, 0xe2, 0x89, 0x95, 0xd1, 0x8d, 0xc4, 0x97, 0xe2, 0x85, 0x87, 0xe2, 0x89, 0x92, 0xf0, 0x9d, 0x94, 0xa2, 0xe2, 0xaa, 0x9a, 0xc3, 0xa8, 0xe2, 0xaa, 0x96, 0xe2, 0xaa, 0x98, 0xe2, 0xaa, 0x99, 0xe2, 0x8f, 0xa7, 0xe2, 0x84, 0x93, 0xe2, 0xaa, 0x95, 0xe2, 0xaa, 0x97, 0xc4, 0x93, 0xe2, 0x88, 0x85, 0xe2, 0x88, 0x85, 0xe2, 0x88, 0x85, 0xe2, 0x80, 0x83, 0xe2, 0x80, 0x84, 0xe2, 0x80, 0x85, 0xc5, 0x8b, 0xe2, 0x80, 0x82, 0xc4, 0x99, 0xf0, 0x9d, 0x95, 0x96, 0xe2, 0x8b, 0x95, 0xe2, 0xa7, 0xa3, 0xe2, 0xa9, 0xb1, 0xce, 0xb5, 0xce, 0xb5, 0xcf, 0xb5, 0xe2, 0x89, 0x96, 0xe2, 0x89, 0x95, 0xe2, 0x89, 0x82, 0xe2, 0xaa, 0x96, 0xe2, 0xaa, 0x95, 0x3d, 0xe2, 0x89, 0x9f, 0xe2, 0x89, 0xa1, 0xe2, 0xa9, 0xb8, 0xe2, 0xa7, 0xa5, 0xe2, 0x89, 0x93, 0xe2, 0xa5, 0xb1, 0xe2, 0x84, 0xaf, 0xe2, 0x89, 0x90, 0xe2, 0x89, 0x82, 0xce, 0xb7, 0xc3, 0xb0, 0xc3, 0xab, 0xe2, 0x82, 0xac, 0x21, 0xe2, 0x88, 0x83, 0xe2, 0x84, 0xb0, 0xe2, 0x85, 0x87, 0xe2, 0x89, 0x92, 0xd1, 0x84, 0xe2, 0x99, 0x80, 0xef, 0xac, 0x83, 0xef, 0xac, 0x80, 0xef, 0xac, 0x84, 0xf0, 0x9d, 0x94, 0xa3, 0xef, 0xac, 0x81, 0x66, 0x6a, 0xe2, 0x99, 0xad, 0xef, 0xac, 0x82, 0xe2, 0x96, 0xb1, 0xc6, 0x92, 0xf0, 0x9d, 0x95, 0x97, 0xe2, 0x88, 0x80, 0xe2, 0x8b, 0x94, 0xe2, 0xab, 0x99, 0xe2, 0xa8, 0x8d, 0xc2, 0xbd, 0xe2, 0x85, 0x93, 0xc2, 0xbc, 0xe2, 0x85, 0x95, 0xe2, 0x85, 0x99, 0xe2, 0x85, 0x9b, 0xe2, 0x85, 0x94, 0xe2, 0x85, 0x96, 0xc2, 0xbe, 0xe2, 0x85, 0x97, 0xe2, 0x85, 0x9c, 0xe2, 0x85, 0x98, 0xe2, 0x85, 0x9a, 0xe2, 0x85, 0x9d, 0xe2, 0x85, 0x9e, 0xe2, 0x81, 0x84, 0xe2, 0x8c, 0xa2, 0xf0, 0x9d, 0x92, 0xbb, 0xe2, 0x89, 0xa7, 0xe2, 0xaa, 0x8c, 0xc7, 0xb5, 0xce, 0xb3, 0xcf, 0x9d, 0xe2, 0xaa, 0x86, 0xc4, 0x9f, 0xc4, 0x9d, 0xd0, 0xb3, 0xc4, 0xa1, 0xe2, 0x89, 0xa5, 0xe2, 0x8b, 0x9b, 0xe2, 0x89, 0xa5, 0xe2, 0x89, 0xa7, 0xe2, 0xa9, 0xbe, 0xe2, 0xa9, 0xbe, 0xe2, 0xaa, 0xa9, 0xe2, 0xaa, 0x80, 0xe2, 0xaa, 0x82, 0xe2, 0xaa, 0x84, 0xe2, 0x8b, 0x9b, 0xef, 0xb8, 0x80, 0xe2, 0xaa, 0x94, 0xf0, 0x9d, 0x94, 0xa4, 0xe2, 0x89, 0xab, 0xe2, 0x8b, 0x99, 0xe2, 0x84, 0xb7, 0xd1, 0x93, 0xe2, 0x89, 0xb7, 0xe2, 0xaa, 0x92, 0xe2, 0xaa, 0xa5, 0xe2, 0xaa, 0xa4, 0xe2, 0x89, 0xa9, 0xe2, 0xaa, 0x8a, 0xe2, 0xaa, 0x8a, 0xe2, 0xaa, 0x88, 0xe2, 0xaa, 0x88, 0xe2, 0x89, 0xa9, 0xe2, 0x8b, 0xa7, 0xf0, 0x9d, 0x95, 0x98, 0x60, 0xe2, 0x84, 0x8a, 0xe2, 0x89, 0xb3, 0xe2, 0xaa, 0x8e, 0xe2, 0xaa, 0x90, 0x3e, 0xe2, 0xaa, 0xa7, 0xe2, 0xa9, 0xba, 0xe2, 0x8b, 0x97, 0xe2, 0xa6, 0x95, 0xe2, 0xa9, 0xbc, 0xe2, 0xaa, 0x86, 0xe2, 0xa5, 0xb8, 0xe2, 0x8b, 0x97, 0xe2, 0x8b, 0x9b, 0xe2, 0xaa, 0x8c, 0xe2, 0x89, 0xb7, 0xe2, 0x89, 0xb3, 0xe2, 0x89, 0xa9, 0xef, 0xb8, 0x80, 0xe2, 0x89, 0xa9, 0xef, 0xb8, 0x80, 0xe2, 0x87, 0x94, 0xe2, 0x80, 0x8a, 0xc2, 0xbd, 0xe2, 0x84, 0x8b, 0xd1, 0x8a, 0xe2, 0x86, 0x94, 0xe2, 0xa5, 0x88, 0xe2, 0x86, 0xad, 0xe2, 0x84, 0x8f, 0xc4, 0xa5, 0xe2, 0x99, 0xa5, 0xe2, 0x99, 0xa5, 0xe2, 0x80, 0xa6, 0xe2, 0x8a, 0xb9, 0xf0, 0x9d, 0x94, 0xa5, 0xe2, 0xa4, 0xa5, 0xe2, 0xa4, 0xa6, 0xe2, 0x87, 0xbf, 0xe2, 0x88, 0xbb, 0xe2, 0x86, 0xa9, 0xe2, 0x86, 0xaa, 0xf0, 0x9d, 0x95, 0x99, 0xe2, 0x80, 0x95, 0xf0, 0x9d, 0x92, 0xbd, 0xe2, 0x84, 0x8f, 0xc4, 0xa7, 0xe2, 0x81, 0x83, 0xe2, 0x80, 0x90, 0xc3, 0xad, 0xe2, 0x81, 0xa3, 0xc3, 0xae, 0xd0, 0xb8, 0xd0, 0xb5, 0xc2, 0xa1, 0xe2, 0x87, 0x94, 0xf0, 0x9d, 0x94, 0xa6, 0xc3, 0xac, 0xe2, 0x85, 0x88, 0xe2, 0xa8, 0x8c, 0xe2, 0x88, 0xad, 0xe2, 0xa7, 0x9c, 0xe2, 0x84, 0xa9, 0xc4, 0xb3, 0xc4, 0xab, 0xe2, 0x84, 0x91, 0xe2, 0x84, 0x90, 0xe2, 0x84, 0x91, 0xc4, 0xb1, 0xe2, 0x8a, 0xb7, 0xc6, 0xb5, 0xe2, 0x88, 0x88, 0xe2, 0x84, 0x85, 0xe2, 0x88, 0x9e, 0xe2, 0xa7, 0x9d, 0xc4, 0xb1, 0xe2, 0x88, 0xab, 0xe2, 0x8a, 0xba, 0xe2, 0x84, 0xa4, 0xe2, 0x8a, 0xba, 0xe2, 0xa8, 0x97, 0xe2, 0xa8, 0xbc, 0xd1, 0x91, 0xc4, 0xaf, 0xf0, 0x9d, 0x95, 0x9a, 0xce, 0xb9, 0xe2, 0xa8, 0xbc, 0xc2, 0xbf, 0xf0, 0x9d, 0x92, 0xbe, 0xe2, 0x88, 0x88, 0xe2, 0x8b, 0xb9, 0xe2, 0x8b, 0xb5, 0xe2, 0x8b, 0xb4, 0xe2, 0x8b, 0xb3, 0xe2, 0x88, 0x88, 0xe2, 0x81, 0xa2, 0xc4, 0xa9, 0xd1, 0x96, 0xc3, 0xaf, 0xc4, 0xb5, 0xd0, 0xb9, 0xf0, 0x9d, 0x94, 0xa7, 0xc8, 0xb7, 0xf0, 0x9d, 0x95, 0x9b, 0xf0, 0x9d, 0x92, 0xbf, 0xd1, 0x98, 0xd1, 0x94, 0xce, 0xba, 0xcf, 0xb0, 0xc4, 0xb7, 0xd0, 0xba, 0xf0, 0x9d, 0x94, 0xa8, 0xc4, 0xb8, 0xd1, 0x85, 0xd1, 0x9c, 0xf0, 0x9d, 0x95, 0x9c, 0xf0, 0x9d, 0x93, 0x80, 0xe2, 0x87, 0x9a, 0xe2, 0x87, 0x90, 0xe2, 0xa4, 0x9b, 0xe2, 0xa4, 0x8e, 0xe2, 0x89, 0xa6, 0xe2, 0xaa, 0x8b, 0xe2, 0xa5, 0xa2, 0xc4, 0xba, 0xe2, 0xa6, 0xb4, 0xe2, 0x84, 0x92, 0xce, 0xbb, 0xe2, 0x9f, 0xa8, 0xe2, 0xa6, 0x91, 0xe2, 0x9f, 0xa8, 0xe2, 0xaa, 0x85, 0xc2, 0xab, 0xe2, 0x86, 0x90, 0xe2, 0x87, 0xa4, 0xe2, 0xa4, 0x9f, 0xe2, 0xa4, 0x9d, 0xe2, 0x86, 0xa9, 0xe2, 0x86, 0xab, 0xe2, 0xa4, 0xb9, 0xe2, 0xa5, 0xb3, 0xe2, 0x86, 0xa2, 0xe2, 0xaa, 0xab, 0xe2, 0xa4, 0x99, 0xe2, 0xaa, 0xad, 0xe2, 0xaa, 0xad, 0xef, 0xb8, 0x80, 0xe2, 0xa4, 0x8c, 0xe2, 0x9d, 0xb2, 0x7b, 0x5b, 0xe2, 0xa6, 0x8b, 0xe2, 0xa6, 0x8f, 0xe2, 0xa6, 0x8d, 0xc4, 0xbe, 0xc4, 0xbc, 0xe2, 0x8c, 0x88, 0x7b, 0xd0, 0xbb, 0xe2, 0xa4, 0xb6, 0xe2, 0x80, 0x9c, 0xe2, 0x80, 0x9e, 0xe2, 0xa5, 0xa7, 0xe2, 0xa5, 0x8b, 0xe2, 0x86, 0xb2, 0xe2, 0x89, 0xa4, 0xe2, 0x86, 0x90, 0xe2, 0x86, 0xa2, 0xe2, 0x86, 0xbd, 0xe2, 0x86, 0xbc, 0xe2, 0x87, 0x87, 0xe2, 0x86, 0x94, 0xe2, 0x87, 0x86, 0xe2, 0x87, 0x8b, 0xe2, 0x86, 0xad, 0xe2, 0x8b, 0x8b, 0xe2, 0x8b, 0x9a, 0xe2, 0x89, 0xa4, 0xe2, 0x89, 0xa6, 0xe2, 0xa9, 0xbd, 0xe2, 0xa9, 0xbd, 0xe2, 0xaa, 0xa8, 0xe2, 0xa9, 0xbf, 0xe2, 0xaa, 0x81, 0xe2, 0xaa, 0x83, 0xe2, 0x8b, 0x9a, 0xef, 0xb8, 0x80, 0xe2, 0xaa, 0x93, 0xe2, 0xaa, 0x85, 0xe2, 0x8b, 0x96, 0xe2, 0x8b, 0x9a, 0xe2, 0xaa, 0x8b, 0xe2, 0x89, 0xb6, 0xe2, 0x89, 0xb2, 0xe2, 0xa5, 0xbc, 0xe2, 0x8c, 0x8a, 0xf0, 0x9d, 0x94, 0xa9, 0xe2, 0x89, 0xb6, 0xe2, 0xaa, 0x91, 0xe2, 0x86, 0xbd, 0xe2, 0x86, 0xbc, 0xe2, 0xa5, 0xaa, 0xe2, 0x96, 0x84, 0xd1, 0x99, 0xe2, 0x89, 0xaa, 0xe2, 0x87, 0x87, 0xe2, 0x8c, 0x9e, 0xe2, 0xa5, 0xab, 0xe2, 0x97, 0xba, 0xc5, 0x80, 0xe2, 0x8e, 0xb0, 0xe2, 0x8e, 0xb0, 0xe2, 0x89, 0xa8, 0xe2, 0xaa, 0x89, 0xe2, 0xaa, 0x89, 0xe2, 0xaa, 0x87, 0xe2, 0xaa, 0x87, 0xe2, 0x89, 0xa8, 0xe2, 0x8b, 0xa6, 0xe2, 0x9f, 0xac, 0xe2, 0x87, 0xbd, 0xe2, 0x9f, 0xa6, 0xe2, 0x9f, 0xb5, 0xe2, 0x9f, 0xb7, 0xe2, 0x9f, 0xbc, 0xe2, 0x9f, 0xb6, 0xe2, 0x86, 0xab, 0xe2, 0x86, 0xac, 0xe2, 0xa6, 0x85, 0xf0, 0x9d, 0x95, 0x9d, 0xe2, 0xa8, 0xad, 0xe2, 0xa8, 0xb4, 0xe2, 0x88, 0x97, 0x5f, 0xe2, 0x97, 0x8a, 0xe2, 0x97, 0x8a, 0xe2, 0xa7, 0xab, 0x28, 0xe2, 0xa6, 0x93, 0xe2, 0x87, 0x86, 0xe2, 0x8c, 0x9f, 0xe2, 0x87, 0x8b, 0xe2, 0xa5, 0xad, 0xe2, 0x80, 0x8e, 0xe2, 0x8a, 0xbf, 0xe2, 0x80, 0xb9, 0xf0, 0x9d, 0x93, 0x81, 0xe2, 0x86, 0xb0, 0xe2, 0x89, 0xb2, 0xe2, 0xaa, 0x8d, 0xe2, 0xaa, 0x8f, 0x5b, 0xe2, 0x80, 0x98, 0xe2, 0x80, 0x9a, 0xc5, 0x82, 0x3c, 0xe2, 0xaa, 0xa6, 0xe2, 0xa9, 0xb9, 0xe2, 0x8b, 0x96, 0xe2, 0x8b, 0x8b, 0xe2, 0x8b, 0x89, 0xe2, 0xa5, 0xb6, 0xe2, 0xa9, 0xbb, 0xe2, 0xa6, 0x96, 0xe2, 0x97, 0x83, 0xe2, 0x8a, 0xb4, 0xe2, 0x97, 0x82, 0xe2, 0xa5, 0x8a, 0xe2, 0xa5, 0xa6, 0xe2, 0x89, 0xa8, 0xef, 0xb8, 0x80, 0xe2, 0x89, 0xa8, 0xef, 0xb8, 0x80, 0xe2, 0x88, 0xba, 0xc2, 0xaf, 0xe2, 0x99, 0x82, 0xe2, 0x9c, 0xa0, 0xe2, 0x9c, 0xa0, 0xe2, 0x86, 0xa6, 0xe2, 0x86, 0xa6, 0xe2, 0x86, 0xa7, 0xe2, 0x86, 0xa4, 0xe2, 0x86, 0xa5, 0xe2, 0x96, 0xae, 0xe2, 0xa8, 0xa9, 0xd0, 0xbc, 0xe2, 0x80, 0x94, 0xe2, 0x88, 0xa1, 0xf0, 0x9d, 0x94, 0xaa, 0xe2, 0x84, 0xa7, 0xc2, 0xb5, 0xe2, 0x88, 0xa3, 0x2a, 0xe2, 0xab, 0xb0, 0xc2, 0xb7, 0xe2, 0x88, 0x92, 0xe2, 0x8a, 0x9f, 0xe2, 0x88, 0xb8, 0xe2, 0xa8, 0xaa, 0xe2, 0xab, 0x9b, 0xe2, 0x80, 0xa6, 0xe2, 0x88, 0x93, 0xe2, 0x8a, 0xa7, 0xf0, 0x9d, 0x95, 0x9e, 0xe2, 0x88, 0x93, 0xf0, 0x9d, 0x93, 0x82, 0xe2, 0x88, 0xbe, 0xce, 0xbc, 0xe2, 0x8a, 0xb8, 0xe2, 0x8a, 0xb8, 0xe2, 0x8b, 0x99, 0xcc, 0xb8, 0xe2, 0x89, 0xab, 0xe2, 0x83, 0x92, 0xe2, 0x89, 0xab, 0xcc, 0xb8, 0xe2, 0x87, 0x8d, 0xe2, 0x87, 0x8e, 0xe2, 0x8b, 0x98, 0xcc, 0xb8, 0xe2, 0x89, 0xaa, 0xe2, 0x83, 0x92, 0xe2, 0x89, 0xaa, 0xcc, 0xb8, 0xe2, 0x87, 0x8f, 0xe2, 0x8a, 0xaf, 0xe2, 0x8a, 0xae, 0xe2, 0x88, 0x87, 0xc5, 0x84, 0xe2, 0x88, 0xa0, 0xe2, 0x83, 0x92, 0xe2, 0x89, 0x89, 0xe2, 0xa9, 0xb0, 0xcc, 0xb8, 0xe2, 0x89, 0x8b, 0xcc, 0xb8, 0xc5, 0x89, 0xe2, 0x89, 0x89, 0xe2, 0x99, 0xae, 0xe2, 0x99, 0xae, 0xe2, 0x84, 0x95, 0xc2, 0xa0, 0xe2, 0x89, 0x8e, 0xcc, 0xb8, 0xe2, 0x89, 0x8f, 0xcc, 0xb8, 0xe2, 0xa9, 0x83, 0xc5, 0x88, 0xc5, 0x86, 0xe2, 0x89, 0x87, 0xe2, 0xa9, 0xad, 0xcc, 0xb8, 0xe2, 0xa9, 0x82, 0xd0, 0xbd, 0xe2, 0x80, 0x93, 0xe2, 0x89, 0xa0, 0xe2, 0x87, 0x97, 0xe2, 0xa4, 0xa4, 0xe2, 0x86, 0x97, 0xe2, 0x86, 0x97, 0xe2, 0x89, 0x90, 0xcc, 0xb8, 0xe2, 0x89, 0xa2, 0xe2, 0xa4, 0xa8, 0xe2, 0x89, 0x82, 0xcc, 0xb8, 0xe2, 0x88, 0x84, 0xe2, 0x88, 0x84, 0xf0, 0x9d, 0x94, 0xab, 0xe2, 0x89, 0xa7, 0xcc, 0xb8, 0xe2, 0x89, 0xb1, 0xe2, 0x89, 0xb1, 0xe2, 0x89, 0xa7, 0xcc, 0xb8, 0xe2, 0xa9, 0xbe, 0xcc, 0xb8, 0xe2, 0xa9, 0xbe, 0xcc, 0xb8, 0xe2, 0x89, 0xb5, 0xe2, 0x89, 0xaf, 0xe2, 0x89, 0xaf, 0xe2, 0x87, 0x8e, 0xe2, 0x86, 0xae, 0xe2, 0xab, 0xb2, 0xe2, 0x88, 0x8b, 0xe2, 0x8b, 0xbc, 0xe2, 0x8b, 0xba, 0xe2, 0x88, 0x8b, 0xd1, 0x9a, 0xe2, 0x87, 0x8d, 0xe2, 0x89, 0xa6, 0xcc, 0xb8, 0xe2, 0x86, 0x9a, 0xe2, 0x80, 0xa5, 0xe2, 0x89, 0xb0, 0xe2, 0x86, 0x9a, 0xe2, 0x86, 0xae, 0xe2, 0x89, 0xb0, 0xe2, 0x89, 0xa6, 0xcc, 0xb8, 0xe2, 0xa9, 0xbd, 0xcc, 0xb8, 0xe2, 0xa9, 0xbd, 0xcc, 0xb8, 0xe2, 0x89, 0xae, 0xe2, 0x89, 0xb4, 0xe2, 0x89, 0xae, 0xe2, 0x8b, 0xaa, 0xe2, 0x8b, 0xac, 0xe2, 0x88, 0xa4, 0xf0, 0x9d, 0x95, 0x9f, 0xc2, 0xac, 0xe2, 0x88, 0x89, 0xe2, 0x8b, 0xb9, 0xcc, 0xb8, 0xe2, 0x8b, 0xb5, 0xcc, 0xb8, 0xe2, 0x88, 0x89, 0xe2, 0x8b, 0xb7, 0xe2, 0x8b, 0xb6, 0xe2, 0x88, 0x8c, 0xe2, 0x88, 0x8c, 0xe2, 0x8b, 0xbe, 0xe2, 0x8b, 0xbd, 0xe2, 0x88, 0xa6, 0xe2, 0x88, 0xa6, 0xe2, 0xab, 0xbd, 0xe2, 0x83, 0xa5, 0xe2, 0x88, 0x82, 0xcc, 0xb8, 0xe2, 0xa8, 0x94, 0xe2, 0x8a, 0x80, 0xe2, 0x8b, 0xa0, 0xe2, 0xaa, 0xaf, 0xcc, 0xb8, 0xe2, 0x8a, 0x80, 0xe2, 0xaa, 0xaf, 0xcc, 0xb8, 0xe2, 0x87, 0x8f, 0xe2, 0x86, 0x9b, 0xe2, 0xa4, 0xb3, 0xcc, 0xb8, 0xe2, 0x86, 0x9d, 0xcc, 0xb8, 0xe2, 0x86, 0x9b, 0xe2, 0x8b, 0xab, 0xe2, 0x8b, 0xad, 0xe2, 0x8a, 0x81, 0xe2, 0x8b, 0xa1, 0xe2, 0xaa, 0xb0, 0xcc, 0xb8, 0xf0, 0x9d, 0x93, 0x83, 0xe2, 0x88, 0xa4, 0xe2, 0x88, 0xa6, 0xe2, 0x89, 0x81, 0xe2, 0x89, 0x84, 0xe2, 0x89, 0x84, 0xe2, 0x88, 0xa4, 0xe2, 0x88, 0xa6, 0xe2, 0x8b, 0xa2, 0xe2, 0x8b, 0xa3, 0xe2, 0x8a, 0x84, 0xe2, 0xab, 0x85, 0xcc, 0xb8, 0xe2, 0x8a, 0x88, 0xe2, 0x8a, 0x82, 0xe2, 0x83, 0x92, 0xe2, 0x8a, 0x88, 0xe2, 0xab, 0x85, 0xcc, 0xb8, 0xe2, 0x8a, 0x81, 0xe2, 0xaa, 0xb0, 0xcc, 0xb8, 0xe2, 0x8a, 0x85, 0xe2, 0xab, 0x86, 0xcc, 0xb8, 0xe2, 0x8a, 0x89, 0xe2, 0x8a, 0x83, 0xe2, 0x83, 0x92, 0xe2, 0x8a, 0x89, 0xe2, 0xab, 0x86, 0xcc, 0xb8, 0xe2, 0x89, 0xb9, 0xc3, 0xb1, 0xe2, 0x89, 0xb8, 0xe2, 0x8b, 0xaa, 0xe2, 0x8b, 0xac, 0xe2, 0x8b, 0xab, 0xe2, 0x8b, 0xad, 0xce, 0xbd, 0x23, 0xe2, 0x84, 0x96, 0xe2, 0x80, 0x87, 0xe2, 0x8a, 0xad, 0xe2, 0xa4, 0x84, 0xe2, 0x89, 0x8d, 0xe2, 0x83, 0x92, 0xe2, 0x8a, 0xac, 0xe2, 0x89, 0xa5, 0xe2, 0x83, 0x92, 0x3e, 0xe2, 0x83, 0x92, 0xe2, 0xa7, 0x9e, 0xe2, 0xa4, 0x82, 0xe2, 0x89, 0xa4, 0xe2, 0x83, 0x92, 0x3c, 0xe2, 0x83, 0x92, 0xe2, 0x8a, 0xb4, 0xe2, 0x83, 0x92, 0xe2, 0xa4, 0x83, 0xe2, 0x8a, 0xb5, 0xe2, 0x83, 0x92, 0xe2, 0x88, 0xbc, 0xe2, 0x83, 0x92, 0xe2, 0x87, 0x96, 0xe2, 0xa4, 0xa3, 0xe2, 0x86, 0x96, 0xe2, 0x86, 0x96, 0xe2, 0xa4, 0xa7, 0xe2, 0x93, 0x88, 0xc3, 0xb3, 0xe2, 0x8a, 0x9b, 0xe2, 0x8a, 0x9a, 0xc3, 0xb4, 0xd0, 0xbe, 0xe2, 0x8a, 0x9d, 0xc5, 0x91, 0xe2, 0xa8, 0xb8, 0xe2, 0x8a, 0x99, 0xe2, 0xa6, 0xbc, 0xc5, 0x93, 0xe2, 0xa6, 0xbf, 0xf0, 0x9d, 0x94, 0xac, 0xcb, 0x9b, 0xc3, 0xb2, 0xe2, 0xa7, 0x81, 0xe2, 0xa6, 0xb5, 0xce, 0xa9, 0xe2, 0x88, 0xae, 0xe2, 0x86, 0xba, 0xe2, 0xa6, 0xbe, 0xe2, 0xa6, 0xbb, 0xe2, 0x80, 0xbe, 0xe2, 0xa7, 0x80, 0xc5, 0x8d, 0xcf, 0x89, 0xce, 0xbf, 0xe2, 0xa6, 0xb6, 0xe2, 0x8a, 0x96, 0xf0, 0x9d, 0x95, 0xa0, 0xe2, 0xa6, 0xb7, 0xe2, 0xa6, 0xb9, 0xe2, 0x8a, 0x95, 0xe2, 0x88, 0xa8, 0xe2, 0x86, 0xbb, 0xe2, 0xa9, 0x9d, 0xe2, 0x84, 0xb4, 0xe2, 0x84, 0xb4, 0xc2, 0xaa, 0xc2, 0xba, 0xe2, 0x8a, 0xb6, 0xe2, 0xa9, 0x96, 0xe2, 0xa9, 0x97, 0xe2, 0xa9, 0x9b, 0xe2, 0x84, 0xb4, 0xc3, 0xb8, 0xe2, 0x8a, 0x98, 0xc3, 0xb5, 0xe2, 0x8a, 0x97, 0xe2, 0xa8, 0xb6, 0xc3, 0xb6, 0xe2, 0x8c, 0xbd, 0xe2, 0x88, 0xa5, 0xc2, 0xb6, 0xe2, 0x88, 0xa5, 0xe2, 0xab, 0xb3, 0xe2, 0xab, 0xbd, 0xe2, 0x88, 0x82, 0xd0, 0xbf, 0x25, 0x2e, 0xe2, 0x80, 0xb0, 0xe2, 0x8a, 0xa5, 0xe2, 0x80, 0xb1, 0xf0, 0x9d, 0x94, 0xad, 0xcf, 0x86, 0xcf, 0x95, 0xe2, 0x84, 0xb3, 0xe2, 0x98, 0x8e, 0xcf, 0x80, 0xe2, 0x8b, 0x94, 0xcf, 0x96, 0xe2, 0x84, 0x8f, 0xe2, 0x84, 0x8e, 0xe2, 0x84, 0x8f, 0x2b, 0xe2, 0xa8, 0xa3, 0xe2, 0x8a, 0x9e, 0xe2, 0xa8, 0xa2, 0xe2, 0x88, 0x94, 0xe2, 0xa8, 0xa5, 0xe2, 0xa9, 0xb2, 0xc2, 0xb1, 0xe2, 0xa8, 0xa6, 0xe2, 0xa8, 0xa7, 0xc2, 0xb1, 0xe2, 0xa8, 0x95, 0xf0, 0x9d, 0x95, 0xa1, 0xc2, 0xa3, 0xe2, 0x89, 0xba, 0xe2, 0xaa, 0xb3, 0xe2, 0xaa, 0xb7, 0xe2, 0x89, 0xbc, 0xe2, 0xaa, 0xaf, 0xe2, 0x89, 0xba, 0xe2, 0xaa, 0xb7, 0xe2, 0x89, 0xbc, 0xe2, 0xaa, 0xaf, 0xe2, 0xaa, 0xb9, 0xe2, 0xaa, 0xb5, 0xe2, 0x8b, 0xa8, 0xe2, 0x89, 0xbe, 0xe2, 0x80, 0xb2, 0xe2, 0x84, 0x99, 0xe2, 0xaa, 0xb5, 0xe2, 0xaa, 0xb9, 0xe2, 0x8b, 0xa8, 0xe2, 0x88, 0x8f, 0xe2, 0x8c, 0xae, 0xe2, 0x8c, 0x92, 0xe2, 0x8c, 0x93, 0xe2, 0x88, 0x9d, 0xe2, 0x88, 0x9d, 0xe2, 0x89, 0xbe, 0xe2, 0x8a, 0xb0, 0xf0, 0x9d, 0x93, 0x85, 0xcf, 0x88, 0xe2, 0x80, 0x88, 0xf0, 0x9d, 0x94, 0xae, 0xe2, 0xa8, 0x8c, 0xf0, 0x9d, 0x95, 0xa2, 0xe2, 0x81, 0x97, 0xf0, 0x9d, 0x93, 0x86, 0xe2, 0x84, 0x8d, 0xe2, 0xa8, 0x96, 0x3f, 0xe2, 0x89, 0x9f, 0x22, 0xe2, 0x87, 0x9b, 0xe2, 0x87, 0x92, 0xe2, 0xa4, 0x9c, 0xe2, 0xa4, 0x8f, 0xe2, 0xa5, 0xa4, 0xe2, 0x88, 0xbd, 0xcc, 0xb1, 0xc5, 0x95, 0xe2, 0x88, 0x9a, 0xe2, 0xa6, 0xb3, 0xe2, 0x9f, 0xa9, 0xe2, 0xa6, 0x92, 0xe2, 0xa6, 0xa5, 0xe2, 0x9f, 0xa9, 0xc2, 0xbb, 0xe2, 0x86, 0x92, 0xe2, 0xa5, 0xb5, 0xe2, 0x87, 0xa5, 0xe2, 0xa4, 0xa0, 0xe2, 0xa4, 0xb3, 0xe2, 0xa4, 0x9e, 0xe2, 0x86, 0xaa, 0xe2, 0x86, 0xac, 0xe2, 0xa5, 0x85, 0xe2, 0xa5, 0xb4, 0xe2, 0x86, 0xa3, 0xe2, 0x86, 0x9d, 0xe2, 0xa4, 0x9a, 0xe2, 0x88, 0xb6, 0xe2, 0x84, 0x9a, 0xe2, 0xa4, 0x8d, 0xe2, 0x9d, 0xb3, 0x7d, 0x5d, 0xe2, 0xa6, 0x8c, 0xe2, 0xa6, 0x8e, 0xe2, 0xa6, 0x90, 0xc5, 0x99, 0xc5, 0x97, 0xe2, 0x8c, 0x89, 0x7d, 0xd1, 0x80, 0xe2, 0xa4, 0xb7, 0xe2, 0xa5, 0xa9, 0xe2, 0x80, 0x9d, 0xe2, 0x80, 0x9d, 0xe2, 0x86, 0xb3, 0xe2, 0x84, 0x9c, 0xe2, 0x84, 0x9b, 0xe2, 0x84, 0x9c, 0xe2, 0x84, 0x9d, 0xe2, 0x96, 0xad, 0xc2, 0xae, 0xe2, 0xa5, 0xbd, 0xe2, 0x8c, 0x8b, 0xf0, 0x9d, 0x94, 0xaf, 0xe2, 0x87, 0x81, 0xe2, 0x87, 0x80, 0xe2, 0xa5, 0xac, 0xcf, 0x81, 0xcf, 0xb1, 0xe2, 0x86, 0x92, 0xe2, 0x86, 0xa3, 0xe2, 0x87, 0x81, 0xe2, 0x87, 0x80, 0xe2, 0x87, 0x84, 0xe2, 0x87, 0x8c, 0xe2, 0x87, 0x89, 0xe2, 0x86, 0x9d, 0xe2, 0x8b, 0x8c, 0xcb, 0x9a, 0xe2, 0x89, 0x93, 0xe2, 0x87, 0x84, 0xe2, 0x87, 0x8c, 0xe2, 0x80, 0x8f, 0xe2, 0x8e, 0xb1, 0xe2, 0x8e, 0xb1, 0xe2, 0xab, 0xae, 0xe2, 0x9f, 0xad, 0xe2, 0x87, 0xbe, 0xe2, 0x9f, 0xa7, 0xe2, 0xa6, 0x86, 0xf0, 0x9d, 0x95, 0xa3, 0xe2, 0xa8, 0xae, 0xe2, 0xa8, 0xb5, 0x29, 0xe2, 0xa6, 0x94, 0xe2, 0xa8, 0x92, 0xe2, 0x87, 0x89, 0xe2, 0x80, 0xba, 0xf0, 0x9d, 0x93, 0x87, 0xe2, 0x86, 0xb1, 0x5d, 0xe2, 0x80, 0x99, 0xe2, 0x80, 0x99, 0xe2, 0x8b, 0x8c, 0xe2, 0x8b, 0x8a, 0xe2, 0x96, 0xb9, 0xe2, 0x8a, 0xb5, 0xe2, 0x96, 0xb8, 0xe2, 0xa7, 0x8e, 0xe2, 0xa5, 0xa8, 0xe2, 0x84, 0x9e, 0xc5, 0x9b, 0xe2, 0x80, 0x9a, 0xe2, 0x89, 0xbb, 0xe2, 0xaa, 0xb4, 0xe2, 0xaa, 0xb8, 0xc5, 0xa1, 0xe2, 0x89, 0xbd, 0xe2, 0xaa, 0xb0, 0xc5, 0x9f, 0xc5, 0x9d, 0xe2, 0xaa, 0xb6, 0xe2, 0xaa, 0xba, 0xe2, 0x8b, 0xa9, 0xe2, 0xa8, 0x93, 0xe2, 0x89, 0xbf, 0xd1, 0x81, 0xe2, 0x8b, 0x85, 0xe2, 0x8a, 0xa1, 0xe2, 0xa9, 0xa6, 0xe2, 0x87, 0x98, 0xe2, 0xa4, 0xa5, 0xe2, 0x86, 0x98, 0xe2, 0x86, 0x98, 0xc2, 0xa7, 0x3b, 0xe2, 0xa4, 0xa9, 0xe2, 0x88, 0x96, 0xe2, 0x88, 0x96, 0xe2, 0x9c, 0xb6, 0xf0, 0x9d, 0x94, 0xb0, 0xe2, 0x8c, 0xa2, 0xe2, 0x99, 0xaf, 0xd1, 0x89, 0xd1, 0x88, 0xe2, 0x88, 0xa3, 0xe2, 0x88, 0xa5, 0xc2, 0xad, 0xcf, 0x83, 0xcf, 0x82, 0xcf, 0x82, 0xe2, 0x88, 0xbc, 0xe2, 0xa9, 0xaa, 0xe2, 0x89, 0x83, 0xe2, 0x89, 0x83, 0xe2, 0xaa, 0x9e, 0xe2, 0xaa, 0xa0, 0xe2, 0xaa, 0x9d, 0xe2, 0xaa, 0x9f, 0xe2, 0x89, 0x86, 0xe2, 0xa8, 0xa4, 0xe2, 0xa5, 0xb2, 0xe2, 0x86, 0x90, 0xe2, 0x88, 0x96, 0xe2, 0xa8, 0xb3, 0xe2, 0xa7, 0xa4, 0xe2, 0x88, 0xa3, 0xe2, 0x8c, 0xa3, 0xe2, 0xaa, 0xaa, 0xe2, 0xaa, 0xac, 0xe2, 0xaa, 0xac, 0xef, 0xb8, 0x80, 0xd1, 0x8c, 0x2f, 0xe2, 0xa7, 0x84, 0xe2, 0x8c, 0xbf, 0xf0, 0x9d, 0x95, 0xa4, 0xe2, 0x99, 0xa0, 0xe2, 0x99, 0xa0, 0xe2, 0x88, 0xa5, 0xe2, 0x8a, 0x93, 0xe2, 0x8a, 0x93, 0xef, 0xb8, 0x80, 0xe2, 0x8a, 0x94, 0xe2, 0x8a, 0x94, 0xef, 0xb8, 0x80, 0xe2, 0x8a, 0x8f, 0xe2, 0x8a, 0x91, 0xe2, 0x8a, 0x8f, 0xe2, 0x8a, 0x91, 0xe2, 0x8a, 0x90, 0xe2, 0x8a, 0x92, 0xe2, 0x8a, 0x90, 0xe2, 0x8a, 0x92, 0xe2, 0x96, 0xa1, 0xe2, 0x96, 0xa1, 0xe2, 0x96, 0xaa, 0xe2, 0x96, 0xaa, 0xe2, 0x86, 0x92, 0xf0, 0x9d, 0x93, 0x88, 0xe2, 0x88, 0x96, 0xe2, 0x8c, 0xa3, 0xe2, 0x8b, 0x86, 0xe2, 0x98, 0x86, 0xe2, 0x98, 0x85, 0xcf, 0xb5, 0xcf, 0x95, 0xc2, 0xaf, 0xe2, 0x8a, 0x82, 0xe2, 0xab, 0x85, 0xe2, 0xaa, 0xbd, 0xe2, 0x8a, 0x86, 0xe2, 0xab, 0x83, 0xe2, 0xab, 0x81, 0xe2, 0xab, 0x8b, 0xe2, 0x8a, 0x8a, 0xe2, 0xaa, 0xbf, 0xe2, 0xa5, 0xb9, 0xe2, 0x8a, 0x82, 0xe2, 0x8a, 0x86, 0xe2, 0xab, 0x85, 0xe2, 0x8a, 0x8a, 0xe2, 0xab, 0x8b, 0xe2, 0xab, 0x87, 0xe2, 0xab, 0x95, 0xe2, 0xab, 0x93, 0xe2, 0x89, 0xbb, 0xe2, 0xaa, 0xb8, 0xe2, 0x89, 0xbd, 0xe2, 0xaa, 0xb0, 0xe2, 0xaa, 0xba, 0xe2, 0xaa, 0xb6, 0xe2, 0x8b, 0xa9, 0xe2, 0x89, 0xbf, 0xe2, 0x88, 0x91, 0xe2, 0x99, 0xaa, 0xe2, 0x8a, 0x83, 0xc2, 0xb9, 0xc2, 0xb2, 0xc2, 0xb3, 0xe2, 0xab, 0x86, 0xe2, 0xaa, 0xbe, 0xe2, 0xab, 0x98, 0xe2, 0x8a, 0x87, 0xe2, 0xab, 0x84, 0xe2, 0x9f, 0x89, 0xe2, 0xab, 0x97, 0xe2, 0xa5, 0xbb, 0xe2, 0xab, 0x82, 0xe2, 0xab, 0x8c, 0xe2, 0x8a, 0x8b, 0xe2, 0xab, 0x80, 0xe2, 0x8a, 0x83, 0xe2, 0x8a, 0x87, 0xe2, 0xab, 0x86, 0xe2, 0x8a, 0x8b, 0xe2, 0xab, 0x8c, 0xe2, 0xab, 0x88, 0xe2, 0xab, 0x94, 0xe2, 0xab, 0x96, 0xe2, 0x87, 0x99, 0xe2, 0xa4, 0xa6, 0xe2, 0x86, 0x99, 0xe2, 0x86, 0x99, 0xe2, 0xa4, 0xaa, 0xc3, 0x9f, 0xe2, 0x8c, 0x96, 0xcf, 0x84, 0xe2, 0x8e, 0xb4, 0xc5, 0xa5, 0xc5, 0xa3, 0xd1, 0x82, 0xe2, 0x83, 0x9b, 0xe2, 0x8c, 0x95, 0xf0, 0x9d, 0x94, 0xb1, 0xe2, 0x88, 0xb4, 0xe2, 0x88, 0xb4, 0xce, 0xb8, 0xcf, 0x91, 0xcf, 0x91, 0xe2, 0x89, 0x88, 0xe2, 0x88, 0xbc, 0xe2, 0x80, 0x89, 0xe2, 0x89, 0x88, 0xe2, 0x88, 0xbc, 0xc3, 0xbe, 0xcb, 0x9c, 0xc3, 0x97, 0xe2, 0x8a, 0xa0, 0xe2, 0xa8, 0xb1, 0xe2, 0xa8, 0xb0, 0xe2, 0x88, 0xad, 0xe2, 0xa4, 0xa8, 0xe2, 0x8a, 0xa4, 0xe2, 0x8c, 0xb6, 0xe2, 0xab, 0xb1, 0xf0, 0x9d, 0x95, 0xa5, 0xe2, 0xab, 0x9a, 0xe2, 0xa4, 0xa9, 0xe2, 0x80, 0xb4, 0xe2, 0x84, 0xa2, 0xe2, 0x96, 0xb5, 0xe2, 0x96, 0xbf, 0xe2, 0x97, 0x83, 0xe2, 0x8a, 0xb4, 0xe2, 0x89, 0x9c, 0xe2, 0x96, 0xb9, 0xe2, 0x8a, 0xb5, 0xe2, 0x97, 0xac, 0xe2, 0x89, 0x9c, 0xe2, 0xa8, 0xba, 0xe2, 0xa8, 0xb9, 0xe2, 0xa7, 0x8d, 0xe2, 0xa8, 0xbb, 0xe2, 0x8f, 0xa2, 0xf0, 0x9d, 0x93, 0x89, 0xd1, 0x86, 0xd1, 0x9b, 0xc5, 0xa7, 0xe2, 0x89, 0xac, 0xe2, 0x86, 0x9e, 0xe2, 0x86, 0xa0, 0xe2, 0x87, 0x91, 0xe2, 0xa5, 0xa3, 0xc3, 0xba, 0xe2, 0x86, 0x91, 0xd1, 0x9e, 0xc5, 0xad, 0xc3, 0xbb, 0xd1, 0x83, 0xe2, 0x87, 0x85, 0xc5, 0xb1, 0xe2, 0xa5, 0xae, 0xe2, 0xa5, 0xbe, 0xf0, 0x9d, 0x94, 0xb2, 0xc3, 0xb9, 0xe2, 0x86, 0xbf, 0xe2, 0x86, 0xbe, 0xe2, 0x96, 0x80, 0xe2, 0x8c, 0x9c, 0xe2, 0x8c, 0x9c, 0xe2, 0x8c, 0x8f, 0xe2, 0x97, 0xb8, 0xc5, 0xab, 0xc2, 0xa8, 0xc5, 0xb3, 0xf0, 0x9d, 0x95, 0xa6, 0xe2, 0x86, 0x91, 0xe2, 0x86, 0x95, 0xe2, 0x86, 0xbf, 0xe2, 0x86, 0xbe, 0xe2, 0x8a, 0x8e, 0xcf, 0x85, 0xcf, 0x92, 0xcf, 0x85, 0xe2, 0x87, 0x88, 0xe2, 0x8c, 0x9d, 0xe2, 0x8c, 0x9d, 0xe2, 0x8c, 0x8e, 0xc5, 0xaf, 0xe2, 0x97, 0xb9, 0xf0, 0x9d, 0x93, 0x8a, 0xe2, 0x8b, 0xb0, 0xc5, 0xa9, 0xe2, 0x96, 0xb5, 0xe2, 0x96, 0xb4, 0xe2, 0x87, 0x88, 0xc3, 0xbc, 0xe2, 0xa6, 0xa7, 0xe2, 0x87, 0x95, 0xe2, 0xab, 0xa8, 0xe2, 0xab, 0xa9, 0xe2, 0x8a, 0xa8, 0xe2, 0xa6, 0x9c, 0xcf, 0xb5, 0xcf, 0xb0, 0xe2, 0x88, 0x85, 0xcf, 0x95, 0xcf, 0x96, 0xe2, 0x88, 0x9d, 0xe2, 0x86, 0x95, 0xcf, 0xb1, 0xcf, 0x82, 0xe2, 0x8a, 0x8a, 0xef, 0xb8, 0x80, 0xe2, 0xab, 0x8b, 0xef, 0xb8, 0x80, 0xe2, 0x8a, 0x8b, 0xef, 0xb8, 0x80, 0xe2, 0xab, 0x8c, 0xef, 0xb8, 0x80, 0xcf, 0x91, 0xe2, 0x8a, 0xb2, 0xe2, 0x8a, 0xb3, 0xd0, 0xb2, 0xe2, 0x8a, 0xa2, 0xe2, 0x88, 0xa8, 0xe2, 0x8a, 0xbb, 0xe2, 0x89, 0x9a, 0xe2, 0x8b, 0xae, 0x7c, 0x7c, 0xf0, 0x9d, 0x94, 0xb3, 0xe2, 0x8a, 0xb2, 0xe2, 0x8a, 0x82, 0xe2, 0x83, 0x92, 0xe2, 0x8a, 0x83, 0xe2, 0x83, 0x92, 0xf0, 0x9d, 0x95, 0xa7, 0xe2, 0x88, 0x9d, 0xe2, 0x8a, 0xb3, 0xf0, 0x9d, 0x93, 0x8b, 0xe2, 0xab, 0x8b, 0xef, 0xb8, 0x80, 0xe2, 0x8a, 0x8a, 0xef, 0xb8, 0x80, 0xe2, 0xab, 0x8c, 0xef, 0xb8, 0x80, 0xe2, 0x8a, 0x8b, 0xef, 0xb8, 0x80, 0xe2, 0xa6, 0x9a, 0xc5, 0xb5, 0xe2, 0xa9, 0x9f, 0xe2, 0x88, 0xa7, 0xe2, 0x89, 0x99, 0xe2, 0x84, 0x98, 0xf0, 0x9d, 0x94, 0xb4, 0xf0, 0x9d, 0x95, 0xa8, 0xe2, 0x84, 0x98, 0xe2, 0x89, 0x80, 0xe2, 0x89, 0x80, 0xf0, 0x9d, 0x93, 0x8c, 0xe2, 0x8b, 0x82, 0xe2, 0x97, 0xaf, 0xe2, 0x8b, 0x83, 0xe2, 0x96, 0xbd, 0xf0, 0x9d, 0x94, 0xb5, 0xe2, 0x9f, 0xba, 0xe2, 0x9f, 0xb7, 0xce, 0xbe, 0xe2, 0x9f, 0xb8, 0xe2, 0x9f, 0xb5, 0xe2, 0x9f, 0xbc, 0xe2, 0x8b, 0xbb, 0xe2, 0xa8, 0x80, 0xf0, 0x9d, 0x95, 0xa9, 0xe2, 0xa8, 0x81, 0xe2, 0xa8, 0x82, 0xe2, 0x9f, 0xb9, 0xe2, 0x9f, 0xb6, 0xf0, 0x9d, 0x93, 0x8d, 0xe2, 0xa8, 0x86, 0xe2, 0xa8, 0x84, 0xe2, 0x96, 0xb3, 0xe2, 0x8b, 0x81, 0xe2, 0x8b, 0x80, 0xc3, 0xbd, 0xd1, 0x8f, 0xc5, 0xb7, 0xd1, 0x8b, 0xc2, 0xa5, 0xf0, 0x9d, 0x94, 0xb6, 0xd1, 0x97, 0xf0, 0x9d, 0x95, 0xaa, 0xf0, 0x9d, 0x93, 0x8e, 0xd1, 0x8e, 0xc3, 0xbf, 0xc5, 0xba, 0xc5, 0xbe, 0xd0, 0xb7, 0xc5, 0xbc, 0xe2, 0x84, 0xa8, 0xce, 0xb6, 0xf0, 0x9d, 0x94, 0xb7, 0xd0, 0xb6, 0xe2, 0x87, 0x9d, 0xf0, 0x9d, 0x95, 0xab, 0xf0, 0x9d, 0x93, 0x8f, 0xe2, 0x80, 0x8d, 0xe2, 0x80, 0x8c}
var _html5entitiesCharactersIndex  = "\x02\x01\x02\x02\x02\x04\x02\x02\x02\x03\x02\x04\x03\x02\x04\x03\x02\x02\x03\x03\x03\x02\x03\x03\x02\x04\x04\x02\x03\x03\x02\x02\x02\x03\x03\x03\x02\x02\x02\x03\x02\x02\x02\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x03\x03\x02\x02\x02\x03\x03\x03\x02\x02\x03\x02\x04\x02\x02\x02\x01\x02\x03\x03\x04\x02\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x02\x02\x02\x02\x02\x02\x02\x02\x04\x02\x03\x02\x03\x03\x02\x04\x02\x03\x03\x03\x03\x03\x02\x02\x03\x03\x02\x04\x03\x03\x04\x03\x03\x03\x02\x01\x02\x02\x02\x02\x02\x02\x02\x04\x03\x04\x03\x03\x03\x03\x03\x03\x03\x04\x03\x02\x02\x01\x02\x03\x03\x03\x03\x03\x02\x03\x03\x02\x02\x02\x02\x02\x02\x02\x03\x02\x03\x02\x03\x03\x03\x03\x03\x03\x03\x02\x04\x02\x03\x02\x02\x02\x02\x02\x04\x04\x04\x02\x02\x02\x02\x02\x02\x02\x04\x04\x04\x02\x01\x02\x02\x03\x03\x03\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x02\x03\x03\x03\x03\x03\x03\x04\x03\x03\x03\x03\x02\x03\x03\x02\x03\x03\x04\x03\x04\x03\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x01\x04\x03\x02\x03\x03\x03\x03\x03\x03\x03\x05\x03\x03\x03\x05\x05\x03\x05\x03\x05\x05\x03\x05\x03\x03\x03\x03\x05\x05\x03\x05\x05\x03\x05\x03\x03\x03\x05\x03\x05\x03\x05\x03\x06\x03\x03\x05\x03\x05\x06\x03\x03\x03\x03\x03\x03\x04\x02\x02\x02\x02\x02\x02\x02\x04\x02\x02\x02\x02\x04\x03\x03\x03\x04\x02\x02\x03\x02\x03\x03\x03\x03\x03\x02\x04\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x02\x01\x04\x03\x04\x03\x02\x02\x03\x03\x03\x02\x02\x02\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x02\x02\x02\x03\x02\x02\x02\x02\x04\x03\x03\x03\x03\x02\x03\x04\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x02\x02\x01\x02\x02\x02\x02\x04\x03\x02\x06\x03\x03\x03\x03\x03\x04\x03\x04\x02\x02\x03\x03\x02\x02\x02\x02\x02\x04\x02\x02\x01\x03\x03\x03\x03\x03\x02\x04\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x02\x02\x04\x02\x02\x03\x03\x02\x03\x03\x03\x03\x03\x03\x01\x03\x03\x03\x04\x04\x04\x03\x02\x03\x04\x04\x04\x04\x02\x04\x04\x02\x02\x02\x02\x02\x02\x04\x04\x04\x02\x02\x02\x02\x02\x02\x03\x02\x03\x03\x04\x02\x02\x03\x05\x03\x02\x02\x02\x02\x03\x04\x02\x03\x03\x02\x02\x03\x01\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x02\x04\x03\x03\x03\x03\x03\x01\x03\x03\x02\x04\x01\x03\x03\x02\x02\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x02\x03\x02\x03\x03\x04\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x06\x03\x04\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x02\x04\x03\x03\x03\x01\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x06\x03\x02\x03\x02\x02\x02\x03\x03\x02\x02\x03\x02\x02\x04\x02\x03\x03\x02\x03\x03\x02\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x01\x03\x03\x01\x01\x03\x03\x03\x03\x03\x03\x03\x04\x03\x02\x03\x03\x03\x04\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x06\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x02\x02\x03\x03\x03\x03\x02\x02\x03\x03\x04\x03\x03\x03\x03\x03\x03\x02\x02\x03\x02\x02\x03\x03\x02\x03\x03\x01\x04\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x02\x03\x02\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x02\x03\x02\x03\x02\x03\x02\x02\x03\x03\x04\x03\x02\x03\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x02\x03\x02\x04\x03\x03\x03\x02\x02\x02\x03\x03\x03\x03\x03\x01\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x02\x02\x03\x01\x03\x03\x03\x03\x02\x03\x03\x03\x03\x04\x03\x02\x03\x03\x03\x02\x04\x03\x03\x03\x03\x02\x03\x02\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x02\x02\x02\x03\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x06\x03\x04\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x01\x03\x03\x03\x03\x01\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x06\x06\x03\x03\x02\x03\x02\x03\x03\x03\x03\x02\x03\x03\x03\x03\x04\x03\x03\x03\x03\x03\x03\x04\x03\x04\x03\x02\x03\x03\x02\x03\x02\x02\x02\x02\x03\x04\x02\x03\x03\x03\x03\x03\x02\x02\x03\x03\x03\x02\x03\x02\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x02\x02\x04\x02\x03\x02\x04\x03\x03\x03\x03\x03\x03\x03\x02\x02\x02\x02\x02\x04\x02\x04\x04\x02\x02\x02\x02\x02\x02\x04\x02\x02\x02\x04\x04\x03\x03\x03\x03\x03\x03\x03\x02\x03\x03\x02\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x06\x03\x03\x01\x01\x03\x03\x03\x02\x02\x03\x01\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x06\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x03\x01\x03\x03\x03\x01\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x03\x03\x01\x03\x03\x02\x01\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x06\x06\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x03\x04\x03\x02\x03\x01\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x04\x03\x02\x03\x03\x05\x06\x05\x03\x03\x05\x06\x05\x03\x03\x03\x03\x02\x06\x03\x05\x05\x02\x03\x03\x03\x03\x02\x05\x05\x03\x02\x02\x03\x05\x03\x02\x03\x03\x03\x03\x03\x03\x05\x03\x03\x05\x03\x03\x04\x05\x03\x03\x05\x05\x05\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x05\x03\x03\x03\x03\x03\x03\x05\x05\x05\x03\x03\x03\x03\x03\x03\x04\x02\x03\x05\x05\x03\x03\x03\x03\x03\x03\x03\x03\x03\x06\x05\x03\x03\x03\x05\x03\x05\x03\x03\x05\x05\x03\x03\x03\x03\x03\x05\x04\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x05\x03\x06\x03\x05\x03\x05\x03\x05\x03\x06\x03\x05\x03\x02\x03\x03\x03\x03\x03\x02\x01\x03\x03\x03\x03\x06\x03\x06\x04\x03\x03\x06\x04\x06\x03\x06\x06\x03\x03\x03\x03\x03\x03\x02\x03\x03\x02\x02\x03\x02\x03\x03\x03\x02\x03\x04\x02\x02\x03\x03\x02\x03\x03\x03\x03\x03\x03\x02\x02\x02\x03\x03\x04\x03\x03\x03\x03\x03\x03\x03\x03\x02\x02\x03\x03\x03\x03\x03\x02\x03\x02\x03\x03\x02\x03\x03\x02\x03\x03\x03\x03\x02\x01\x01\x03\x03\x03\x04\x02\x02\x03\x03\x02\x03\x02\x03\x03\x03\x01\x03\x03\x03\x03\x03\x03\x02\x03\x03\x02\x03\x04\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x02\x03\x04\x03\x04\x03\x04\x03\x03\x01\x03\x01\x03\x03\x03\x03\x03\x05\x02\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x01\x01\x03\x03\x03\x02\x02\x03\x01\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x03\x04\x03\x03\x03\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x01\x03\x03\x03\x03\x04\x03\x01\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x02\x03\x03\x02\x02\x03\x03\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x03\x02\x01\x03\x03\x03\x03\x04\x03\x03\x02\x02\x03\x03\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x06\x02\x01\x03\x03\x04\x03\x03\x03\x03\x06\x03\x06\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x03\x03\x03\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x02\x03\x02\x03\x02\x02\x02\x03\x03\x04\x03\x03\x02\x02\x02\x03\x03\x03\x03\x03\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x02\x02\x02\x03\x03\x03\x03\x03\x02\x03\x02\x02\x02\x02\x03\x02\x03\x03\x04\x02\x03\x03\x03\x03\x03\x03\x03\x02\x02\x02\x04\x03\x03\x03\x03\x03\x02\x02\x02\x03\x03\x03\x03\x02\x03\x04\x03\x02\x03\x03\x03\x02\x03\x03\x03\x03\x03\x03\x02\x02\x03\x02\x02\x03\x03\x02\x02\x06\x06\x06\x06\x02\x03\x03\x02\x03\x03\x03\x03\x03\x01\x01\x04\x03\x06\x06\x04\x03\x03\x04\x06\x06\x06\x06\x03\x02\x03\x03\x03\x03\x04\x04\x03\x03\x03\x04\x03\x03\x03\x03\x04\x03\x03\x02\x03\x03\x03\x03\x03\x04\x03\x03\x03\x03\x04\x03\x03\x03\x03\x03\x02\x02\x02\x02\x02\x04\x02\x04\x04\x02\x02\x02\x02\x02\x02\x03\x02\x04\x02\x03\x04\x04\x03\x03"
</file>

<file path="util/unicode_case_folding.gen.go">
// Code generated by _tools; DO NOT EDIT.
package util
const _unicodeCaseFoldingLength = 1530
var _unicodeCaseFoldingFrom = [...]rune{0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xb5, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10a, 0x10c, 0x10e, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11a, 0x11c, 0x11e, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 0x12e, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13b, 0x13d, 0x13f, 0x141, 0x143, 0x145, 0x147, 0x149, 0x14a, 0x14c, 0x14e, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15a, 0x15c, 0x15e, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16a, 0x16c, 0x16e, 0x170, 0x172, 0x174, 0x176, 0x178, 0x179, 0x17b, 0x17d, 0x17f, 0x181, 0x182, 0x184, 0x186, 0x187, 0x189, 0x18a, 0x18b, 0x18e, 0x18f, 0x190, 0x191, 0x193, 0x194, 0x196, 0x197, 0x198, 0x19c, 0x19d, 0x19f, 0x1a0, 0x1a2, 0x1a4, 0x1a6, 0x1a7, 0x1a9, 0x1ac, 0x1ae, 0x1af, 0x1b1, 0x1b2, 0x1b3, 0x1b5, 0x1b7, 0x1b8, 0x1bc, 0x1c4, 0x1c5, 0x1c7, 0x1c8, 0x1ca, 0x1cb, 0x1cd, 0x1cf, 0x1d1, 0x1d3, 0x1d5, 0x1d7, 0x1d9, 0x1db, 0x1de, 0x1e0, 0x1e2, 0x1e4, 0x1e6, 0x1e8, 0x1ea, 0x1ec, 0x1ee, 0x1f0, 0x1f1, 0x1f2, 0x1f4, 0x1f6, 0x1f7, 0x1f8, 0x1fa, 0x1fc, 0x1fe, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20a, 0x20c, 0x20e, 0x210, 0x212, 0x214, 0x216, 0x218, 0x21a, 0x21c, 0x21e, 0x220, 0x222, 0x224, 0x226, 0x228, 0x22a, 0x22c, 0x22e, 0x230, 0x232, 0x23a, 0x23b, 0x23d, 0x23e, 0x241, 0x243, 0x244, 0x245, 0x246, 0x248, 0x24a, 0x24c, 0x24e, 0x345, 0x370, 0x372, 0x376, 0x37f, 0x386, 0x388, 0x389, 0x38a, 0x38c, 0x38e, 0x38f, 0x390, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39a, 0x39b, 0x39c, 0x39d, 0x39e, 0x39f, 0x3a0, 0x3a1, 0x3a3, 0x3a4, 0x3a5, 0x3a6, 0x3a7, 0x3a8, 0x3a9, 0x3aa, 0x3ab, 0x3b0, 0x3c2, 0x3cf, 0x3d0, 0x3d1, 0x3d5, 0x3d6, 0x3d8, 0x3da, 0x3dc, 0x3de, 0x3e0, 0x3e2, 0x3e4, 0x3e6, 0x3e8, 0x3ea, 0x3ec, 0x3ee, 0x3f0, 0x3f1, 0x3f4, 0x3f5, 0x3f7, 0x3f9, 0x3fa, 0x3fd, 0x3fe, 0x3ff, 0x400, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40a, 0x40b, 0x40c, 0x40d, 0x40e, 0x40f, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41a, 0x41b, 0x41c, 0x41d, 0x41e, 0x41f, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42a, 0x42b, 0x42c, 0x42d, 0x42e, 0x42f, 0x460, 0x462, 0x464, 0x466, 0x468, 0x46a, 0x46c, 0x46e, 0x470, 0x472, 0x474, 0x476, 0x478, 0x47a, 0x47c, 0x47e, 0x480, 0x48a, 0x48c, 0x48e, 0x490, 0x492, 0x494, 0x496, 0x498, 0x49a, 0x49c, 0x49e, 0x4a0, 0x4a2, 0x4a4, 0x4a6, 0x4a8, 0x4aa, 0x4ac, 0x4ae, 0x4b0, 0x4b2, 0x4b4, 0x4b6, 0x4b8, 0x4ba, 0x4bc, 0x4be, 0x4c0, 0x4c1, 0x4c3, 0x4c5, 0x4c7, 0x4c9, 0x4cb, 0x4cd, 0x4d0, 0x4d2, 0x4d4, 0x4d6, 0x4d8, 0x4da, 0x4dc, 0x4de, 0x4e0, 0x4e2, 0x4e4, 0x4e6, 0x4e8, 0x4ea, 0x4ec, 0x4ee, 0x4f0, 0x4f2, 0x4f4, 0x4f6, 0x4f8, 0x4fa, 0x4fc, 0x4fe, 0x500, 0x502, 0x504, 0x506, 0x508, 0x50a, 0x50c, 0x50e, 0x510, 0x512, 0x514, 0x516, 0x518, 0x51a, 0x51c, 0x51e, 0x520, 0x522, 0x524, 0x526, 0x528, 0x52a, 0x52c, 0x52e, 0x531, 0x532, 0x533, 0x534, 0x535, 0x536, 0x537, 0x538, 0x539, 0x53a, 0x53b, 0x53c, 0x53d, 0x53e, 0x53f, 0x540, 0x541, 0x542, 0x543, 0x544, 0x545, 0x546, 0x547, 0x548, 0x549, 0x54a, 0x54b, 0x54c, 0x54d, 0x54e, 0x54f, 0x550, 0x551, 0x552, 0x553, 0x554, 0x555, 0x556, 0x587, 0x10a0, 0x10a1, 0x10a2, 0x10a3, 0x10a4, 0x10a5, 0x10a6, 0x10a7, 0x10a8, 0x10a9, 0x10aa, 0x10ab, 0x10ac, 0x10ad, 0x10ae, 0x10af, 0x10b0, 0x10b1, 0x10b2, 0x10b3, 0x10b4, 0x10b5, 0x10b6, 0x10b7, 0x10b8, 0x10b9, 0x10ba, 0x10bb, 0x10bc, 0x10bd, 0x10be, 0x10bf, 0x10c0, 0x10c1, 0x10c2, 0x10c3, 0x10c4, 0x10c5, 0x10c7, 0x10cd, 0x13f8, 0x13f9, 0x13fa, 0x13fb, 0x13fc, 0x13fd, 0x1c80, 0x1c81, 0x1c82, 0x1c83, 0x1c84, 0x1c85, 0x1c86, 0x1c87, 0x1c88, 0x1c90, 0x1c91, 0x1c92, 0x1c93, 0x1c94, 0x1c95, 0x1c96, 0x1c97, 0x1c98, 0x1c99, 0x1c9a, 0x1c9b, 0x1c9c, 0x1c9d, 0x1c9e, 0x1c9f, 0x1ca0, 0x1ca1, 0x1ca2, 0x1ca3, 0x1ca4, 0x1ca5, 0x1ca6, 0x1ca7, 0x1ca8, 0x1ca9, 0x1caa, 0x1cab, 0x1cac, 0x1cad, 0x1cae, 0x1caf, 0x1cb0, 0x1cb1, 0x1cb2, 0x1cb3, 0x1cb4, 0x1cb5, 0x1cb6, 0x1cb7, 0x1cb8, 0x1cb9, 0x1cba, 0x1cbd, 0x1cbe, 0x1cbf, 0x1e00, 0x1e02, 0x1e04, 0x1e06, 0x1e08, 0x1e0a, 0x1e0c, 0x1e0e, 0x1e10, 0x1e12, 0x1e14, 0x1e16, 0x1e18, 0x1e1a, 0x1e1c, 0x1e1e, 0x1e20, 0x1e22, 0x1e24, 0x1e26, 0x1e28, 0x1e2a, 0x1e2c, 0x1e2e, 0x1e30, 0x1e32, 0x1e34, 0x1e36, 0x1e38, 0x1e3a, 0x1e3c, 0x1e3e, 0x1e40, 0x1e42, 0x1e44, 0x1e46, 0x1e48, 0x1e4a, 0x1e4c, 0x1e4e, 0x1e50, 0x1e52, 0x1e54, 0x1e56, 0x1e58, 0x1e5a, 0x1e5c, 0x1e5e, 0x1e60, 0x1e62, 0x1e64, 0x1e66, 0x1e68, 0x1e6a, 0x1e6c, 0x1e6e, 0x1e70, 0x1e72, 0x1e74, 0x1e76, 0x1e78, 0x1e7a, 0x1e7c, 0x1e7e, 0x1e80, 0x1e82, 0x1e84, 0x1e86, 0x1e88, 0x1e8a, 0x1e8c, 0x1e8e, 0x1e90, 0x1e92, 0x1e94, 0x1e96, 0x1e97, 0x1e98, 0x1e99, 0x1e9a, 0x1e9b, 0x1e9e, 0x1ea0, 0x1ea2, 0x1ea4, 0x1ea6, 0x1ea8, 0x1eaa, 0x1eac, 0x1eae, 0x1eb0, 0x1eb2, 0x1eb4, 0x1eb6, 0x1eb8, 0x1eba, 0x1ebc, 0x1ebe, 0x1ec0, 0x1ec2, 0x1ec4, 0x1ec6, 0x1ec8, 0x1eca, 0x1ecc, 0x1ece, 0x1ed0, 0x1ed2, 0x1ed4, 0x1ed6, 0x1ed8, 0x1eda, 0x1edc, 0x1ede, 0x1ee0, 0x1ee2, 0x1ee4, 0x1ee6, 0x1ee8, 0x1eea, 0x1eec, 0x1eee, 0x1ef0, 0x1ef2, 0x1ef4, 0x1ef6, 0x1ef8, 0x1efa, 0x1efc, 0x1efe, 0x1f08, 0x1f09, 0x1f0a, 0x1f0b, 0x1f0c, 0x1f0d, 0x1f0e, 0x1f0f, 0x1f18, 0x1f19, 0x1f1a, 0x1f1b, 0x1f1c, 0x1f1d, 0x1f28, 0x1f29, 0x1f2a, 0x1f2b, 0x1f2c, 0x1f2d, 0x1f2e, 0x1f2f, 0x1f38, 0x1f39, 0x1f3a, 0x1f3b, 0x1f3c, 0x1f3d, 0x1f3e, 0x1f3f, 0x1f48, 0x1f49, 0x1f4a, 0x1f4b, 0x1f4c, 0x1f4d, 0x1f50, 0x1f52, 0x1f54, 0x1f56, 0x1f59, 0x1f5b, 0x1f5d, 0x1f5f, 0x1f68, 0x1f69, 0x1f6a, 0x1f6b, 0x1f6c, 0x1f6d, 0x1f6e, 0x1f6f, 0x1f80, 0x1f81, 0x1f82, 0x1f83, 0x1f84, 0x1f85, 0x1f86, 0x1f87, 0x1f88, 0x1f89, 0x1f8a, 0x1f8b, 0x1f8c, 0x1f8d, 0x1f8e, 0x1f8f, 0x1f90, 0x1f91, 0x1f92, 0x1f93, 0x1f94, 0x1f95, 0x1f96, 0x1f97, 0x1f98, 0x1f99, 0x1f9a, 0x1f9b, 0x1f9c, 0x1f9d, 0x1f9e, 0x1f9f, 0x1fa0, 0x1fa1, 0x1fa2, 0x1fa3, 0x1fa4, 0x1fa5, 0x1fa6, 0x1fa7, 0x1fa8, 0x1fa9, 0x1faa, 0x1fab, 0x1fac, 0x1fad, 0x1fae, 0x1faf, 0x1fb2, 0x1fb3, 0x1fb4, 0x1fb6, 0x1fb7, 0x1fb8, 0x1fb9, 0x1fba, 0x1fbb, 0x1fbc, 0x1fbe, 0x1fc2, 0x1fc3, 0x1fc4, 0x1fc6, 0x1fc7, 0x1fc8, 0x1fc9, 0x1fca, 0x1fcb, 0x1fcc, 0x1fd2, 0x1fd3, 0x1fd6, 0x1fd7, 0x1fd8, 0x1fd9, 0x1fda, 0x1fdb, 0x1fe2, 0x1fe3, 0x1fe4, 0x1fe6, 0x1fe7, 0x1fe8, 0x1fe9, 0x1fea, 0x1feb, 0x1fec, 0x1ff2, 0x1ff3, 0x1ff4, 0x1ff6, 0x1ff7, 0x1ff8, 0x1ff9, 0x1ffa, 0x1ffb, 0x1ffc, 0x2126, 0x212a, 0x212b, 0x2132, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216a, 0x216b, 0x216c, 0x216d, 0x216e, 0x216f, 0x2183, 0x24b6, 0x24b7, 0x24b8, 0x24b9, 0x24ba, 0x24bb, 0x24bc, 0x24bd, 0x24be, 0x24bf, 0x24c0, 0x24c1, 0x24c2, 0x24c3, 0x24c4, 0x24c5, 0x24c6, 0x24c7, 0x24c8, 0x24c9, 0x24ca, 0x24cb, 0x24cc, 0x24cd, 0x24ce, 0x24cf, 0x2c00, 0x2c01, 0x2c02, 0x2c03, 0x2c04, 0x2c05, 0x2c06, 0x2c07, 0x2c08, 0x2c09, 0x2c0a, 0x2c0b, 0x2c0c, 0x2c0d, 0x2c0e, 0x2c0f, 0x2c10, 0x2c11, 0x2c12, 0x2c13, 0x2c14, 0x2c15, 0x2c16, 0x2c17, 0x2c18, 0x2c19, 0x2c1a, 0x2c1b, 0x2c1c, 0x2c1d, 0x2c1e, 0x2c1f, 0x2c20, 0x2c21, 0x2c22, 0x2c23, 0x2c24, 0x2c25, 0x2c26, 0x2c27, 0x2c28, 0x2c29, 0x2c2a, 0x2c2b, 0x2c2c, 0x2c2d, 0x2c2e, 0x2c2f, 0x2c60, 0x2c62, 0x2c63, 0x2c64, 0x2c67, 0x2c69, 0x2c6b, 0x2c6d, 0x2c6e, 0x2c6f, 0x2c70, 0x2c72, 0x2c75, 0x2c7e, 0x2c7f, 0x2c80, 0x2c82, 0x2c84, 0x2c86, 0x2c88, 0x2c8a, 0x2c8c, 0x2c8e, 0x2c90, 0x2c92, 0x2c94, 0x2c96, 0x2c98, 0x2c9a, 0x2c9c, 0x2c9e, 0x2ca0, 0x2ca2, 0x2ca4, 0x2ca6, 0x2ca8, 0x2caa, 0x2cac, 0x2cae, 0x2cb0, 0x2cb2, 0x2cb4, 0x2cb6, 0x2cb8, 0x2cba, 0x2cbc, 0x2cbe, 0x2cc0, 0x2cc2, 0x2cc4, 0x2cc6, 0x2cc8, 0x2cca, 0x2ccc, 0x2cce, 0x2cd0, 0x2cd2, 0x2cd4, 0x2cd6, 0x2cd8, 0x2cda, 0x2cdc, 0x2cde, 0x2ce0, 0x2ce2, 0x2ceb, 0x2ced, 0x2cf2, 0xa640, 0xa642, 0xa644, 0xa646, 0xa648, 0xa64a, 0xa64c, 0xa64e, 0xa650, 0xa652, 0xa654, 0xa656, 0xa658, 0xa65a, 0xa65c, 0xa65e, 0xa660, 0xa662, 0xa664, 0xa666, 0xa668, 0xa66a, 0xa66c, 0xa680, 0xa682, 0xa684, 0xa686, 0xa688, 0xa68a, 0xa68c, 0xa68e, 0xa690, 0xa692, 0xa694, 0xa696, 0xa698, 0xa69a, 0xa722, 0xa724, 0xa726, 0xa728, 0xa72a, 0xa72c, 0xa72e, 0xa732, 0xa734, 0xa736, 0xa738, 0xa73a, 0xa73c, 0xa73e, 0xa740, 0xa742, 0xa744, 0xa746, 0xa748, 0xa74a, 0xa74c, 0xa74e, 0xa750, 0xa752, 0xa754, 0xa756, 0xa758, 0xa75a, 0xa75c, 0xa75e, 0xa760, 0xa762, 0xa764, 0xa766, 0xa768, 0xa76a, 0xa76c, 0xa76e, 0xa779, 0xa77b, 0xa77d, 0xa77e, 0xa780, 0xa782, 0xa784, 0xa786, 0xa78b, 0xa78d, 0xa790, 0xa792, 0xa796, 0xa798, 0xa79a, 0xa79c, 0xa79e, 0xa7a0, 0xa7a2, 0xa7a4, 0xa7a6, 0xa7a8, 0xa7aa, 0xa7ab, 0xa7ac, 0xa7ad, 0xa7ae, 0xa7b0, 0xa7b1, 0xa7b2, 0xa7b3, 0xa7b4, 0xa7b6, 0xa7b8, 0xa7ba, 0xa7bc, 0xa7be, 0xa7c0, 0xa7c2, 0xa7c4, 0xa7c5, 0xa7c6, 0xa7c7, 0xa7c9, 0xa7d0, 0xa7d6, 0xa7d8, 0xa7f5, 0xab70, 0xab71, 0xab72, 0xab73, 0xab74, 0xab75, 0xab76, 0xab77, 0xab78, 0xab79, 0xab7a, 0xab7b, 0xab7c, 0xab7d, 0xab7e, 0xab7f, 0xab80, 0xab81, 0xab82, 0xab83, 0xab84, 0xab85, 0xab86, 0xab87, 0xab88, 0xab89, 0xab8a, 0xab8b, 0xab8c, 0xab8d, 0xab8e, 0xab8f, 0xab90, 0xab91, 0xab92, 0xab93, 0xab94, 0xab95, 0xab96, 0xab97, 0xab98, 0xab99, 0xab9a, 0xab9b, 0xab9c, 0xab9d, 0xab9e, 0xab9f, 0xaba0, 0xaba1, 0xaba2, 0xaba3, 0xaba4, 0xaba5, 0xaba6, 0xaba7, 0xaba8, 0xaba9, 0xabaa, 0xabab, 0xabac, 0xabad, 0xabae, 0xabaf, 0xabb0, 0xabb1, 0xabb2, 0xabb3, 0xabb4, 0xabb5, 0xabb6, 0xabb7, 0xabb8, 0xabb9, 0xabba, 0xabbb, 0xabbc, 0xabbd, 0xabbe, 0xabbf, 0xfb00, 0xfb01, 0xfb02, 0xfb03, 0xfb04, 0xfb05, 0xfb06, 0xfb13, 0xfb14, 0xfb15, 0xfb16, 0xfb17, 0xff21, 0xff22, 0xff23, 0xff24, 0xff25, 0xff26, 0xff27, 0xff28, 0xff29, 0xff2a, 0xff2b, 0xff2c, 0xff2d, 0xff2e, 0xff2f, 0xff30, 0xff31, 0xff32, 0xff33, 0xff34, 0xff35, 0xff36, 0xff37, 0xff38, 0xff39, 0xff3a, 0x10400, 0x10401, 0x10402, 0x10403, 0x10404, 0x10405, 0x10406, 0x10407, 0x10408, 0x10409, 0x1040a, 0x1040b, 0x1040c, 0x1040d, 0x1040e, 0x1040f, 0x10410, 0x10411, 0x10412, 0x10413, 0x10414, 0x10415, 0x10416, 0x10417, 0x10418, 0x10419, 0x1041a, 0x1041b, 0x1041c, 0x1041d, 0x1041e, 0x1041f, 0x10420, 0x10421, 0x10422, 0x10423, 0x10424, 0x10425, 0x10426, 0x10427, 0x104b0, 0x104b1, 0x104b2, 0x104b3, 0x104b4, 0x104b5, 0x104b6, 0x104b7, 0x104b8, 0x104b9, 0x104ba, 0x104bb, 0x104bc, 0x104bd, 0x104be, 0x104bf, 0x104c0, 0x104c1, 0x104c2, 0x104c3, 0x104c4, 0x104c5, 0x104c6, 0x104c7, 0x104c8, 0x104c9, 0x104ca, 0x104cb, 0x104cc, 0x104cd, 0x104ce, 0x104cf, 0x104d0, 0x104d1, 0x104d2, 0x104d3, 0x10570, 0x10571, 0x10572, 0x10573, 0x10574, 0x10575, 0x10576, 0x10577, 0x10578, 0x10579, 0x1057a, 0x1057c, 0x1057d, 0x1057e, 0x1057f, 0x10580, 0x10581, 0x10582, 0x10583, 0x10584, 0x10585, 0x10586, 0x10587, 0x10588, 0x10589, 0x1058a, 0x1058c, 0x1058d, 0x1058e, 0x1058f, 0x10590, 0x10591, 0x10592, 0x10594, 0x10595, 0x10c80, 0x10c81, 0x10c82, 0x10c83, 0x10c84, 0x10c85, 0x10c86, 0x10c87, 0x10c88, 0x10c89, 0x10c8a, 0x10c8b, 0x10c8c, 0x10c8d, 0x10c8e, 0x10c8f, 0x10c90, 0x10c91, 0x10c92, 0x10c93, 0x10c94, 0x10c95, 0x10c96, 0x10c97, 0x10c98, 0x10c99, 0x10c9a, 0x10c9b, 0x10c9c, 0x10c9d, 0x10c9e, 0x10c9f, 0x10ca0, 0x10ca1, 0x10ca2, 0x10ca3, 0x10ca4, 0x10ca5, 0x10ca6, 0x10ca7, 0x10ca8, 0x10ca9, 0x10caa, 0x10cab, 0x10cac, 0x10cad, 0x10cae, 0x10caf, 0x10cb0, 0x10cb1, 0x10cb2, 0x118a0, 0x118a1, 0x118a2, 0x118a3, 0x118a4, 0x118a5, 0x118a6, 0x118a7, 0x118a8, 0x118a9, 0x118aa, 0x118ab, 0x118ac, 0x118ad, 0x118ae, 0x118af, 0x118b0, 0x118b1, 0x118b2, 0x118b3, 0x118b4, 0x118b5, 0x118b6, 0x118b7, 0x118b8, 0x118b9, 0x118ba, 0x118bb, 0x118bc, 0x118bd, 0x118be, 0x118bf, 0x16e40, 0x16e41, 0x16e42, 0x16e43, 0x16e44, 0x16e45, 0x16e46, 0x16e47, 0x16e48, 0x16e49, 0x16e4a, 0x16e4b, 0x16e4c, 0x16e4d, 0x16e4e, 0x16e4f, 0x16e50, 0x16e51, 0x16e52, 0x16e53, 0x16e54, 0x16e55, 0x16e56, 0x16e57, 0x16e58, 0x16e59, 0x16e5a, 0x16e5b, 0x16e5c, 0x16e5d, 0x16e5e, 0x16e5f, 0x1e900, 0x1e901, 0x1e902, 0x1e903, 0x1e904, 0x1e905, 0x1e906, 0x1e907, 0x1e908, 0x1e909, 0x1e90a, 0x1e90b, 0x1e90c, 0x1e90d, 0x1e90e, 0x1e90f, 0x1e910, 0x1e911, 0x1e912, 0x1e913, 0x1e914, 0x1e915, 0x1e916, 0x1e917, 0x1e918, 0x1e919, 0x1e91a, 0x1e91b, 0x1e91c, 0x1e91d, 0x1e91e, 0x1e91f, 0x1e920, 0x1e921}
var _unicodeCaseFoldingTo = [...]rune{97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 956, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 248, 249, 250, 251, 252, 253, 254, 115, 115, 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 105, 775, 307, 309, 311, 314, 316, 318, 320, 322, 324, 326, 328, 700, 110, 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 255, 378, 380, 382, 115, 595, 387, 389, 596, 392, 598, 599, 396, 477, 601, 603, 402, 608, 611, 617, 616, 409, 623, 626, 629, 417, 419, 421, 640, 424, 643, 429, 648, 432, 650, 651, 436, 438, 658, 441, 445, 454, 454, 457, 457, 460, 460, 462, 464, 466, 468, 470, 472, 474, 476, 479, 481, 483, 485, 487, 489, 491, 493, 495, 106, 780, 499, 499, 501, 405, 447, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 414, 547, 549, 551, 553, 555, 557, 559, 561, 563, 11365, 572, 410, 11366, 578, 384, 649, 652, 583, 585, 587, 589, 591, 953, 881, 883, 887, 1011, 940, 941, 942, 943, 972, 973, 974, 953, 776, 769, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969, 970, 971, 965, 776, 769, 963, 983, 946, 952, 966, 960, 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, 1007, 954, 961, 952, 949, 1016, 1010, 1019, 891, 892, 893, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1231, 1218, 1220, 1222, 1224, 1226, 1228, 1230, 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1381, 1410, 11520, 11521, 11522, 11523, 11524, 11525, 11526, 11527, 11528, 11529, 11530, 11531, 11532, 11533, 11534, 11535, 11536, 11537, 11538, 11539, 11540, 11541, 11542, 11543, 11544, 11545, 11546, 11547, 11548, 11549, 11550, 11551, 11552, 11553, 11554, 11555, 11556, 11557, 11559, 11565, 5104, 5105, 5106, 5107, 5108, 5109, 1074, 1076, 1086, 1089, 1090, 1090, 1098, 1123, 42571, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4349, 4350, 4351, 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, 7829, 104, 817, 116, 776, 119, 778, 121, 778, 97, 702, 7777, 115, 115, 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, 7935, 7936, 7937, 7938, 7939, 7940, 7941, 7942, 7943, 7952, 7953, 7954, 7955, 7956, 7957, 7968, 7969, 7970, 7971, 7972, 7973, 7974, 7975, 7984, 7985, 7986, 7987, 7988, 7989, 7990, 7991, 8000, 8001, 8002, 8003, 8004, 8005, 965, 787, 965, 787, 768, 965, 787, 769, 965, 787, 834, 8017, 8019, 8021, 8023, 8032, 8033, 8034, 8035, 8036, 8037, 8038, 8039, 7936, 953, 7937, 953, 7938, 953, 7939, 953, 7940, 953, 7941, 953, 7942, 953, 7943, 953, 7936, 953, 7937, 953, 7938, 953, 7939, 953, 7940, 953, 7941, 953, 7942, 953, 7943, 953, 7968, 953, 7969, 953, 7970, 953, 7971, 953, 7972, 953, 7973, 953, 7974, 953, 7975, 953, 7968, 953, 7969, 953, 7970, 953, 7971, 953, 7972, 953, 7973, 953, 7974, 953, 7975, 953, 8032, 953, 8033, 953, 8034, 953, 8035, 953, 8036, 953, 8037, 953, 8038, 953, 8039, 953, 8032, 953, 8033, 953, 8034, 953, 8035, 953, 8036, 953, 8037, 953, 8038, 953, 8039, 953, 8048, 953, 945, 953, 940, 953, 945, 834, 945, 834, 953, 8112, 8113, 8048, 8049, 945, 953, 953, 8052, 953, 951, 953, 942, 953, 951, 834, 951, 834, 953, 8050, 8051, 8052, 8053, 951, 953, 953, 776, 768, 953, 776, 769, 953, 834, 953, 776, 834, 8144, 8145, 8054, 8055, 965, 776, 768, 965, 776, 769, 961, 787, 965, 834, 965, 776, 834, 8160, 8161, 8058, 8059, 8165, 8060, 953, 969, 953, 974, 953, 969, 834, 969, 834, 953, 8056, 8057, 8060, 8061, 969, 953, 969, 107, 229, 8526, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 8570, 8571, 8572, 8573, 8574, 8575, 8580, 9424, 9425, 9426, 9427, 9428, 9429, 9430, 9431, 9432, 9433, 9434, 9435, 9436, 9437, 9438, 9439, 9440, 9441, 9442, 9443, 9444, 9445, 9446, 9447, 9448, 9449, 11312, 11313, 11314, 11315, 11316, 11317, 11318, 11319, 11320, 11321, 11322, 11323, 11324, 11325, 11326, 11327, 11328, 11329, 11330, 11331, 11332, 11333, 11334, 11335, 11336, 11337, 11338, 11339, 11340, 11341, 11342, 11343, 11344, 11345, 11346, 11347, 11348, 11349, 11350, 11351, 11352, 11353, 11354, 11355, 11356, 11357, 11358, 11359, 11361, 619, 7549, 637, 11368, 11370, 11372, 593, 625, 592, 594, 11379, 11382, 575, 576, 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, 11491, 11500, 11502, 11507, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42651, 42787, 42789, 42791, 42793, 42795, 42797, 42799, 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42863, 42874, 42876, 7545, 42879, 42881, 42883, 42885, 42887, 42892, 613, 42897, 42899, 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 614, 604, 609, 620, 618, 670, 647, 669, 43859, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42900, 642, 7566, 42952, 42954, 42961, 42967, 42969, 42998, 5024, 5025, 5026, 5027, 5028, 5029, 5030, 5031, 5032, 5033, 5034, 5035, 5036, 5037, 5038, 5039, 5040, 5041, 5042, 5043, 5044, 5045, 5046, 5047, 5048, 5049, 5050, 5051, 5052, 5053, 5054, 5055, 5056, 5057, 5058, 5059, 5060, 5061, 5062, 5063, 5064, 5065, 5066, 5067, 5068, 5069, 5070, 5071, 5072, 5073, 5074, 5075, 5076, 5077, 5078, 5079, 5080, 5081, 5082, 5083, 5084, 5085, 5086, 5087, 5088, 5089, 5090, 5091, 5092, 5093, 5094, 5095, 5096, 5097, 5098, 5099, 5100, 5101, 5102, 5103, 102, 102, 102, 105, 102, 108, 102, 102, 105, 102, 102, 108, 115, 116, 115, 116, 1396, 1398, 1396, 1381, 1396, 1387, 1406, 1398, 1396, 1389, 65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, 66600, 66601, 66602, 66603, 66604, 66605, 66606, 66607, 66608, 66609, 66610, 66611, 66612, 66613, 66614, 66615, 66616, 66617, 66618, 66619, 66620, 66621, 66622, 66623, 66624, 66625, 66626, 66627, 66628, 66629, 66630, 66631, 66632, 66633, 66634, 66635, 66636, 66637, 66638, 66639, 66776, 66777, 66778, 66779, 66780, 66781, 66782, 66783, 66784, 66785, 66786, 66787, 66788, 66789, 66790, 66791, 66792, 66793, 66794, 66795, 66796, 66797, 66798, 66799, 66800, 66801, 66802, 66803, 66804, 66805, 66806, 66807, 66808, 66809, 66810, 66811, 66967, 66968, 66969, 66970, 66971, 66972, 66973, 66974, 66975, 66976, 66977, 66979, 66980, 66981, 66982, 66983, 66984, 66985, 66986, 66987, 66988, 66989, 66990, 66991, 66992, 66993, 66995, 66996, 66997, 66998, 66999, 67000, 67001, 67003, 67004, 68800, 68801, 68802, 68803, 68804, 68805, 68806, 68807, 68808, 68809, 68810, 68811, 68812, 68813, 68814, 68815, 68816, 68817, 68818, 68819, 68820, 68821, 68822, 68823, 68824, 68825, 68826, 68827, 68828, 68829, 68830, 68831, 68832, 68833, 68834, 68835, 68836, 68837, 68838, 68839, 68840, 68841, 68842, 68843, 68844, 68845, 68846, 68847, 68848, 68849, 68850, 71872, 71873, 71874, 71875, 71876, 71877, 71878, 71879, 71880, 71881, 71882, 71883, 71884, 71885, 71886, 71887, 71888, 71889, 71890, 71891, 71892, 71893, 71894, 71895, 71896, 71897, 71898, 71899, 71900, 71901, 71902, 71903, 93792, 93793, 93794, 93795, 93796, 93797, 93798, 93799, 93800, 93801, 93802, 93803, 93804, 93805, 93806, 93807, 93808, 93809, 93810, 93811, 93812, 93813, 93814, 93815, 93816, 93817, 93818, 93819, 93820, 93821, 93822, 93823, 125218, 125219, 125220, 125221, 125222, 125223, 125224, 125225, 125226, 125227, 125228, 125229, 125230, 125231, 125232, 125233, 125234, 125235, 125236, 125237, 125238, 125239, 125240, 125241, 125242, 125243, 125244, 125245, 125246, 125247, 125248, 125249, 125250, 125251}
var _unicodeCaseFoldingToIndex  = "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x03\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x03\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x03\x03\x03\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x01\x01\x01\x01\x02\x01\x02\x02\x02\x02\x03\x01\x01\x01\x01\x02\x03\x03\x02\x03\x01\x01\x01\x01\x03\x03\x02\x02\x03\x01\x01\x01\x01\x01\x02\x02\x02\x02\x03\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x03\x03\x02\x02\x02\x02\x02\x02\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01"
</file>

<file path="util/util_cjk.go">
package util

import "unicode"

var cjkRadicalsSupplement = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x2E80, 0x2EFF, 1},
	},
}

var kangxiRadicals = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x2F00, 0x2FDF, 1},
	},
}

var ideographicDescriptionCharacters = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x2FF0, 0x2FFF, 1},
	},
}

var cjkSymbolsAndPunctuation = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x3000, 0x303F, 1},
	},
}

var hiragana = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x3040, 0x309F, 1},
	},
}

var katakana = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x30A0, 0x30FF, 1},
	},
}

var kanbun = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x3130, 0x318F, 1},
		{0x3190, 0x319F, 1},
	},
}

var cjkStrokes = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x31C0, 0x31EF, 1},
	},
}

var katakanaPhoneticExtensions = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x31F0, 0x31FF, 1},
	},
}

var cjkCompatibility = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x3300, 0x33FF, 1},
	},
}

var cjkUnifiedIdeographsExtensionA = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x3400, 0x4DBF, 1},
	},
}

var cjkUnifiedIdeographs = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x4E00, 0x9FFF, 1},
	},
}

var yiSyllables = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0xA000, 0xA48F, 1},
	},
}

var yiRadicals = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0xA490, 0xA4CF, 1},
	},
}

var cjkCompatibilityIdeographs = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0xF900, 0xFAFF, 1},
	},
}

var verticalForms = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0xFE10, 0xFE1F, 1},
	},
}

var cjkCompatibilityForms = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0xFE30, 0xFE4F, 1},
	},
}

var smallFormVariants = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0xFE50, 0xFE6F, 1},
	},
}

var halfwidthAndFullwidthForms = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0xFF00, 0xFFEF, 1},
	},
}

var kanaSupplement = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x1B000, 0x1B0FF, 1},
	},
}

var kanaExtendedA = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x1B100, 0x1B12F, 1},
	},
}

var smallKanaExtension = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x1B130, 0x1B16F, 1},
	},
}

var cjkUnifiedIdeographsExtensionB = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x20000, 0x2A6DF, 1},
	},
}

var cjkUnifiedIdeographsExtensionC = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x2A700, 0x2B73F, 1},
	},
}

var cjkUnifiedIdeographsExtensionD = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x2B740, 0x2B81F, 1},
	},
}

var cjkUnifiedIdeographsExtensionE = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x2B820, 0x2CEAF, 1},
	},
}

var cjkUnifiedIdeographsExtensionF = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x2CEB0, 0x2EBEF, 1},
	},
}

var cjkCompatibilityIdeographsSupplement = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x2F800, 0x2FA1F, 1},
	},
}

var cjkUnifiedIdeographsExtensionG = &unicode.RangeTable{
	R32: []unicode.Range32{
		{0x30000, 0x3134F, 1},
	},
}

// IsEastAsianWideRune returns trhe if the given rune is an east asian wide character, otherwise false.
func IsEastAsianWideRune(r rune) bool {
	return unicode.Is(unicode.Hiragana, r) ||
		unicode.Is(unicode.Katakana, r) ||
		unicode.Is(unicode.Han, r) ||
		unicode.Is(unicode.Lm, r) ||
		unicode.Is(unicode.Hangul, r) ||
		unicode.Is(cjkSymbolsAndPunctuation, r)
}

// IsSpaceDiscardingUnicodeRune returns true if the given rune is space-discarding unicode character, otherwise false.
// See https://www.w3.org/TR/2020/WD-css-text-3-20200429/#space-discard-set
func IsSpaceDiscardingUnicodeRune(r rune) bool {
	return unicode.Is(cjkRadicalsSupplement, r) ||
		unicode.Is(kangxiRadicals, r) ||
		unicode.Is(ideographicDescriptionCharacters, r) ||
		unicode.Is(cjkSymbolsAndPunctuation, r) ||
		unicode.Is(hiragana, r) ||
		unicode.Is(katakana, r) ||
		unicode.Is(kanbun, r) ||
		unicode.Is(cjkStrokes, r) ||
		unicode.Is(katakanaPhoneticExtensions, r) ||
		unicode.Is(cjkCompatibility, r) ||
		unicode.Is(cjkUnifiedIdeographsExtensionA, r) ||
		unicode.Is(cjkUnifiedIdeographs, r) ||
		unicode.Is(yiSyllables, r) ||
		unicode.Is(yiRadicals, r) ||
		unicode.Is(cjkCompatibilityIdeographs, r) ||
		unicode.Is(verticalForms, r) ||
		unicode.Is(cjkCompatibilityForms, r) ||
		unicode.Is(smallFormVariants, r) ||
		unicode.Is(halfwidthAndFullwidthForms, r) ||
		unicode.Is(kanaSupplement, r) ||
		unicode.Is(kanaExtendedA, r) ||
		unicode.Is(smallKanaExtension, r) ||
		unicode.Is(cjkUnifiedIdeographsExtensionB, r) ||
		unicode.Is(cjkUnifiedIdeographsExtensionC, r) ||
		unicode.Is(cjkUnifiedIdeographsExtensionD, r) ||
		unicode.Is(cjkUnifiedIdeographsExtensionE, r) ||
		unicode.Is(cjkUnifiedIdeographsExtensionF, r) ||
		unicode.Is(cjkCompatibilityIdeographsSupplement, r) ||
		unicode.Is(cjkUnifiedIdeographsExtensionG, r)
}

// EastAsianWidth returns the east asian width of the given rune.
// See https://www.unicode.org/reports/tr11/tr11-36.html
func EastAsianWidth(r rune) string {
	switch {
	case r == 0x3000,
		(0xFF01 <= r && r <= 0xFF60),
		(0xFFE0 <= r && r <= 0xFFE6):
		return "F"

	case r == 0x20A9,
		(0xFF61 <= r && r <= 0xFFBE),
		(0xFFC2 <= r && r <= 0xFFC7),
		(0xFFCA <= r && r <= 0xFFCF),
		(0xFFD2 <= r && r <= 0xFFD7),
		(0xFFDA <= r && r <= 0xFFDC),
		(0xFFE8 <= r && r <= 0xFFEE):
		return "H"

	case (0x1100 <= r && r <= 0x115F),
		(0x11A3 <= r && r <= 0x11A7),
		(0x11FA <= r && r <= 0x11FF),
		(0x2329 <= r && r <= 0x232A),
		(0x2E80 <= r && r <= 0x2E99),
		(0x2E9B <= r && r <= 0x2EF3),
		(0x2F00 <= r && r <= 0x2FD5),
		(0x2FF0 <= r && r <= 0x2FFB),
		(0x3001 <= r && r <= 0x303E),
		(0x3041 <= r && r <= 0x3096),
		(0x3099 <= r && r <= 0x30FF),
		(0x3105 <= r && r <= 0x312D),
		(0x3131 <= r && r <= 0x318E),
		(0x3190 <= r && r <= 0x31BA),
		(0x31C0 <= r && r <= 0x31E3),
		(0x31F0 <= r && r <= 0x321E),
		(0x3220 <= r && r <= 0x3247),
		(0x3250 <= r && r <= 0x32FE),
		(0x3300 <= r && r <= 0x4DBF),
		(0x4E00 <= r && r <= 0xA48C),
		(0xA490 <= r && r <= 0xA4C6),
		(0xA960 <= r && r <= 0xA97C),
		(0xAC00 <= r && r <= 0xD7A3),
		(0xD7B0 <= r && r <= 0xD7C6),
		(0xD7CB <= r && r <= 0xD7FB),
		(0xF900 <= r && r <= 0xFAFF),
		(0xFE10 <= r && r <= 0xFE19),
		(0xFE30 <= r && r <= 0xFE52),
		(0xFE54 <= r && r <= 0xFE66),
		(0xFE68 <= r && r <= 0xFE6B),
		(0x1B000 <= r && r <= 0x1B001),
		(0x1F200 <= r && r <= 0x1F202),
		(0x1F210 <= r && r <= 0x1F23A),
		(0x1F240 <= r && r <= 0x1F248),
		(0x1F250 <= r && r <= 0x1F251),
		(0x20000 <= r && r <= 0x2F73F),
		(0x2B740 <= r && r <= 0x2FFFD),
		(0x30000 <= r && r <= 0x3FFFD):
		return "W"

	case (0x0020 <= r && r <= 0x007E),
		(0x00A2 <= r && r <= 0x00A3),
		(0x00A5 <= r && r <= 0x00A6),
		r == 0x00AC,
		r == 0x00AF,
		(0x27E6 <= r && r <= 0x27ED),
		(0x2985 <= r && r <= 0x2986):
		return "Na"

	case (0x00A1 == r),
		(0x00A4 == r),
		(0x00A7 <= r && r <= 0x00A8),
		(0x00AA == r),
		(0x00AD <= r && r <= 0x00AE),
		(0x00B0 <= r && r <= 0x00B4),
		(0x00B6 <= r && r <= 0x00BA),
		(0x00BC <= r && r <= 0x00BF),
		(0x00C6 == r),
		(0x00D0 == r),
		(0x00D7 <= r && r <= 0x00D8),
		(0x00DE <= r && r <= 0x00E1),
		(0x00E6 == r),
		(0x00E8 <= r && r <= 0x00EA),
		(0x00EC <= r && r <= 0x00ED),
		(0x00F0 == r),
		(0x00F2 <= r && r <= 0x00F3),
		(0x00F7 <= r && r <= 0x00FA),
		(0x00FC == r),
		(0x00FE == r),
		(0x0101 == r),
		(0x0111 == r),
		(0x0113 == r),
		(0x011B == r),
		(0x0126 <= r && r <= 0x0127),
		(0x012B == r),
		(0x0131 <= r && r <= 0x0133),
		(0x0138 == r),
		(0x013F <= r && r <= 0x0142),
		(0x0144 == r),
		(0x0148 <= r && r <= 0x014B),
		(0x014D == r),
		(0x0152 <= r && r <= 0x0153),
		(0x0166 <= r && r <= 0x0167),
		(0x016B == r),
		(0x01CE == r),
		(0x01D0 == r),
		(0x01D2 == r),
		(0x01D4 == r),
		(0x01D6 == r),
		(0x01D8 == r),
		(0x01DA == r),
		(0x01DC == r),
		(0x0251 == r),
		(0x0261 == r),
		(0x02C4 == r),
		(0x02C7 == r),
		(0x02C9 <= r && r <= 0x02CB),
		(0x02CD == r),
		(0x02D0 == r),
		(0x02D8 <= r && r <= 0x02DB),
		(0x02DD == r),
		(0x02DF == r),
		(0x0300 <= r && r <= 0x036F),
		(0x0391 <= r && r <= 0x03A1),
		(0x03A3 <= r && r <= 0x03A9),
		(0x03B1 <= r && r <= 0x03C1),
		(0x03C3 <= r && r <= 0x03C9),
		(0x0401 == r),
		(0x0410 <= r && r <= 0x044F),
		(0x0451 == r),
		(0x2010 == r),
		(0x2013 <= r && r <= 0x2016),
		(0x2018 <= r && r <= 0x2019),
		(0x201C <= r && r <= 0x201D),
		(0x2020 <= r && r <= 0x2022),
		(0x2024 <= r && r <= 0x2027),
		(0x2030 == r),
		(0x2032 <= r && r <= 0x2033),
		(0x2035 == r),
		(0x203B == r),
		(0x203E == r),
		(0x2074 == r),
		(0x207F == r),
		(0x2081 <= r && r <= 0x2084),
		(0x20AC == r),
		(0x2103 == r),
		(0x2105 == r),
		(0x2109 == r),
		(0x2113 == r),
		(0x2116 == r),
		(0x2121 <= r && r <= 0x2122),
		(0x2126 == r),
		(0x212B == r),
		(0x2153 <= r && r <= 0x2154),
		(0x215B <= r && r <= 0x215E),
		(0x2160 <= r && r <= 0x216B),
		(0x2170 <= r && r <= 0x2179),
		(0x2189 == r),
		(0x2190 <= r && r <= 0x2199),
		(0x21B8 <= r && r <= 0x21B9),
		(0x21D2 == r),
		(0x21D4 == r),
		(0x21E7 == r),
		(0x2200 == r),
		(0x2202 <= r && r <= 0x2203),
		(0x2207 <= r && r <= 0x2208),
		(0x220B == r),
		(0x220F == r),
		(0x2211 == r),
		(0x2215 == r),
		(0x221A == r),
		(0x221D <= r && r <= 0x2220),
		(0x2223 == r),
		(0x2225 == r),
		(0x2227 <= r && r <= 0x222C),
		(0x222E == r),
		(0x2234 <= r && r <= 0x2237),
		(0x223C <= r && r <= 0x223D),
		(0x2248 == r),
		(0x224C == r),
		(0x2252 == r),
		(0x2260 <= r && r <= 0x2261),
		(0x2264 <= r && r <= 0x2267),
		(0x226A <= r && r <= 0x226B),
		(0x226E <= r && r <= 0x226F),
		(0x2282 <= r && r <= 0x2283),
		(0x2286 <= r && r <= 0x2287),
		(0x2295 == r),
		(0x2299 == r),
		(0x22A5 == r),
		(0x22BF == r),
		(0x2312 == r),
		(0x2460 <= r && r <= 0x24E9),
		(0x24EB <= r && r <= 0x254B),
		(0x2550 <= r && r <= 0x2573),
		(0x2580 <= r && r <= 0x258F),
		(0x2592 <= r && r <= 0x2595),
		(0x25A0 <= r && r <= 0x25A1),
		(0x25A3 <= r && r <= 0x25A9),
		(0x25B2 <= r && r <= 0x25B3),
		(0x25B6 <= r && r <= 0x25B7),
		(0x25BC <= r && r <= 0x25BD),
		(0x25C0 <= r && r <= 0x25C1),
		(0x25C6 <= r && r <= 0x25C8),
		(0x25CB == r),
		(0x25CE <= r && r <= 0x25D1),
		(0x25E2 <= r && r <= 0x25E5),
		(0x25EF == r),
		(0x2605 <= r && r <= 0x2606),
		(0x2609 == r),
		(0x260E <= r && r <= 0x260F),
		(0x2614 <= r && r <= 0x2615),
		(0x261C == r),
		(0x261E == r),
		(0x2640 == r),
		(0x2642 == r),
		(0x2660 <= r && r <= 0x2661),
		(0x2663 <= r && r <= 0x2665),
		(0x2667 <= r && r <= 0x266A),
		(0x266C <= r && r <= 0x266D),
		(0x266F == r),
		(0x269E <= r && r <= 0x269F),
		(0x26BE <= r && r <= 0x26BF),
		(0x26C4 <= r && r <= 0x26CD),
		(0x26CF <= r && r <= 0x26E1),
		(0x26E3 == r),
		(0x26E8 <= r && r <= 0x26FF),
		(0x273D == r),
		(0x2757 == r),
		(0x2776 <= r && r <= 0x277F),
		(0x2B55 <= r && r <= 0x2B59),
		(0x3248 <= r && r <= 0x324F),
		(0xE000 <= r && r <= 0xF8FF),
		(0xFE00 <= r && r <= 0xFE0F),
		(0xFFFD == r),
		(0x1F100 <= r && r <= 0x1F10A),
		(0x1F110 <= r && r <= 0x1F12D),
		(0x1F130 <= r && r <= 0x1F169),
		(0x1F170 <= r && r <= 0x1F19A),
		(0xE0100 <= r && r <= 0xE01EF),
		(0xF0000 <= r && r <= 0xFFFFD),
		(0x100000 <= r && r <= 0x10FFFD):
		return "A"

	default:
		return "N"
	}
}
</file>

<file path="util/util_safe.go">
//go:build appengine || js
// +build appengine js

package util

// BytesToReadOnlyString returns a string converted from given bytes.
func BytesToReadOnlyString(b []byte) string {
	return string(b)
}

// StringToReadOnlyBytes returns bytes converted from given string.
func StringToReadOnlyBytes(s string) []byte {
	return []byte(s)
}
</file>

<file path="util/util_unsafe_go120.go">
//go:build !appengine && !js && !go1.21
// +build !appengine,!js,!go1.21

package util

import (
	"reflect"
	"unsafe"
)

// BytesToReadOnlyString returns a string converted from given bytes.
func BytesToReadOnlyString(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}

// StringToReadOnlyBytes returns bytes converted from given string.
func StringToReadOnlyBytes(s string) (bs []byte) {
	sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
	bh := (*reflect.SliceHeader)(unsafe.Pointer(&bs))
	bh.Data = sh.Data
	bh.Cap = sh.Len
	bh.Len = sh.Len
	return
}
</file>

<file path="util/util_unsafe_go121.go">
//go:build !appengine && !js && go1.21
// +build !appengine,!js,go1.21

package util

import (
	"unsafe"
)

// BytesToReadOnlyString returns a string converted from given bytes.
func BytesToReadOnlyString(b []byte) string {
	return unsafe.String(unsafe.SliceData(b), len(b))
}

// StringToReadOnlyBytes returns bytes converted from given string.
func StringToReadOnlyBytes(s string) []byte {
	return unsafe.Slice(unsafe.StringData(s), len(s))
}
</file>

<file path="commonmark_test.go">
package goldmark_test

import (
	"encoding/json"
	"os"
	"testing"

	. "github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
)

type commonmarkSpecTestCase struct {
	Markdown  string `json:"markdown"`
	HTML      string `json:"html"`
	Example   int    `json:"example"`
	StartLine int    `json:"start_line"`
	EndLine   int    `json:"end_line"`
	Section   string `json:"section"`
}

func TestSpec(t *testing.T) {
	bs, err := os.ReadFile("_test/spec.json")
	if err != nil {
		panic(err)
	}
	var testCases []commonmarkSpecTestCase
	if err := json.Unmarshal(bs, &testCases); err != nil {
		panic(err)
	}
	cases := []testutil.MarkdownTestCase{}
	nos := testutil.ParseCliCaseArg()
	for _, c := range testCases {
		shouldAdd := len(nos) == 0
		if !shouldAdd {
			for _, no := range nos {
				if c.Example == no {
					shouldAdd = true
					break
				}
			}
		}

		if shouldAdd {
			cases = append(cases, testutil.MarkdownTestCase{
				No:       c.Example,
				Markdown: c.Markdown,
				Expected: c.HTML,
			})
		}
	}
	markdown := New(WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))
	testutil.DoTestCases(markdown, cases, t)
}
</file>

<file path="markdown.go">
// Package goldmark implements functions to convert markdown text to a desired format.
package goldmark

import (
	"io"

	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

// DefaultParser returns a new Parser that is configured by default values.
func DefaultParser() parser.Parser {
	return parser.NewParser(parser.WithBlockParsers(parser.DefaultBlockParsers()...),
		parser.WithInlineParsers(parser.DefaultInlineParsers()...),
		parser.WithParagraphTransformers(parser.DefaultParagraphTransformers()...),
	)
}

// DefaultRenderer returns a new Renderer that is configured by default values.
func DefaultRenderer() renderer.Renderer {
	return renderer.NewRenderer(renderer.WithNodeRenderers(util.Prioritized(html.NewRenderer(), 1000)))
}

var defaultMarkdown = New()

// Convert interprets a UTF-8 bytes source in Markdown and
// write rendered contents to a writer w.
func Convert(source []byte, w io.Writer, opts ...parser.ParseOption) error {
	return defaultMarkdown.Convert(source, w, opts...)
}

// A Markdown interface offers functions to convert Markdown text to
// a desired format.
type Markdown interface {
	// Convert interprets a UTF-8 bytes source in Markdown and write rendered
	// contents to a writer w.
	Convert(source []byte, writer io.Writer, opts ...parser.ParseOption) error

	// Parser returns a Parser that will be used for conversion.
	Parser() parser.Parser

	// SetParser sets a Parser to this object.
	SetParser(parser.Parser)

	// Parser returns a Renderer that will be used for conversion.
	Renderer() renderer.Renderer

	// SetRenderer sets a Renderer to this object.
	SetRenderer(renderer.Renderer)
}

// Option is a functional option type for Markdown objects.
type Option func(*markdown)

// WithExtensions adds extensions.
func WithExtensions(ext ...Extender) Option {
	return func(m *markdown) {
		m.extensions = append(m.extensions, ext...)
	}
}

// WithParser allows you to override the default parser.
func WithParser(p parser.Parser) Option {
	return func(m *markdown) {
		m.parser = p
	}
}

// WithParserOptions applies options for the parser.
func WithParserOptions(opts ...parser.Option) Option {
	return func(m *markdown) {
		m.parser.AddOptions(opts...)
	}
}

// WithRenderer allows you to override the default renderer.
func WithRenderer(r renderer.Renderer) Option {
	return func(m *markdown) {
		m.renderer = r
	}
}

// WithRendererOptions applies options for the renderer.
func WithRendererOptions(opts ...renderer.Option) Option {
	return func(m *markdown) {
		m.renderer.AddOptions(opts...)
	}
}

type markdown struct {
	parser     parser.Parser
	renderer   renderer.Renderer
	extensions []Extender
}

// New returns a new Markdown with given options.
func New(options ...Option) Markdown {
	md := &markdown{
		parser:     DefaultParser(),
		renderer:   DefaultRenderer(),
		extensions: []Extender{},
	}
	for _, opt := range options {
		opt(md)
	}
	for _, e := range md.extensions {
		e.Extend(md)
	}
	return md
}

func (m *markdown) Convert(source []byte, writer io.Writer, opts ...parser.ParseOption) error {
	reader := text.NewReader(source)
	doc := m.parser.Parse(reader, opts...)
	return m.renderer.Render(writer, source, doc)
}

func (m *markdown) Parser() parser.Parser {
	return m.parser
}

func (m *markdown) SetParser(v parser.Parser) {
	m.parser = v
}

func (m *markdown) Renderer() renderer.Renderer {
	return m.renderer
}

func (m *markdown) SetRenderer(v renderer.Renderer) {
	m.renderer = v
}

// An Extender interface is used for extending Markdown.
type Extender interface {
	// Extend extends the Markdown.
	Extend(Markdown)
}
</file>

<file path="ast/ast_test.go">
package ast

import (
	"reflect"
	"testing"
)

func TestWalk(t *testing.T) {
	tests := []struct {
		name   string
		node   Node
		want   []NodeKind
		action map[NodeKind]WalkStatus
	}{
		{
			"visits all in depth first order",
			node(NewDocument(), node(NewHeading(1), NewText()), NewLink()),
			[]NodeKind{KindDocument, KindHeading, KindText, KindLink},
			map[NodeKind]WalkStatus{},
		},
		{
			"stops after heading",
			node(NewDocument(), node(NewHeading(1), NewText()), NewLink()),
			[]NodeKind{KindDocument, KindHeading},
			map[NodeKind]WalkStatus{KindHeading: WalkStop},
		},
		{
			"skip children",
			node(NewDocument(), node(NewHeading(1), NewText()), NewLink()),
			[]NodeKind{KindDocument, KindHeading, KindLink},
			map[NodeKind]WalkStatus{KindHeading: WalkSkipChildren},
		},
	}
	for _, tt := range tests {
		var kinds []NodeKind
		collectKinds := func(n Node, entering bool) (WalkStatus, error) {
			if entering {
				kinds = append(kinds, n.Kind())
			}
			if status, ok := tt.action[n.Kind()]; ok {
				return status, nil
			}
			return WalkContinue, nil
		}
		t.Run(tt.name, func(t *testing.T) {
			if err := Walk(tt.node, collectKinds); err != nil {
				t.Errorf("Walk() error = %v", err)
			} else if !reflect.DeepEqual(kinds, tt.want) {
				t.Errorf("Walk() expected = %v, got = %v", tt.want, kinds)
			}
		})
	}
}

func node(n Node, children ...Node) Node {
	for _, c := range children {
		n.AppendChild(n, c)
	}
	return n
}
</file>

<file path="extension/_test/strikethrough.txt">
1
//- - - - - - - - -//
~~Hi~~ Hello, world!
//- - - - - - - - -//
<p><del>Hi</del> Hello, world!</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

2
//- - - - - - - - -//
This ~~has a

new paragraph~~.
//- - - - - - - - -//
<p>This ~~has a</p>
<p>new paragraph~~.</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

3
//- - - - - - - - -//
~Hi~ Hello, world!
//- - - - - - - - -//
<p><del>Hi</del> Hello, world!</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

4: Three or more tildes do not create a strikethrough
//- - - - - - - - -//
This will ~~~not~~~ strike.
//- - - - - - - - -//
<p>This will ~~~not~~~ strike.</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

5: Leading three or more tildes do not create a strikethrough, create a code block
//- - - - - - - - -//
~~~Hi~~~ Hello, world!
//- - - - - - - - -//
<pre><code class="language-Hi~~~"></code></pre>
//= = = = = = = = = = = = = = = = = = = = = = = =//
</file>

<file path="extension/ast_test.go">
package extension

import (
	"bytes"
	"testing"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
	"github.com/yuin/goldmark/text"
)

func TestASTBlockNodeText(t *testing.T) {
	var cases = []struct {
		Name   string
		Source string
		T1     string
		T2     string
		C      bool
	}{
		{
			Name: "DefinitionList",
			Source: `c1
:   c2
    c3

a

c4
:   c5
    c6`,
			T1: `c1c2
c3`,
			T2: `c4c5
c6`,
		},
		{
			Name: "Table",
			Source: `| h1 | h2 |
| -- | -- |
| c1 | c2 |

a


| h3 | h4 |
| -- | -- |
| c3 | c4 |`,

			T1: `h1h2c1c2`,
			T2: `h3h4c3c4`,
		},
	}

	for _, cs := range cases {
		t.Run(cs.Name, func(t *testing.T) {
			s := []byte(cs.Source)
			md := goldmark.New(
				goldmark.WithRendererOptions(
					html.WithUnsafe(),
				),
				goldmark.WithExtensions(
					DefinitionList,
					Table,
				),
			)
			n := md.Parser().Parse(text.NewReader(s))
			c1 := n.FirstChild()
			c2 := c1.NextSibling().NextSibling()
			if cs.C {
				c1 = c1.FirstChild()
				c2 = c2.FirstChild()
			}
			if !bytes.Equal(c1.Text(s), []byte(cs.T1)) { // nolint: staticcheck

				t.Errorf("%s unmatch:\n%s", cs.Name, testutil.DiffPretty(c1.Text(s), []byte(cs.T1))) // nolint: staticcheck

			}
			if !bytes.Equal(c2.Text(s), []byte(cs.T2)) { // nolint: staticcheck

				t.Errorf("%s(EOF) unmatch: %s", cs.Name, testutil.DiffPretty(c2.Text(s), []byte(cs.T2))) // nolint: staticcheck

			}
		})
	}

}

func TestASTInlineNodeText(t *testing.T) {
	var cases = []struct {
		Name   string
		Source string
		T1     string
	}{
		{
			Name:   "Strikethrough",
			Source: `~c1 *c2*~`,
			T1:     `c1 c2`,
		},
	}

	for _, cs := range cases {
		t.Run(cs.Name, func(t *testing.T) {
			s := []byte(cs.Source)
			md := goldmark.New(
				goldmark.WithRendererOptions(
					html.WithUnsafe(),
				),
				goldmark.WithExtensions(
					Strikethrough,
				),
			)
			n := md.Parser().Parse(text.NewReader(s))
			c1 := n.FirstChild().FirstChild()
			if !bytes.Equal(c1.Text(s), []byte(cs.T1)) { // nolint: staticcheck

				t.Errorf("%s unmatch:\n%s", cs.Name, testutil.DiffPretty(c1.Text(s), []byte(cs.T1))) // nolint: staticcheck

			}
		})
	}

}
</file>

<file path="extension/footnote.go">
package extension

import (
	"bytes"
	"fmt"
	"strconv"

	"github.com/yuin/goldmark"
	gast "github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/extension/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

var footnoteListKey = parser.NewContextKey()
var footnoteLinkListKey = parser.NewContextKey()

type footnoteBlockParser struct {
}

var defaultFootnoteBlockParser = &footnoteBlockParser{}

// NewFootnoteBlockParser returns a new parser.BlockParser that can parse
// footnotes of the Markdown(PHP Markdown Extra) text.
func NewFootnoteBlockParser() parser.BlockParser {
	return defaultFootnoteBlockParser
}

func (b *footnoteBlockParser) Trigger() []byte {
	return []byte{'['}
}

func (b *footnoteBlockParser) Open(parent gast.Node, reader text.Reader, pc parser.Context) (gast.Node, parser.State) {
	line, segment := reader.PeekLine()
	pos := pc.BlockOffset()
	if pos < 0 || line[pos] != '[' {
		return nil, parser.NoChildren
	}
	pos++
	if pos > len(line)-1 || line[pos] != '^' {
		return nil, parser.NoChildren
	}
	open := pos + 1
	var closes int
	closure := util.FindClosure(line[pos+1:], '[', ']', false, false) //nolint:staticcheck
	closes = pos + 1 + closure
	next := closes + 1
	if closure > -1 {
		if next >= len(line) || line[next] != ':' {
			return nil, parser.NoChildren
		}
	} else {
		return nil, parser.NoChildren
	}
	padding := segment.Padding
	label := reader.Value(text.NewSegment(segment.Start+open-padding, segment.Start+closes-padding))
	if util.IsBlank(label) {
		return nil, parser.NoChildren
	}
	item := ast.NewFootnote(label)

	pos = next + 1 - padding
	if pos >= len(line) {
		reader.Advance(pos)
		return item, parser.NoChildren
	}
	reader.AdvanceAndSetPadding(pos, padding)
	return item, parser.HasChildren
}

func (b *footnoteBlockParser) Continue(node gast.Node, reader text.Reader, pc parser.Context) parser.State {
	line, _ := reader.PeekLine()
	if util.IsBlank(line) {
		return parser.Continue | parser.HasChildren
	}
	childpos, padding := util.IndentPosition(line, reader.LineOffset(), 4)
	if childpos < 0 {
		return parser.Close
	}
	reader.AdvanceAndSetPadding(childpos, padding)
	return parser.Continue | parser.HasChildren
}

func (b *footnoteBlockParser) Close(node gast.Node, reader text.Reader, pc parser.Context) {
	var list *ast.FootnoteList
	if tlist := pc.Get(footnoteListKey); tlist != nil {
		list = tlist.(*ast.FootnoteList)
	} else {
		list = ast.NewFootnoteList()
		pc.Set(footnoteListKey, list)
		node.Parent().InsertBefore(node.Parent(), node, list)
	}
	node.Parent().RemoveChild(node.Parent(), node)
	list.AppendChild(list, node)
}

func (b *footnoteBlockParser) CanInterruptParagraph() bool {
	return true
}

func (b *footnoteBlockParser) CanAcceptIndentedLine() bool {
	return false
}

type footnoteParser struct {
}

var defaultFootnoteParser = &footnoteParser{}

// NewFootnoteParser returns a new parser.InlineParser that can parse
// footnote links of the Markdown(PHP Markdown Extra) text.
func NewFootnoteParser() parser.InlineParser {
	return defaultFootnoteParser
}

func (s *footnoteParser) Trigger() []byte {
	// footnote syntax probably conflict with the image syntax.
	// So we need trigger this parser with '!'.
	return []byte{'!', '['}
}

func (s *footnoteParser) Parse(parent gast.Node, block text.Reader, pc parser.Context) gast.Node {
	line, segment := block.PeekLine()
	pos := 1
	if len(line) > 0 && line[0] == '!' {
		pos++
	}
	if pos >= len(line) || line[pos] != '^' {
		return nil
	}
	pos++
	if pos >= len(line) {
		return nil
	}
	open := pos
	closure := util.FindClosure(line[pos:], '[', ']', false, false) //nolint:staticcheck
	if closure < 0 {
		return nil
	}
	closes := pos + closure
	value := block.Value(text.NewSegment(segment.Start+open, segment.Start+closes))
	block.Advance(closes + 1)

	var list *ast.FootnoteList
	if tlist := pc.Get(footnoteListKey); tlist != nil {
		list = tlist.(*ast.FootnoteList)
	}
	if list == nil {
		return nil
	}
	index := 0
	for def := list.FirstChild(); def != nil; def = def.NextSibling() {
		d := def.(*ast.Footnote)
		if bytes.Equal(d.Ref, value) {
			if d.Index < 0 {
				list.Count++
				d.Index = list.Count
			}
			index = d.Index
			break
		}
	}
	if index == 0 {
		return nil
	}

	fnlink := ast.NewFootnoteLink(index)
	var fnlist []*ast.FootnoteLink
	if tmp := pc.Get(footnoteLinkListKey); tmp != nil {
		fnlist = tmp.([]*ast.FootnoteLink)
	} else {
		fnlist = []*ast.FootnoteLink{}
		pc.Set(footnoteLinkListKey, fnlist)
	}
	pc.Set(footnoteLinkListKey, append(fnlist, fnlink))
	if line[0] == '!' {
		parent.AppendChild(parent, gast.NewTextSegment(text.NewSegment(segment.Start, segment.Start+1)))
	}

	return fnlink
}

type footnoteASTTransformer struct {
}

var defaultFootnoteASTTransformer = &footnoteASTTransformer{}

// NewFootnoteASTTransformer returns a new parser.ASTTransformer that
// insert a footnote list to the last of the document.
func NewFootnoteASTTransformer() parser.ASTTransformer {
	return defaultFootnoteASTTransformer
}

func (a *footnoteASTTransformer) Transform(node *gast.Document, reader text.Reader, pc parser.Context) {
	var list *ast.FootnoteList
	var fnlist []*ast.FootnoteLink
	if tmp := pc.Get(footnoteListKey); tmp != nil {
		list = tmp.(*ast.FootnoteList)
	}
	if tmp := pc.Get(footnoteLinkListKey); tmp != nil {
		fnlist = tmp.([]*ast.FootnoteLink)
	}

	pc.Set(footnoteListKey, nil)
	pc.Set(footnoteLinkListKey, nil)

	if list == nil {
		return
	}

	counter := map[int]int{}
	if fnlist != nil {
		for _, fnlink := range fnlist {
			if fnlink.Index >= 0 {
				counter[fnlink.Index]++
			}
		}
		refCounter := map[int]int{}
		for _, fnlink := range fnlist {
			fnlink.RefCount = counter[fnlink.Index]
			if _, ok := refCounter[fnlink.Index]; !ok {
				refCounter[fnlink.Index] = 0
			}
			fnlink.RefIndex = refCounter[fnlink.Index]
			refCounter[fnlink.Index]++
		}
	}
	for footnote := list.FirstChild(); footnote != nil; {
		var container gast.Node = footnote
		next := footnote.NextSibling()
		if fc := container.LastChild(); fc != nil && gast.IsParagraph(fc) {
			container = fc
		}
		fn := footnote.(*ast.Footnote)
		index := fn.Index
		if index < 0 {
			list.RemoveChild(list, footnote)
		} else {
			refCount := counter[index]
			backLink := ast.NewFootnoteBacklink(index)
			backLink.RefCount = refCount
			backLink.RefIndex = 0
			container.AppendChild(container, backLink)
			if refCount > 1 {
				for i := 1; i < refCount; i++ {
					backLink := ast.NewFootnoteBacklink(index)
					backLink.RefCount = refCount
					backLink.RefIndex = i
					container.AppendChild(container, backLink)
				}
			}
		}
		footnote = next
	}
	list.SortChildren(func(n1, n2 gast.Node) int {
		if n1.(*ast.Footnote).Index < n2.(*ast.Footnote).Index {
			return -1
		}
		return 1
	})
	if list.Count <= 0 {
		list.Parent().RemoveChild(list.Parent(), list)
		return
	}

	node.AppendChild(node, list)
}

// FootnoteConfig holds configuration values for the footnote extension.
//
// Link* and Backlink* configurations have some variables:
// Occurrences of “^^” in the string will be replaced by the
// corresponding footnote number in the HTML output.
// Occurrences of “%%” will be replaced by a number for the
// reference (footnotes can have multiple references).
type FootnoteConfig struct {
	html.Config

	// IDPrefix is a prefix for the id attributes generated by footnotes.
	IDPrefix []byte

	// IDPrefix is a function that determines the id attribute for given Node.
	IDPrefixFunction func(gast.Node) []byte

	// LinkTitle is an optional title attribute for footnote links.
	LinkTitle []byte

	// BacklinkTitle is an optional title attribute for footnote backlinks.
	BacklinkTitle []byte

	// LinkClass is a class for footnote links.
	LinkClass []byte

	// BacklinkClass is a class for footnote backlinks.
	BacklinkClass []byte

	// BacklinkHTML is an HTML content for footnote backlinks.
	BacklinkHTML []byte
}

// FootnoteOption interface is a functional option interface for the extension.
type FootnoteOption interface {
	renderer.Option
	// SetFootnoteOption sets given option to the extension.
	SetFootnoteOption(*FootnoteConfig)
}

// NewFootnoteConfig returns a new Config with defaults.
func NewFootnoteConfig() FootnoteConfig {
	return FootnoteConfig{
		Config:        html.NewConfig(),
		LinkTitle:     []byte(""),
		BacklinkTitle: []byte(""),
		LinkClass:     []byte("footnote-ref"),
		BacklinkClass: []byte("footnote-backref"),
		BacklinkHTML:  []byte("&#x21a9;&#xfe0e;"),
	}
}

// SetOption implements renderer.SetOptioner.
func (c *FootnoteConfig) SetOption(name renderer.OptionName, value interface{}) {
	switch name {
	case optFootnoteIDPrefixFunction:
		c.IDPrefixFunction = value.(func(gast.Node) []byte)
	case optFootnoteIDPrefix:
		c.IDPrefix = value.([]byte)
	case optFootnoteLinkTitle:
		c.LinkTitle = value.([]byte)
	case optFootnoteBacklinkTitle:
		c.BacklinkTitle = value.([]byte)
	case optFootnoteLinkClass:
		c.LinkClass = value.([]byte)
	case optFootnoteBacklinkClass:
		c.BacklinkClass = value.([]byte)
	case optFootnoteBacklinkHTML:
		c.BacklinkHTML = value.([]byte)
	default:
		c.Config.SetOption(name, value)
	}
}

type withFootnoteHTMLOptions struct {
	value []html.Option
}

func (o *withFootnoteHTMLOptions) SetConfig(c *renderer.Config) {
	if o.value != nil {
		for _, v := range o.value {
			v.(renderer.Option).SetConfig(c)
		}
	}
}

func (o *withFootnoteHTMLOptions) SetFootnoteOption(c *FootnoteConfig) {
	if o.value != nil {
		for _, v := range o.value {
			v.SetHTMLOption(&c.Config)
		}
	}
}

// WithFootnoteHTMLOptions is functional option that wraps goldmark HTMLRenderer options.
func WithFootnoteHTMLOptions(opts ...html.Option) FootnoteOption {
	return &withFootnoteHTMLOptions{opts}
}

const optFootnoteIDPrefix renderer.OptionName = "FootnoteIDPrefix"

type withFootnoteIDPrefix struct {
	value []byte
}

func (o *withFootnoteIDPrefix) SetConfig(c *renderer.Config) {
	c.Options[optFootnoteIDPrefix] = o.value
}

func (o *withFootnoteIDPrefix) SetFootnoteOption(c *FootnoteConfig) {
	c.IDPrefix = o.value
}

// WithFootnoteIDPrefix is a functional option that is a prefix for the id attributes generated by footnotes.
func WithFootnoteIDPrefix[T []byte | string](a T) FootnoteOption {
	return &withFootnoteIDPrefix{[]byte(a)}
}

const optFootnoteIDPrefixFunction renderer.OptionName = "FootnoteIDPrefixFunction"

type withFootnoteIDPrefixFunction struct {
	value func(gast.Node) []byte
}

func (o *withFootnoteIDPrefixFunction) SetConfig(c *renderer.Config) {
	c.Options[optFootnoteIDPrefixFunction] = o.value
}

func (o *withFootnoteIDPrefixFunction) SetFootnoteOption(c *FootnoteConfig) {
	c.IDPrefixFunction = o.value
}

// WithFootnoteIDPrefixFunction is a functional option that is a prefix for the id attributes generated by footnotes.
func WithFootnoteIDPrefixFunction(a func(gast.Node) []byte) FootnoteOption {
	return &withFootnoteIDPrefixFunction{a}
}

const optFootnoteLinkTitle renderer.OptionName = "FootnoteLinkTitle"

type withFootnoteLinkTitle struct {
	value []byte
}

func (o *withFootnoteLinkTitle) SetConfig(c *renderer.Config) {
	c.Options[optFootnoteLinkTitle] = o.value
}

func (o *withFootnoteLinkTitle) SetFootnoteOption(c *FootnoteConfig) {
	c.LinkTitle = o.value
}

// WithFootnoteLinkTitle is a functional option that is an optional title attribute for footnote links.
func WithFootnoteLinkTitle[T []byte | string](a T) FootnoteOption {
	return &withFootnoteLinkTitle{[]byte(a)}
}

const optFootnoteBacklinkTitle renderer.OptionName = "FootnoteBacklinkTitle"

type withFootnoteBacklinkTitle struct {
	value []byte
}

func (o *withFootnoteBacklinkTitle) SetConfig(c *renderer.Config) {
	c.Options[optFootnoteBacklinkTitle] = o.value
}

func (o *withFootnoteBacklinkTitle) SetFootnoteOption(c *FootnoteConfig) {
	c.BacklinkTitle = o.value
}

// WithFootnoteBacklinkTitle is a functional option that is an optional title attribute for footnote backlinks.
func WithFootnoteBacklinkTitle[T []byte | string](a T) FootnoteOption {
	return &withFootnoteBacklinkTitle{[]byte(a)}
}

const optFootnoteLinkClass renderer.OptionName = "FootnoteLinkClass"

type withFootnoteLinkClass struct {
	value []byte
}

func (o *withFootnoteLinkClass) SetConfig(c *renderer.Config) {
	c.Options[optFootnoteLinkClass] = o.value
}

func (o *withFootnoteLinkClass) SetFootnoteOption(c *FootnoteConfig) {
	c.LinkClass = o.value
}

// WithFootnoteLinkClass is a functional option that is a class for footnote links.
func WithFootnoteLinkClass[T []byte | string](a T) FootnoteOption {
	return &withFootnoteLinkClass{[]byte(a)}
}

const optFootnoteBacklinkClass renderer.OptionName = "FootnoteBacklinkClass"

type withFootnoteBacklinkClass struct {
	value []byte
}

func (o *withFootnoteBacklinkClass) SetConfig(c *renderer.Config) {
	c.Options[optFootnoteBacklinkClass] = o.value
}

func (o *withFootnoteBacklinkClass) SetFootnoteOption(c *FootnoteConfig) {
	c.BacklinkClass = o.value
}

// WithFootnoteBacklinkClass is a functional option that is a class for footnote backlinks.
func WithFootnoteBacklinkClass[T []byte | string](a T) FootnoteOption {
	return &withFootnoteBacklinkClass{[]byte(a)}
}

const optFootnoteBacklinkHTML renderer.OptionName = "FootnoteBacklinkHTML"

type withFootnoteBacklinkHTML struct {
	value []byte
}

func (o *withFootnoteBacklinkHTML) SetConfig(c *renderer.Config) {
	c.Options[optFootnoteBacklinkHTML] = o.value
}

func (o *withFootnoteBacklinkHTML) SetFootnoteOption(c *FootnoteConfig) {
	c.BacklinkHTML = o.value
}

// WithFootnoteBacklinkHTML is an HTML content for footnote backlinks.
func WithFootnoteBacklinkHTML[T []byte | string](a T) FootnoteOption {
	return &withFootnoteBacklinkHTML{[]byte(a)}
}

// FootnoteHTMLRenderer is a renderer.NodeRenderer implementation that
// renders FootnoteLink nodes.
type FootnoteHTMLRenderer struct {
	FootnoteConfig
}

// NewFootnoteHTMLRenderer returns a new FootnoteHTMLRenderer.
func NewFootnoteHTMLRenderer(opts ...FootnoteOption) renderer.NodeRenderer {
	r := &FootnoteHTMLRenderer{
		FootnoteConfig: NewFootnoteConfig(),
	}
	for _, opt := range opts {
		opt.SetFootnoteOption(&r.FootnoteConfig)
	}
	return r
}

// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.
func (r *FootnoteHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	reg.Register(ast.KindFootnoteLink, r.renderFootnoteLink)
	reg.Register(ast.KindFootnoteBacklink, r.renderFootnoteBacklink)
	reg.Register(ast.KindFootnote, r.renderFootnote)
	reg.Register(ast.KindFootnoteList, r.renderFootnoteList)
}

func (r *FootnoteHTMLRenderer) renderFootnoteLink(
	w util.BufWriter, source []byte, node gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		n := node.(*ast.FootnoteLink)
		is := strconv.Itoa(n.Index)
		_, _ = w.WriteString(`<sup id="`)
		_, _ = w.Write(r.idPrefix(node))
		_, _ = w.WriteString(`fnref`)
		if n.RefIndex > 0 {
			_, _ = w.WriteString(fmt.Sprintf("%v", n.RefIndex))
		}
		_ = w.WriteByte(':')
		_, _ = w.WriteString(is)
		_, _ = w.WriteString(`"><a href="#`)
		_, _ = w.Write(r.idPrefix(node))
		_, _ = w.WriteString(`fn:`)
		_, _ = w.WriteString(is)
		_, _ = w.WriteString(`" class="`)
		_, _ = w.Write(applyFootnoteTemplate(r.FootnoteConfig.LinkClass,
			n.Index, n.RefCount))
		if len(r.FootnoteConfig.LinkTitle) > 0 {
			_, _ = w.WriteString(`" title="`)
			_, _ = w.Write(util.EscapeHTML(applyFootnoteTemplate(r.FootnoteConfig.LinkTitle, n.Index, n.RefCount)))
		}
		_, _ = w.WriteString(`" role="doc-noteref">`)

		_, _ = w.WriteString(is)
		_, _ = w.WriteString(`</a></sup>`)
	}
	return gast.WalkContinue, nil
}

func (r *FootnoteHTMLRenderer) renderFootnoteBacklink(
	w util.BufWriter, source []byte, node gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		n := node.(*ast.FootnoteBacklink)
		is := strconv.Itoa(n.Index)
		_, _ = w.WriteString(`&#160;<a href="#`)
		_, _ = w.Write(r.idPrefix(node))
		_, _ = w.WriteString(`fnref`)
		if n.RefIndex > 0 {
			_, _ = w.WriteString(fmt.Sprintf("%v", n.RefIndex))
		}
		_ = w.WriteByte(':')
		_, _ = w.WriteString(is)
		_, _ = w.WriteString(`" class="`)
		_, _ = w.Write(applyFootnoteTemplate(r.FootnoteConfig.BacklinkClass, n.Index, n.RefCount))
		if len(r.FootnoteConfig.BacklinkTitle) > 0 {
			_, _ = w.WriteString(`" title="`)
			_, _ = w.Write(util.EscapeHTML(applyFootnoteTemplate(r.FootnoteConfig.BacklinkTitle, n.Index, n.RefCount)))
		}
		_, _ = w.WriteString(`" role="doc-backlink">`)
		_, _ = w.Write(applyFootnoteTemplate(r.FootnoteConfig.BacklinkHTML, n.Index, n.RefCount))
		_, _ = w.WriteString(`</a>`)
	}
	return gast.WalkContinue, nil
}

func (r *FootnoteHTMLRenderer) renderFootnote(
	w util.BufWriter, source []byte, node gast.Node, entering bool) (gast.WalkStatus, error) {
	n := node.(*ast.Footnote)
	is := strconv.Itoa(n.Index)
	if entering {
		_, _ = w.WriteString(`<li id="`)
		_, _ = w.Write(r.idPrefix(node))
		_, _ = w.WriteString(`fn:`)
		_, _ = w.WriteString(is)
		_, _ = w.WriteString(`"`)
		if node.Attributes() != nil {
			html.RenderAttributes(w, node, html.ListItemAttributeFilter)
		}
		_, _ = w.WriteString(">\n")
	} else {
		_, _ = w.WriteString("</li>\n")
	}
	return gast.WalkContinue, nil
}

func (r *FootnoteHTMLRenderer) renderFootnoteList(
	w util.BufWriter, source []byte, node gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		_, _ = w.WriteString(`<div class="footnotes" role="doc-endnotes"`)
		if node.Attributes() != nil {
			html.RenderAttributes(w, node, html.GlobalAttributeFilter)
		}
		_ = w.WriteByte('>')
		if r.Config.XHTML {
			_, _ = w.WriteString("\n<hr />\n")
		} else {
			_, _ = w.WriteString("\n<hr>\n")
		}
		_, _ = w.WriteString("<ol>\n")
	} else {
		_, _ = w.WriteString("</ol>\n")
		_, _ = w.WriteString("</div>\n")
	}
	return gast.WalkContinue, nil
}

func (r *FootnoteHTMLRenderer) idPrefix(node gast.Node) []byte {
	if r.FootnoteConfig.IDPrefix != nil {
		return r.FootnoteConfig.IDPrefix
	}
	if r.FootnoteConfig.IDPrefixFunction != nil {
		return r.FootnoteConfig.IDPrefixFunction(node)
	}
	return []byte("")
}

func applyFootnoteTemplate(b []byte, index, refCount int) []byte {
	fast := true
	for i, c := range b {
		if i != 0 {
			if b[i-1] == '^' && c == '^' {
				fast = false
				break
			}
			if b[i-1] == '%' && c == '%' {
				fast = false
				break
			}
		}
	}
	if fast {
		return b
	}
	is := []byte(strconv.Itoa(index))
	rs := []byte(strconv.Itoa(refCount))
	ret := bytes.Replace(b, []byte("^^"), is, -1)
	return bytes.Replace(ret, []byte("%%"), rs, -1)
}

type footnote struct {
	options []FootnoteOption
}

// Footnote is an extension that allow you to use PHP Markdown Extra Footnotes.
var Footnote = &footnote{
	options: []FootnoteOption{},
}

// NewFootnote returns a new extension with given options.
func NewFootnote(opts ...FootnoteOption) goldmark.Extender {
	return &footnote{
		options: opts,
	}
}

func (e *footnote) Extend(m goldmark.Markdown) {
	m.Parser().AddOptions(
		parser.WithBlockParsers(
			util.Prioritized(NewFootnoteBlockParser(), 999),
		),
		parser.WithInlineParsers(
			util.Prioritized(NewFootnoteParser(), 101),
		),
		parser.WithASTTransformers(
			util.Prioritized(NewFootnoteASTTransformer(), 999),
		),
	)
	m.Renderer().AddOptions(renderer.WithNodeRenderers(
		util.Prioritized(NewFootnoteHTMLRenderer(e.options...), 500),
	))
}
</file>

<file path="extension/linkify.go">
package extension

import (
	"bytes"
	"regexp"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

var wwwURLRegxp = regexp.MustCompile(`^www\.[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-z]+(?:[/#?][-a-zA-Z0-9@:%_\+.~#!?&/=\(\);,'">\^{}\[\]` + "`" + `]*)?`) //nolint:golint,lll

var urlRegexp = regexp.MustCompile(`^(?:http|https|ftp)://[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-z]+(?::\d+)?(?:[/#?][-a-zA-Z0-9@:%_+.~#$!?&/=\(\);,'">\^{}\[\]` + "`" + `]*)?`) //nolint:golint,lll

// An LinkifyConfig struct is a data structure that holds configuration of the
// Linkify extension.
type LinkifyConfig struct {
	AllowedProtocols [][]byte
	URLRegexp        *regexp.Regexp
	WWWRegexp        *regexp.Regexp
	EmailRegexp      *regexp.Regexp
}

const (
	optLinkifyAllowedProtocols parser.OptionName = "LinkifyAllowedProtocols"
	optLinkifyURLRegexp        parser.OptionName = "LinkifyURLRegexp"
	optLinkifyWWWRegexp        parser.OptionName = "LinkifyWWWRegexp"
	optLinkifyEmailRegexp      parser.OptionName = "LinkifyEmailRegexp"
)

// SetOption implements SetOptioner.
func (c *LinkifyConfig) SetOption(name parser.OptionName, value interface{}) {
	switch name {
	case optLinkifyAllowedProtocols:
		c.AllowedProtocols = value.([][]byte)
	case optLinkifyURLRegexp:
		c.URLRegexp = value.(*regexp.Regexp)
	case optLinkifyWWWRegexp:
		c.WWWRegexp = value.(*regexp.Regexp)
	case optLinkifyEmailRegexp:
		c.EmailRegexp = value.(*regexp.Regexp)
	}
}

// A LinkifyOption interface sets options for the LinkifyOption.
type LinkifyOption interface {
	parser.Option
	SetLinkifyOption(*LinkifyConfig)
}

type withLinkifyAllowedProtocols struct {
	value [][]byte
}

func (o *withLinkifyAllowedProtocols) SetParserOption(c *parser.Config) {
	c.Options[optLinkifyAllowedProtocols] = o.value
}

func (o *withLinkifyAllowedProtocols) SetLinkifyOption(p *LinkifyConfig) {
	p.AllowedProtocols = o.value
}

// WithLinkifyAllowedProtocols is a functional option that specify allowed
// protocols in autolinks. Each protocol must end with ':' like
// 'http:' .
func WithLinkifyAllowedProtocols[T []byte | string](value []T) LinkifyOption {
	opt := &withLinkifyAllowedProtocols{}
	for _, v := range value {
		opt.value = append(opt.value, []byte(v))
	}
	return opt
}

type withLinkifyURLRegexp struct {
	value *regexp.Regexp
}

func (o *withLinkifyURLRegexp) SetParserOption(c *parser.Config) {
	c.Options[optLinkifyURLRegexp] = o.value
}

func (o *withLinkifyURLRegexp) SetLinkifyOption(p *LinkifyConfig) {
	p.URLRegexp = o.value
}

// WithLinkifyURLRegexp is a functional option that specify
// a pattern of the URL including a protocol.
func WithLinkifyURLRegexp(value *regexp.Regexp) LinkifyOption {
	return &withLinkifyURLRegexp{
		value: value,
	}
}

type withLinkifyWWWRegexp struct {
	value *regexp.Regexp
}

func (o *withLinkifyWWWRegexp) SetParserOption(c *parser.Config) {
	c.Options[optLinkifyWWWRegexp] = o.value
}

func (o *withLinkifyWWWRegexp) SetLinkifyOption(p *LinkifyConfig) {
	p.WWWRegexp = o.value
}

// WithLinkifyWWWRegexp is a functional option that specify
// a pattern of the URL without a protocol.
// This pattern must start with 'www.' .
func WithLinkifyWWWRegexp(value *regexp.Regexp) LinkifyOption {
	return &withLinkifyWWWRegexp{
		value: value,
	}
}

type withLinkifyEmailRegexp struct {
	value *regexp.Regexp
}

func (o *withLinkifyEmailRegexp) SetParserOption(c *parser.Config) {
	c.Options[optLinkifyEmailRegexp] = o.value
}

func (o *withLinkifyEmailRegexp) SetLinkifyOption(p *LinkifyConfig) {
	p.EmailRegexp = o.value
}

// WithLinkifyEmailRegexp is a functional otpion that specify
// a pattern of the email address.
func WithLinkifyEmailRegexp(value *regexp.Regexp) LinkifyOption {
	return &withLinkifyEmailRegexp{
		value: value,
	}
}

type linkifyParser struct {
	LinkifyConfig
}

// NewLinkifyParser return a new InlineParser can parse
// text that seems like a URL.
func NewLinkifyParser(opts ...LinkifyOption) parser.InlineParser {
	p := &linkifyParser{
		LinkifyConfig: LinkifyConfig{
			AllowedProtocols: nil,
			URLRegexp:        urlRegexp,
			WWWRegexp:        wwwURLRegxp,
		},
	}
	for _, o := range opts {
		o.SetLinkifyOption(&p.LinkifyConfig)
	}
	return p
}

func (s *linkifyParser) Trigger() []byte {
	// ' ' indicates any white spaces and a line head
	return []byte{' ', '*', '_', '~', '('}
}

var (
	protoHTTP  = []byte("http:")
	protoHTTPS = []byte("https:")
	protoFTP   = []byte("ftp:")
	domainWWW  = []byte("www.")
)

func (s *linkifyParser) Parse(parent ast.Node, block text.Reader, pc parser.Context) ast.Node {
	if pc.IsInLinkLabel() {
		return nil
	}
	line, segment := block.PeekLine()
	consumes := 0
	start := segment.Start
	c := line[0]
	// advance if current position is not a line head.
	if c == ' ' || c == '*' || c == '_' || c == '~' || c == '(' {
		consumes++
		start++
		line = line[1:]
	}

	var m []int
	var protocol []byte
	var typ ast.AutoLinkType = ast.AutoLinkURL
	if s.LinkifyConfig.AllowedProtocols == nil {
		if bytes.HasPrefix(line, protoHTTP) || bytes.HasPrefix(line, protoHTTPS) || bytes.HasPrefix(line, protoFTP) {
			m = s.LinkifyConfig.URLRegexp.FindSubmatchIndex(line)
		}
	} else {
		for _, prefix := range s.LinkifyConfig.AllowedProtocols {
			if bytes.HasPrefix(line, prefix) {
				m = s.LinkifyConfig.URLRegexp.FindSubmatchIndex(line)
				break
			}
		}
	}
	if m == nil && bytes.HasPrefix(line, domainWWW) {
		m = s.LinkifyConfig.WWWRegexp.FindSubmatchIndex(line)
		protocol = []byte("http")
	}
	if m != nil && m[0] != 0 {
		m = nil
	}
	if m != nil && m[0] == 0 {
		lastChar := line[m[1]-1]
		if lastChar == '.' {
			m[1]--
		} else if lastChar == ')' {
			closing := 0
			for i := m[1] - 1; i >= m[0]; i-- {
				if line[i] == ')' {
					closing++
				} else if line[i] == '(' {
					closing--
				}
			}
			if closing > 0 {
				m[1] -= closing
			}
		} else if lastChar == ';' {
			i := m[1] - 2
			for ; i >= m[0]; i-- {
				if util.IsAlphaNumeric(line[i]) {
					continue
				}
				break
			}
			if i != m[1]-2 {
				if line[i] == '&' {
					m[1] -= m[1] - i
				}
			}
		}
	}
	if m == nil {
		if len(line) > 0 && util.IsPunct(line[0]) {
			return nil
		}
		typ = ast.AutoLinkEmail
		stop := -1
		if s.LinkifyConfig.EmailRegexp == nil {
			stop = util.FindEmailIndex(line)
		} else {
			m := s.LinkifyConfig.EmailRegexp.FindSubmatchIndex(line)
			if m != nil && m[0] == 0 {
				stop = m[1]
			}
		}
		if stop < 0 {
			return nil
		}
		at := bytes.IndexByte(line, '@')
		m = []int{0, stop, at, stop - 1}
		if m == nil || bytes.IndexByte(line[m[2]:m[3]], '.') < 0 {
			return nil
		}
		lastChar := line[m[1]-1]
		if lastChar == '.' {
			m[1]--
		}
		if m[1] < len(line) {
			nextChar := line[m[1]]
			if nextChar == '-' || nextChar == '_' {
				return nil
			}
		}
	}
	if m == nil {
		return nil
	}
	if consumes != 0 {
		s := segment.WithStop(segment.Start + 1)
		ast.MergeOrAppendTextSegment(parent, s)
	}
	i := m[1] - 1
	for ; i > 0; i-- {
		c := line[i]
		switch c {
		case '?', '!', '.', ',', ':', '*', '_', '~':
		default:
			goto endfor
		}
	}
endfor:
	i++
	consumes += i
	block.Advance(consumes)
	n := ast.NewTextSegment(text.NewSegment(start, start+i))
	link := ast.NewAutoLink(typ, n)
	link.Protocol = protocol
	return link
}

func (s *linkifyParser) CloseBlock(parent ast.Node, pc parser.Context) {
	// nothing to do
}

type linkify struct {
	options []LinkifyOption
}

// Linkify is an extension that allow you to parse text that seems like a URL.
var Linkify = &linkify{}

// NewLinkify creates a new [goldmark.Extender] that
// allow you to parse text that seems like a URL.
func NewLinkify(opts ...LinkifyOption) goldmark.Extender {
	return &linkify{
		options: opts,
	}
}

func (e *linkify) Extend(m goldmark.Markdown) {
	m.Parser().AddOptions(
		parser.WithInlineParsers(
			util.Prioritized(NewLinkifyParser(e.options...), 999),
		),
	)
}
</file>

<file path="extension/tasklist.go">
package extension

import (
	"regexp"

	"github.com/yuin/goldmark"
	gast "github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/extension/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

var taskListRegexp = regexp.MustCompile(`^\[([\sxX])\]\s*`)

type taskCheckBoxParser struct {
}

var defaultTaskCheckBoxParser = &taskCheckBoxParser{}

// NewTaskCheckBoxParser returns a new  InlineParser that can parse
// checkboxes in list items.
// This parser must take precedence over the parser.LinkParser.
func NewTaskCheckBoxParser() parser.InlineParser {
	return defaultTaskCheckBoxParser
}

func (s *taskCheckBoxParser) Trigger() []byte {
	return []byte{'['}
}

func (s *taskCheckBoxParser) Parse(parent gast.Node, block text.Reader, pc parser.Context) gast.Node {
	// Given AST structure must be like
	// - List
	//   - ListItem         : parent.Parent
	//     - TextBlock      : parent
	//       (current line)
	if parent.Parent() == nil || parent.Parent().FirstChild() != parent {
		return nil
	}

	if parent.HasChildren() {
		return nil
	}
	if _, ok := parent.Parent().(*gast.ListItem); !ok {
		return nil
	}
	line, _ := block.PeekLine()
	m := taskListRegexp.FindSubmatchIndex(line)
	if m == nil {
		return nil
	}
	value := line[m[2]:m[3]][0]
	block.Advance(m[1])
	checked := value == 'x' || value == 'X'
	return ast.NewTaskCheckBox(checked)
}

func (s *taskCheckBoxParser) CloseBlock(parent gast.Node, pc parser.Context) {
	// nothing to do
}

// TaskCheckBoxHTMLRenderer is a renderer.NodeRenderer implementation that
// renders checkboxes in list items.
type TaskCheckBoxHTMLRenderer struct {
	html.Config
}

// NewTaskCheckBoxHTMLRenderer returns a new TaskCheckBoxHTMLRenderer.
func NewTaskCheckBoxHTMLRenderer(opts ...html.Option) renderer.NodeRenderer {
	r := &TaskCheckBoxHTMLRenderer{
		Config: html.NewConfig(),
	}
	for _, opt := range opts {
		opt.SetHTMLOption(&r.Config)
	}
	return r
}

// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.
func (r *TaskCheckBoxHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	reg.Register(ast.KindTaskCheckBox, r.renderTaskCheckBox)
}

func (r *TaskCheckBoxHTMLRenderer) renderTaskCheckBox(
	w util.BufWriter, source []byte, node gast.Node, entering bool) (gast.WalkStatus, error) {
	if !entering {
		return gast.WalkContinue, nil
	}
	n := node.(*ast.TaskCheckBox)

	if n.IsChecked {
		_, _ = w.WriteString(`<input checked="" disabled="" type="checkbox"`)
	} else {
		_, _ = w.WriteString(`<input disabled="" type="checkbox"`)
	}
	if r.XHTML {
		_, _ = w.WriteString(" /> ")
	} else {
		_, _ = w.WriteString("> ")
	}
	return gast.WalkContinue, nil
}

type taskList struct {
}

// TaskList is an extension that allow you to use GFM task lists.
var TaskList = &taskList{}

func (e *taskList) Extend(m goldmark.Markdown) {
	m.Parser().AddOptions(parser.WithInlineParsers(
		util.Prioritized(NewTaskCheckBoxParser(), 0),
	))
	m.Renderer().AddOptions(renderer.WithNodeRenderers(
		util.Prioritized(NewTaskCheckBoxHTMLRenderer(), 500),
	))
}
</file>

<file path="extension/typographer.go">
package extension

import (
	"unicode"

	"github.com/yuin/goldmark"
	gast "github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

var uncloseCounterKey = parser.NewContextKey()

type unclosedCounter struct {
	Single int
	Double int
}

func (u *unclosedCounter) Reset() {
	u.Single = 0
	u.Double = 0
}

func getUnclosedCounter(pc parser.Context) *unclosedCounter {
	v := pc.Get(uncloseCounterKey)
	if v == nil {
		v = &unclosedCounter{}
		pc.Set(uncloseCounterKey, v)
	}
	return v.(*unclosedCounter)
}

// TypographicPunctuation is a key of the punctuations that can be replaced with
// typographic entities.
type TypographicPunctuation int

const (
	// LeftSingleQuote is ' .
	LeftSingleQuote TypographicPunctuation = iota + 1
	// RightSingleQuote is ' .
	RightSingleQuote
	// LeftDoubleQuote is " .
	LeftDoubleQuote
	// RightDoubleQuote is " .
	RightDoubleQuote
	// EnDash is -- .
	EnDash
	// EmDash is --- .
	EmDash
	// Ellipsis is ... .
	Ellipsis
	// LeftAngleQuote is << .
	LeftAngleQuote
	// RightAngleQuote is >> .
	RightAngleQuote
	// Apostrophe is ' .
	Apostrophe

	typographicPunctuationMax
)

// An TypographerConfig struct is a data structure that holds configuration of the
// Typographer extension.
type TypographerConfig struct {
	Substitutions [][]byte
}

func newDefaultSubstitutions() [][]byte {
	replacements := make([][]byte, typographicPunctuationMax)
	replacements[LeftSingleQuote] = []byte("&lsquo;")
	replacements[RightSingleQuote] = []byte("&rsquo;")
	replacements[LeftDoubleQuote] = []byte("&ldquo;")
	replacements[RightDoubleQuote] = []byte("&rdquo;")
	replacements[EnDash] = []byte("&ndash;")
	replacements[EmDash] = []byte("&mdash;")
	replacements[Ellipsis] = []byte("&hellip;")
	replacements[LeftAngleQuote] = []byte("&laquo;")
	replacements[RightAngleQuote] = []byte("&raquo;")
	replacements[Apostrophe] = []byte("&rsquo;")

	return replacements
}

// SetOption implements SetOptioner.
func (b *TypographerConfig) SetOption(name parser.OptionName, value interface{}) {
	switch name {
	case optTypographicSubstitutions:
		b.Substitutions = value.([][]byte)
	}
}

// A TypographerOption interface sets options for the TypographerParser.
type TypographerOption interface {
	parser.Option
	SetTypographerOption(*TypographerConfig)
}

const optTypographicSubstitutions parser.OptionName = "TypographicSubstitutions"

// TypographicSubstitutions is a list of the substitutions for the Typographer extension.
type TypographicSubstitutions map[TypographicPunctuation][]byte

type withTypographicSubstitutions struct {
	value [][]byte
}

func (o *withTypographicSubstitutions) SetParserOption(c *parser.Config) {
	c.Options[optTypographicSubstitutions] = o.value
}

func (o *withTypographicSubstitutions) SetTypographerOption(p *TypographerConfig) {
	p.Substitutions = o.value
}

// WithTypographicSubstitutions is a functional otpion that specify replacement text
// for punctuations.
func WithTypographicSubstitutions[T []byte | string](values map[TypographicPunctuation]T) TypographerOption {
	replacements := newDefaultSubstitutions()
	for k, v := range values {
		replacements[k] = []byte(v)
	}

	return &withTypographicSubstitutions{replacements}
}

type typographerDelimiterProcessor struct {
}

func (p *typographerDelimiterProcessor) IsDelimiter(b byte) bool {
	return b == '\'' || b == '"'
}

func (p *typographerDelimiterProcessor) CanOpenCloser(opener, closer *parser.Delimiter) bool {
	return opener.Char == closer.Char
}

func (p *typographerDelimiterProcessor) OnMatch(consumes int) gast.Node {
	return nil
}

var defaultTypographerDelimiterProcessor = &typographerDelimiterProcessor{}

type typographerParser struct {
	TypographerConfig
}

// NewTypographerParser return a new InlineParser that parses
// typographer expressions.
func NewTypographerParser(opts ...TypographerOption) parser.InlineParser {
	p := &typographerParser{
		TypographerConfig: TypographerConfig{
			Substitutions: newDefaultSubstitutions(),
		},
	}
	for _, o := range opts {
		o.SetTypographerOption(&p.TypographerConfig)
	}
	return p
}

func (s *typographerParser) Trigger() []byte {
	return []byte{'\'', '"', '-', '.', ',', '<', '>', '*', '['}
}

func (s *typographerParser) Parse(parent gast.Node, block text.Reader, pc parser.Context) gast.Node {
	line, _ := block.PeekLine()
	c := line[0]
	if len(line) > 2 {
		if c == '-' {
			if s.Substitutions[EmDash] != nil && line[1] == '-' && line[2] == '-' { // ---
				node := gast.NewString(s.Substitutions[EmDash])
				node.SetCode(true)
				block.Advance(3)
				return node
			}
		} else if c == '.' {
			if s.Substitutions[Ellipsis] != nil && line[1] == '.' && line[2] == '.' { // ...
				node := gast.NewString(s.Substitutions[Ellipsis])
				node.SetCode(true)
				block.Advance(3)
				return node
			}
			return nil
		}
	}
	if len(line) > 1 {
		if c == '<' {
			if s.Substitutions[LeftAngleQuote] != nil && line[1] == '<' { // <<
				node := gast.NewString(s.Substitutions[LeftAngleQuote])
				node.SetCode(true)
				block.Advance(2)
				return node
			}
			return nil
		} else if c == '>' {
			if s.Substitutions[RightAngleQuote] != nil && line[1] == '>' { // >>
				node := gast.NewString(s.Substitutions[RightAngleQuote])
				node.SetCode(true)
				block.Advance(2)
				return node
			}
			return nil
		} else if s.Substitutions[EnDash] != nil && c == '-' && line[1] == '-' { // --
			node := gast.NewString(s.Substitutions[EnDash])
			node.SetCode(true)
			block.Advance(2)
			return node
		}
	}
	if c == '\'' || c == '"' {
		before := block.PrecendingCharacter()
		d := parser.ScanDelimiter(line, before, 1, defaultTypographerDelimiterProcessor)
		if d == nil {
			return nil
		}
		counter := getUnclosedCounter(pc)
		if c == '\'' {
			if s.Substitutions[Apostrophe] != nil {
				// Handle decade abbrevations such as '90s
				if d.CanOpen && !d.CanClose && len(line) > 3 &&
					util.IsNumeric(line[1]) && util.IsNumeric(line[2]) && line[3] == 's' {
					after := rune(' ')
					if len(line) > 4 {
						after = util.ToRune(line, 4)
					}
					if len(line) == 3 || util.IsSpaceRune(after) || util.IsPunctRune(after) {
						node := gast.NewString(s.Substitutions[Apostrophe])
						node.SetCode(true)
						block.Advance(1)
						return node
					}
				}
				// special cases: 'twas, 'em, 'net
				if len(line) > 1 && (unicode.IsPunct(before) || unicode.IsSpace(before)) &&
					(line[1] == 't' || line[1] == 'e' || line[1] == 'n' || line[1] == 'l') {
					node := gast.NewString(s.Substitutions[Apostrophe])
					node.SetCode(true)
					block.Advance(1)
					return node
				}
				// Convert normal apostrophes. This is probably more flexible than necessary but
				// converts any apostrophe in between two alphanumerics.
				if len(line) > 1 && (unicode.IsDigit(before) || unicode.IsLetter(before)) &&
					(unicode.IsLetter(util.ToRune(line, 1))) {
					node := gast.NewString(s.Substitutions[Apostrophe])
					node.SetCode(true)
					block.Advance(1)
					return node
				}
			}
			if s.Substitutions[LeftSingleQuote] != nil && d.CanOpen && !d.CanClose {
				nt := LeftSingleQuote
				// special cases: Alice's, I'm, Don't, You'd
				if len(line) > 1 && (line[1] == 's' || line[1] == 'm' || line[1] == 't' || line[1] == 'd') &&
					(len(line) < 3 || util.IsPunct(line[2]) || util.IsSpace(line[2])) {
					nt = RightSingleQuote
				}
				// special cases: I've, I'll, You're
				if len(line) > 2 && ((line[1] == 'v' && line[2] == 'e') ||
					(line[1] == 'l' && line[2] == 'l') || (line[1] == 'r' && line[2] == 'e')) &&
					(len(line) < 4 || util.IsPunct(line[3]) || util.IsSpace(line[3])) {
					nt = RightSingleQuote
				}
				if nt == LeftSingleQuote {
					counter.Single++
				}

				node := gast.NewString(s.Substitutions[nt])
				node.SetCode(true)
				block.Advance(1)
				return node
			}
			if s.Substitutions[RightSingleQuote] != nil {
				// plural possesive and abbreviations: Smiths', doin'
				if len(line) > 1 && unicode.IsSpace(util.ToRune(line, 0)) || unicode.IsPunct(util.ToRune(line, 0)) &&
					(len(line) > 2 && !unicode.IsDigit(util.ToRune(line, 1))) {
					node := gast.NewString(s.Substitutions[RightSingleQuote])
					node.SetCode(true)
					block.Advance(1)
					return node
				}
			}
			if s.Substitutions[RightSingleQuote] != nil && counter.Single > 0 {
				isClose := d.CanClose && !d.CanOpen
				maybeClose := d.CanClose && d.CanOpen && len(line) > 1 && unicode.IsPunct(util.ToRune(line, 1)) &&
					(len(line) == 2 || (len(line) > 2 && util.IsPunct(line[2]) || util.IsSpace(line[2])))
				if isClose || maybeClose {
					node := gast.NewString(s.Substitutions[RightSingleQuote])
					node.SetCode(true)
					block.Advance(1)
					counter.Single--
					return node
				}
			}
		}
		if c == '"' {
			if s.Substitutions[LeftDoubleQuote] != nil && d.CanOpen && !d.CanClose {
				node := gast.NewString(s.Substitutions[LeftDoubleQuote])
				node.SetCode(true)
				block.Advance(1)
				counter.Double++
				return node
			}
			if s.Substitutions[RightDoubleQuote] != nil && counter.Double > 0 {
				isClose := d.CanClose && !d.CanOpen
				maybeClose := d.CanClose && d.CanOpen && len(line) > 1 && (unicode.IsPunct(util.ToRune(line, 1))) &&
					(len(line) == 2 || (len(line) > 2 && util.IsPunct(line[2]) || util.IsSpace(line[2])))
				if isClose || maybeClose {
					// special case: "Monitor 21""
					if len(line) > 1 && line[1] == '"' && unicode.IsDigit(before) {
						return nil
					}
					node := gast.NewString(s.Substitutions[RightDoubleQuote])
					node.SetCode(true)
					block.Advance(1)
					counter.Double--
					return node
				}
			}
		}
	}
	return nil
}

func (s *typographerParser) CloseBlock(parent gast.Node, pc parser.Context) {
	getUnclosedCounter(pc).Reset()
}

type typographer struct {
	options []TypographerOption
}

// Typographer is an extension that replaces punctuations with typographic entities.
var Typographer = &typographer{}

// NewTypographer returns a new Extender that replaces punctuations with typographic entities.
func NewTypographer(opts ...TypographerOption) goldmark.Extender {
	return &typographer{
		options: opts,
	}
}

func (e *typographer) Extend(m goldmark.Markdown) {
	m.Parser().AddOptions(parser.WithInlineParsers(
		util.Prioritized(NewTypographerParser(e.options...), 9999),
	))
}
</file>

<file path="fuzz/fuzz_test.go">
package fuzz

import (
	"bytes"
	"encoding/json"
	"os"
	"testing"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/extension"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/util"
)

func fuzz(f *testing.F) {
	f.Fuzz(func(t *testing.T, orig string) {
		markdown := goldmark.New(
			goldmark.WithParserOptions(
				parser.WithAutoHeadingID(),
				parser.WithAttribute(),
			),
			goldmark.WithRendererOptions(
				html.WithUnsafe(),
				html.WithXHTML(),
			),
			goldmark.WithExtensions(
				extension.DefinitionList,
				extension.Footnote,
				extension.GFM,
				extension.Typographer,
				extension.Linkify,
				extension.Table,
				extension.TaskList,
			),
		)
		var b bytes.Buffer
		if err := markdown.Convert(util.StringToReadOnlyBytes(orig), &b); err != nil {
			panic(err)
		}
	})
}

func FuzzDefault(f *testing.F) {
	bs, err := os.ReadFile("../_test/spec.json")
	if err != nil {
		panic(err)
	}
	var testCases []map[string]interface{}
	if err := json.Unmarshal(bs, &testCases); err != nil {
		panic(err)
	}
	for _, c := range testCases {
		f.Add(c["markdown"])
	}
	fuzz(f)
}
</file>

<file path="parser/code_block.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type codeBlockParser struct {
}

// CodeBlockParser is a BlockParser implementation that parses indented code blocks.
var defaultCodeBlockParser = &codeBlockParser{}

// NewCodeBlockParser returns a new BlockParser that
// parses code blocks.
func NewCodeBlockParser() BlockParser {
	return defaultCodeBlockParser
}

func (b *codeBlockParser) Trigger() []byte {
	return nil
}

func (b *codeBlockParser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	line, segment := reader.PeekLine()
	pos, padding := util.IndentPosition(line, reader.LineOffset(), 4)
	if pos < 0 || util.IsBlank(line) {
		return nil, NoChildren
	}
	node := ast.NewCodeBlock()
	reader.AdvanceAndSetPadding(pos, padding)
	_, segment = reader.PeekLine()
	// if code block line starts with a tab, keep a tab as it is.
	if segment.Padding != 0 {
		preserveLeadingTabInCodeBlock(&segment, reader, 0)
	}
	segment.ForceNewline = true
	node.Lines().Append(segment)
	reader.AdvanceToEOL()
	return node, NoChildren

}

func (b *codeBlockParser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	line, segment := reader.PeekLine()
	if util.IsBlank(line) {
		node.Lines().Append(segment.TrimLeftSpaceWidth(4, reader.Source()))
		return Continue | NoChildren
	}
	pos, padding := util.IndentPosition(line, reader.LineOffset(), 4)
	if pos < 0 {
		return Close
	}
	reader.AdvanceAndSetPadding(pos, padding)
	_, segment = reader.PeekLine()

	// if code block line starts with a tab, keep a tab as it is.
	if segment.Padding != 0 {
		preserveLeadingTabInCodeBlock(&segment, reader, 0)
	}

	segment.ForceNewline = true
	node.Lines().Append(segment)
	reader.AdvanceToEOL()
	return Continue | NoChildren
}

func (b *codeBlockParser) Close(node ast.Node, reader text.Reader, pc Context) {
	// trim trailing blank lines
	lines := node.Lines()
	length := lines.Len() - 1
	source := reader.Source()
	for length >= 0 {
		line := lines.At(length)
		if util.IsBlank(line.Value(source)) {
			length--
		} else {
			break
		}
	}
	lines.SetSliced(0, length+1)
}

func (b *codeBlockParser) CanInterruptParagraph() bool {
	return false
}

func (b *codeBlockParser) CanAcceptIndentedLine() bool {
	return true
}

func preserveLeadingTabInCodeBlock(segment *text.Segment, reader text.Reader, indent int) {
	offsetWithPadding := reader.LineOffset() + indent
	sl, ss := reader.Position()
	reader.SetPosition(sl, text.NewSegment(ss.Start-1, ss.Stop))
	if offsetWithPadding == reader.LineOffset() {
		segment.Padding = 0
		segment.Start--
	}
	reader.SetPosition(sl, ss)
}
</file>

<file path="parser/delimiter.go">
package parser

import (
	"fmt"
	"strings"

	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

// A DelimiterProcessor interface provides a set of functions about
// Delimiter nodes.
type DelimiterProcessor interface {
	// IsDelimiter returns true if given character is a delimiter, otherwise false.
	IsDelimiter(byte) bool

	// CanOpenCloser returns true if given opener can close given closer, otherwise false.
	CanOpenCloser(opener, closer *Delimiter) bool

	// OnMatch will be called when new matched delimiter found.
	// OnMatch should return a new Node correspond to the matched delimiter.
	OnMatch(consumes int) ast.Node
}

// A Delimiter struct represents a delimiter like '*' of the Markdown text.
type Delimiter struct {
	ast.BaseInline

	Segment text.Segment

	// CanOpen is set true if this delimiter can open a span for a new node.
	// See https://spec.commonmark.org/0.30/#can-open-emphasis for details.
	CanOpen bool

	// CanClose is set true if this delimiter can close a span for a new node.
	// See https://spec.commonmark.org/0.30/#can-open-emphasis for details.
	CanClose bool

	// Length is a remaining length of this delimiter.
	Length int

	// OriginalLength is a original length of this delimiter.
	OriginalLength int

	// Char is a character of this delimiter.
	Char byte

	// PreviousDelimiter is a previous sibling delimiter node of this delimiter.
	PreviousDelimiter *Delimiter

	// NextDelimiter is a next sibling delimiter node of this delimiter.
	NextDelimiter *Delimiter

	// Processor is a DelimiterProcessor associated with this delimiter.
	Processor DelimiterProcessor
}

// Inline implements Inline.Inline.
func (d *Delimiter) Inline() {}

// Dump implements Node.Dump.
func (d *Delimiter) Dump(source []byte, level int) {
	fmt.Printf("%sDelimiter: \"%s\"\n", strings.Repeat("    ", level), string(d.Text(source)))
}

var kindDelimiter = ast.NewNodeKind("Delimiter")

// Kind implements Node.Kind.
func (d *Delimiter) Kind() ast.NodeKind {
	return kindDelimiter
}

// Text implements Node.Text.
func (d *Delimiter) Text(source []byte) []byte {
	return d.Segment.Value(source)
}

// ConsumeCharacters consumes delimiters.
func (d *Delimiter) ConsumeCharacters(n int) {
	d.Length -= n
	d.Segment = d.Segment.WithStop(d.Segment.Start + d.Length)
}

// CalcComsumption calculates how many characters should be used for opening
// a new span correspond to given closer.
func (d *Delimiter) CalcComsumption(closer *Delimiter) int {
	if (d.CanClose || closer.CanOpen) && (d.OriginalLength+closer.OriginalLength)%3 == 0 && closer.OriginalLength%3 != 0 {
		return 0
	}
	if d.Length >= 2 && closer.Length >= 2 {
		return 2
	}
	return 1
}

// NewDelimiter returns a new Delimiter node.
func NewDelimiter(canOpen, canClose bool, length int, char byte, processor DelimiterProcessor) *Delimiter {
	c := &Delimiter{
		BaseInline:        ast.BaseInline{},
		CanOpen:           canOpen,
		CanClose:          canClose,
		Length:            length,
		OriginalLength:    length,
		Char:              char,
		PreviousDelimiter: nil,
		NextDelimiter:     nil,
		Processor:         processor,
	}
	return c
}

// ScanDelimiter scans a delimiter by given DelimiterProcessor.
func ScanDelimiter(line []byte, before rune, minimum int, processor DelimiterProcessor) *Delimiter {
	i := 0
	c := line[i]
	j := i
	if !processor.IsDelimiter(c) {
		return nil
	}
	for ; j < len(line) && c == line[j]; j++ {
	}
	if (j - i) >= minimum {
		after := rune(' ')
		if j != len(line) {
			after = util.ToRune(line, j)
		}

		var canOpen, canClose bool
		beforeIsPunctuation := util.IsPunctRune(before)
		beforeIsWhitespace := util.IsSpaceRune(before)
		afterIsPunctuation := util.IsPunctRune(after)
		afterIsWhitespace := util.IsSpaceRune(after)

		isLeft := !afterIsWhitespace &&
			(!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation)
		isRight := !beforeIsWhitespace &&
			(!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation)

		if line[i] == '_' {
			canOpen = isLeft && (!isRight || beforeIsPunctuation)
			canClose = isRight && (!isLeft || afterIsPunctuation)
		} else {
			canOpen = isLeft
			canClose = isRight
		}
		return NewDelimiter(canOpen, canClose, j-i, c, processor)
	}
	return nil
}

// ProcessDelimiters processes the delimiter list in the context.
// Processing will be stop when reaching the bottom.
//
// If you implement an inline parser that can have other inline nodes as
// children, you should call this function when nesting span has closed.
func ProcessDelimiters(bottom ast.Node, pc Context) {
	lastDelimiter := pc.LastDelimiter()
	if lastDelimiter == nil {
		return
	}
	var closer *Delimiter
	if bottom != nil {
		if bottom != lastDelimiter {
			for c := lastDelimiter.PreviousSibling(); c != nil && c != bottom; {
				if d, ok := c.(*Delimiter); ok {
					closer = d
				}
				c = c.PreviousSibling()
			}
		}
	} else {
		closer = pc.FirstDelimiter()
	}
	if closer == nil {
		pc.ClearDelimiters(bottom)
		return
	}
	for closer != nil {
		if !closer.CanClose {
			closer = closer.NextDelimiter
			continue
		}
		consume := 0
		found := false
		maybeOpener := false
		var opener *Delimiter
		for opener = closer.PreviousDelimiter; opener != nil && opener != bottom; opener = opener.PreviousDelimiter {
			if opener.CanOpen && opener.Processor.CanOpenCloser(opener, closer) {
				maybeOpener = true
				consume = opener.CalcComsumption(closer)
				if consume > 0 {
					found = true
					break
				}
			}
		}
		if !found {
			next := closer.NextDelimiter
			if !maybeOpener && !closer.CanOpen {
				pc.RemoveDelimiter(closer)
			}
			closer = next
			continue
		}
		opener.ConsumeCharacters(consume)
		closer.ConsumeCharacters(consume)

		node := opener.Processor.OnMatch(consume)

		parent := opener.Parent()
		child := opener.NextSibling()

		for child != nil && child != closer {
			next := child.NextSibling()
			node.AppendChild(node, child)
			child = next
		}
		parent.InsertAfter(parent, opener, node)

		for c := opener.NextDelimiter; c != nil && c != closer; {
			next := c.NextDelimiter
			pc.RemoveDelimiter(c)
			c = next
		}

		if opener.Length == 0 {
			pc.RemoveDelimiter(opener)
		}

		if closer.Length == 0 {
			next := closer.NextDelimiter
			pc.RemoveDelimiter(closer)
			closer = next
		}
	}
	pc.ClearDelimiters(bottom)
}
</file>

<file path="parser/fcode_block.go">
package parser

import (
	"bytes"

	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type fencedCodeBlockParser struct {
}

var defaultFencedCodeBlockParser = &fencedCodeBlockParser{}

// NewFencedCodeBlockParser returns a new BlockParser that
// parses fenced code blocks.
func NewFencedCodeBlockParser() BlockParser {
	return defaultFencedCodeBlockParser
}

type fenceData struct {
	char   byte
	indent int
	length int
	node   ast.Node
}

var fencedCodeBlockInfoKey = NewContextKey()

func (b *fencedCodeBlockParser) Trigger() []byte {
	return []byte{'~', '`'}
}

func (b *fencedCodeBlockParser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	line, segment := reader.PeekLine()
	pos := pc.BlockOffset()
	if pos < 0 || (line[pos] != '`' && line[pos] != '~') {
		return nil, NoChildren
	}
	findent := pos
	fenceChar := line[pos]
	i := pos
	for ; i < len(line) && line[i] == fenceChar; i++ {
	}
	oFenceLength := i - pos
	if oFenceLength < 3 {
		return nil, NoChildren
	}
	var info *ast.Text
	if i < len(line)-1 {
		rest := line[i:]
		left := util.TrimLeftSpaceLength(rest)
		right := util.TrimRightSpaceLength(rest)
		if left < len(rest)-right {
			infoStart, infoStop := segment.Start-segment.Padding+i+left, segment.Stop-right
			value := rest[left : len(rest)-right]
			if fenceChar == '`' && bytes.IndexByte(value, '`') > -1 {
				return nil, NoChildren
			} else if infoStart != infoStop {
				info = ast.NewTextSegment(text.NewSegment(infoStart, infoStop))
			}
		}
	}
	node := ast.NewFencedCodeBlock(info)
	pc.Set(fencedCodeBlockInfoKey, &fenceData{fenceChar, findent, oFenceLength, node})
	return node, NoChildren

}

func (b *fencedCodeBlockParser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	line, segment := reader.PeekLine()
	fdata := pc.Get(fencedCodeBlockInfoKey).(*fenceData)

	w, pos := util.IndentWidth(line, reader.LineOffset())
	if w < 4 {
		i := pos
		for ; i < len(line) && line[i] == fdata.char; i++ {
		}
		length := i - pos
		if length >= fdata.length && util.IsBlank(line[i:]) {
			newline := 1
			if line[len(line)-1] != '\n' {
				newline = 0
			}
			reader.Advance(segment.Stop - segment.Start - newline + segment.Padding)
			return Close
		}
	}
	pos, padding := util.IndentPositionPadding(line, reader.LineOffset(), segment.Padding, fdata.indent)
	if pos < 0 {
		pos = util.FirstNonSpacePosition(line)
		if pos < 0 {
			pos = 0
		}
		padding = 0
	}
	seg := text.NewSegmentPadding(segment.Start+pos, segment.Stop, padding)
	// if code block line starts with a tab, keep a tab as it is.
	if padding != 0 {
		preserveLeadingTabInCodeBlock(&seg, reader, fdata.indent)
	}
	seg.ForceNewline = true // EOF as newline
	node.Lines().Append(seg)
	reader.AdvanceAndSetPadding(segment.Stop-segment.Start-pos-1, padding)
	return Continue | NoChildren
}

func (b *fencedCodeBlockParser) Close(node ast.Node, reader text.Reader, pc Context) {
	fdata := pc.Get(fencedCodeBlockInfoKey).(*fenceData)
	if fdata.node == node {
		pc.Set(fencedCodeBlockInfoKey, nil)
	}
}

func (b *fencedCodeBlockParser) CanInterruptParagraph() bool {
	return true
}

func (b *fencedCodeBlockParser) CanAcceptIndentedLine() bool {
	return false
}
</file>

<file path="parser/link.go">
package parser

import (
	"fmt"
	"strings"

	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

var linkLabelStateKey = NewContextKey()

type linkLabelState struct {
	ast.BaseInline

	Segment text.Segment

	IsImage bool

	Prev *linkLabelState

	Next *linkLabelState

	First *linkLabelState

	Last *linkLabelState
}

func newLinkLabelState(segment text.Segment, isImage bool) *linkLabelState {
	return &linkLabelState{
		Segment: segment,
		IsImage: isImage,
	}
}

func (s *linkLabelState) Text(source []byte) []byte {
	return s.Segment.Value(source)
}

func (s *linkLabelState) Dump(source []byte, level int) {
	fmt.Printf("%slinkLabelState: \"%s\"\n", strings.Repeat("    ", level), s.Text(source))
}

var kindLinkLabelState = ast.NewNodeKind("LinkLabelState")

func (s *linkLabelState) Kind() ast.NodeKind {
	return kindLinkLabelState
}

func linkLabelStateLength(v *linkLabelState) int {
	if v == nil || v.Last == nil || v.First == nil {
		return 0
	}
	return v.Last.Segment.Stop - v.First.Segment.Start
}

func pushLinkLabelState(pc Context, v *linkLabelState) {
	tlist := pc.Get(linkLabelStateKey)
	var list *linkLabelState
	if tlist == nil {
		list = v
		v.First = v
		v.Last = v
		pc.Set(linkLabelStateKey, list)
	} else {
		list = tlist.(*linkLabelState)
		l := list.Last
		list.Last = v
		l.Next = v
		v.Prev = l
	}
}

func removeLinkLabelState(pc Context, d *linkLabelState) {
	tlist := pc.Get(linkLabelStateKey)
	var list *linkLabelState
	if tlist == nil {
		return
	}
	list = tlist.(*linkLabelState)

	if d.Prev == nil {
		list = d.Next
		if list != nil {
			list.First = d
			list.Last = d.Last
			list.Prev = nil
			pc.Set(linkLabelStateKey, list)
		} else {
			pc.Set(linkLabelStateKey, nil)
		}
	} else {
		d.Prev.Next = d.Next
		if d.Next != nil {
			d.Next.Prev = d.Prev
		}
	}
	if list != nil && d.Next == nil {
		list.Last = d.Prev
	}
	d.Next = nil
	d.Prev = nil
	d.First = nil
	d.Last = nil
}

type linkParser struct {
}

var defaultLinkParser = &linkParser{}

// NewLinkParser return a new InlineParser that parses links.
func NewLinkParser() InlineParser {
	return defaultLinkParser
}

func (s *linkParser) Trigger() []byte {
	return []byte{'!', '[', ']'}
}

var linkBottom = NewContextKey()

func (s *linkParser) Parse(parent ast.Node, block text.Reader, pc Context) ast.Node {
	line, segment := block.PeekLine()
	if line[0] == '!' {
		if len(line) > 1 && line[1] == '[' {
			block.Advance(1)
			pushLinkBottom(pc)
			return processLinkLabelOpen(block, segment.Start+1, true, pc)
		}
		return nil
	}
	if line[0] == '[' {
		pushLinkBottom(pc)
		return processLinkLabelOpen(block, segment.Start, false, pc)
	}

	// line[0] == ']'
	tlist := pc.Get(linkLabelStateKey)
	if tlist == nil {
		return nil
	}
	last := tlist.(*linkLabelState).Last
	if last == nil {
		_ = popLinkBottom(pc)
		return nil
	}
	block.Advance(1)
	removeLinkLabelState(pc, last)
	// CommonMark spec says:
	//  > A link label can have at most 999 characters inside the square brackets.
	if linkLabelStateLength(tlist.(*linkLabelState)) > 998 {
		ast.MergeOrReplaceTextSegment(last.Parent(), last, last.Segment)
		_ = popLinkBottom(pc)
		return nil
	}

	if !last.IsImage && s.containsLink(last) { // a link in a link text is not allowed
		ast.MergeOrReplaceTextSegment(last.Parent(), last, last.Segment)
		_ = popLinkBottom(pc)
		return nil
	}

	c := block.Peek()
	l, pos := block.Position()
	var link *ast.Link
	var hasValue bool
	if c == '(' { // normal link
		link = s.parseLink(parent, last, block, pc)
	} else if c == '[' { // reference link
		link, hasValue = s.parseReferenceLink(parent, last, block, pc)
		if link == nil && hasValue {
			ast.MergeOrReplaceTextSegment(last.Parent(), last, last.Segment)
			_ = popLinkBottom(pc)
			return nil
		}
	}

	if link == nil {
		// maybe shortcut reference link
		block.SetPosition(l, pos)
		ssegment := text.NewSegment(last.Segment.Stop, segment.Start)
		maybeReference := block.Value(ssegment)
		// CommonMark spec says:
		//  > A link label can have at most 999 characters inside the square brackets.
		if len(maybeReference) > 999 {
			ast.MergeOrReplaceTextSegment(last.Parent(), last, last.Segment)
			_ = popLinkBottom(pc)
			return nil
		}

		ref, ok := pc.Reference(util.ToLinkReference(maybeReference))
		if !ok {
			ast.MergeOrReplaceTextSegment(last.Parent(), last, last.Segment)
			_ = popLinkBottom(pc)
			return nil
		}
		link = ast.NewLink()
		s.processLinkLabel(parent, link, last, pc)
		link.Title = ref.Title()
		link.Destination = ref.Destination()
	}
	if last.IsImage {
		last.Parent().RemoveChild(last.Parent(), last)
		return ast.NewImage(link)
	}
	last.Parent().RemoveChild(last.Parent(), last)
	return link
}

func (s *linkParser) containsLink(n ast.Node) bool {
	if n == nil {
		return false
	}
	for c := n; c != nil; c = c.NextSibling() {
		if _, ok := c.(*ast.Link); ok {
			return true
		}
		if s.containsLink(c.FirstChild()) {
			return true
		}
	}
	return false
}

func processLinkLabelOpen(block text.Reader, pos int, isImage bool, pc Context) *linkLabelState {
	start := pos
	if isImage {
		start--
	}
	state := newLinkLabelState(text.NewSegment(start, pos+1), isImage)
	pushLinkLabelState(pc, state)
	block.Advance(1)
	return state
}

func (s *linkParser) processLinkLabel(parent ast.Node, link *ast.Link, last *linkLabelState, pc Context) {
	bottom := popLinkBottom(pc)
	ProcessDelimiters(bottom, pc)
	for c := last.NextSibling(); c != nil; {
		next := c.NextSibling()
		parent.RemoveChild(parent, c)
		link.AppendChild(link, c)
		c = next
	}
}

var linkFindClosureOptions text.FindClosureOptions = text.FindClosureOptions{
	Nesting: false,
	Newline: true,
	Advance: true,
}

func (s *linkParser) parseReferenceLink(parent ast.Node, last *linkLabelState,
	block text.Reader, pc Context) (*ast.Link, bool) {
	_, orgpos := block.Position()
	block.Advance(1) // skip '['
	segments, found := block.FindClosure('[', ']', linkFindClosureOptions)
	if !found {
		return nil, false
	}

	var maybeReference []byte
	if segments.Len() == 1 { // avoid allocate a new byte slice
		maybeReference = block.Value(segments.At(0))
	} else {
		maybeReference = []byte{}
		for i := 0; i < segments.Len(); i++ {
			s := segments.At(i)
			maybeReference = append(maybeReference, block.Value(s)...)
		}
	}
	if util.IsBlank(maybeReference) { // collapsed reference link
		s := text.NewSegment(last.Segment.Stop, orgpos.Start-1)
		maybeReference = block.Value(s)
	}
	// CommonMark spec says:
	//  > A link label can have at most 999 characters inside the square brackets.
	if len(maybeReference) > 999 {
		return nil, true
	}

	ref, ok := pc.Reference(util.ToLinkReference(maybeReference))
	if !ok {
		return nil, true
	}

	link := ast.NewLink()
	s.processLinkLabel(parent, link, last, pc)
	link.Title = ref.Title()
	link.Destination = ref.Destination()
	return link, true
}

func (s *linkParser) parseLink(parent ast.Node, last *linkLabelState, block text.Reader, pc Context) *ast.Link {
	block.Advance(1) // skip '('
	block.SkipSpaces()
	var title []byte
	var destination []byte
	var ok bool
	if block.Peek() == ')' { // empty link like '[link]()'
		block.Advance(1)
	} else {
		destination, ok = parseLinkDestination(block)
		if !ok {
			return nil
		}
		block.SkipSpaces()
		if block.Peek() == ')' {
			block.Advance(1)
		} else {
			title, ok = parseLinkTitle(block)
			if !ok {
				return nil
			}
			block.SkipSpaces()
			if block.Peek() == ')' {
				block.Advance(1)
			} else {
				return nil
			}
		}
	}

	link := ast.NewLink()
	s.processLinkLabel(parent, link, last, pc)
	link.Destination = destination
	link.Title = title
	return link
}

func parseLinkDestination(block text.Reader) ([]byte, bool) {
	block.SkipSpaces()
	line, _ := block.PeekLine()
	if block.Peek() == '<' {
		i := 1
		for i < len(line) {
			c := line[i]
			if c == '\\' && i < len(line)-1 && util.IsPunct(line[i+1]) {
				i += 2
				continue
			} else if c == '>' {
				block.Advance(i + 1)
				return line[1:i], true
			}
			i++
		}
		return nil, false
	}
	opened := 0
	i := 0
	for i < len(line) {
		c := line[i]
		if c == '\\' && i < len(line)-1 && util.IsPunct(line[i+1]) {
			i += 2
			continue
		} else if c == '(' {
			opened++
		} else if c == ')' {
			opened--
			if opened < 0 {
				break
			}
		} else if util.IsSpace(c) {
			break
		}
		i++
	}
	block.Advance(i)
	return line[:i], len(line[:i]) != 0
}

func parseLinkTitle(block text.Reader) ([]byte, bool) {
	block.SkipSpaces()
	opener := block.Peek()
	if opener != '"' && opener != '\'' && opener != '(' {
		return nil, false
	}
	closer := opener
	if opener == '(' {
		closer = ')'
	}
	block.Advance(1)
	segments, found := block.FindClosure(opener, closer, linkFindClosureOptions)
	if found {
		if segments.Len() == 1 {
			return block.Value(segments.At(0)), true
		}
		var title []byte
		for i := 0; i < segments.Len(); i++ {
			s := segments.At(i)
			title = append(title, block.Value(s)...)
		}
		return title, true
	}
	return nil, false
}

func pushLinkBottom(pc Context) {
	bottoms := pc.Get(linkBottom)
	b := pc.LastDelimiter()
	if bottoms == nil {
		pc.Set(linkBottom, b)
		return
	}
	if s, ok := bottoms.([]ast.Node); ok {
		pc.Set(linkBottom, append(s, b))
		return
	}
	pc.Set(linkBottom, []ast.Node{bottoms.(ast.Node), b})
}

func popLinkBottom(pc Context) ast.Node {
	bottoms := pc.Get(linkBottom)
	if bottoms == nil {
		return nil
	}
	if v, ok := bottoms.(ast.Node); ok {
		pc.Set(linkBottom, nil)
		return v
	}
	s := bottoms.([]ast.Node)
	v := s[len(s)-1]
	n := s[0 : len(s)-1]
	switch len(n) {
	case 0:
		pc.Set(linkBottom, nil)
	case 1:
		pc.Set(linkBottom, n[0])
	default:
		pc.Set(linkBottom, s[0:len(s)-1])
	}
	return v
}

func (s *linkParser) CloseBlock(parent ast.Node, block text.Reader, pc Context) {
	pc.Set(linkBottom, nil)
	tlist := pc.Get(linkLabelStateKey)
	if tlist == nil {
		return
	}
	for s := tlist.(*linkLabelState); s != nil; {
		next := s.Next
		removeLinkLabelState(pc, s)
		s.Parent().ReplaceChild(s.Parent(), s, ast.NewTextSegment(s.Segment))
		s = next
	}
}
</file>

<file path="parser/list_item.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type listItemParser struct {
}

var defaultListItemParser = &listItemParser{}

// NewListItemParser returns a new BlockParser that
// parses list items.
func NewListItemParser() BlockParser {
	return defaultListItemParser
}

func (b *listItemParser) Trigger() []byte {
	return []byte{'-', '+', '*', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
}

func (b *listItemParser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	list, lok := parent.(*ast.List)
	if !lok { // list item must be a child of a list
		return nil, NoChildren
	}
	offset := lastOffset(list)
	line, _ := reader.PeekLine()
	match, typ := matchesListItem(line, false)
	if typ == notList {
		return nil, NoChildren
	}
	if match[1]-offset > 3 {
		return nil, NoChildren
	}

	pc.Set(emptyListItemWithBlankLines, nil)

	itemOffset := calcListOffset(line, match)
	node := ast.NewListItem(match[3] + itemOffset)
	if match[4] < 0 || util.IsBlank(line[match[4]:match[5]]) {
		return node, NoChildren
	}

	pos, padding := util.IndentPosition(line[match[4]:], match[4], itemOffset)
	child := match[3] + pos
	reader.AdvanceAndSetPadding(child, padding)
	return node, HasChildren
}

func (b *listItemParser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	line, _ := reader.PeekLine()
	if util.IsBlank(line) {
		reader.AdvanceToEOL()
		return Continue | HasChildren
	}

	offset := lastOffset(node.Parent())
	isEmpty := node.ChildCount() == 0 && pc.Get(emptyListItemWithBlankLines) != nil
	indent, _ := util.IndentWidth(line, reader.LineOffset())
	if (isEmpty || indent < offset) && indent < 4 {
		_, typ := matchesListItem(line, true)
		// new list item found
		if typ != notList {
			pc.Set(skipListParserKey, listItemFlagValue)
			return Close
		}
		if !isEmpty {
			return Close
		}
	}
	pos, padding := util.IndentPosition(line, reader.LineOffset(), offset)
	reader.AdvanceAndSetPadding(pos, padding)

	return Continue | HasChildren
}

func (b *listItemParser) Close(node ast.Node, reader text.Reader, pc Context) {
	// nothing to do
}

func (b *listItemParser) CanInterruptParagraph() bool {
	return true
}

func (b *listItemParser) CanAcceptIndentedLine() bool {
	return false
}
</file>

<file path="parser/paragraph.go">
package parser

import (
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type paragraphParser struct {
}

var defaultParagraphParser = &paragraphParser{}

// NewParagraphParser returns a new BlockParser that
// parses paragraphs.
func NewParagraphParser() BlockParser {
	return defaultParagraphParser
}

func (b *paragraphParser) Trigger() []byte {
	return nil
}

func (b *paragraphParser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	_, segment := reader.PeekLine()
	segment = segment.TrimLeftSpace(reader.Source())
	if segment.IsEmpty() {
		return nil, NoChildren
	}
	node := ast.NewParagraph()
	node.Lines().Append(segment)
	reader.AdvanceToEOL()
	return node, NoChildren
}

func (b *paragraphParser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	line, segment := reader.PeekLine()
	if util.IsBlank(line) {
		return Close
	}
	node.Lines().Append(segment)
	reader.AdvanceToEOL()
	return Continue | NoChildren
}

func (b *paragraphParser) Close(node ast.Node, reader text.Reader, pc Context) {
	lines := node.Lines()
	if lines.Len() != 0 {
		// trim leading spaces
		for i := 0; i < lines.Len(); i++ {
			l := lines.At(i)
			lines.Set(i, l.TrimLeftSpace(reader.Source()))
		}

		// trim trailing spaces
		length := lines.Len()
		lastLine := node.Lines().At(length - 1)
		node.Lines().Set(length-1, lastLine.TrimRightSpace(reader.Source()))
	}
	if lines.Len() == 0 {
		node.Parent().RemoveChild(node.Parent(), node)
		return
	}
}

func (b *paragraphParser) CanInterruptParagraph() bool {
	return false
}

func (b *paragraphParser) CanAcceptIndentedLine() bool {
	return false
}
</file>

<file path="util/unicode_case_folding.go">
package util

//go:generate go run ../_tools unicode-case-folding-map -o ../_tools/unicode-case-folding-map.json
//go:generate go run ../_tools emb-structs -i ../_tools/unicode-case-folding-map.json -o ./unicode_case_folding.gen.go

var unicodeCaseFoldings map[rune][]rune

func init() {
	unicodeCaseFoldings = make(map[rune][]rune, _unicodeCaseFoldingLength)
	cTo := 0
	for i := 0; i < _unicodeCaseFoldingLength; i++ {
		tTo := cTo + int(_unicodeCaseFoldingToIndex[i])
		to := _unicodeCaseFoldingTo[cTo:tTo]
		unicodeCaseFoldings[_unicodeCaseFoldingFrom[i]] = to
		cTo = tTo
	}
}
</file>

<file path="extra_test.go">
package goldmark_test

import (
	"bytes"
	"os"
	"strconv"
	"strings"
	"testing"
	"time"

	. "github.com/yuin/goldmark"
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
)

var testTimeoutMultiplier = 1.0

func init() {
	m, err := strconv.ParseFloat(os.Getenv("GOLDMARK_TEST_TIMEOUT_MULTIPLIER"), 64)
	if err == nil {
		testTimeoutMultiplier = m
	}
}

func TestExtras(t *testing.T) {
	markdown := New(WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))
	testutil.DoTestCaseFile(markdown, "_test/extra.txt", t, testutil.ParseCliCaseArg()...)
}

func TestEndsWithNonSpaceCharacters(t *testing.T) {
	markdown := New(WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))
	source := []byte("```\na\n```")
	var b bytes.Buffer
	err := markdown.Convert(source, &b)
	if err != nil {
		t.Error(err.Error())
	}
	if b.String() != "<pre><code>a\n</code></pre>\n" {
		t.Errorf("%s \n---------\n %s", source, b.String())
	}
}

func TestWindowsNewLine(t *testing.T) {
	markdown := New(WithRendererOptions(
		html.WithXHTML(),
	))
	source := []byte("a  \r\nb\n")
	var b bytes.Buffer
	err := markdown.Convert(source, &b)
	if err != nil {
		t.Error(err.Error())
	}
	if b.String() != "<p>a<br />\nb</p>\n" {
		t.Errorf("%s\n---------\n%s", source, b.String())
	}

	source = []byte("a\\\r\nb\r\n")
	var b2 bytes.Buffer
	err = markdown.Convert(source, &b2)
	if err != nil {
		t.Error(err.Error())
	}
	if b2.String() != "<p>a<br />\nb</p>\n" {
		t.Errorf("\n%s\n---------\n%s", source, b2.String())
	}
}

type myIDs struct {
}

func (s *myIDs) Generate(value []byte, kind ast.NodeKind) []byte {
	return []byte("my-id")
}

func (s *myIDs) Put(value []byte) {
}

func TestAutogeneratedIDs(t *testing.T) {
	ctx := parser.NewContext(parser.WithIDs(&myIDs{}))
	markdown := New(WithParserOptions(parser.WithAutoHeadingID()))
	source := []byte("# Title1\n## Title2")
	var b bytes.Buffer
	err := markdown.Convert(source, &b, parser.WithContext(ctx))
	if err != nil {
		t.Error(err.Error())
	}
	if b.String() != `<h1 id="my-id">Title1</h1>
<h2 id="my-id">Title2</h2>
` {
		t.Errorf("%s\n---------\n%s", source, b.String())
	}
}

func nowMillis() int64 {
	// TODO: replace UnixNano to UnixMillis(drops Go1.16 support)
	return time.Now().UnixNano() / 1000000
}

func TestDeepNestedLabelPerformance(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping performance test in short mode")
	}
	markdown := New(WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))

	started := nowMillis()
	n := 50000
	source := []byte(strings.Repeat("[", n) + strings.Repeat("]", n))
	var b bytes.Buffer
	_ = markdown.Convert(source, &b)
	finished := nowMillis()
	if (finished - started) > int64(5000*testTimeoutMultiplier) {
		t.Error("Parsing deep nested labels took too long")
	}
}

func TestManyProcessingInstructionPerformance(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping performance test in short mode")
	}
	markdown := New(WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))

	started := nowMillis()
	n := 50000
	source := []byte("a " + strings.Repeat("<?", n))
	var b bytes.Buffer
	_ = markdown.Convert(source, &b)
	finished := nowMillis()
	if (finished - started) > int64(5000*testTimeoutMultiplier) {
		t.Error("Parsing processing instructions took too long")
	}
}

func TestManyCDATAPerformance(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping performance test in short mode")
	}
	markdown := New(WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))

	started := nowMillis()
	n := 50000
	source := []byte(strings.Repeat("a <![CDATA[", n))
	var b bytes.Buffer
	_ = markdown.Convert(source, &b)
	finished := nowMillis()
	if (finished - started) > int64(5000*testTimeoutMultiplier) {
		t.Error("Parsing processing instructions took too long")
	}
}

func TestManyDeclPerformance(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping performance test in short mode")
	}
	markdown := New(WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))

	started := nowMillis()
	n := 50000
	source := []byte(strings.Repeat("a <!A ", n))
	var b bytes.Buffer
	_ = markdown.Convert(source, &b)
	finished := nowMillis()
	if (finished - started) > int64(5000*testTimeoutMultiplier) {
		t.Error("Parsing processing instructions took too long")
	}
}

func TestManyCommentPerformance(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping performance test in short mode")
	}
	markdown := New(WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))

	started := nowMillis()
	n := 50000
	source := []byte(strings.Repeat("a <!-- ", n))
	var b bytes.Buffer
	_ = markdown.Convert(source, &b)
	finished := nowMillis()
	if (finished - started) > int64(5000*testTimeoutMultiplier) {
		t.Error("Parsing processing instructions took too long")
	}
}

func TestDangerousURLStringCase(t *testing.T) {
	markdown := New()

	source := []byte(`[Basic](javascript:alert('Basic'))
[CaseInsensitive](JaVaScRiPt:alert('CaseInsensitive'))
`)
	expected := []byte(`<p><a href="">Basic</a>
<a href="">CaseInsensitive</a></p>
`)
	var b bytes.Buffer
	_ = markdown.Convert(source, &b)
	if !bytes.Equal(expected, b.Bytes()) {
		t.Error("Dangerous URL should ignore cases:\n" + string(testutil.DiffPretty(expected, b.Bytes())))
	}
}
</file>

<file path="go.mod">
module github.com/yuin/goldmark

go 1.22
</file>

<file path="Makefile">
.PHONY: test fuzz lint gen

lint:
	golangci-lint run -c .golangci.yml ./...

test:
	go test -coverprofile=profile.out -coverpkg=github.com/yuin/goldmark,github.com/yuin/goldmark/ast,github.com/yuin/goldmark/extension,github.com/yuin/goldmark/extension/ast,github.com/yuin/goldmark/parser,github.com/yuin/goldmark/renderer,github.com/yuin/goldmark/renderer/html,github.com/yuin/goldmark/text,github.com/yuin/goldmark/util ./...

cov: test
	go tool cover -html=profile.out

fuzz:
	cd ./fuzz && go test -fuzz=FuzzDefault

gen:
	go generate ./...
</file>

<file path="_benchmark/go/go.mod">
module banchmark

go 1.22

toolchain go1.22.9

require (
	github.com/88250/lute v1.7.5
	github.com/gomarkdown/markdown v0.0.0-20230322041520-c84983bdbf2a
	github.com/russross/blackfriday/v2 v2.1.0
	github.com/yuin/goldmark v0.0.0
	gitlab.com/golang-commonmark/markdown v0.0.0-20211110145824-bf3e522c626a
)

require (
	github.com/alecthomas/chroma v0.10.0 // indirect
	github.com/dlclark/regexp2 v1.10.0 // indirect
	github.com/gopherjs/gopherjs v1.17.2 // indirect
	gitlab.com/golang-commonmark/html v0.0.0-20191124015941-a22733972181 // indirect
	gitlab.com/golang-commonmark/linkify v0.0.0-20191026162114-a0c2df6c8f82 // indirect
	gitlab.com/golang-commonmark/mdurl v0.0.0-20191124015652-932350d1cb84 // indirect
	gitlab.com/golang-commonmark/puny v0.0.0-20191124015043-9f83538fa04f // indirect
	golang.org/x/text v0.10.0 // indirect
)

replace gopkg.in/russross/blackfriday.v2 v2.0.1 => github.com/russross/blackfriday/v2 v2.0.1

replace github.com/yuin/goldmark v0.0.0 => ../../
</file>

<file path="extension/strikethrough.go">
package extension

import (
	"github.com/yuin/goldmark"
	gast "github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/extension/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type strikethroughDelimiterProcessor struct {
}

func (p *strikethroughDelimiterProcessor) IsDelimiter(b byte) bool {
	return b == '~'
}

func (p *strikethroughDelimiterProcessor) CanOpenCloser(opener, closer *parser.Delimiter) bool {
	return opener.Char == closer.Char
}

func (p *strikethroughDelimiterProcessor) OnMatch(consumes int) gast.Node {
	return ast.NewStrikethrough()
}

var defaultStrikethroughDelimiterProcessor = &strikethroughDelimiterProcessor{}

type strikethroughParser struct {
}

var defaultStrikethroughParser = &strikethroughParser{}

// NewStrikethroughParser return a new InlineParser that parses
// strikethrough expressions.
func NewStrikethroughParser() parser.InlineParser {
	return defaultStrikethroughParser
}

func (s *strikethroughParser) Trigger() []byte {
	return []byte{'~'}
}

func (s *strikethroughParser) Parse(parent gast.Node, block text.Reader, pc parser.Context) gast.Node {
	before := block.PrecendingCharacter()
	line, segment := block.PeekLine()
	node := parser.ScanDelimiter(line, before, 1, defaultStrikethroughDelimiterProcessor)
	if node == nil || node.OriginalLength > 2 || before == '~' {
		return nil
	}

	node.Segment = segment.WithStop(segment.Start + node.OriginalLength)
	block.Advance(node.OriginalLength)
	pc.PushDelimiter(node)
	return node
}

func (s *strikethroughParser) CloseBlock(parent gast.Node, pc parser.Context) {
	// nothing to do
}

// StrikethroughHTMLRenderer is a renderer.NodeRenderer implementation that
// renders Strikethrough nodes.
type StrikethroughHTMLRenderer struct {
	html.Config
}

// NewStrikethroughHTMLRenderer returns a new StrikethroughHTMLRenderer.
func NewStrikethroughHTMLRenderer(opts ...html.Option) renderer.NodeRenderer {
	r := &StrikethroughHTMLRenderer{
		Config: html.NewConfig(),
	}
	for _, opt := range opts {
		opt.SetHTMLOption(&r.Config)
	}
	return r
}

// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.
func (r *StrikethroughHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	reg.Register(ast.KindStrikethrough, r.renderStrikethrough)
}

// StrikethroughAttributeFilter defines attribute names which dd elements can have.
var StrikethroughAttributeFilter = html.GlobalAttributeFilter

func (r *StrikethroughHTMLRenderer) renderStrikethrough(
	w util.BufWriter, source []byte, n gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		if n.Attributes() != nil {
			_, _ = w.WriteString("<del")
			html.RenderAttributes(w, n, StrikethroughAttributeFilter)
			_ = w.WriteByte('>')
		} else {
			_, _ = w.WriteString("<del>")
		}
	} else {
		_, _ = w.WriteString("</del>")
	}
	return gast.WalkContinue, nil
}

type strikethrough struct {
}

// Strikethrough is an extension that allow you to use strikethrough expression like '~~text~~' .
var Strikethrough = &strikethrough{}

func (e *strikethrough) Extend(m goldmark.Markdown) {
	m.Parser().AddOptions(parser.WithInlineParsers(
		util.Prioritized(NewStrikethroughParser(), 500),
	))
	m.Renderer().AddOptions(renderer.WithNodeRenderers(
		util.Prioritized(NewStrikethroughHTMLRenderer(), 500),
	))
}
</file>

<file path="parser/raw_html.go">
package parser

import (
	"bytes"
	"regexp"

	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

type rawHTMLParser struct {
}

var defaultRawHTMLParser = &rawHTMLParser{}

// NewRawHTMLParser return a new InlineParser that can parse
// inline htmls.
func NewRawHTMLParser() InlineParser {
	return defaultRawHTMLParser
}

func (s *rawHTMLParser) Trigger() []byte {
	return []byte{'<'}
}

func (s *rawHTMLParser) Parse(parent ast.Node, block text.Reader, pc Context) ast.Node {
	line, _ := block.PeekLine()
	if len(line) > 1 && util.IsAlphaNumeric(line[1]) {
		return s.parseMultiLineRegexp(openTagRegexp, block, pc)
	}
	if len(line) > 2 && line[1] == '/' && util.IsAlphaNumeric(line[2]) {
		return s.parseMultiLineRegexp(closeTagRegexp, block, pc)
	}
	if bytes.HasPrefix(line, openComment) {
		return s.parseComment(block, pc)
	}
	if bytes.HasPrefix(line, openProcessingInstruction) {
		return s.parseUntil(block, closeProcessingInstruction, pc)
	}
	if len(line) > 2 && line[1] == '!' && line[2] >= 'A' && line[2] <= 'Z' {
		return s.parseUntil(block, closeDecl, pc)
	}
	if bytes.HasPrefix(line, openCDATA) {
		return s.parseUntil(block, closeCDATA, pc)
	}
	return nil
}

var tagnamePattern = `([A-Za-z][A-Za-z0-9-]*)`
var spaceOrOneNewline = `(?:[ \t]|(?:\r\n|\n){0,1})`
var attributePattern = `(?:[\r\n \t]+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:[\r\n \t]*=[\r\n \t]*(?:[^\"'=<>` + "`" + `\x00-\x20]+|'[^']*'|"[^"]*"))?)` //nolint:golint,lll
var openTagRegexp = regexp.MustCompile("^<" + tagnamePattern + attributePattern + `*` + spaceOrOneNewline + `*/?>`)
var closeTagRegexp = regexp.MustCompile("^</" + tagnamePattern + spaceOrOneNewline + `*>`)

var openProcessingInstruction = []byte("<?")
var closeProcessingInstruction = []byte("?>")
var openCDATA = []byte("<![CDATA[")
var closeCDATA = []byte("]]>")
var closeDecl = []byte(">")
var emptyComment1 = []byte("<!-->")
var emptyComment2 = []byte("<!--->")
var openComment = []byte("<!--")
var closeComment = []byte("-->")

func (s *rawHTMLParser) parseComment(block text.Reader, pc Context) ast.Node {
	savedLine, savedSegment := block.Position()
	node := ast.NewRawHTML()
	line, segment := block.PeekLine()
	if bytes.HasPrefix(line, emptyComment1) {
		node.Segments.Append(segment.WithStop(segment.Start + len(emptyComment1)))
		block.Advance(len(emptyComment1))
		return node
	}
	if bytes.HasPrefix(line, emptyComment2) {
		node.Segments.Append(segment.WithStop(segment.Start + len(emptyComment2)))
		block.Advance(len(emptyComment2))
		return node
	}
	offset := len(openComment)
	line = line[offset:]
	for {
		index := bytes.Index(line, closeComment)
		if index > -1 {
			node.Segments.Append(segment.WithStop(segment.Start + offset + index + len(closeComment)))
			block.Advance(offset + index + len(closeComment))
			return node
		}
		offset = 0
		node.Segments.Append(segment)
		block.AdvanceLine()
		line, segment = block.PeekLine()
		if line == nil {
			break
		}
	}
	block.SetPosition(savedLine, savedSegment)
	return nil
}

func (s *rawHTMLParser) parseUntil(block text.Reader, closer []byte, pc Context) ast.Node {
	savedLine, savedSegment := block.Position()
	node := ast.NewRawHTML()
	for {
		line, segment := block.PeekLine()
		if line == nil {
			break
		}
		index := bytes.Index(line, closer)
		if index > -1 {
			node.Segments.Append(segment.WithStop(segment.Start + index + len(closer)))
			block.Advance(index + len(closer))
			return node
		}
		node.Segments.Append(segment)
		block.AdvanceLine()
	}
	block.SetPosition(savedLine, savedSegment)
	return nil
}

func (s *rawHTMLParser) parseMultiLineRegexp(reg *regexp.Regexp, block text.Reader, pc Context) ast.Node {
	sline, ssegment := block.Position()
	if block.Match(reg) {
		node := ast.NewRawHTML()
		eline, esegment := block.Position()
		block.SetPosition(sline, ssegment)
		for {
			line, segment := block.PeekLine()
			if line == nil {
				break
			}
			l, _ := block.Position()
			start := segment.Start
			if l == sline {
				start = ssegment.Start
			}
			end := segment.Stop
			if l == eline {
				end = esegment.Start
			}

			node.Segments.Append(text.NewSegment(start, end))
			if l == eline {
				block.Advance(end - start)
				break
			}
			block.AdvanceLine()
		}
		return node
	}
	return nil
}
</file>

<file path="util/html5entities.go">
package util

import (
	"sync"
)

//go:generate go run ../_tools emb-structs -i ../_tools/html5entities.json -o ./html5entities.gen.go

var _html5entitiesOnce sync.Once
var _html5entitiesMap map[string]*HTML5Entity

func buildHTML5Entities() {
	_html5entitiesOnce.Do(func() {
		entities := make([]HTML5Entity, _html5entitiesLength)
		_html5entitiesMap = make(map[string]*HTML5Entity, _html5entitiesLength)

		cName := 0
		cCharacters := 0
		for i := 0; i < _html5entitiesLength; i++ {
			tName := cName + int(_html5entitiesNameIndex[i])
			tCharacters := cCharacters + int(_html5entitiesCharactersIndex[i])

			name := _html5entitiesName[cName:tName]
			e := &entities[i]
			e.Name = name
			e.Characters = _html5entitiesCharacters[cCharacters:tCharacters]
			_html5entitiesMap[name] = e

			cName = tName
			cCharacters = tCharacters
		}
	})
}

// HTML5Entity struct represents HTML5 entitites.
type HTML5Entity struct {
	Name       string
	Characters []byte
}

// LookUpHTML5EntityByName returns (an HTML5Entity, true) if an entity named
// given name is found, otherwise (nil, false).
func LookUpHTML5EntityByName(name string) (*HTML5Entity, bool) {
	buildHTML5Entities()
	v, ok := _html5entitiesMap[name]
	return v, ok
}
</file>

<file path=".golangci.yml">
issues:
  exclude-use-default: false
  exclude-rules:
    - path: _test.go
      linters:
        - errcheck
        - lll
  exclude:
  - "Package util"

linters:
  disable-all: true
  enable:
    - errcheck
    - gosimple
    - govet
    - ineffassign
    - staticcheck
    - typecheck
    - unused
    - gofmt
    - godot
    - makezero
    - misspell
    - revive
    - wastedassign
    - lll

linters-settings:
  revive:
    severity: "warning"
    confidence: 0.8
    rules:
      - name: blank-imports
        severity: warning
        disabled: false
      - name: context-as-argument
        severity: warning
        disabled: false
      - name: context-keys-type
        severity: warning
        disabled: false
      - name: dot-imports
        severity: warning
        disabled: true
      - name: error-return
        severity: warning
        disabled: false
      - name: error-strings
        severity: warning
        disabled: false
      - name: error-naming
        severity: warning
        disabled: false
      - name: exported
        severity: warning
        disabled: false
      - name: increment-decrement
        severity: warning
        disabled: false
      - name: var-naming
        severity: warning
        disabled: false
      - name: var-declaration
        severity: warning
        disabled: false
      - name: package-comments
        severity: warning
        disabled: false
      - name: range
        severity: warning
        disabled: false
      - name: receiver-naming
        severity: warning
        disabled: false
      - name: time-naming
        severity: warning
        disabled: false
      - name: unexported-return
        severity: warning
        disabled: false
      - name: indent-error-flow
        severity: warning
        disabled: false
      - name: errorf
        severity: warning
        disabled: false
      - name: empty-block
        severity: warning
        disabled: true
      - name: superfluous-else
        severity: warning
        disabled: false
      - name: unused-parameter
        severity: warning
        disabled: true
      - name: unreachable-code
        severity: warning
        disabled: false
      - name: redefines-builtin-id
        severity: warning
        disabled: false
</file>

<file path="ast_test.go">
package goldmark_test

import (
	"bytes"
	"testing"

	. "github.com/yuin/goldmark"
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/testutil"
	"github.com/yuin/goldmark/text"
)

func TestASTBlockNodeText(t *testing.T) {
	var cases = []struct {
		Name   string
		Source string
		T1     string
		T2     string
		C      bool
	}{
		{
			Name: "AtxHeading",
			Source: `# l1

a

# l2`,
			T1: `l1`,
			T2: `l2`,
		},
		{
			Name: "SetextHeading",
			Source: `l1
l2
===============

a

l3
l4
==============`,
			T1: `l1
l2`,
			T2: `l3
l4`,
		},
		{
			Name: "CodeBlock",
			Source: `    l1
    l2

a

    l3
	l4`,
			T1: `l1
l2
`,
			T2: `l3
l4
`,
		},
		{
			Name: "FencedCodeBlock",
			Source: "```" + `
l1
l2
` + "```" + `

a

` + "```" + `
l3
l4`,
			T1: `l1
l2
`,
			T2: `l3
l4
`,
		},
		{
			Name: "Blockquote",
			Source: `> l1
> l2

a

> l3
> l4`,
			T1: `l1
l2`,
			T2: `l3
l4`,
		},
		{
			Name: "List",
			Source: `- l1
  l2

a

- l3
  l4`,
			T1: `l1
l2`,
			T2: `l3
l4`,
			C: true,
		},
		{
			Name: "HTMLBlock",
			Source: `<div>
l1
l2
</div>

a

<div>
l3
l4`,
			T1: `<div>
l1
l2
</div>
`,
			T2: `<div>
l3
l4`,
		},
	}

	for _, cs := range cases {
		t.Run(cs.Name, func(t *testing.T) {
			s := []byte(cs.Source)
			md := New()
			n := md.Parser().Parse(text.NewReader(s))
			c1 := n.FirstChild()
			c2 := c1.NextSibling().NextSibling()
			if cs.C {
				c1 = c1.FirstChild()
				c2 = c2.FirstChild()
			}
			if !bytes.Equal(c1.Text(s), []byte(cs.T1)) { // nolint: staticcheck

				t.Errorf("%s unmatch: %s", cs.Name, testutil.DiffPretty(c1.Text(s), []byte(cs.T1))) // nolint: staticcheck

			}
			if !bytes.Equal(c2.Text(s), []byte(cs.T2)) { // nolint: staticcheck

				t.Errorf("%s(EOF) unmatch: %s", cs.Name, testutil.DiffPretty(c2.Text(s), []byte(cs.T2))) // nolint: staticcheck

			}
		})
	}

}

func TestASTInlineNodeText(t *testing.T) {
	var cases = []struct {
		Name   string
		Source string
		T1     string
	}{
		{
			Name:   "CodeSpan",
			Source: "`c1`",
			T1:     `c1`,
		},
		{
			Name:   "Emphasis",
			Source: `*c1 **c2***`,
			T1:     `c1 c2`,
		},
		{
			Name:   "Link",
			Source: `[label](url)`,
			T1:     `label`,
		},
		{
			Name:   "AutoLink",
			Source: `<http://url>`,
			T1:     `http://url`,
		},
		{
			Name:   "RawHTML",
			Source: `<span>c1</span>`,
			T1:     `<span>`,
		},
	}

	for _, cs := range cases {
		t.Run(cs.Name, func(t *testing.T) {
			s := []byte(cs.Source)
			md := New()
			n := md.Parser().Parse(text.NewReader(s))
			c1 := n.FirstChild().FirstChild()
			if !bytes.Equal(c1.Text(s), []byte(cs.T1)) { // nolint: staticcheck
				t.Errorf("%s unmatch:\n%s", cs.Name, testutil.DiffPretty(c1.Text(s), []byte(cs.T1))) // nolint: staticcheck
			}
		})
	}

}

func TestHasBlankPreviousLines(t *testing.T) {
	var cases = []struct {
		Name     string
		Source   string
		Node     func(n ast.Node) ast.Node
		Expected bool
	}{
		{
			Name: "nesting paragraphs in blockquotes",
			Source: `
> a
> 
> b
`,
			Node: func(n ast.Node) ast.Node {
				return n.FirstChild().FirstChild().NextSibling()
			},
			Expected: true,
		},
		{
			Name: "nesting HTML blocks in blockquotes",
			Source: `
> <!-- a -->
> 
> <!-- b -->
`,
			Node: func(n ast.Node) ast.Node {
				return n.FirstChild().FirstChild().NextSibling()
			},
			Expected: true,
		},
		{
			Name: "nesting HTML blocks in blockquotes",
			Source: `
> <!-- a -->
> <!-- b -->
`,
			Node: func(n ast.Node) ast.Node {
				return n.FirstChild().FirstChild().NextSibling()
			},
			Expected: false,
		},
		{
			Name: "nesting loose lists in blockquotes",
			Source: `
> - a
> 
> - b
`,
			Node: func(n ast.Node) ast.Node {
				return n.FirstChild().FirstChild().FirstChild().NextSibling()
			},
			Expected: true,
		},
		{
			Name: "nesting tight lists in blockquotes",
			Source: `
> - a
> - b
`,
			Node: func(n ast.Node) ast.Node {
				return n.FirstChild().FirstChild().FirstChild().NextSibling()
			},
			Expected: false,
		},
		{
			Name: "nesting paragraphs in lists",
			Source: `
- a

  b
`,
			Node: func(n ast.Node) ast.Node {
				return n.FirstChild().FirstChild().FirstChild().NextSibling()
			},
			Expected: true,
		},
	}
	md := New()
	for _, cs := range cases {
		t.Run(cs.Name, func(t *testing.T) {
			n := md.Parser().Parse(text.NewReader([]byte(cs.Source)))
			if cs.Node(n).HasBlankPreviousLines() != cs.Expected {
				t.Errorf("expected %v, got %v", cs.Expected, !cs.Expected)
			}
		})
	}
}
</file>

<file path=".github/workflows/test.yaml">
on: [push, pull_request]
name: test
jobs:
  test:
    strategy:
      fail-fast: false
      matrix:
        go-version: [1.22.x,1.23.x,1.24.x]
        platform: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.platform }}
    steps:
    - name: Install Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ matrix.go-version }}
    - name: Checkout code
      uses: actions/checkout@v3
    - name: Run lints
      uses: golangci/golangci-lint-action@v6
      with:
        version: latest
      if: "matrix.platform == 'ubuntu-latest'" # gofmt linter fails on Windows for CRLF problems
    - name: Run tests
      env:
        GOLDMARK_TEST_TIMEOUT_MULTIPLIER: 5
      run: go test -v ./... -covermode=count -coverprofile=coverage.out -coverpkg=./...
    - name: Install goveralls
      run: go install github.com/mattn/goveralls@latest
    - name: Send coverage
      if: "matrix.platform == 'ubuntu-latest'"
      env:
        COVERALLS_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: goveralls -coverprofile=coverage.out -service=github
</file>

<file path="ast/inline.go">
package ast

import (
	"fmt"
	"strings"

	textm "github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

// A BaseInline struct implements the Node interface partialliy.
type BaseInline struct {
	BaseNode
}

// Type implements Node.Type.
func (b *BaseInline) Type() NodeType {
	return TypeInline
}

// IsRaw implements Node.IsRaw.
func (b *BaseInline) IsRaw() bool {
	return false
}

// HasBlankPreviousLines implements Node.HasBlankPreviousLines.
func (b *BaseInline) HasBlankPreviousLines() bool {
	panic("can not call with inline nodes.")
}

// SetBlankPreviousLines implements Node.SetBlankPreviousLines.
func (b *BaseInline) SetBlankPreviousLines(v bool) {
	panic("can not call with inline nodes.")
}

// Lines implements Node.Lines.
func (b *BaseInline) Lines() *textm.Segments {
	panic("can not call with inline nodes.")
}

// SetLines implements Node.SetLines.
func (b *BaseInline) SetLines(v *textm.Segments) {
	panic("can not call with inline nodes.")
}

// A Text struct represents a textual content of the Markdown text.
type Text struct {
	BaseInline
	// Segment is a position in a source text.
	Segment textm.Segment

	flags uint8
}

const (
	textSoftLineBreak = 1 << iota
	textHardLineBreak
	textRaw
	textCode
)

func textFlagsString(flags uint8) string {
	buf := []string{}
	if flags&textSoftLineBreak != 0 {
		buf = append(buf, "SoftLineBreak")
	}
	if flags&textHardLineBreak != 0 {
		buf = append(buf, "HardLineBreak")
	}
	if flags&textRaw != 0 {
		buf = append(buf, "Raw")
	}
	if flags&textCode != 0 {
		buf = append(buf, "Code")
	}
	return strings.Join(buf, ", ")
}

// Inline implements Inline.Inline.
func (n *Text) Inline() {
}

// SoftLineBreak returns true if this node ends with a new line,
// otherwise false.
func (n *Text) SoftLineBreak() bool {
	return n.flags&textSoftLineBreak != 0
}

// SetSoftLineBreak sets whether this node ends with a new line.
func (n *Text) SetSoftLineBreak(v bool) {
	if v {
		n.flags |= textSoftLineBreak
	} else {
		n.flags = n.flags &^ textSoftLineBreak
	}
}

// IsRaw returns true if this text should be rendered without unescaping
// back slash escapes and resolving references.
func (n *Text) IsRaw() bool {
	return n.flags&textRaw != 0
}

// SetRaw sets whether this text should be rendered as raw contents.
func (n *Text) SetRaw(v bool) {
	if v {
		n.flags |= textRaw
	} else {
		n.flags = n.flags &^ textRaw
	}
}

// HardLineBreak returns true if this node ends with a hard line break.
// See https://spec.commonmark.org/0.30/#hard-line-breaks for details.
func (n *Text) HardLineBreak() bool {
	return n.flags&textHardLineBreak != 0
}

// SetHardLineBreak sets whether this node ends with a hard line break.
func (n *Text) SetHardLineBreak(v bool) {
	if v {
		n.flags |= textHardLineBreak
	} else {
		n.flags = n.flags &^ textHardLineBreak
	}
}

// Merge merges a Node n into this node.
// Merge returns true if the given node has been merged, otherwise false.
func (n *Text) Merge(node Node, source []byte) bool {
	t, ok := node.(*Text)
	if !ok {
		return false
	}
	if n.Segment.Stop != t.Segment.Start || t.Segment.Padding != 0 ||
		source[n.Segment.Stop-1] == '\n' || t.IsRaw() != n.IsRaw() {
		return false
	}
	n.Segment.Stop = t.Segment.Stop
	n.SetSoftLineBreak(t.SoftLineBreak())
	n.SetHardLineBreak(t.HardLineBreak())
	return true
}

// Text implements Node.Text.
//
// Deprecated: Use other properties of the node to get the text value(i.e. Text.Value).
func (n *Text) Text(source []byte) []byte {
	return n.Segment.Value(source)
}

// Value returns a value of this node.
// SoftLineBreaks are not included in the returned value.
func (n *Text) Value(source []byte) []byte {
	return n.Segment.Value(source)
}

// Dump implements Node.Dump.
func (n *Text) Dump(source []byte, level int) {
	fs := textFlagsString(n.flags)
	if len(fs) != 0 {
		fs = "(" + fs + ")"
	}
	fmt.Printf("%sText%s: \"%s\"\n", strings.Repeat("    ", level), fs, strings.TrimRight(string(n.Value(source)), "\n"))
}

// KindText is a NodeKind of the Text node.
var KindText = NewNodeKind("Text")

// Kind implements Node.Kind.
func (n *Text) Kind() NodeKind {
	return KindText
}

// NewText returns a new Text node.
func NewText() *Text {
	return &Text{
		BaseInline: BaseInline{},
	}
}

// NewTextSegment returns a new Text node with the given source position.
func NewTextSegment(v textm.Segment) *Text {
	return &Text{
		BaseInline: BaseInline{},
		Segment:    v,
	}
}

// NewRawTextSegment returns a new Text node with the given source position.
// The new node should be rendered as raw contents.
func NewRawTextSegment(v textm.Segment) *Text {
	t := &Text{
		BaseInline: BaseInline{},
		Segment:    v,
	}
	t.SetRaw(true)
	return t
}

// MergeOrAppendTextSegment merges a given s into the last child of the parent if
// it can be merged, otherwise creates a new Text node and appends it to after current
// last child.
func MergeOrAppendTextSegment(parent Node, s textm.Segment) {
	last := parent.LastChild()
	t, ok := last.(*Text)
	if ok && t.Segment.Stop == s.Start && !t.SoftLineBreak() {
		t.Segment = t.Segment.WithStop(s.Stop)
	} else {
		parent.AppendChild(parent, NewTextSegment(s))
	}
}

// MergeOrReplaceTextSegment merges a given s into a previous sibling of the node n
// if a previous sibling of the node n is *Text, otherwise replaces Node n with s.
func MergeOrReplaceTextSegment(parent Node, n Node, s textm.Segment) {
	prev := n.PreviousSibling()
	if t, ok := prev.(*Text); ok && t.Segment.Stop == s.Start && !t.SoftLineBreak() {
		t.Segment = t.Segment.WithStop(s.Stop)
		parent.RemoveChild(parent, n)
	} else {
		parent.ReplaceChild(parent, n, NewTextSegment(s))
	}
}

// A String struct is a textual content that has a concrete value.
type String struct {
	BaseInline

	Value []byte
	flags uint8
}

// Inline implements Inline.Inline.
func (n *String) Inline() {
}

// IsRaw returns true if this text should be rendered without unescaping
// back slash escapes and resolving references.
func (n *String) IsRaw() bool {
	return n.flags&textRaw != 0
}

// SetRaw sets whether this text should be rendered as raw contents.
func (n *String) SetRaw(v bool) {
	if v {
		n.flags |= textRaw
	} else {
		n.flags = n.flags &^ textRaw
	}
}

// IsCode returns true if this text should be rendered without any
// modifications.
func (n *String) IsCode() bool {
	return n.flags&textCode != 0
}

// SetCode sets whether this text should be rendered without any modifications.
func (n *String) SetCode(v bool) {
	if v {
		n.flags |= textCode
	} else {
		n.flags = n.flags &^ textCode
	}
}

// Text implements Node.Text.
//
// Deprecated: Use other properties of the node to get the text value(i.e. String.Value).
func (n *String) Text(source []byte) []byte {
	return n.Value
}

// Dump implements Node.Dump.
func (n *String) Dump(source []byte, level int) {
	fs := textFlagsString(n.flags)
	if len(fs) != 0 {
		fs = "(" + fs + ")"
	}
	fmt.Printf("%sString%s: \"%s\"\n", strings.Repeat("    ", level), fs, strings.TrimRight(string(n.Value), "\n"))
}

// KindString is a NodeKind of the String node.
var KindString = NewNodeKind("String")

// Kind implements Node.Kind.
func (n *String) Kind() NodeKind {
	return KindString
}

// NewString returns a new String node.
func NewString(v []byte) *String {
	return &String{
		Value: v,
	}
}

// A CodeSpan struct represents a code span of Markdown text.
type CodeSpan struct {
	BaseInline
}

// Inline implements Inline.Inline .
func (n *CodeSpan) Inline() {
}

// IsBlank returns true if this node consists of spaces, otherwise false.
func (n *CodeSpan) IsBlank(source []byte) bool {
	for c := n.FirstChild(); c != nil; c = c.NextSibling() {
		text := c.(*Text).Segment
		if !util.IsBlank(text.Value(source)) {
			return false
		}
	}
	return true
}

// Dump implements Node.Dump.
func (n *CodeSpan) Dump(source []byte, level int) {
	DumpHelper(n, source, level, nil, nil)
}

// KindCodeSpan is a NodeKind of the CodeSpan node.
var KindCodeSpan = NewNodeKind("CodeSpan")

// Kind implements Node.Kind.
func (n *CodeSpan) Kind() NodeKind {
	return KindCodeSpan
}

// NewCodeSpan returns a new CodeSpan node.
func NewCodeSpan() *CodeSpan {
	return &CodeSpan{
		BaseInline: BaseInline{},
	}
}

// An Emphasis struct represents an emphasis of Markdown text.
type Emphasis struct {
	BaseInline

	// Level is a level of the emphasis.
	Level int
}

// Dump implements Node.Dump.
func (n *Emphasis) Dump(source []byte, level int) {
	m := map[string]string{
		"Level": fmt.Sprintf("%v", n.Level),
	}
	DumpHelper(n, source, level, m, nil)
}

// KindEmphasis is a NodeKind of the Emphasis node.
var KindEmphasis = NewNodeKind("Emphasis")

// Kind implements Node.Kind.
func (n *Emphasis) Kind() NodeKind {
	return KindEmphasis
}

// NewEmphasis returns a new Emphasis node with the given level.
func NewEmphasis(level int) *Emphasis {
	return &Emphasis{
		BaseInline: BaseInline{},
		Level:      level,
	}
}

type baseLink struct {
	BaseInline

	// Destination is a destination(URL) of this link.
	Destination []byte

	// Title is a title of this link.
	Title []byte
}

// Inline implements Inline.Inline.
func (n *baseLink) Inline() {
}

// A Link struct represents a link of the Markdown text.
type Link struct {
	baseLink
}

// Dump implements Node.Dump.
func (n *Link) Dump(source []byte, level int) {
	m := map[string]string{}
	m["Destination"] = string(n.Destination)
	m["Title"] = string(n.Title)
	DumpHelper(n, source, level, m, nil)
}

// KindLink is a NodeKind of the Link node.
var KindLink = NewNodeKind("Link")

// Kind implements Node.Kind.
func (n *Link) Kind() NodeKind {
	return KindLink
}

// NewLink returns a new Link node.
func NewLink() *Link {
	c := &Link{
		baseLink: baseLink{
			BaseInline: BaseInline{},
		},
	}
	return c
}

// An Image struct represents an image of the Markdown text.
type Image struct {
	baseLink
}

// Dump implements Node.Dump.
func (n *Image) Dump(source []byte, level int) {
	m := map[string]string{}
	m["Destination"] = string(n.Destination)
	m["Title"] = string(n.Title)
	DumpHelper(n, source, level, m, nil)
}

// KindImage is a NodeKind of the Image node.
var KindImage = NewNodeKind("Image")

// Kind implements Node.Kind.
func (n *Image) Kind() NodeKind {
	return KindImage
}

// NewImage returns a new Image node.
func NewImage(link *Link) *Image {
	c := &Image{
		baseLink: baseLink{
			BaseInline: BaseInline{},
		},
	}
	c.Destination = link.Destination
	c.Title = link.Title
	for n := link.FirstChild(); n != nil; {
		next := n.NextSibling()
		link.RemoveChild(link, n)
		c.AppendChild(c, n)
		n = next
	}

	return c
}

// AutoLinkType defines kind of auto links.
type AutoLinkType int

const (
	// AutoLinkEmail indicates that an autolink is an email address.
	AutoLinkEmail AutoLinkType = iota + 1
	// AutoLinkURL indicates that an autolink is a generic URL.
	AutoLinkURL
)

// An AutoLink struct represents an autolink of the Markdown text.
type AutoLink struct {
	BaseInline
	// Type is a type of this autolink.
	AutoLinkType AutoLinkType

	// Protocol specified a protocol of the link.
	Protocol []byte

	value *Text
}

// Inline implements Inline.Inline.
func (n *AutoLink) Inline() {}

// Dump implements Node.Dump.
func (n *AutoLink) Dump(source []byte, level int) {
	segment := n.value.Segment
	m := map[string]string{
		"Value": string(segment.Value(source)),
	}
	DumpHelper(n, source, level, m, nil)
}

// KindAutoLink is a NodeKind of the AutoLink node.
var KindAutoLink = NewNodeKind("AutoLink")

// Kind implements Node.Kind.
func (n *AutoLink) Kind() NodeKind {
	return KindAutoLink
}

// URL returns an url of this node.
func (n *AutoLink) URL(source []byte) []byte {
	if n.Protocol != nil {
		s := n.value.Segment
		ret := make([]byte, 0, len(n.Protocol)+s.Len()+3)
		ret = append(ret, n.Protocol...)
		ret = append(ret, ':', '/', '/')
		ret = append(ret, n.value.Value(source)...)
		return ret
	}
	return n.value.Value(source)
}

// Label returns a label of this node.
func (n *AutoLink) Label(source []byte) []byte {
	return n.value.Value(source)
}

// Text implements Node.Text.
//
// Deprecated: Use other properties of the node to get the text value(i.e. AutoLink.Label).
func (n *AutoLink) Text(source []byte) []byte {
	return n.value.Value(source)
}

// NewAutoLink returns a new AutoLink node.
func NewAutoLink(typ AutoLinkType, value *Text) *AutoLink {
	return &AutoLink{
		BaseInline:   BaseInline{},
		value:        value,
		AutoLinkType: typ,
	}
}

// A RawHTML struct represents an inline raw HTML of the Markdown text.
type RawHTML struct {
	BaseInline
	Segments *textm.Segments
}

// Inline implements Inline.Inline.
func (n *RawHTML) Inline() {}

// Dump implements Node.Dump.
func (n *RawHTML) Dump(source []byte, level int) {
	m := map[string]string{}
	t := []string{}
	for i := 0; i < n.Segments.Len(); i++ {
		segment := n.Segments.At(i)
		t = append(t, string(segment.Value(source)))
	}
	m["RawText"] = strings.Join(t, "")
	DumpHelper(n, source, level, m, nil)
}

// KindRawHTML is a NodeKind of the RawHTML node.
var KindRawHTML = NewNodeKind("RawHTML")

// Kind implements Node.Kind.
func (n *RawHTML) Kind() NodeKind {
	return KindRawHTML
}

// Text implements Node.Text.
//
// Deprecated: Use other properties of the node to get the text value(i.e. RawHTML.Segments).
func (n *RawHTML) Text(source []byte) []byte {
	return n.Segments.Value(source)
}

// NewRawHTML returns a new RawHTML node.
func NewRawHTML() *RawHTML {
	return &RawHTML{
		Segments: textm.NewSegments(),
	}
}
</file>

<file path="parser/html_block.go">
package parser

import (
	"bytes"
	"regexp"
	"strings"

	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

var allowedBlockTags = map[string]bool{
	"address":    true,
	"article":    true,
	"aside":      true,
	"base":       true,
	"basefont":   true,
	"blockquote": true,
	"body":       true,
	"caption":    true,
	"center":     true,
	"col":        true,
	"colgroup":   true,
	"dd":         true,
	"details":    true,
	"dialog":     true,
	"dir":        true,
	"div":        true,
	"dl":         true,
	"dt":         true,
	"fieldset":   true,
	"figcaption": true,
	"figure":     true,
	"footer":     true,
	"form":       true,
	"frame":      true,
	"frameset":   true,
	"h1":         true,
	"h2":         true,
	"h3":         true,
	"h4":         true,
	"h5":         true,
	"h6":         true,
	"head":       true,
	"header":     true,
	"hr":         true,
	"html":       true,
	"iframe":     true,
	"legend":     true,
	"li":         true,
	"link":       true,
	"main":       true,
	"menu":       true,
	"menuitem":   true,
	"meta":       true,
	"nav":        true,
	"noframes":   true,
	"ol":         true,
	"optgroup":   true,
	"option":     true,
	"p":          true,
	"param":      true,
	"search":     true,
	"section":    true,
	"summary":    true,
	"table":      true,
	"tbody":      true,
	"td":         true,
	"tfoot":      true,
	"th":         true,
	"thead":      true,
	"title":      true,
	"tr":         true,
	"track":      true,
	"ul":         true,
}

var htmlBlockType1OpenRegexp = regexp.MustCompile(`(?i)^[ ]{0,3}<(script|pre|style|textarea)(?:\s.*|>.*|/>.*|)(?:\r\n|\n)?$`) //nolint:golint,lll
var htmlBlockType1CloseRegexp = regexp.MustCompile(`(?i)^.*</(?:script|pre|style|textarea)>.*`)

var htmlBlockType2OpenRegexp = regexp.MustCompile(`^[ ]{0,3}<!\-\-`)
var htmlBlockType2Close = []byte{'-', '-', '>'}

var htmlBlockType3OpenRegexp = regexp.MustCompile(`^[ ]{0,3}<\?`)
var htmlBlockType3Close = []byte{'?', '>'}

var htmlBlockType4OpenRegexp = regexp.MustCompile(`^[ ]{0,3}<![A-Z]+.*(?:\r\n|\n)?$`)
var htmlBlockType4Close = []byte{'>'}

var htmlBlockType5OpenRegexp = regexp.MustCompile(`^[ ]{0,3}<\!\[CDATA\[`)
var htmlBlockType5Close = []byte{']', ']', '>'}

var htmlBlockType6Regexp = regexp.MustCompile(`^[ ]{0,3}<(?:/[ ]*)?([a-zA-Z]+[a-zA-Z0-9\-]*)(?:[ ].*|>.*|/>.*|)(?:\r\n|\n)?$`) //nolint:golint,lll

var htmlBlockType7Regexp = regexp.MustCompile(`^[ ]{0,3}<(/[ ]*)?([a-zA-Z]+[a-zA-Z0-9\-]*)(` + attributePattern + `*)[ ]*(?:>|/>)[ ]*(?:\r\n|\n)?$`) //nolint:golint,lll

type htmlBlockParser struct {
}

var defaultHTMLBlockParser = &htmlBlockParser{}

// NewHTMLBlockParser return a new BlockParser that can parse html
// blocks.
func NewHTMLBlockParser() BlockParser {
	return defaultHTMLBlockParser
}

func (b *htmlBlockParser) Trigger() []byte {
	return []byte{'<'}
}

func (b *htmlBlockParser) Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State) {
	var node *ast.HTMLBlock
	line, segment := reader.PeekLine()
	last := pc.LastOpenedBlock().Node
	if pos := pc.BlockOffset(); pos < 0 || line[pos] != '<' {
		return nil, NoChildren
	}

	if m := htmlBlockType1OpenRegexp.FindSubmatchIndex(line); m != nil {
		node = ast.NewHTMLBlock(ast.HTMLBlockType1)
	} else if htmlBlockType2OpenRegexp.Match(line) {
		node = ast.NewHTMLBlock(ast.HTMLBlockType2)
	} else if htmlBlockType3OpenRegexp.Match(line) {
		node = ast.NewHTMLBlock(ast.HTMLBlockType3)
	} else if htmlBlockType4OpenRegexp.Match(line) {
		node = ast.NewHTMLBlock(ast.HTMLBlockType4)
	} else if htmlBlockType5OpenRegexp.Match(line) {
		node = ast.NewHTMLBlock(ast.HTMLBlockType5)
	} else if match := htmlBlockType7Regexp.FindSubmatchIndex(line); match != nil {
		isCloseTag := match[2] > -1 && bytes.Equal(line[match[2]:match[3]], []byte("/"))
		hasAttr := match[6] != match[7]
		tagName := strings.ToLower(string(line[match[4]:match[5]]))
		_, ok := allowedBlockTags[tagName]
		if ok {
			node = ast.NewHTMLBlock(ast.HTMLBlockType6)
		} else if tagName != "script" && tagName != "style" &&
			tagName != "pre" && !ast.IsParagraph(last) && !(isCloseTag && hasAttr) { // type 7 can not interrupt paragraph
			node = ast.NewHTMLBlock(ast.HTMLBlockType7)
		}
	}
	if node == nil {
		if match := htmlBlockType6Regexp.FindSubmatchIndex(line); match != nil {
			tagName := string(line[match[2]:match[3]])
			_, ok := allowedBlockTags[strings.ToLower(tagName)]
			if ok {
				node = ast.NewHTMLBlock(ast.HTMLBlockType6)
			}
		}
	}
	if node != nil {
		reader.AdvanceToEOL()
		node.Lines().Append(segment)
		return node, NoChildren
	}
	return nil, NoChildren
}

func (b *htmlBlockParser) Continue(node ast.Node, reader text.Reader, pc Context) State {
	htmlBlock := node.(*ast.HTMLBlock)
	lines := htmlBlock.Lines()
	line, segment := reader.PeekLine()
	var closurePattern []byte

	switch htmlBlock.HTMLBlockType {
	case ast.HTMLBlockType1:
		if lines.Len() == 1 {
			firstLine := lines.At(0)
			if htmlBlockType1CloseRegexp.Match(firstLine.Value(reader.Source())) {
				return Close
			}
		}
		if htmlBlockType1CloseRegexp.Match(line) {
			htmlBlock.ClosureLine = segment
			reader.AdvanceToEOL()
			return Close
		}
	case ast.HTMLBlockType2:
		closurePattern = htmlBlockType2Close
		fallthrough
	case ast.HTMLBlockType3:
		if closurePattern == nil {
			closurePattern = htmlBlockType3Close
		}
		fallthrough
	case ast.HTMLBlockType4:
		if closurePattern == nil {
			closurePattern = htmlBlockType4Close
		}
		fallthrough
	case ast.HTMLBlockType5:
		if closurePattern == nil {
			closurePattern = htmlBlockType5Close
		}

		if lines.Len() == 1 {
			firstLine := lines.At(0)
			if bytes.Contains(firstLine.Value(reader.Source()), closurePattern) {
				return Close
			}
		}
		if bytes.Contains(line, closurePattern) {
			htmlBlock.ClosureLine = segment
			reader.AdvanceToEOL()
			return Close
		}

	case ast.HTMLBlockType6, ast.HTMLBlockType7:
		if util.IsBlank(line) {
			return Close
		}
	}
	node.Lines().Append(segment)
	reader.AdvanceToEOL()
	return Continue | NoChildren
}

func (b *htmlBlockParser) Close(node ast.Node, reader text.Reader, pc Context) {
	// nothing to do
}

func (b *htmlBlockParser) CanInterruptParagraph() bool {
	return true
}

func (b *htmlBlockParser) CanAcceptIndentedLine() bool {
	return false
}
</file>

<file path="text/segment.go">
package text

import (
	"bytes"

	"github.com/yuin/goldmark/util"
)

var space = []byte(" ")

// A Segment struct holds information about source positions.
type Segment struct {
	// Start is a start position of the segment.
	Start int

	// Stop is a stop position of the segment.
	// This value should be excluded.
	Stop int

	// Padding is a padding length of the segment.
	Padding int

	// ForceNewline is true if the segment should be ended with a newline.
	// Some elements(i.e. CodeBlock, FencedCodeBlock) does not trim trailing
	// newlines. Spec defines that EOF is treated as a newline, so we need to
	// add a newline to the end of the segment if it is not empty.
	//
	// i.e.:
	//
	//     ```go
	//     const test = "test"
	//
	// This code does not close the code block and ends with EOF. In this case,
	// we need to add a newline to the end of the last line like `const test = "test"\n`.
	ForceNewline bool
}

// NewSegment return a new Segment.
func NewSegment(start, stop int) Segment {
	return Segment{
		Start:   start,
		Stop:    stop,
		Padding: 0,
	}
}

// NewSegmentPadding returns a new Segment with the given padding.
func NewSegmentPadding(start, stop, n int) Segment {
	return Segment{
		Start:   start,
		Stop:    stop,
		Padding: n,
	}
}

// Value returns a value of the segment.
func (t *Segment) Value(buffer []byte) []byte {
	var result []byte
	if t.Padding == 0 {
		result = buffer[t.Start:t.Stop]
	} else {
		result = make([]byte, 0, t.Padding+t.Stop-t.Start+1)
		result = append(result, bytes.Repeat(space, t.Padding)...)
		result = append(result, buffer[t.Start:t.Stop]...)
	}
	if t.ForceNewline && len(result) > 0 && result[len(result)-1] != '\n' {
		result = append(result, '\n')
	}
	return result
}

// Len returns a length of the segment.
func (t *Segment) Len() int {
	return t.Stop - t.Start + t.Padding
}

// Between returns a segment between this segment and the given segment.
func (t *Segment) Between(other Segment) Segment {
	if t.Stop != other.Stop {
		panic("invalid state")
	}
	return NewSegmentPadding(
		t.Start,
		other.Start,
		t.Padding-other.Padding,
	)
}

// IsEmpty returns true if this segment is empty, otherwise false.
func (t *Segment) IsEmpty() bool {
	return t.Start >= t.Stop && t.Padding == 0
}

// TrimRightSpace returns a new segment by slicing off all trailing
// space characters.
func (t *Segment) TrimRightSpace(buffer []byte) Segment {
	v := buffer[t.Start:t.Stop]
	l := util.TrimRightSpaceLength(v)
	if l == len(v) {
		return NewSegment(t.Start, t.Start)
	}
	return NewSegmentPadding(t.Start, t.Stop-l, t.Padding)
}

// TrimLeftSpace returns a new segment by slicing off all leading
// space characters including padding.
func (t *Segment) TrimLeftSpace(buffer []byte) Segment {
	v := buffer[t.Start:t.Stop]
	l := util.TrimLeftSpaceLength(v)
	return NewSegment(t.Start+l, t.Stop)
}

// TrimLeftSpaceWidth returns a new segment by slicing off leading space
// characters until the given width.
func (t *Segment) TrimLeftSpaceWidth(width int, buffer []byte) Segment {
	padding := t.Padding
	for ; width > 0; width-- {
		if padding == 0 {
			break
		}
		padding--
	}
	if width == 0 {
		return NewSegmentPadding(t.Start, t.Stop, padding)
	}
	text := buffer[t.Start:t.Stop]
	start := t.Start
	for _, c := range text {
		if start >= t.Stop-1 || width <= 0 {
			break
		}
		if c == ' ' {
			width--
		} else if c == '\t' {
			width -= 4
		} else {
			break
		}
		start++
	}
	if width < 0 {
		padding = width * -1
	}
	return NewSegmentPadding(start, t.Stop, padding)
}

// WithStart returns a new Segment with same value except Start.
func (t *Segment) WithStart(v int) Segment {
	return NewSegmentPadding(v, t.Stop, t.Padding)
}

// WithStop returns a new Segment with same value except Stop.
func (t *Segment) WithStop(v int) Segment {
	return NewSegmentPadding(t.Start, v, t.Padding)
}

// ConcatPadding concats the padding to the given slice.
func (t *Segment) ConcatPadding(v []byte) []byte {
	if t.Padding > 0 {
		return append(v, bytes.Repeat(space, t.Padding)...)
	}
	return v
}

// Segments is a collection of the Segment.
type Segments struct {
	values []Segment
}

// NewSegments return a new Segments.
func NewSegments() *Segments {
	return &Segments{
		values: nil,
	}
}

// Append appends the given segment after the tail of the collection.
func (s *Segments) Append(t Segment) {
	s.values = append(s.values, t)
}

// AppendAll appends all elements of given segments after the tail of the collection.
func (s *Segments) AppendAll(t []Segment) {
	s.values = append(s.values, t...)
}

// Len returns the length of the collection.
func (s *Segments) Len() int {
	if s.values == nil {
		return 0
	}
	return len(s.values)
}

// At returns a segment at the given index.
func (s *Segments) At(i int) Segment {
	return s.values[i]
}

// Set sets the given Segment.
func (s *Segments) Set(i int, v Segment) {
	s.values[i] = v
}

// SetSliced replace the collection with a subsliced value.
func (s *Segments) SetSliced(lo, hi int) {
	s.values = s.values[lo:hi]
}

// Sliced returns a subslice of the collection.
func (s *Segments) Sliced(lo, hi int) []Segment {
	return s.values[lo:hi]
}

// Clear delete all element of the collection.
func (s *Segments) Clear() {
	s.values = nil
}

// Unshift insert the given Segment to head of the collection.
func (s *Segments) Unshift(v Segment) {
	s.values = append(s.values[0:1], s.values[0:]...)
	s.values[0] = v
}

// Value returns a string value of the collection.
func (s *Segments) Value(buffer []byte) []byte {
	var result []byte
	for _, v := range s.values {
		result = append(result, v.Value(buffer)...)
	}
	return result
}
</file>

<file path="extension/table.go">
package extension

import (
	"bytes"
	"fmt"
	"regexp"

	"github.com/yuin/goldmark"
	gast "github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/extension/ast"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

var escapedPipeCellListKey = parser.NewContextKey()

type escapedPipeCell struct {
	Cell        *ast.TableCell
	Pos         []int
	Transformed bool
}

// TableCellAlignMethod indicates how are table cells aligned in HTML format.
type TableCellAlignMethod int

const (
	// TableCellAlignDefault renders alignments by default method.
	// With XHTML, alignments are rendered as an align attribute.
	// With HTML5, alignments are rendered as a style attribute.
	TableCellAlignDefault TableCellAlignMethod = iota

	// TableCellAlignAttribute renders alignments as an align attribute.
	TableCellAlignAttribute

	// TableCellAlignStyle renders alignments as a style attribute.
	TableCellAlignStyle

	// TableCellAlignNone does not care about alignments.
	// If you using classes or other styles, you can add these attributes
	// in an ASTTransformer.
	TableCellAlignNone
)

// TableConfig struct holds options for the extension.
type TableConfig struct {
	html.Config

	// TableCellAlignMethod indicates how are table celss aligned.
	TableCellAlignMethod TableCellAlignMethod
}

// TableOption interface is a functional option interface for the extension.
type TableOption interface {
	renderer.Option
	// SetTableOption sets given option to the extension.
	SetTableOption(*TableConfig)
}

// NewTableConfig returns a new Config with defaults.
func NewTableConfig() TableConfig {
	return TableConfig{
		Config:               html.NewConfig(),
		TableCellAlignMethod: TableCellAlignDefault,
	}
}

// SetOption implements renderer.SetOptioner.
func (c *TableConfig) SetOption(name renderer.OptionName, value interface{}) {
	switch name {
	case optTableCellAlignMethod:
		c.TableCellAlignMethod = value.(TableCellAlignMethod)
	default:
		c.Config.SetOption(name, value)
	}
}

type withTableHTMLOptions struct {
	value []html.Option
}

func (o *withTableHTMLOptions) SetConfig(c *renderer.Config) {
	if o.value != nil {
		for _, v := range o.value {
			v.(renderer.Option).SetConfig(c)
		}
	}
}

func (o *withTableHTMLOptions) SetTableOption(c *TableConfig) {
	if o.value != nil {
		for _, v := range o.value {
			v.SetHTMLOption(&c.Config)
		}
	}
}

// WithTableHTMLOptions is functional option that wraps goldmark HTMLRenderer options.
func WithTableHTMLOptions(opts ...html.Option) TableOption {
	return &withTableHTMLOptions{opts}
}

const optTableCellAlignMethod renderer.OptionName = "TableTableCellAlignMethod"

type withTableCellAlignMethod struct {
	value TableCellAlignMethod
}

func (o *withTableCellAlignMethod) SetConfig(c *renderer.Config) {
	c.Options[optTableCellAlignMethod] = o.value
}

func (o *withTableCellAlignMethod) SetTableOption(c *TableConfig) {
	c.TableCellAlignMethod = o.value
}

// WithTableCellAlignMethod is a functional option that indicates how are table cells aligned in HTML format.
func WithTableCellAlignMethod(a TableCellAlignMethod) TableOption {
	return &withTableCellAlignMethod{a}
}

func isTableDelim(bs []byte) bool {
	if w, _ := util.IndentWidth(bs, 0); w > 3 {
		return false
	}
	for _, b := range bs {
		if !(util.IsSpace(b) || b == '-' || b == '|' || b == ':') {
			return false
		}
	}
	return true
}

var tableDelimLeft = regexp.MustCompile(`^\s*\:\-+\s*$`)
var tableDelimRight = regexp.MustCompile(`^\s*\-+\:\s*$`)
var tableDelimCenter = regexp.MustCompile(`^\s*\:\-+\:\s*$`)
var tableDelimNone = regexp.MustCompile(`^\s*\-+\s*$`)

type tableParagraphTransformer struct {
}

var defaultTableParagraphTransformer = &tableParagraphTransformer{}

// NewTableParagraphTransformer returns  a new ParagraphTransformer
// that can transform paragraphs into tables.
func NewTableParagraphTransformer() parser.ParagraphTransformer {
	return defaultTableParagraphTransformer
}

func (b *tableParagraphTransformer) Transform(node *gast.Paragraph, reader text.Reader, pc parser.Context) {
	lines := node.Lines()
	if lines.Len() < 2 {
		return
	}
	for i := 1; i < lines.Len(); i++ {
		alignments := b.parseDelimiter(lines.At(i), reader)
		if alignments == nil {
			continue
		}
		header := b.parseRow(lines.At(i-1), alignments, true, reader, pc)
		if header == nil || len(alignments) != header.ChildCount() {
			return
		}
		table := ast.NewTable()
		table.Alignments = alignments
		table.AppendChild(table, ast.NewTableHeader(header))
		for j := i + 1; j < lines.Len(); j++ {
			table.AppendChild(table, b.parseRow(lines.At(j), alignments, false, reader, pc))
		}
		node.Lines().SetSliced(0, i-1)
		node.Parent().InsertAfter(node.Parent(), node, table)
		if node.Lines().Len() == 0 {
			node.Parent().RemoveChild(node.Parent(), node)
		} else {
			last := node.Lines().At(i - 2)
			last.Stop = last.Stop - 1 // trim last newline(\n)
			node.Lines().Set(i-2, last)
		}
	}
}

func (b *tableParagraphTransformer) parseRow(segment text.Segment,
	alignments []ast.Alignment, isHeader bool, reader text.Reader, pc parser.Context) *ast.TableRow {
	source := reader.Source()
	segment = segment.TrimLeftSpace(source)
	segment = segment.TrimRightSpace(source)
	line := segment.Value(source)
	pos := 0
	limit := len(line)
	row := ast.NewTableRow(alignments)
	if len(line) > 0 && line[pos] == '|' {
		pos++
	}
	if len(line) > 0 && line[limit-1] == '|' {
		limit--
	}
	i := 0
	for ; pos < limit; i++ {
		alignment := ast.AlignNone
		if i >= len(alignments) {
			if !isHeader {
				return row
			}
		} else {
			alignment = alignments[i]
		}

		var escapedCell *escapedPipeCell
		node := ast.NewTableCell()
		node.Alignment = alignment
		hasBacktick := false
		closure := pos
		for ; closure < limit; closure++ {
			if line[closure] == '`' {
				hasBacktick = true
			}
			if line[closure] == '|' {
				if closure == 0 || line[closure-1] != '\\' {
					break
				} else if hasBacktick {
					if escapedCell == nil {
						escapedCell = &escapedPipeCell{node, []int{}, false}
						escapedList := pc.ComputeIfAbsent(escapedPipeCellListKey,
							func() interface{} {
								return []*escapedPipeCell{}
							}).([]*escapedPipeCell)
						escapedList = append(escapedList, escapedCell)
						pc.Set(escapedPipeCellListKey, escapedList)
					}
					escapedCell.Pos = append(escapedCell.Pos, segment.Start+closure-1)
				}
			}
		}
		seg := text.NewSegment(segment.Start+pos, segment.Start+closure)
		seg = seg.TrimLeftSpace(source)
		seg = seg.TrimRightSpace(source)
		node.Lines().Append(seg)
		row.AppendChild(row, node)
		pos = closure + 1
	}
	for ; i < len(alignments); i++ {
		row.AppendChild(row, ast.NewTableCell())
	}
	return row
}

func (b *tableParagraphTransformer) parseDelimiter(segment text.Segment, reader text.Reader) []ast.Alignment {

	line := segment.Value(reader.Source())
	if !isTableDelim(line) {
		return nil
	}
	cols := bytes.Split(line, []byte{'|'})
	if util.IsBlank(cols[0]) {
		cols = cols[1:]
	}
	if len(cols) > 0 && util.IsBlank(cols[len(cols)-1]) {
		cols = cols[:len(cols)-1]
	}

	var alignments []ast.Alignment
	for _, col := range cols {
		if tableDelimLeft.Match(col) {
			alignments = append(alignments, ast.AlignLeft)
		} else if tableDelimRight.Match(col) {
			alignments = append(alignments, ast.AlignRight)
		} else if tableDelimCenter.Match(col) {
			alignments = append(alignments, ast.AlignCenter)
		} else if tableDelimNone.Match(col) {
			alignments = append(alignments, ast.AlignNone)
		} else {
			return nil
		}
	}
	return alignments
}

type tableASTTransformer struct {
}

var defaultTableASTTransformer = &tableASTTransformer{}

// NewTableASTTransformer returns a parser.ASTTransformer for tables.
func NewTableASTTransformer() parser.ASTTransformer {
	return defaultTableASTTransformer
}

func (a *tableASTTransformer) Transform(node *gast.Document, reader text.Reader, pc parser.Context) {
	lst := pc.Get(escapedPipeCellListKey)
	if lst == nil {
		return
	}
	pc.Set(escapedPipeCellListKey, nil)
	for _, v := range lst.([]*escapedPipeCell) {
		if v.Transformed {
			continue
		}
		_ = gast.Walk(v.Cell, func(n gast.Node, entering bool) (gast.WalkStatus, error) {
			if !entering || n.Kind() != gast.KindCodeSpan {
				return gast.WalkContinue, nil
			}

			for c := n.FirstChild(); c != nil; {
				next := c.NextSibling()
				if c.Kind() != gast.KindText {
					c = next
					continue
				}
				parent := c.Parent()
				ts := &c.(*gast.Text).Segment
				n := c
				for _, v := range lst.([]*escapedPipeCell) {
					for _, pos := range v.Pos {
						if ts.Start <= pos && pos < ts.Stop {
							segment := n.(*gast.Text).Segment
							n1 := gast.NewRawTextSegment(segment.WithStop(pos))
							n2 := gast.NewRawTextSegment(segment.WithStart(pos + 1))
							parent.InsertAfter(parent, n, n1)
							parent.InsertAfter(parent, n1, n2)
							parent.RemoveChild(parent, n)
							n = n2
							v.Transformed = true
						}
					}
				}
				c = next
			}
			return gast.WalkContinue, nil
		})
	}
}

// TableHTMLRenderer is a renderer.NodeRenderer implementation that
// renders Table nodes.
type TableHTMLRenderer struct {
	TableConfig
}

// NewTableHTMLRenderer returns a new TableHTMLRenderer.
func NewTableHTMLRenderer(opts ...TableOption) renderer.NodeRenderer {
	r := &TableHTMLRenderer{
		TableConfig: NewTableConfig(),
	}
	for _, opt := range opts {
		opt.SetTableOption(&r.TableConfig)
	}
	return r
}

// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.
func (r *TableHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	reg.Register(ast.KindTable, r.renderTable)
	reg.Register(ast.KindTableHeader, r.renderTableHeader)
	reg.Register(ast.KindTableRow, r.renderTableRow)
	reg.Register(ast.KindTableCell, r.renderTableCell)
}

// TableAttributeFilter defines attribute names which table elements can have.
//
// - align: Deprecated
// - bgcolor: Deprecated
// - border: Deprecated
// - cellpadding: Deprecated
// - cellspacing: Deprecated
// - frame: Deprecated
// - rules: Deprecated
// - summary: Deprecated
// - width: Deprecated.
var TableAttributeFilter = html.GlobalAttributeFilter.ExtendString(`align,bgcolor,border,cellpadding,cellspacing,frame,rules,summary,width`) // nolint: lll

func (r *TableHTMLRenderer) renderTable(
	w util.BufWriter, source []byte, n gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		_, _ = w.WriteString("<table")
		if n.Attributes() != nil {
			html.RenderAttributes(w, n, TableAttributeFilter)
		}
		_, _ = w.WriteString(">\n")
	} else {
		_, _ = w.WriteString("</table>\n")
	}
	return gast.WalkContinue, nil
}

// TableHeaderAttributeFilter defines attribute names which <thead> elements can have.
//
// - align: Deprecated since HTML4, Obsolete since HTML5
// - bgcolor: Not Standardized
// - char: Deprecated since HTML4, Obsolete since HTML5
// - charoff: Deprecated since HTML4, Obsolete since HTML5
// - valign: Deprecated since HTML4, Obsolete since HTML5.
var TableHeaderAttributeFilter = html.GlobalAttributeFilter.ExtendString(`align,bgcolor,char,charoff,valign`)

func (r *TableHTMLRenderer) renderTableHeader(
	w util.BufWriter, source []byte, n gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		_, _ = w.WriteString("<thead")
		if n.Attributes() != nil {
			html.RenderAttributes(w, n, TableHeaderAttributeFilter)
		}
		_, _ = w.WriteString(">\n")
		_, _ = w.WriteString("<tr>\n") // Header <tr> has no separate handle
	} else {
		_, _ = w.WriteString("</tr>\n")
		_, _ = w.WriteString("</thead>\n")
		if n.NextSibling() != nil {
			_, _ = w.WriteString("<tbody>\n")
		}
	}
	return gast.WalkContinue, nil
}

// TableRowAttributeFilter defines attribute names which <tr> elements can have.
//
// - align: Obsolete since HTML5
// - bgcolor: Obsolete since HTML5
// - char: Obsolete since HTML5
// - charoff: Obsolete since HTML5
// - valign: Obsolete since HTML5.
var TableRowAttributeFilter = html.GlobalAttributeFilter.ExtendString(`align,bgcolor,char,charoff,valign`)

func (r *TableHTMLRenderer) renderTableRow(
	w util.BufWriter, source []byte, n gast.Node, entering bool) (gast.WalkStatus, error) {
	if entering {
		_, _ = w.WriteString("<tr")
		if n.Attributes() != nil {
			html.RenderAttributes(w, n, TableRowAttributeFilter)
		}
		_, _ = w.WriteString(">\n")
	} else {
		_, _ = w.WriteString("</tr>\n")
		if n.Parent().LastChild() == n {
			_, _ = w.WriteString("</tbody>\n")
		}
	}
	return gast.WalkContinue, nil
}

// TableThCellAttributeFilter defines attribute names which table <th> cells can have.
//
//   - abbr:  [OK] Contains a short abbreviated description of the cell's content [NOT OK in <td>]
//   - align:  Obsolete since HTML5
//   - axis:  Obsolete since HTML5
//   - bgcolor:  Not Standardized
//   - char:  Obsolete since HTML5
//   - charoff:  Obsolete since HTML5
//   - colspan:  [OK] Number of columns that the cell is to span
//   - headers:  [OK] This attribute contains a list of space-separated strings,
//     each corresponding to the id attribute of the <th> elements that apply to this element
//   - height:  Deprecated since HTML4. Obsolete since HTML5
//   - rowspan:  [OK] Number of rows that the cell is to span
//   - scope:  [OK] This enumerated attribute defines the cells that the header
//     (defined in the <th>) element relates to [NOT OK in <td>]
//   - valign:  Obsolete since HTML5
//   - width:  Deprecated since HTML4. Obsolete since HTML5.
var TableThCellAttributeFilter = html.GlobalAttributeFilter.ExtendString(`abbr,align,axis,bgcolor,char,charoff,colspan,headers,height,rowspan,scope,valign,width`) // nolint:lll

// TableTdCellAttributeFilter defines attribute names which table <td> cells can have.
//
//   - abbr:  Obsolete since HTML5. [OK in <th>]
//   - align:  Obsolete since HTML5
//   - axis:  Obsolete since HTML5
//   - bgcolor:  Not Standardized
//   - char:  Obsolete since HTML5
//   - charoff:  Obsolete since HTML5
//   - colspan:  [OK] Number of columns that the cell is to span
//   - headers:  [OK] This attribute contains a list of space-separated strings, each corresponding
//     to the id attribute of the <th> elements that apply to this element
//   - height:  Deprecated since HTML4. Obsolete since HTML5
//   - rowspan:  [OK] Number of rows that the cell is to span
//   - scope:  Obsolete since HTML5. [OK in <th>]
//   - valign:  Obsolete since HTML5
//   - width:  Deprecated since HTML4. Obsolete since HTML5.
var TableTdCellAttributeFilter = html.GlobalAttributeFilter.ExtendString(`abbr,align,axis,bgcolor,char,charoff,colspan,headers,height,rowspan,scope,valign,width`) // nolint: lll

func (r *TableHTMLRenderer) renderTableCell(
	w util.BufWriter, source []byte, node gast.Node, entering bool) (gast.WalkStatus, error) {
	n := node.(*ast.TableCell)
	tag := "td"
	if n.Parent().Kind() == ast.KindTableHeader {
		tag = "th"
	}
	if entering {
		_, _ = fmt.Fprintf(w, "<%s", tag)
		if n.Alignment != ast.AlignNone {
			amethod := r.TableConfig.TableCellAlignMethod
			if amethod == TableCellAlignDefault {
				if r.Config.XHTML {
					amethod = TableCellAlignAttribute
				} else {
					amethod = TableCellAlignStyle
				}
			}
			switch amethod {
			case TableCellAlignAttribute:
				if _, ok := n.AttributeString("align"); !ok { // Skip align render if overridden
					_, _ = fmt.Fprintf(w, ` align="%s"`, n.Alignment.String())
				}
			case TableCellAlignStyle:
				v, ok := n.AttributeString("style")
				var cob util.CopyOnWriteBuffer
				if ok {
					cob = util.NewCopyOnWriteBuffer(v.([]byte))
					cob.AppendByte(';')
				}
				style := fmt.Sprintf("text-align:%s", n.Alignment.String())
				cob.AppendString(style)
				n.SetAttributeString("style", cob.Bytes())
			}
		}
		if n.Attributes() != nil {
			if tag == "td" {
				html.RenderAttributes(w, n, TableTdCellAttributeFilter) // <td>
			} else {
				html.RenderAttributes(w, n, TableThCellAttributeFilter) // <th>
			}
		}
		_ = w.WriteByte('>')
	} else {
		_, _ = fmt.Fprintf(w, "</%s>\n", tag)
	}
	return gast.WalkContinue, nil
}

type table struct {
	options []TableOption
}

// Table is an extension that allow you to use GFM tables .
var Table = &table{
	options: []TableOption{},
}

// NewTable returns a new extension with given options.
func NewTable(opts ...TableOption) goldmark.Extender {
	return &table{
		options: opts,
	}
}

func (e *table) Extend(m goldmark.Markdown) {
	m.Parser().AddOptions(
		parser.WithParagraphTransformers(
			util.Prioritized(NewTableParagraphTransformer(), 200),
		),
		parser.WithASTTransformers(
			util.Prioritized(defaultTableASTTransformer, 0),
		),
	)
	m.Renderer().AddOptions(renderer.WithNodeRenderers(
		util.Prioritized(NewTableHTMLRenderer(e.options...), 500),
	))
}
</file>

<file path="text/reader.go">
package text

import (
	"bytes"
	"io"
	"regexp"
	"unicode/utf8"

	"github.com/yuin/goldmark/util"
)

const invalidValue = -1

// EOF indicates the end of file.
const EOF = byte(0xff)

// A Reader interface provides abstracted method for reading text.
type Reader interface {
	io.RuneReader

	// Source returns a source of the reader.
	Source() []byte

	// ResetPosition resets positions.
	ResetPosition()

	// Peek returns a byte at current position without advancing the internal pointer.
	Peek() byte

	// PeekLine returns the current line without advancing the internal pointer.
	PeekLine() ([]byte, Segment)

	// PrecendingCharacter returns a character just before current internal pointer.
	PrecendingCharacter() rune

	// Value returns a value of the given segment.
	Value(Segment) []byte

	// LineOffset returns a distance from the line head to current position.
	LineOffset() int

	// Position returns current line number and position.
	Position() (int, Segment)

	// SetPosition sets current line number and position.
	SetPosition(int, Segment)

	// SetPadding sets padding to the reader.
	SetPadding(int)

	// Advance advances the internal pointer.
	Advance(int)

	// AdvanceAndSetPadding advances the internal pointer and add padding to the
	// reader.
	AdvanceAndSetPadding(int, int)

	// AdvanceToEOL advances the internal pointer to the end of line.
	// If the line ends with a newline, it will be included in the segment.
	// If the line ends with EOF, it will not be included in the segment.
	AdvanceToEOL()

	// AdvanceLine advances the internal pointer to the next line head.
	AdvanceLine()

	// SkipSpaces skips space characters and returns a non-blank line.
	// If it reaches EOF, returns false.
	SkipSpaces() (Segment, int, bool)

	// SkipSpaces skips blank lines and returns a non-blank line.
	// If it reaches EOF, returns false.
	SkipBlankLines() (Segment, int, bool)

	// Match performs regular expression matching to current line.
	Match(reg *regexp.Regexp) bool

	// Match performs regular expression searching to current line.
	FindSubMatch(reg *regexp.Regexp) [][]byte

	// FindClosure finds corresponding closure.
	FindClosure(opener, closer byte, options FindClosureOptions) (*Segments, bool)
}

// FindClosureOptions is options for Reader.FindClosure.
type FindClosureOptions struct {
	// CodeSpan is a flag for the FindClosure. If this is set to true,
	// FindClosure ignores closers in codespans.
	CodeSpan bool

	// Nesting is a flag for the FindClosure. If this is set to true,
	// FindClosure allows nesting.
	Nesting bool

	// Newline is a flag for the FindClosure. If this is set to true,
	// FindClosure searches for a closer over multiple lines.
	Newline bool

	// Advance is a flag for the FindClosure. If this is set to true,
	// FindClosure advances pointers when closer is found.
	Advance bool
}

type reader struct {
	source       []byte
	sourceLength int
	line         int
	peekedLine   []byte
	pos          Segment
	head         int
	lineOffset   int
}

// NewReader return a new Reader that can read UTF-8 bytes .
func NewReader(source []byte) Reader {
	r := &reader{
		source:       source,
		sourceLength: len(source),
	}
	r.ResetPosition()
	return r
}

func (r *reader) FindClosure(opener, closer byte, options FindClosureOptions) (*Segments, bool) {
	return findClosureReader(r, opener, closer, options)
}

func (r *reader) ResetPosition() {
	r.line = -1
	r.head = 0
	r.lineOffset = -1
	r.AdvanceLine()
}

func (r *reader) Source() []byte {
	return r.source
}

func (r *reader) Value(seg Segment) []byte {
	return seg.Value(r.source)
}

func (r *reader) Peek() byte {
	if r.pos.Start >= 0 && r.pos.Start < r.sourceLength {
		if r.pos.Padding != 0 {
			return space[0]
		}
		return r.source[r.pos.Start]
	}
	return EOF
}

func (r *reader) PeekLine() ([]byte, Segment) {
	if r.pos.Start >= 0 && r.pos.Start < r.sourceLength {
		if r.peekedLine == nil {
			r.peekedLine = r.pos.Value(r.Source())
		}
		return r.peekedLine, r.pos
	}
	return nil, r.pos
}

// io.RuneReader interface.
func (r *reader) ReadRune() (rune, int, error) {
	return readRuneReader(r)
}

func (r *reader) LineOffset() int {
	if r.lineOffset < 0 {
		v := 0
		for i := r.head; i < r.pos.Start; i++ {
			if r.source[i] == '\t' {
				v += util.TabWidth(v)
			} else {
				v++
			}
		}
		r.lineOffset = v - r.pos.Padding
	}
	return r.lineOffset
}

func (r *reader) PrecendingCharacter() rune {
	if r.pos.Start <= 0 {
		if r.pos.Padding != 0 {
			return rune(' ')
		}
		return rune('\n')
	}
	i := r.pos.Start - 1
	for ; i >= 0; i-- {
		if utf8.RuneStart(r.source[i]) {
			break
		}
	}
	rn, _ := utf8.DecodeRune(r.source[i:])
	return rn
}

func (r *reader) Advance(n int) {
	r.lineOffset = -1
	if n < len(r.peekedLine) && r.pos.Padding == 0 {
		r.pos.Start += n
		r.peekedLine = nil
		return
	}
	r.peekedLine = nil
	l := r.sourceLength
	for ; n > 0 && r.pos.Start < l; n-- {
		if r.pos.Padding != 0 {
			r.pos.Padding--
			continue
		}
		if r.source[r.pos.Start] == '\n' {
			r.AdvanceLine()
			continue
		}
		r.pos.Start++
	}
}

func (r *reader) AdvanceAndSetPadding(n, padding int) {
	r.Advance(n)
	if padding > r.pos.Padding {
		r.SetPadding(padding)
	}
}

func (r *reader) AdvanceToEOL() {
	if r.pos.Start >= r.sourceLength {
		return
	}

	r.lineOffset = -1
	i := -1
	if r.peekedLine != nil {
		r.pos.Start += len(r.peekedLine) - r.pos.Padding - 1
		if r.source[r.pos.Start] == '\n' {
			i = 0
		}
	}
	if i == -1 {
		i = bytes.IndexByte(r.source[r.pos.Start:], '\n')
	}
	r.peekedLine = nil
	if i != -1 {
		r.pos.Start += i
	} else {
		r.pos.Start = r.sourceLength
	}
	r.pos.Padding = 0
}

func (r *reader) AdvanceLine() {
	r.lineOffset = -1
	r.peekedLine = nil
	r.pos.Start = r.pos.Stop
	r.head = r.pos.Start
	if r.pos.Start < 0 || r.pos.Start >= r.sourceLength {
		return
	}
	r.pos.Stop = r.sourceLength
	i := 0
	if r.source[r.pos.Start] != '\n' {
		i = bytes.IndexByte(r.source[r.pos.Start:], '\n')
	}
	if i != -1 {
		r.pos.Stop = r.pos.Start + i + 1
	}
	r.line++
	r.pos.Padding = 0
}

func (r *reader) Position() (int, Segment) {
	return r.line, r.pos
}

func (r *reader) SetPosition(line int, pos Segment) {
	r.lineOffset = -1
	r.line = line
	r.pos = pos
}

func (r *reader) SetPadding(v int) {
	r.pos.Padding = v
}

func (r *reader) SkipSpaces() (Segment, int, bool) {
	return skipSpacesReader(r)
}

func (r *reader) SkipBlankLines() (Segment, int, bool) {
	return skipBlankLinesReader(r)
}

func (r *reader) Match(reg *regexp.Regexp) bool {
	return matchReader(r, reg)
}

func (r *reader) FindSubMatch(reg *regexp.Regexp) [][]byte {
	return findSubMatchReader(r, reg)
}

// A BlockReader interface is a reader that is optimized for Blocks.
type BlockReader interface {
	Reader
	// Reset resets current state and sets new segments to the reader.
	Reset(segment *Segments)
}

type blockReader struct {
	source         []byte
	segments       *Segments
	segmentsLength int
	line           int
	pos            Segment
	head           int
	last           int
	lineOffset     int
}

// NewBlockReader returns a new BlockReader.
func NewBlockReader(source []byte, segments *Segments) BlockReader {
	r := &blockReader{
		source: source,
	}
	if segments != nil {
		r.Reset(segments)
	}
	return r
}

func (r *blockReader) FindClosure(opener, closer byte, options FindClosureOptions) (*Segments, bool) {
	return findClosureReader(r, opener, closer, options)
}

func (r *blockReader) ResetPosition() {
	r.line = -1
	r.head = 0
	r.last = 0
	r.lineOffset = -1
	r.pos.Start = -1
	r.pos.Stop = -1
	r.pos.Padding = 0
	if r.segmentsLength > 0 {
		last := r.segments.At(r.segmentsLength - 1)
		r.last = last.Stop
	}
	r.AdvanceLine()
}

func (r *blockReader) Reset(segments *Segments) {
	r.segments = segments
	r.segmentsLength = segments.Len()
	r.ResetPosition()
}

func (r *blockReader) Source() []byte {
	return r.source
}

func (r *blockReader) Value(seg Segment) []byte {
	line := r.segmentsLength - 1
	ret := make([]byte, 0, seg.Stop-seg.Start+1)
	for ; line >= 0; line-- {
		if seg.Start >= r.segments.At(line).Start {
			break
		}
	}
	i := seg.Start
	for ; line < r.segmentsLength; line++ {
		s := r.segments.At(line)
		if i < 0 {
			i = s.Start
		}
		ret = s.ConcatPadding(ret)
		for ; i < seg.Stop && i < s.Stop; i++ {
			ret = append(ret, r.source[i])
		}
		i = -1
		if s.Stop > seg.Stop {
			break
		}
	}
	return ret
}

// io.RuneReader interface.
func (r *blockReader) ReadRune() (rune, int, error) {
	return readRuneReader(r)
}

func (r *blockReader) PrecendingCharacter() rune {
	if r.pos.Padding != 0 {
		return rune(' ')
	}
	if r.segments.Len() < 1 {
		return rune('\n')
	}
	firstSegment := r.segments.At(0)
	if r.line == 0 && r.pos.Start <= firstSegment.Start {
		return rune('\n')
	}
	l := len(r.source)
	i := r.pos.Start - 1
	for ; i < l && i >= 0; i-- {
		if utf8.RuneStart(r.source[i]) {
			break
		}
	}
	if i < 0 || i >= l {
		return rune('\n')
	}
	rn, _ := utf8.DecodeRune(r.source[i:])
	return rn
}

func (r *blockReader) LineOffset() int {
	if r.lineOffset < 0 {
		v := 0
		for i := r.head; i < r.pos.Start; i++ {
			if r.source[i] == '\t' {
				v += util.TabWidth(v)
			} else {
				v++
			}
		}
		r.lineOffset = v - r.pos.Padding
	}
	return r.lineOffset
}

func (r *blockReader) Peek() byte {
	if r.line < r.segmentsLength && r.pos.Start >= 0 && r.pos.Start < r.last {
		if r.pos.Padding != 0 {
			return space[0]
		}
		return r.source[r.pos.Start]
	}
	return EOF
}

func (r *blockReader) PeekLine() ([]byte, Segment) {
	if r.line < r.segmentsLength && r.pos.Start >= 0 && r.pos.Start < r.last {
		return r.pos.Value(r.source), r.pos
	}
	return nil, r.pos
}

func (r *blockReader) Advance(n int) {
	r.lineOffset = -1

	if n < r.pos.Stop-r.pos.Start && r.pos.Padding == 0 {
		r.pos.Start += n
		return
	}

	for ; n > 0; n-- {
		if r.pos.Padding != 0 {
			r.pos.Padding--
			continue
		}
		if r.pos.Start >= r.pos.Stop-1 && r.pos.Stop < r.last {
			r.AdvanceLine()
			continue
		}
		r.pos.Start++
	}
}

func (r *blockReader) AdvanceAndSetPadding(n, padding int) {
	r.Advance(n)
	if padding > r.pos.Padding {
		r.SetPadding(padding)
	}
}

func (r *blockReader) AdvanceToEOL() {
	r.lineOffset = -1
	r.pos.Padding = 0
	c := r.source[r.pos.Stop-1]
	if c == '\n' {
		r.pos.Start = r.pos.Stop - 1
	} else {
		r.pos.Start = r.pos.Stop
	}
}

func (r *blockReader) AdvanceLine() {
	r.SetPosition(r.line+1, NewSegment(invalidValue, invalidValue))
	r.head = r.pos.Start
}

func (r *blockReader) Position() (int, Segment) {
	return r.line, r.pos
}

func (r *blockReader) SetPosition(line int, pos Segment) {
	r.lineOffset = -1
	r.line = line
	if pos.Start == invalidValue {
		if r.line < r.segmentsLength {
			s := r.segments.At(line)
			r.head = s.Start
			r.pos = s
		}
	} else {
		r.pos = pos
		if r.line < r.segmentsLength {
			s := r.segments.At(line)
			r.head = s.Start
		}
	}
}

func (r *blockReader) SetPadding(v int) {
	r.lineOffset = -1
	r.pos.Padding = v
}

func (r *blockReader) SkipSpaces() (Segment, int, bool) {
	return skipSpacesReader(r)
}

func (r *blockReader) SkipBlankLines() (Segment, int, bool) {
	return skipBlankLinesReader(r)
}

func (r *blockReader) Match(reg *regexp.Regexp) bool {
	return matchReader(r, reg)
}

func (r *blockReader) FindSubMatch(reg *regexp.Regexp) [][]byte {
	return findSubMatchReader(r, reg)
}

func skipBlankLinesReader(r Reader) (Segment, int, bool) {
	lines := 0
	for {
		line, seg := r.PeekLine()
		if line == nil {
			return seg, lines, false
		}
		if util.IsBlank(line) {
			lines++
			r.AdvanceLine()
		} else {
			return seg, lines, true
		}
	}
}

func skipSpacesReader(r Reader) (Segment, int, bool) {
	chars := 0
	for {
		line, segment := r.PeekLine()
		if line == nil {
			return segment, chars, false
		}
		for i, c := range line {
			if util.IsSpace(c) {
				chars++
				r.Advance(1)
				continue
			}
			return segment.WithStart(segment.Start + i + 1), chars, true
		}
	}
}

func matchReader(r Reader, reg *regexp.Regexp) bool {
	oldline, oldseg := r.Position()
	match := reg.FindReaderSubmatchIndex(r)
	r.SetPosition(oldline, oldseg)
	if match == nil {
		return false
	}
	r.Advance(match[1] - match[0])
	return true
}

func findSubMatchReader(r Reader, reg *regexp.Regexp) [][]byte {
	oldLine, oldSeg := r.Position()
	match := reg.FindReaderSubmatchIndex(r)
	r.SetPosition(oldLine, oldSeg)
	if match == nil {
		return nil
	}
	var bb bytes.Buffer
	bb.Grow(match[1] - match[0])
	for i := 0; i < match[1]; {
		r, size, _ := readRuneReader(r)
		i += size
		bb.WriteRune(r)
	}
	bs := bb.Bytes()
	var result [][]byte
	for i := 0; i < len(match); i += 2 {
		if match[i] < 0 {
			result = append(result, []byte{})
			continue
		}
		result = append(result, bs[match[i]:match[i+1]])
	}

	r.SetPosition(oldLine, oldSeg)
	r.Advance(match[1] - match[0])
	return result
}

func readRuneReader(r Reader) (rune, int, error) {
	line, _ := r.PeekLine()
	if line == nil {
		return 0, 0, io.EOF
	}
	rn, size := utf8.DecodeRune(line)
	if rn == utf8.RuneError {
		return 0, 0, io.EOF
	}
	r.Advance(size)
	return rn, size, nil
}

func findClosureReader(r Reader, opener, closer byte, opts FindClosureOptions) (*Segments, bool) {
	opened := 1
	codeSpanOpener := 0
	closed := false
	orgline, orgpos := r.Position()
	var ret *Segments

	for {
		bs, seg := r.PeekLine()
		if bs == nil {
			goto end
		}
		i := 0
		for i < len(bs) {
			c := bs[i]
			if opts.CodeSpan && codeSpanOpener != 0 && c == '`' {
				codeSpanCloser := 0
				for ; i < len(bs); i++ {
					if bs[i] == '`' {
						codeSpanCloser++
					} else {
						i--
						break
					}
				}
				if codeSpanCloser == codeSpanOpener {
					codeSpanOpener = 0
				}
			} else if codeSpanOpener == 0 && c == '\\' && i < len(bs)-1 && util.IsPunct(bs[i+1]) {
				i += 2
				continue
			} else if opts.CodeSpan && codeSpanOpener == 0 && c == '`' {
				for ; i < len(bs); i++ {
					if bs[i] == '`' {
						codeSpanOpener++
					} else {
						i--
						break
					}
				}
			} else if (opts.CodeSpan && codeSpanOpener == 0) || !opts.CodeSpan {
				if c == closer {
					opened--
					if opened == 0 {
						if ret == nil {
							ret = NewSegments()
						}
						ret.Append(seg.WithStop(seg.Start + i))
						r.Advance(i + 1)
						closed = true
						goto end
					}
				} else if c == opener {
					if !opts.Nesting {
						goto end
					}
					opened++
				}
			}
			i++
		}
		if !opts.Newline {
			goto end
		}
		r.AdvanceLine()
		if ret == nil {
			ret = NewSegments()
		}
		ret.Append(seg)
	}
end:
	if !opts.Advance {
		r.SetPosition(orgline, orgpos)
	}
	if closed {
		return ret, true
	}
	return nil, false
}
</file>

<file path="ast/ast.go">
// Package ast defines AST nodes that represent markdown elements.
package ast

import (
	"bytes"
	"fmt"
	"strings"

	textm "github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

// A NodeType indicates what type a node belongs to.
type NodeType int

const (
	// TypeBlock indicates that a node is kind of block nodes.
	TypeBlock NodeType = iota + 1
	// TypeInline indicates that a node is kind of inline nodes.
	TypeInline
	// TypeDocument indicates that a node is kind of document nodes.
	TypeDocument
)

// NodeKind indicates more specific type than NodeType.
type NodeKind int

func (k NodeKind) String() string {
	return kindNames[k]
}

var kindMax NodeKind
var kindNames = []string{""}

// NewNodeKind returns a new Kind value.
func NewNodeKind(name string) NodeKind {
	kindMax++
	kindNames = append(kindNames, name)
	return kindMax
}

// An Attribute is an attribute of the Node.
type Attribute struct {
	Name  []byte
	Value interface{}
}

// A Node interface defines basic AST node functionalities.
type Node interface {
	// Type returns a type of this node.
	Type() NodeType

	// Kind returns a kind of this node.
	Kind() NodeKind

	// NextSibling returns a next sibling node of this node.
	NextSibling() Node

	// PreviousSibling returns a previous sibling node of this node.
	PreviousSibling() Node

	// Parent returns a parent node of this node.
	Parent() Node

	// SetParent sets a parent node to this node.
	SetParent(Node)

	// SetPreviousSibling sets a previous sibling node to this node.
	SetPreviousSibling(Node)

	// SetNextSibling sets a next sibling node to this node.
	SetNextSibling(Node)

	// HasChildren returns true if this node has any children, otherwise false.
	HasChildren() bool

	// ChildCount returns a total number of children.
	ChildCount() int

	// FirstChild returns a first child of this node.
	FirstChild() Node

	// LastChild returns a last child of this node.
	LastChild() Node

	// AppendChild append a node child to the tail of the children.
	AppendChild(self, child Node)

	// RemoveChild removes a node child from this node.
	// If a node child is not children of this node, RemoveChild nothing to do.
	RemoveChild(self, child Node)

	// RemoveChildren removes all children from this node.
	RemoveChildren(self Node)

	// SortChildren sorts childrens by comparator.
	SortChildren(comparator func(n1, n2 Node) int)

	// ReplaceChild replace a node v1 with a node insertee.
	// If v1 is not children of this node, ReplaceChild append a insetee to the
	// tail of the children.
	ReplaceChild(self, v1, insertee Node)

	// InsertBefore inserts a node insertee before a node v1.
	// If v1 is not children of this node, InsertBefore append a insetee to the
	// tail of the children.
	InsertBefore(self, v1, insertee Node)

	// InsertAfterinserts a node insertee after a node v1.
	// If v1 is not children of this node, InsertBefore append a insetee to the
	// tail of the children.
	InsertAfter(self, v1, insertee Node)

	// OwnerDocument returns this node's owner document.
	// If this node is not a child of the Document node, OwnerDocument
	// returns nil.
	OwnerDocument() *Document

	// Dump dumps an AST tree structure to stdout.
	// This function completely aimed for debugging.
	// level is a indent level. Implementer should indent informations with
	// 2 * level spaces.
	Dump(source []byte, level int)

	// Text returns text values of this node.
	// This method is valid only for some inline nodes.
	// If this node is a block node, Text returns a text value as reasonable as possible.
	// Notice that there are no 'correct' text values for the block nodes.
	// Result for the block nodes may be different from your expectation.
	//
	// Deprecated: Use other properties of the node to get the text value(i.e. Pragraph.Lines, Text.Value).
	Text(source []byte) []byte

	// HasBlankPreviousLines returns true if the row before this node is blank,
	// otherwise false.
	// This method is valid only for block nodes.
	HasBlankPreviousLines() bool

	// SetBlankPreviousLines sets whether the row before this node is blank.
	// This method is valid only for block nodes.
	SetBlankPreviousLines(v bool)

	// Lines returns text segments that hold positions in a source.
	// This method is valid only for block nodes.
	Lines() *textm.Segments

	// SetLines sets text segments that hold positions in a source.
	// This method is valid only for block nodes.
	SetLines(*textm.Segments)

	// IsRaw returns true if contents should be rendered as 'raw' contents.
	IsRaw() bool

	// SetAttribute sets the given value to the attributes.
	SetAttribute(name []byte, value interface{})

	// SetAttributeString sets the given value to the attributes.
	SetAttributeString(name string, value interface{})

	// Attribute returns a (attribute value, true) if an attribute
	// associated with the given name is found, otherwise
	// (nil, false)
	Attribute(name []byte) (interface{}, bool)

	// AttributeString returns a (attribute value, true) if an attribute
	// associated with the given name is found, otherwise
	// (nil, false)
	AttributeString(name string) (interface{}, bool)

	// Attributes returns a list of attributes.
	// This may be a nil if there are no attributes.
	Attributes() []Attribute

	// RemoveAttributes removes all attributes from this node.
	RemoveAttributes()
}

// A BaseNode struct implements the Node interface partialliy.
type BaseNode struct {
	firstChild Node
	lastChild  Node
	parent     Node
	next       Node
	prev       Node
	childCount int
	attributes []Attribute
}

func ensureIsolated(v Node) {
	if p := v.Parent(); p != nil {
		p.RemoveChild(p, v)
	}
}

// HasChildren implements Node.HasChildren .
func (n *BaseNode) HasChildren() bool {
	return n.firstChild != nil
}

// SetPreviousSibling implements Node.SetPreviousSibling .
func (n *BaseNode) SetPreviousSibling(v Node) {
	n.prev = v
}

// SetNextSibling implements Node.SetNextSibling .
func (n *BaseNode) SetNextSibling(v Node) {
	n.next = v
}

// PreviousSibling implements Node.PreviousSibling .
func (n *BaseNode) PreviousSibling() Node {
	return n.prev
}

// NextSibling implements Node.NextSibling .
func (n *BaseNode) NextSibling() Node {
	return n.next
}

// RemoveChild implements Node.RemoveChild .
func (n *BaseNode) RemoveChild(self, v Node) {
	if v.Parent() != self {
		return
	}
	n.childCount--
	prev := v.PreviousSibling()
	next := v.NextSibling()
	if prev != nil {
		prev.SetNextSibling(next)
	} else {
		n.firstChild = next
	}
	if next != nil {
		next.SetPreviousSibling(prev)
	} else {
		n.lastChild = prev
	}
	v.SetParent(nil)
	v.SetPreviousSibling(nil)
	v.SetNextSibling(nil)
}

// RemoveChildren implements Node.RemoveChildren .
func (n *BaseNode) RemoveChildren(self Node) {
	for c := n.firstChild; c != nil; {
		c.SetParent(nil)
		c.SetPreviousSibling(nil)
		next := c.NextSibling()
		c.SetNextSibling(nil)
		c = next
	}
	n.firstChild = nil
	n.lastChild = nil
	n.childCount = 0
}

// SortChildren implements Node.SortChildren.
func (n *BaseNode) SortChildren(comparator func(n1, n2 Node) int) {
	var sorted Node
	current := n.firstChild
	for current != nil {
		next := current.NextSibling()
		if sorted == nil || comparator(sorted, current) >= 0 {
			current.SetNextSibling(sorted)
			if sorted != nil {
				sorted.SetPreviousSibling(current)
			}
			sorted = current
			sorted.SetPreviousSibling(nil)
		} else {
			c := sorted
			for c.NextSibling() != nil && comparator(c.NextSibling(), current) < 0 {
				c = c.NextSibling()
			}
			current.SetNextSibling(c.NextSibling())
			current.SetPreviousSibling(c)
			if c.NextSibling() != nil {
				c.NextSibling().SetPreviousSibling(current)
			}
			c.SetNextSibling(current)
		}
		current = next
	}
	n.firstChild = sorted
	for c := n.firstChild; c != nil; c = c.NextSibling() {
		n.lastChild = c
	}
}

// FirstChild implements Node.FirstChild .
func (n *BaseNode) FirstChild() Node {
	return n.firstChild
}

// LastChild implements Node.LastChild .
func (n *BaseNode) LastChild() Node {
	return n.lastChild
}

// ChildCount implements Node.ChildCount .
func (n *BaseNode) ChildCount() int {
	return n.childCount
}

// Parent implements Node.Parent .
func (n *BaseNode) Parent() Node {
	return n.parent
}

// SetParent implements Node.SetParent .
func (n *BaseNode) SetParent(v Node) {
	n.parent = v
}

// AppendChild implements Node.AppendChild .
func (n *BaseNode) AppendChild(self, v Node) {
	ensureIsolated(v)
	if n.firstChild == nil {
		n.firstChild = v
		v.SetNextSibling(nil)
		v.SetPreviousSibling(nil)
	} else {
		last := n.lastChild
		last.SetNextSibling(v)
		v.SetPreviousSibling(last)
	}
	v.SetParent(self)
	n.lastChild = v
	n.childCount++
}

// ReplaceChild implements Node.ReplaceChild .
func (n *BaseNode) ReplaceChild(self, v1, insertee Node) {
	n.InsertBefore(self, v1, insertee)
	n.RemoveChild(self, v1)
}

// InsertAfter implements Node.InsertAfter .
func (n *BaseNode) InsertAfter(self, v1, insertee Node) {
	n.InsertBefore(self, v1.NextSibling(), insertee)
}

// InsertBefore implements Node.InsertBefore .
func (n *BaseNode) InsertBefore(self, v1, insertee Node) {
	n.childCount++
	if v1 == nil {
		n.AppendChild(self, insertee)
		return
	}
	ensureIsolated(insertee)
	if v1.Parent() == self {
		c := v1
		prev := c.PreviousSibling()
		if prev != nil {
			prev.SetNextSibling(insertee)
			insertee.SetPreviousSibling(prev)
		} else {
			n.firstChild = insertee
			insertee.SetPreviousSibling(nil)
		}
		insertee.SetNextSibling(c)
		c.SetPreviousSibling(insertee)
		insertee.SetParent(self)
	}
}

// OwnerDocument implements Node.OwnerDocument.
func (n *BaseNode) OwnerDocument() *Document {
	d := n.Parent()
	for {
		p := d.Parent()
		if p == nil {
			if v, ok := d.(*Document); ok {
				return v
			}
			break
		}
		d = p
	}
	return nil
}

// Text implements Node.Text .
//
// Deprecated: Use other properties of the node to get the text value(i.e. Pragraph.Lines, Text.Value).
func (n *BaseNode) Text(source []byte) []byte {
	var buf bytes.Buffer
	for c := n.firstChild; c != nil; c = c.NextSibling() {
		buf.Write(c.Text(source))
		if sb, ok := c.(interface {
			SoftLineBreak() bool
		}); ok && sb.SoftLineBreak() {
			buf.WriteByte('\n')
		}
	}
	return buf.Bytes()
}

// SetAttribute implements Node.SetAttribute.
func (n *BaseNode) SetAttribute(name []byte, value interface{}) {
	if n.attributes == nil {
		n.attributes = make([]Attribute, 0, 10)
	} else {
		for i, a := range n.attributes {
			if bytes.Equal(a.Name, name) {
				n.attributes[i].Name = name
				n.attributes[i].Value = value
				return
			}
		}
	}
	n.attributes = append(n.attributes, Attribute{name, value})
}

// SetAttributeString implements Node.SetAttributeString.
func (n *BaseNode) SetAttributeString(name string, value interface{}) {
	n.SetAttribute(util.StringToReadOnlyBytes(name), value)
}

// Attribute implements Node.Attribute.
func (n *BaseNode) Attribute(name []byte) (interface{}, bool) {
	if n.attributes == nil {
		return nil, false
	}
	for i, a := range n.attributes {
		if bytes.Equal(a.Name, name) {
			return n.attributes[i].Value, true
		}
	}
	return nil, false
}

// AttributeString implements Node.AttributeString.
func (n *BaseNode) AttributeString(s string) (interface{}, bool) {
	return n.Attribute(util.StringToReadOnlyBytes(s))
}

// Attributes implements Node.Attributes.
func (n *BaseNode) Attributes() []Attribute {
	return n.attributes
}

// RemoveAttributes implements Node.RemoveAttributes.
func (n *BaseNode) RemoveAttributes() {
	n.attributes = nil
}

// DumpHelper is a helper function to implement Node.Dump.
// kv is pairs of an attribute name and an attribute value.
// cb is a function called after wrote a name and attributes.
func DumpHelper(v Node, source []byte, level int, kv map[string]string, cb func(int)) {
	name := v.Kind().String()
	indent := strings.Repeat("    ", level)
	fmt.Printf("%s%s {\n", indent, name)
	indent2 := strings.Repeat("    ", level+1)
	if v.Type() == TypeBlock {
		fmt.Printf("%sRawText: \"", indent2)
		for i := 0; i < v.Lines().Len(); i++ {
			line := v.Lines().At(i)
			fmt.Printf("%s", line.Value(source))
		}
		fmt.Printf("\"\n")
		fmt.Printf("%sHasBlankPreviousLines: %v\n", indent2, v.HasBlankPreviousLines())
	}
	for name, value := range kv {
		fmt.Printf("%s%s: %s\n", indent2, name, value)
	}
	if cb != nil {
		cb(level + 1)
	}
	for c := v.FirstChild(); c != nil; c = c.NextSibling() {
		c.Dump(source, level+1)
	}
	fmt.Printf("%s}\n", indent)
}

// WalkStatus represents a current status of the Walk function.
type WalkStatus int

const (
	// WalkStop indicates no more walking needed.
	WalkStop WalkStatus = iota + 1

	// WalkSkipChildren indicates that Walk wont walk on children of current
	// node.
	WalkSkipChildren

	// WalkContinue indicates that Walk can continue to walk.
	WalkContinue
)

// Walker is a function that will be called when Walk find a
// new node.
// entering is set true before walks children, false after walked children.
// If Walker returns error, Walk function immediately stop walking.
type Walker func(n Node, entering bool) (WalkStatus, error)

// Walk walks a AST tree by the depth first search algorithm.
func Walk(n Node, walker Walker) error {
	_, err := walkHelper(n, walker)
	return err
}

func walkHelper(n Node, walker Walker) (WalkStatus, error) {
	status, err := walker(n, true)
	if err != nil || status == WalkStop {
		return status, err
	}
	if status != WalkSkipChildren {
		for c := n.FirstChild(); c != nil; c = c.NextSibling() {
			if st, err := walkHelper(c, walker); err != nil || st == WalkStop {
				return WalkStop, err
			}
		}
	}
	status, err = walker(n, false)
	if err != nil || status == WalkStop {
		return WalkStop, err
	}
	return WalkContinue, nil
}
</file>

<file path="ast/block.go">
package ast

import (
	"fmt"
	"strings"

	textm "github.com/yuin/goldmark/text"
)

// A BaseBlock struct implements the Node interface partialliy.
type BaseBlock struct {
	BaseNode
	lines              textm.Segments
	blankPreviousLines bool
}

// Type implements Node.Type.
func (b *BaseBlock) Type() NodeType {
	return TypeBlock
}

// IsRaw implements Node.IsRaw.
func (b *BaseBlock) IsRaw() bool {
	return false
}

// HasBlankPreviousLines implements Node.HasBlankPreviousLines.
func (b *BaseBlock) HasBlankPreviousLines() bool {
	return b.blankPreviousLines
}

// SetBlankPreviousLines implements Node.SetBlankPreviousLines.
func (b *BaseBlock) SetBlankPreviousLines(v bool) {
	b.blankPreviousLines = v
}

// Lines implements Node.Lines.
func (b *BaseBlock) Lines() *textm.Segments {
	return &b.lines
}

// SetLines implements Node.SetLines.
func (b *BaseBlock) SetLines(v *textm.Segments) {
	b.lines = *v
}

// A Document struct is a root node of Markdown text.
type Document struct {
	BaseBlock

	meta map[string]interface{}
}

// KindDocument is a NodeKind of the Document node.
var KindDocument = NewNodeKind("Document")

// Dump implements Node.Dump .
func (n *Document) Dump(source []byte, level int) {
	DumpHelper(n, source, level, nil, nil)
}

// Type implements Node.Type .
func (n *Document) Type() NodeType {
	return TypeDocument
}

// Kind implements Node.Kind.
func (n *Document) Kind() NodeKind {
	return KindDocument
}

// OwnerDocument implements Node.OwnerDocument.
func (n *Document) OwnerDocument() *Document {
	return n
}

// Meta returns metadata of this document.
func (n *Document) Meta() map[string]interface{} {
	if n.meta == nil {
		n.meta = map[string]interface{}{}
	}
	return n.meta
}

// SetMeta sets given metadata to this document.
func (n *Document) SetMeta(meta map[string]interface{}) {
	if n.meta == nil {
		n.meta = map[string]interface{}{}
	}
	for k, v := range meta {
		n.meta[k] = v
	}
}

// AddMeta adds given metadata to this document.
func (n *Document) AddMeta(key string, value interface{}) {
	if n.meta == nil {
		n.meta = map[string]interface{}{}
	}
	n.meta[key] = value
}

// NewDocument returns a new Document node.
func NewDocument() *Document {
	return &Document{
		BaseBlock: BaseBlock{},
		meta:      nil,
	}
}

// A TextBlock struct is a node whose lines
// should be rendered without any containers.
type TextBlock struct {
	BaseBlock
}

// Dump implements Node.Dump .
func (n *TextBlock) Dump(source []byte, level int) {
	DumpHelper(n, source, level, nil, nil)
}

// KindTextBlock is a NodeKind of the TextBlock node.
var KindTextBlock = NewNodeKind("TextBlock")

// Kind implements Node.Kind.
func (n *TextBlock) Kind() NodeKind {
	return KindTextBlock
}

// Text implements Node.Text.
//
// Deprecated: Use other properties of the node to get the text value(i.e. TextBlock.Lines).
func (n *TextBlock) Text(source []byte) []byte {
	return n.Lines().Value(source)
}

// NewTextBlock returns a new TextBlock node.
func NewTextBlock() *TextBlock {
	return &TextBlock{
		BaseBlock: BaseBlock{},
	}
}

// A Paragraph struct represents a paragraph of Markdown text.
type Paragraph struct {
	BaseBlock
}

// Dump implements Node.Dump .
func (n *Paragraph) Dump(source []byte, level int) {
	DumpHelper(n, source, level, nil, nil)
}

// KindParagraph is a NodeKind of the Paragraph node.
var KindParagraph = NewNodeKind("Paragraph")

// Kind implements Node.Kind.
func (n *Paragraph) Kind() NodeKind {
	return KindParagraph
}

// Text implements Node.Text.
//
// Deprecated: Use other properties of the node to get the text value(i.e. Paragraph.Lines).
func (n *Paragraph) Text(source []byte) []byte {
	return n.Lines().Value(source)
}

// NewParagraph returns a new Paragraph node.
func NewParagraph() *Paragraph {
	return &Paragraph{
		BaseBlock: BaseBlock{},
	}
}

// IsParagraph returns true if the given node implements the Paragraph interface,
// otherwise false.
func IsParagraph(node Node) bool {
	_, ok := node.(*Paragraph)
	return ok
}

// A Heading struct represents headings like SetextHeading and ATXHeading.
type Heading struct {
	BaseBlock
	// Level returns a level of this heading.
	// This value is between 1 and 6.
	Level int
}

// Dump implements Node.Dump .
func (n *Heading) Dump(source []byte, level int) {
	m := map[string]string{
		"Level": fmt.Sprintf("%d", n.Level),
	}
	DumpHelper(n, source, level, m, nil)
}

// KindHeading is a NodeKind of the Heading node.
var KindHeading = NewNodeKind("Heading")

// Kind implements Node.Kind.
func (n *Heading) Kind() NodeKind {
	return KindHeading
}

// NewHeading returns a new Heading node.
func NewHeading(level int) *Heading {
	return &Heading{
		BaseBlock: BaseBlock{},
		Level:     level,
	}
}

// A ThematicBreak struct represents a thematic break of Markdown text.
type ThematicBreak struct {
	BaseBlock
}

// Dump implements Node.Dump .
func (n *ThematicBreak) Dump(source []byte, level int) {
	DumpHelper(n, source, level, nil, nil)
}

// KindThematicBreak is a NodeKind of the ThematicBreak node.
var KindThematicBreak = NewNodeKind("ThematicBreak")

// Kind implements Node.Kind.
func (n *ThematicBreak) Kind() NodeKind {
	return KindThematicBreak
}

// NewThematicBreak returns a new ThematicBreak node.
func NewThematicBreak() *ThematicBreak {
	return &ThematicBreak{
		BaseBlock: BaseBlock{},
	}
}

// A CodeBlock interface represents an indented code block of Markdown text.
type CodeBlock struct {
	BaseBlock
}

// IsRaw implements Node.IsRaw.
func (n *CodeBlock) IsRaw() bool {
	return true
}

// Dump implements Node.Dump .
func (n *CodeBlock) Dump(source []byte, level int) {
	DumpHelper(n, source, level, nil, nil)
}

// KindCodeBlock is a NodeKind of the CodeBlock node.
var KindCodeBlock = NewNodeKind("CodeBlock")

// Kind implements Node.Kind.
func (n *CodeBlock) Kind() NodeKind {
	return KindCodeBlock
}

// Text implements Node.Text.
//
// Deprecated: Use other properties of the node to get the text value(i.e. CodeBlock.Lines).
func (n *CodeBlock) Text(source []byte) []byte {
	return n.Lines().Value(source)
}

// NewCodeBlock returns a new CodeBlock node.
func NewCodeBlock() *CodeBlock {
	return &CodeBlock{
		BaseBlock: BaseBlock{},
	}
}

// A FencedCodeBlock struct represents a fenced code block of Markdown text.
type FencedCodeBlock struct {
	BaseBlock
	// Info returns a info text of this fenced code block.
	Info *Text

	language []byte
}

// Language returns an language in an info string.
// Language returns nil if this node does not have an info string.
func (n *FencedCodeBlock) Language(source []byte) []byte {
	if n.language == nil && n.Info != nil {
		segment := n.Info.Segment
		info := segment.Value(source)
		i := 0
		for ; i < len(info); i++ {
			if info[i] == ' ' {
				break
			}
		}
		n.language = info[:i]
	}
	return n.language
}

// IsRaw implements Node.IsRaw.
func (n *FencedCodeBlock) IsRaw() bool {
	return true
}

// Dump implements Node.Dump .
func (n *FencedCodeBlock) Dump(source []byte, level int) {
	m := map[string]string{}
	if n.Info != nil {
		m["Info"] = fmt.Sprintf("\"%s\"", n.Info.Text(source))
	}
	DumpHelper(n, source, level, m, nil)
}

// KindFencedCodeBlock is a NodeKind of the FencedCodeBlock node.
var KindFencedCodeBlock = NewNodeKind("FencedCodeBlock")

// Kind implements Node.Kind.
func (n *FencedCodeBlock) Kind() NodeKind {
	return KindFencedCodeBlock
}

// Text implements Node.Text.
//
// Deprecated: Use other properties of the node to get the text value(i.e. FencedCodeBlock.Lines).
func (n *FencedCodeBlock) Text(source []byte) []byte {
	return n.Lines().Value(source)
}

// NewFencedCodeBlock return a new FencedCodeBlock node.
func NewFencedCodeBlock(info *Text) *FencedCodeBlock {
	return &FencedCodeBlock{
		BaseBlock: BaseBlock{},
		Info:      info,
	}
}

// A Blockquote struct represents an blockquote block of Markdown text.
type Blockquote struct {
	BaseBlock
}

// Dump implements Node.Dump .
func (n *Blockquote) Dump(source []byte, level int) {
	DumpHelper(n, source, level, nil, nil)
}

// KindBlockquote is a NodeKind of the Blockquote node.
var KindBlockquote = NewNodeKind("Blockquote")

// Kind implements Node.Kind.
func (n *Blockquote) Kind() NodeKind {
	return KindBlockquote
}

// NewBlockquote returns a new Blockquote node.
func NewBlockquote() *Blockquote {
	return &Blockquote{
		BaseBlock: BaseBlock{},
	}
}

// A List struct represents a list of Markdown text.
type List struct {
	BaseBlock

	// Marker is a marker character like '-', '+', ')' and '.'.
	Marker byte

	// IsTight is a true if this list is a 'tight' list.
	// See https://spec.commonmark.org/0.30/#loose for details.
	IsTight bool

	// Start is an initial number of this ordered list.
	// If this list is not an ordered list, Start is 0.
	Start int
}

// IsOrdered returns true if this list is an ordered list, otherwise false.
func (l *List) IsOrdered() bool {
	return l.Marker == '.' || l.Marker == ')'
}

// CanContinue returns true if this list can continue with
// the given mark and a list type, otherwise false.
func (l *List) CanContinue(marker byte, isOrdered bool) bool {
	return marker == l.Marker && isOrdered == l.IsOrdered()
}

// Dump implements Node.Dump.
func (l *List) Dump(source []byte, level int) {
	m := map[string]string{
		"Ordered": fmt.Sprintf("%v", l.IsOrdered()),
		"Marker":  fmt.Sprintf("%c", l.Marker),
		"Tight":   fmt.Sprintf("%v", l.IsTight),
	}
	if l.IsOrdered() {
		m["Start"] = fmt.Sprintf("%d", l.Start)
	}
	DumpHelper(l, source, level, m, nil)
}

// KindList is a NodeKind of the List node.
var KindList = NewNodeKind("List")

// Kind implements Node.Kind.
func (l *List) Kind() NodeKind {
	return KindList
}

// NewList returns a new List node.
func NewList(marker byte) *List {
	return &List{
		BaseBlock: BaseBlock{},
		Marker:    marker,
		IsTight:   true,
	}
}

// A ListItem struct represents a list item of Markdown text.
type ListItem struct {
	BaseBlock

	// Offset is an offset position of this item.
	Offset int
}

// Dump implements Node.Dump.
func (n *ListItem) Dump(source []byte, level int) {
	m := map[string]string{
		"Offset": fmt.Sprintf("%d", n.Offset),
	}
	DumpHelper(n, source, level, m, nil)
}

// KindListItem is a NodeKind of the ListItem node.
var KindListItem = NewNodeKind("ListItem")

// Kind implements Node.Kind.
func (n *ListItem) Kind() NodeKind {
	return KindListItem
}

// NewListItem returns a new ListItem node.
func NewListItem(offset int) *ListItem {
	return &ListItem{
		BaseBlock: BaseBlock{},
		Offset:    offset,
	}
}

// HTMLBlockType represents kinds of an html blocks.
// See https://spec.commonmark.org/0.30/#html-blocks
type HTMLBlockType int

const (
	// HTMLBlockType1 represents type 1 html blocks.
	HTMLBlockType1 HTMLBlockType = iota + 1
	// HTMLBlockType2 represents type 2 html blocks.
	HTMLBlockType2
	// HTMLBlockType3 represents type 3 html blocks.
	HTMLBlockType3
	// HTMLBlockType4 represents type 4 html blocks.
	HTMLBlockType4
	// HTMLBlockType5 represents type 5 html blocks.
	HTMLBlockType5
	// HTMLBlockType6 represents type 6 html blocks.
	HTMLBlockType6
	// HTMLBlockType7 represents type 7 html blocks.
	HTMLBlockType7
)

// An HTMLBlock struct represents an html block of Markdown text.
type HTMLBlock struct {
	BaseBlock

	// Type is a type of this html block.
	HTMLBlockType HTMLBlockType

	// ClosureLine is a line that closes this html block.
	ClosureLine textm.Segment
}

// IsRaw implements Node.IsRaw.
func (n *HTMLBlock) IsRaw() bool {
	return true
}

// HasClosure returns true if this html block has a closure line,
// otherwise false.
func (n *HTMLBlock) HasClosure() bool {
	return n.ClosureLine.Start >= 0
}

// Dump implements Node.Dump.
func (n *HTMLBlock) Dump(source []byte, level int) {
	indent := strings.Repeat("    ", level)
	fmt.Printf("%s%s {\n", indent, "HTMLBlock")
	indent2 := strings.Repeat("    ", level+1)
	fmt.Printf("%sRawText: \"", indent2)
	for i := 0; i < n.Lines().Len(); i++ {
		s := n.Lines().At(i)
		fmt.Print(string(source[s.Start:s.Stop]))
	}
	fmt.Printf("\"\n")
	for c := n.FirstChild(); c != nil; c = c.NextSibling() {
		c.Dump(source, level+1)
	}
	if n.HasClosure() {
		cl := n.ClosureLine
		fmt.Printf("%sClosure: \"%s\"\n", indent2, string(cl.Value(source)))
	}
	fmt.Printf("%sHasBlankPreviousLines: %v\n", indent2, n.HasBlankPreviousLines())
	fmt.Printf("%s}\n", indent)
}

// KindHTMLBlock is a NodeKind of the HTMLBlock node.
var KindHTMLBlock = NewNodeKind("HTMLBlock")

// Kind implements Node.Kind.
func (n *HTMLBlock) Kind() NodeKind {
	return KindHTMLBlock
}

// Text implements Node.Text.
//
// Deprecated: Use other properties of the node to get the text value(i.e. HTMLBlock.Lines).
func (n *HTMLBlock) Text(source []byte) []byte {
	ret := n.Lines().Value(source)
	if n.HasClosure() {
		ret = append(ret, n.ClosureLine.Value(source)...)
	}
	return ret
}

// NewHTMLBlock returns a new HTMLBlock node.
func NewHTMLBlock(typ HTMLBlockType) *HTMLBlock {
	return &HTMLBlock{
		BaseBlock:     BaseBlock{},
		HTMLBlockType: typ,
		ClosureLine:   textm.NewSegment(-1, -1),
	}
}
</file>

<file path="extension/cjk.go">
package extension

import (
	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer/html"
)

// A CJKOption sets options for CJK support mostly for HTML based renderers.
type CJKOption func(*cjk)

// A EastAsianLineBreaks is a style of east asian line breaks.
type EastAsianLineBreaks int

const (
	//EastAsianLineBreaksNone renders line breaks as it is.
	EastAsianLineBreaksNone EastAsianLineBreaks = iota
	// EastAsianLineBreaksSimple is a style where soft line breaks are ignored
	// if both sides of the break are east asian wide characters.
	EastAsianLineBreaksSimple
	// EastAsianLineBreaksCSS3Draft is a style where soft line breaks are ignored
	// even if only one side of the break is an east asian wide character.
	EastAsianLineBreaksCSS3Draft
)

// WithEastAsianLineBreaks is a functional option that indicates whether softline breaks
// between east asian wide characters should be ignored.
// style defauts to [EastAsianLineBreaksSimple] .
func WithEastAsianLineBreaks(style ...EastAsianLineBreaks) CJKOption {
	return func(c *cjk) {
		if len(style) == 0 {
			c.EastAsianLineBreaks = EastAsianLineBreaksSimple
			return
		}
		c.EastAsianLineBreaks = style[0]
	}
}

// WithEscapedSpace is a functional option that indicates that a '\' escaped half-space(0x20) should not be rendered.
func WithEscapedSpace() CJKOption {
	return func(c *cjk) {
		c.EscapedSpace = true
	}
}

type cjk struct {
	EastAsianLineBreaks EastAsianLineBreaks
	EscapedSpace        bool
}

// CJK is a goldmark extension that provides functionalities for CJK languages.
var CJK = NewCJK(WithEastAsianLineBreaks(), WithEscapedSpace())

// NewCJK returns a new extension with given options.
func NewCJK(opts ...CJKOption) goldmark.Extender {
	e := &cjk{
		EastAsianLineBreaks: EastAsianLineBreaksNone,
	}
	for _, opt := range opts {
		opt(e)
	}
	return e
}

func (e *cjk) Extend(m goldmark.Markdown) {
	m.Renderer().AddOptions(html.WithEastAsianLineBreaks(
		html.EastAsianLineBreaks(e.EastAsianLineBreaks)))
	if e.EscapedSpace {
		m.Renderer().AddOptions(html.WithWriter(html.NewWriter(html.WithEscapedSpace())))
		m.Parser().AddOptions(parser.WithEscapedSpace())
	}
}
</file>

<file path="util/util.go">
// Package util provides utility functions for the goldmark.
package util

import (
	"bytes"
	"io"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"unicode"
	"unicode/utf8"
)

// A CopyOnWriteBuffer is a byte buffer that copies buffer when
// it need to be changed.
type CopyOnWriteBuffer struct {
	buffer []byte
	copied bool
}

// NewCopyOnWriteBuffer returns a new CopyOnWriteBuffer.
func NewCopyOnWriteBuffer(buffer []byte) CopyOnWriteBuffer {
	return CopyOnWriteBuffer{
		buffer: buffer,
		copied: false,
	}
}

// Write writes given bytes to the buffer.
// Write allocate new buffer and clears it at the first time.
func (b *CopyOnWriteBuffer) Write(value []byte) {
	if !b.copied {
		b.buffer = make([]byte, 0, len(b.buffer)+20)
		b.copied = true
	}
	b.buffer = append(b.buffer, value...)
}

// WriteString writes given string to the buffer.
// WriteString allocate new buffer and clears it at the first time.
func (b *CopyOnWriteBuffer) WriteString(value string) {
	b.Write(StringToReadOnlyBytes(value))
}

// Append appends given bytes to the buffer.
// Append copy buffer at the first time.
func (b *CopyOnWriteBuffer) Append(value []byte) {
	if !b.copied {
		tmp := make([]byte, len(b.buffer), len(b.buffer)+20)
		copy(tmp, b.buffer)
		b.buffer = tmp
		b.copied = true
	}
	b.buffer = append(b.buffer, value...)
}

// AppendString appends given string to the buffer.
// AppendString copy buffer at the first time.
func (b *CopyOnWriteBuffer) AppendString(value string) {
	b.Append(StringToReadOnlyBytes(value))
}

// WriteByte writes the given byte to the buffer.
// WriteByte allocate new buffer and clears it at the first time.
func (b *CopyOnWriteBuffer) WriteByte(c byte) error {
	if !b.copied {
		b.buffer = make([]byte, 0, len(b.buffer)+20)
		b.copied = true
	}
	b.buffer = append(b.buffer, c)
	return nil
}

// AppendByte appends given bytes to the buffer.
// AppendByte copy buffer at the first time.
func (b *CopyOnWriteBuffer) AppendByte(c byte) {
	if !b.copied {
		tmp := make([]byte, len(b.buffer), len(b.buffer)+20)
		copy(tmp, b.buffer)
		b.buffer = tmp
		b.copied = true
	}
	b.buffer = append(b.buffer, c)
}

// Bytes returns bytes of this buffer.
func (b *CopyOnWriteBuffer) Bytes() []byte {
	return b.buffer
}

// IsCopied returns true if buffer has been copied, otherwise false.
func (b *CopyOnWriteBuffer) IsCopied() bool {
	return b.copied
}

// IsEscapedPunctuation returns true if character at a given index i
// is an escaped punctuation, otherwise false.
func IsEscapedPunctuation(source []byte, i int) bool {
	return source[i] == '\\' && i < len(source)-1 && IsPunct(source[i+1])
}

// ReadWhile read the given source while pred is true.
func ReadWhile(source []byte, index [2]int, pred func(byte) bool) (int, bool) {
	j := index[0]
	ok := false
	for ; j < index[1]; j++ {
		c1 := source[j]
		if pred(c1) {
			ok = true
			continue
		}
		break
	}
	return j, ok
}

// IsBlank returns true if the given string is all space characters.
func IsBlank(bs []byte) bool {
	for _, b := range bs {
		if !IsSpace(b) {
			return false
		}
	}
	return true
}

// VisualizeSpaces visualize invisible space characters.
func VisualizeSpaces(bs []byte) []byte {
	bs = bytes.Replace(bs, []byte(" "), []byte("[SPACE]"), -1)
	bs = bytes.Replace(bs, []byte("\t"), []byte("[TAB]"), -1)
	bs = bytes.Replace(bs, []byte("\n"), []byte("[NEWLINE]\n"), -1)
	bs = bytes.Replace(bs, []byte("\r"), []byte("[CR]"), -1)
	bs = bytes.Replace(bs, []byte("\v"), []byte("[VTAB]"), -1)
	bs = bytes.Replace(bs, []byte("\x00"), []byte("[NUL]"), -1)
	bs = bytes.Replace(bs, []byte("\ufffd"), []byte("[U+FFFD]"), -1)
	return bs
}

// TabWidth calculates actual width of a tab at the given position.
func TabWidth(currentPos int) int {
	return 4 - currentPos%4
}

// IndentPosition searches an indent position with the given width for the given line.
// If the line contains tab characters, paddings may be not zero.
// currentPos==0 and width==2:
//
//	position: 0    1
//	          [TAB]aaaa
//	width:    1234 5678
//
// width=2 is in the tab character. In this case, IndentPosition returns
// (pos=1, padding=2).
func IndentPosition(bs []byte, currentPos, width int) (pos, padding int) {
	return IndentPositionPadding(bs, currentPos, 0, width)
}

// IndentPositionPadding searches an indent position with the given width for the given line.
// This function is mostly same as IndentPosition except this function
// takes account into additional paddings.
func IndentPositionPadding(bs []byte, currentPos, paddingv, width int) (pos, padding int) {
	if width == 0 {
		return 0, paddingv
	}
	w := 0
	i := 0
	l := len(bs)
	p := paddingv
	for ; i < l; i++ {
		if p > 0 {
			p--
			w++
			continue
		}
		if bs[i] == '\t' && w < width {
			w += TabWidth(currentPos + w)
		} else if bs[i] == ' ' && w < width {
			w++
		} else {
			break
		}
	}
	if w >= width {
		return i - paddingv, w - width
	}
	return -1, -1
}

// DedentPosition dedents lines by the given width.
//
// Deprecated: This function has bugs. Use util.IndentPositionPadding and util.FirstNonSpacePosition.
func DedentPosition(bs []byte, currentPos, width int) (pos, padding int) {
	if width == 0 {
		return 0, 0
	}
	w := 0
	l := len(bs)
	i := 0
	for ; i < l; i++ {
		if bs[i] == '\t' {
			w += TabWidth(currentPos + w)
		} else if bs[i] == ' ' {
			w++
		} else {
			break
		}
	}
	if w >= width {
		return i, w - width
	}
	return i, 0
}

// DedentPositionPadding dedents lines by the given width.
// This function is mostly same as DedentPosition except this function
// takes account into additional paddings.
//
// Deprecated: This function has bugs. Use util.IndentPositionPadding and util.FirstNonSpacePosition.
func DedentPositionPadding(bs []byte, currentPos, paddingv, width int) (pos, padding int) {
	if width == 0 {
		return 0, paddingv
	}

	w := 0
	i := 0
	l := len(bs)
	for ; i < l; i++ {
		if bs[i] == '\t' {
			w += TabWidth(currentPos + w)
		} else if bs[i] == ' ' {
			w++
		} else {
			break
		}
	}
	if w >= width {
		return i - paddingv, w - width
	}
	return i - paddingv, 0
}

// IndentWidth calculate an indent width for the given line.
func IndentWidth(bs []byte, currentPos int) (width, pos int) {
	l := len(bs)
	for i := 0; i < l; i++ {
		b := bs[i]
		if b == ' ' {
			width++
			pos++
		} else if b == '\t' {
			width += TabWidth(currentPos + width)
			pos++
		} else {
			break
		}
	}
	return
}

// FirstNonSpacePosition returns a position line that is a first nonspace
// character.
func FirstNonSpacePosition(bs []byte) int {
	i := 0
	for ; i < len(bs); i++ {
		c := bs[i]
		if c == ' ' || c == '\t' {
			continue
		}
		if c == '\n' {
			return -1
		}
		return i
	}
	return -1
}

// FindClosure returns a position that closes the given opener.
// If codeSpan is set true, it ignores characters in code spans.
// If allowNesting is set true, closures correspond to nested opener will be
// ignored.
//
// Deprecated: This function can not handle newlines. Many elements
// can be existed over multiple lines(e.g. link labels).
// Use text.Reader.FindClosure.
func FindClosure(bs []byte, opener, closure byte, codeSpan, allowNesting bool) int {
	i := 0
	opened := 1
	codeSpanOpener := 0
	for i < len(bs) {
		c := bs[i]
		if codeSpan && codeSpanOpener != 0 && c == '`' {
			codeSpanCloser := 0
			for ; i < len(bs); i++ {
				if bs[i] == '`' {
					codeSpanCloser++
				} else {
					i--
					break
				}
			}
			if codeSpanCloser == codeSpanOpener {
				codeSpanOpener = 0
			}
		} else if codeSpanOpener == 0 && c == '\\' && i < len(bs)-1 && IsPunct(bs[i+1]) {
			i += 2
			continue
		} else if codeSpan && codeSpanOpener == 0 && c == '`' {
			for ; i < len(bs); i++ {
				if bs[i] == '`' {
					codeSpanOpener++
				} else {
					i--
					break
				}
			}
		} else if (codeSpan && codeSpanOpener == 0) || !codeSpan {
			if c == closure {
				opened--
				if opened == 0 {
					return i
				}
			} else if c == opener {
				if !allowNesting {
					return -1
				}
				opened++
			}
		}
		i++
	}
	return -1
}

// TrimLeft trims characters in the given s from head of the source.
// bytes.TrimLeft offers same functionalities, but bytes.TrimLeft
// allocates new buffer for the result.
func TrimLeft(source, b []byte) []byte {
	i := 0
	for ; i < len(source); i++ {
		c := source[i]
		found := false
		for j := 0; j < len(b); j++ {
			if c == b[j] {
				found = true
				break
			}
		}
		if !found {
			break
		}
	}
	return source[i:]
}

// TrimRight trims characters in the given s from tail of the source.
func TrimRight(source, b []byte) []byte {
	i := len(source) - 1
	for ; i >= 0; i-- {
		c := source[i]
		found := false
		for j := 0; j < len(b); j++ {
			if c == b[j] {
				found = true
				break
			}
		}
		if !found {
			break
		}
	}
	return source[:i+1]
}

// TrimLeftLength returns a length of leading specified characters.
func TrimLeftLength(source, s []byte) int {
	return len(source) - len(TrimLeft(source, s))
}

// TrimRightLength returns a length of trailing specified characters.
func TrimRightLength(source, s []byte) int {
	return len(source) - len(TrimRight(source, s))
}

// TrimLeftSpaceLength returns a length of leading space characters.
func TrimLeftSpaceLength(source []byte) int {
	i := 0
	for ; i < len(source); i++ {
		if !IsSpace(source[i]) {
			break
		}
	}
	return i
}

// TrimRightSpaceLength returns a length of trailing space characters.
func TrimRightSpaceLength(source []byte) int {
	l := len(source)
	i := l - 1
	for ; i >= 0; i-- {
		if !IsSpace(source[i]) {
			break
		}
	}
	if i < 0 {
		return l
	}
	return l - 1 - i
}

// TrimLeftSpace returns a subslice of the given string by slicing off all leading
// space characters.
func TrimLeftSpace(source []byte) []byte {
	return TrimLeft(source, spaces)
}

// TrimRightSpace returns a subslice of the given string by slicing off all trailing
// space characters.
func TrimRightSpace(source []byte) []byte {
	return TrimRight(source, spaces)
}

// DoFullUnicodeCaseFolding performs full unicode case folding to given bytes.
func DoFullUnicodeCaseFolding(v []byte) []byte {
	var rbuf []byte
	cob := NewCopyOnWriteBuffer(v)
	n := 0
	for i := 0; i < len(v); i++ {
		c := v[i]
		if c < 0xb5 {
			if c >= 0x41 && c <= 0x5a {
				// A-Z to a-z
				cob.Write(v[n:i])
				_ = cob.WriteByte(c + 32)
				n = i + 1
			}
			continue
		}

		if !utf8.RuneStart(c) {
			continue
		}
		r, length := utf8.DecodeRune(v[i:])
		if r == utf8.RuneError {
			continue
		}
		folded, ok := unicodeCaseFoldings[r]
		if !ok {
			continue
		}

		cob.Write(v[n:i])
		if rbuf == nil {
			rbuf = make([]byte, 4)
		}
		for _, f := range folded {
			l := utf8.EncodeRune(rbuf, f)
			cob.Write(rbuf[:l])
		}
		i += length - 1
		n = i + 1
	}
	if cob.IsCopied() {
		cob.Write(v[n:])
	}
	return cob.Bytes()
}

// ReplaceSpaces replaces sequence of spaces with the given repl.
func ReplaceSpaces(source []byte, repl byte) []byte {
	var ret []byte
	start := -1
	for i, c := range source {
		iss := IsSpace(c)
		if start < 0 && iss {
			start = i
			continue
		} else if start >= 0 && iss {
			continue
		} else if start >= 0 {
			if ret == nil {
				ret = make([]byte, 0, len(source))
				ret = append(ret, source[:start]...)
			}
			ret = append(ret, repl)
			start = -1
		}
		if ret != nil {
			ret = append(ret, c)
		}
	}
	if start >= 0 && ret != nil {
		ret = append(ret, repl)
	}
	if ret == nil {
		return source
	}
	return ret
}

// ToRune decode given bytes start at pos and returns a rune.
func ToRune(source []byte, pos int) rune {
	i := pos
	for ; i >= 0; i-- {
		if utf8.RuneStart(source[i]) {
			break
		}
	}
	r, _ := utf8.DecodeRune(source[i:])
	return r
}

// ToValidRune returns 0xFFFD if the given rune is invalid, otherwise v.
func ToValidRune(v rune) rune {
	if v == 0 || !utf8.ValidRune(v) {
		return rune(0xFFFD)
	}
	return v
}

// ToLinkReference converts given bytes into a valid link reference string.
// ToLinkReference performs unicode case folding, trims leading and trailing spaces,  converts into lower
// case and replace spaces with a single space character.
func ToLinkReference(v []byte) string {
	v = TrimLeftSpace(v)
	v = TrimRightSpace(v)
	v = DoFullUnicodeCaseFolding(v)
	return string(ReplaceSpaces(v, ' '))
}

var htmlQuote = []byte("&quot;")
var htmlAmp = []byte("&amp;")
var htmlLess = []byte("&lt;")
var htmlGreater = []byte("&gt;")

var htmlEscapeTable = [256]*[]byte{nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, &htmlQuote, nil, nil, nil, &htmlAmp, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, &htmlLess, nil, &htmlGreater, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil} //nolint:golint,lll

// EscapeHTMLByte returns HTML escaped bytes if the given byte should be escaped,
// otherwise nil.
func EscapeHTMLByte(b byte) []byte {
	v := htmlEscapeTable[b]
	if v != nil {
		return *v
	}
	return nil
}

// EscapeHTML escapes characters that should be escaped in HTML text.
func EscapeHTML(v []byte) []byte {
	cob := NewCopyOnWriteBuffer(v)
	n := 0
	for i := 0; i < len(v); i++ {
		c := v[i]
		escaped := htmlEscapeTable[c]
		if escaped != nil {
			cob.Write(v[n:i])
			cob.Write(*escaped)
			n = i + 1
		}
	}
	if cob.IsCopied() {
		cob.Write(v[n:])
	}
	return cob.Bytes()
}

// UnescapePunctuations unescapes blackslash escaped punctuations.
func UnescapePunctuations(source []byte) []byte {
	cob := NewCopyOnWriteBuffer(source)
	limit := len(source)
	n := 0
	for i := 0; i < limit; {
		c := source[i]
		if i < limit-1 && c == '\\' && IsPunct(source[i+1]) {
			cob.Write(source[n:i])
			_ = cob.WriteByte(source[i+1])
			i += 2
			n = i
			continue
		}
		i++
	}
	if cob.IsCopied() {
		cob.Write(source[n:])
	}
	return cob.Bytes()
}

// ResolveNumericReferences resolve numeric references like '&#1234;" .
func ResolveNumericReferences(source []byte) []byte {
	cob := NewCopyOnWriteBuffer(source)
	buf := make([]byte, 6)
	limit := len(source)
	var ok bool
	n := 0
	for i := 0; i < limit; i++ {
		if source[i] == '&' {
			pos := i
			next := i + 1
			if next < limit && source[next] == '#' {
				nnext := next + 1
				if nnext < limit {
					nc := source[nnext]
					// code point like #x22;
					if nnext < limit && nc == 'x' || nc == 'X' {
						start := nnext + 1
						i, ok = ReadWhile(source, [2]int{start, limit}, IsHexDecimal)
						if ok && i < limit && source[i] == ';' {
							v, _ := strconv.ParseUint(BytesToReadOnlyString(source[start:i]), 16, 32)
							cob.Write(source[n:pos])
							n = i + 1
							runeSize := utf8.EncodeRune(buf, ToValidRune(rune(v)))
							cob.Write(buf[:runeSize])
							continue
						}
						// code point like #1234;
					} else if nc >= '0' && nc <= '9' {
						start := nnext
						i, ok = ReadWhile(source, [2]int{start, limit}, IsNumeric)
						if ok && i < limit && i-start < 8 && source[i] == ';' {
							v, _ := strconv.ParseUint(BytesToReadOnlyString(source[start:i]), 0, 32)
							cob.Write(source[n:pos])
							n = i + 1
							runeSize := utf8.EncodeRune(buf, ToValidRune(rune(v)))
							cob.Write(buf[:runeSize])
							continue
						}
					}
				}
			}
			i = next - 1
		}
	}
	if cob.IsCopied() {
		cob.Write(source[n:])
	}
	return cob.Bytes()
}

// ResolveEntityNames resolve entity references like '&ouml;" .
func ResolveEntityNames(source []byte) []byte {
	cob := NewCopyOnWriteBuffer(source)
	limit := len(source)
	var ok bool
	n := 0
	for i := 0; i < limit; i++ {
		if source[i] == '&' {
			pos := i
			next := i + 1
			if !(next < limit && source[next] == '#') {
				start := next
				i, ok = ReadWhile(source, [2]int{start, limit}, IsAlphaNumeric)
				if ok && i < limit && source[i] == ';' {
					name := BytesToReadOnlyString(source[start:i])
					entity, ok := LookUpHTML5EntityByName(name)
					if ok {
						cob.Write(source[n:pos])
						n = i + 1
						cob.Write(entity.Characters)
						continue
					}
				}
			}
			i = next - 1
		}
	}
	if cob.IsCopied() {
		cob.Write(source[n:])
	}
	return cob.Bytes()
}

var htmlSpace = []byte("%20")

// URLEscape escape the given URL.
// If resolveReference is set true:
//  1. unescape punctuations
//  2. resolve numeric references
//  3. resolve entity references
//
// URL encoded values (%xx) are kept as is.
func URLEscape(v []byte, resolveReference bool) []byte {
	if resolveReference {
		v = UnescapePunctuations(v)
		v = ResolveNumericReferences(v)
		v = ResolveEntityNames(v)
	}
	cob := NewCopyOnWriteBuffer(v)
	limit := len(v)
	n := 0

	for i := 0; i < limit; {
		c := v[i]
		if urlEscapeTable[c] == 1 {
			i++
			continue
		}
		if c == '%' && i+2 < limit && IsHexDecimal(v[i+1]) && IsHexDecimal(v[i+1]) {
			i += 3
			continue
		}
		u8len := utf8lenTable[c]
		if u8len == 99 { // invalid utf8 leading byte, skip it
			i++
			continue
		}
		if c == ' ' {
			cob.Write(v[n:i])
			cob.Write(htmlSpace)
			i++
			n = i
			continue
		}
		if int(u8len) > len(v) {
			u8len = int8(len(v) - 1)
		}
		if u8len == 0 {
			i++
			n = i
			continue
		}
		cob.Write(v[n:i])
		stop := i + int(u8len)
		if stop > len(v) {
			i++
			n = i
			continue
		}
		cob.Write(StringToReadOnlyBytes(url.QueryEscape(string(v[i:stop]))))
		i += int(u8len)
		n = i
	}
	if cob.IsCopied() && n < limit {
		cob.Write(v[n:])
	}
	return cob.Bytes()
}

// FindURLIndex returns a stop index value if the given bytes seem an URL.
// This function is equivalent to [A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]* .
func FindURLIndex(b []byte) int {
	i := 0
	if !(len(b) > 0 && urlTable[b[i]]&7 == 7) {
		return -1
	}
	i++
	for ; i < len(b); i++ {
		c := b[i]
		if urlTable[c]&4 != 4 {
			break
		}
	}
	if i == 1 || i > 33 || i >= len(b) {
		return -1
	}
	if b[i] != ':' {
		return -1
	}
	i++
	for ; i < len(b); i++ {
		c := b[i]
		if urlTable[c]&1 != 1 {
			break
		}
	}
	return i
}

var emailDomainRegexp = regexp.MustCompile(`^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*`) //nolint:golint,lll

// FindEmailIndex returns a stop index value if the given bytes seem an email address.
func FindEmailIndex(b []byte) int {
	// TODO: eliminate regexps
	i := 0
	for ; i < len(b); i++ {
		c := b[i]
		if emailTable[c]&1 != 1 {
			break
		}
	}
	if i == 0 {
		return -1
	}
	if i >= len(b) || b[i] != '@' {
		return -1
	}
	i++
	if i >= len(b) {
		return -1
	}
	match := emailDomainRegexp.FindSubmatchIndex(b[i:])
	if match == nil {
		return -1
	}
	return i + match[1]
}

var spaces = []byte(" \t\n\x0b\x0c\x0d")

var spaceTable = [256]int8{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} //nolint:golint,lll

var punctTable = [256]int8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} //nolint:golint,lll

// a-zA-Z0-9, ;/?:@&=+$,-_.!~*'()#

var urlEscapeTable = [256]int8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} //nolint:golint,lll

var utf8lenTable = [256]int8{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 99, 99, 99, 99, 99, 99, 99, 99} //nolint:golint,lll

var urlTable = [256]uint8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 5, 5, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 0, 1, 0, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1} //nolint:golint,lll

var emailTable = [256]uint8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} //nolint:golint,lll

// UTF8Len returns a byte length of the utf-8 character.
func UTF8Len(b byte) int8 {
	return utf8lenTable[b]
}

// IsPunct returns true if the given character is a punctuation, otherwise false.
func IsPunct(c byte) bool {
	return punctTable[c] == 1
}

// IsPunctRune returns true if the given rune is a punctuation, otherwise false.
func IsPunctRune(r rune) bool {
	return unicode.IsSymbol(r) || unicode.IsPunct(r)
}

// IsSpace returns true if the given character is a space, otherwise false.
func IsSpace(c byte) bool {
	return spaceTable[c] == 1
}

// IsSpaceRune returns true if the given rune is a space, otherwise false.
func IsSpaceRune(r rune) bool {
	return int32(r) <= 256 && IsSpace(byte(r)) || unicode.IsSpace(r)
}

// IsNumeric returns true if the given character is a numeric, otherwise false.
func IsNumeric(c byte) bool {
	return c >= '0' && c <= '9'
}

// IsHexDecimal returns true if the given character is a hexdecimal, otherwise false.
func IsHexDecimal(c byte) bool {
	return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F'
}

// IsAlphaNumeric returns true if the given character is a alphabet or a numeric, otherwise false.
func IsAlphaNumeric(c byte) bool {
	return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9'
}

// A BufWriter is a subset of the bufio.Writer .
type BufWriter interface {
	io.Writer
	Available() int
	Buffered() int
	Flush() error
	WriteByte(c byte) error
	WriteRune(r rune) (size int, err error)
	WriteString(s string) (int, error)
}

// A PrioritizedValue struct holds pair of an arbitrary value and a priority.
type PrioritizedValue struct {
	// Value is an arbitrary value that you want to prioritize.
	Value interface{}
	// Priority is a priority of the value.
	Priority int
}

// PrioritizedSlice is a slice of the PrioritizedValues.
type PrioritizedSlice []PrioritizedValue

// Sort sorts the PrioritizedSlice in ascending order.
func (s PrioritizedSlice) Sort() {
	sort.Slice(s, func(i, j int) bool {
		return s[i].Priority < s[j].Priority
	})
}

// Remove removes the given value from this slice.
func (s PrioritizedSlice) Remove(v interface{}) PrioritizedSlice {
	i := 0
	found := false
	for ; i < len(s); i++ {
		if s[i].Value == v {
			found = true
			break
		}
	}
	if !found {
		return s
	}
	return append(s[:i], s[i+1:]...)
}

// Prioritized returns a new PrioritizedValue.
func Prioritized(v interface{}, priority int) PrioritizedValue {
	return PrioritizedValue{v, priority}
}

func bytesHash(b []byte) uint64 {
	var hash uint64 = 5381
	for _, c := range b {
		hash = ((hash << 5) + hash) + uint64(c)
	}
	return hash
}

// BytesFilter is a efficient data structure for checking whether bytes exist or not.
// BytesFilter is thread-safe.
type BytesFilter interface {
	// Add adds given bytes to this set.
	Add([]byte)

	// Contains return true if this set contains given bytes, otherwise false.
	Contains([]byte) bool

	// Extend copies this filter and adds given bytes to new filter.
	Extend(...[]byte) BytesFilter

	// ExtendString copies this filter and adds given bytes to new filter.
	// Given string must be separated by a comma.
	ExtendString(string) BytesFilter
}

type bytesFilter struct {
	chars     [256]uint8
	threshold int
	slots     [][][]byte
}

// NewBytesFilter returns a new BytesFilter.
func NewBytesFilter(elements ...[]byte) BytesFilter {
	s := &bytesFilter{
		threshold: 3,
		slots:     make([][][]byte, 64),
	}
	for _, element := range elements {
		s.Add(element)
	}
	return s
}

// NewBytesFilterString returns a new BytesFilter.
// Given string must be separated by a comma.
func NewBytesFilterString(elements string) BytesFilter {
	s := &bytesFilter{
		threshold: 3,
		slots:     make([][][]byte, 64),
	}
	start := 0
	for i := 0; i < len(elements); i++ {
		if elements[i] == ',' {
			s.Add(StringToReadOnlyBytes(elements[start:i]))
			start = i + 1
		}
	}
	if start < len(elements) {
		s.Add(StringToReadOnlyBytes(elements[start:]))
	}
	return s

}

func (s *bytesFilter) Add(b []byte) {
	l := len(b)
	m := s.threshold
	if l < s.threshold {
		m = l
	}
	for i := 0; i < m; i++ {
		s.chars[b[i]] |= 1 << uint8(i)
	}
	h := bytesHash(b) % uint64(len(s.slots))
	slot := s.slots[h]
	if slot == nil {
		slot = [][]byte{}
	}
	s.slots[h] = append(slot, b)
}

func (s *bytesFilter) Extend(bs ...[]byte) BytesFilter {
	newFilter := NewBytesFilter().(*bytesFilter)
	newFilter.chars = s.chars
	newFilter.threshold = s.threshold
	for k, v := range s.slots {
		newSlot := make([][]byte, len(v))
		copy(newSlot, v)
		newFilter.slots[k] = v
	}
	for _, b := range bs {
		newFilter.Add(b)
	}
	return newFilter
}

func (s *bytesFilter) ExtendString(elements string) BytesFilter {
	newFilter := NewBytesFilter().(*bytesFilter)
	newFilter.chars = s.chars
	newFilter.threshold = s.threshold
	for k, v := range s.slots {
		newSlot := make([][]byte, len(v))
		copy(newSlot, v)
		newFilter.slots[k] = v
	}
	start := 0
	for i := 0; i < len(elements); i++ {
		if elements[i] == ',' {
			newFilter.Add(StringToReadOnlyBytes(elements[start:i]))
			start = i + 1
		}
	}
	if start < len(elements) {
		newFilter.Add(StringToReadOnlyBytes(elements[start:]))
	}
	return newFilter
}

func (s *bytesFilter) Contains(b []byte) bool {
	l := len(b)
	m := s.threshold
	if l < s.threshold {
		m = l
	}
	for i := 0; i < m; i++ {
		if (s.chars[b[i]] & (1 << uint8(i))) == 0 {
			return false
		}
	}
	h := bytesHash(b) % uint64(len(s.slots))
	slot := s.slots[h]
	if len(slot) == 0 {
		return false
	}
	for _, element := range slot {
		if bytes.Equal(element, b) {
			return true
		}
	}
	return false
}
</file>

<file path="parser/parser.go">
// Package parser contains stuff that are related to parsing a Markdown text.
package parser

import (
	"fmt"
	"strings"
	"sync"

	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
)

// A Reference interface represents a link reference in Markdown text.
type Reference interface {
	// String implements Stringer.
	String() string

	// Label returns a label of the reference.
	Label() []byte

	// Destination returns a destination(URL) of the reference.
	Destination() []byte

	// Title returns a title of the reference.
	Title() []byte
}

type reference struct {
	label       []byte
	destination []byte
	title       []byte
}

// NewReference returns a new Reference.
func NewReference(label, destination, title []byte) Reference {
	return &reference{label, destination, title}
}

func (r *reference) Label() []byte {
	return r.label
}

func (r *reference) Destination() []byte {
	return r.destination
}

func (r *reference) Title() []byte {
	return r.title
}

func (r *reference) String() string {
	return fmt.Sprintf("Reference{Label:%s, Destination:%s, Title:%s}", r.label, r.destination, r.title)
}

// An IDs interface is a collection of the element ids.
type IDs interface {
	// Generate generates a new element id.
	Generate(value []byte, kind ast.NodeKind) []byte

	// Put puts a given element id to the used ids table.
	Put(value []byte)
}

type ids struct {
	values map[string]bool
}

func newIDs() IDs {
	return &ids{
		values: map[string]bool{},
	}
}

func (s *ids) Generate(value []byte, kind ast.NodeKind) []byte {
	value = util.TrimLeftSpace(value)
	value = util.TrimRightSpace(value)
	result := []byte{}
	for i := 0; i < len(value); {
		v := value[i]
		l := util.UTF8Len(v)
		i += int(l)
		if l != 1 {
			continue
		}
		if util.IsAlphaNumeric(v) {
			if 'A' <= v && v <= 'Z' {
				v += 'a' - 'A'
			}
			result = append(result, v)
		} else if util.IsSpace(v) || v == '-' || v == '_' {
			result = append(result, '-')
		}
	}
	if len(result) == 0 {
		if kind == ast.KindHeading {
			result = []byte("heading")
		} else {
			result = []byte("id")
		}
	}
	if _, ok := s.values[util.BytesToReadOnlyString(result)]; !ok {
		s.values[util.BytesToReadOnlyString(result)] = true
		return result
	}
	for i := 1; ; i++ {
		newResult := fmt.Sprintf("%s-%d", result, i)
		if _, ok := s.values[newResult]; !ok {
			s.values[newResult] = true
			return []byte(newResult)
		}

	}
}

func (s *ids) Put(value []byte) {
	s.values[util.BytesToReadOnlyString(value)] = true
}

// ContextKey is a key that is used to set arbitrary values to the context.
type ContextKey int

// ContextKeyMax is a maximum value of the ContextKey.
var ContextKeyMax ContextKey

// NewContextKey return a new ContextKey value.
func NewContextKey() ContextKey {
	ContextKeyMax++
	return ContextKeyMax
}

// A Context interface holds a information that are necessary to parse
// Markdown text.
type Context interface {
	// String implements Stringer.
	String() string

	// Get returns a value associated with the given key.
	Get(ContextKey) interface{}

	// ComputeIfAbsent computes a value if a value associated with the given key is absent and returns the value.
	ComputeIfAbsent(ContextKey, func() interface{}) interface{}

	// Set sets the given value to the context.
	Set(ContextKey, interface{})

	// AddReference adds the given reference to this context.
	AddReference(Reference)

	// Reference returns (a reference, true) if a reference associated with
	// the given label exists, otherwise (nil, false).
	Reference(label string) (Reference, bool)

	// References returns a list of references.
	References() []Reference

	// IDs returns a collection of the element ids.
	IDs() IDs

	// BlockOffset returns a first non-space character position on current line.
	// This value is valid only for BlockParser.Open.
	// BlockOffset returns -1 if current line is blank.
	BlockOffset() int

	// BlockOffset sets a first non-space character position on current line.
	// This value is valid only for BlockParser.Open.
	SetBlockOffset(int)

	// BlockIndent returns an indent width on current line.
	// This value is valid only for BlockParser.Open.
	// BlockIndent returns -1 if current line is blank.
	BlockIndent() int

	// BlockIndent sets an indent width on current line.
	// This value is valid only for BlockParser.Open.
	SetBlockIndent(int)

	// FirstDelimiter returns a first delimiter of the current delimiter list.
	FirstDelimiter() *Delimiter

	// LastDelimiter returns a last delimiter of the current delimiter list.
	LastDelimiter() *Delimiter

	// PushDelimiter appends the given delimiter to the tail of the current
	// delimiter list.
	PushDelimiter(delimiter *Delimiter)

	// RemoveDelimiter removes the given delimiter from the current delimiter list.
	RemoveDelimiter(d *Delimiter)

	// ClearDelimiters clears the current delimiter list.
	ClearDelimiters(bottom ast.Node)

	// OpenedBlocks returns a list of nodes that are currently in parsing.
	OpenedBlocks() []Block

	// SetOpenedBlocks sets a list of nodes that are currently in parsing.
	SetOpenedBlocks([]Block)

	// LastOpenedBlock returns a last node that is currently in parsing.
	LastOpenedBlock() Block

	// IsInLinkLabel returns true if current position seems to be in link label.
	IsInLinkLabel() bool
}

// A ContextConfig struct is a data structure that holds configuration of the Context.
type ContextConfig struct {
	IDs IDs
}

// An ContextOption is a functional option type for the Context.
type ContextOption func(*ContextConfig)

// WithIDs is a functional option for the Context.
func WithIDs(ids IDs) ContextOption {
	return func(c *ContextConfig) {
		c.IDs = ids
	}
}

type parseContext struct {
	store         []interface{}
	ids           IDs
	refs          map[string]Reference
	blockOffset   int
	blockIndent   int
	delimiters    *Delimiter
	lastDelimiter *Delimiter
	openedBlocks  []Block
}

// NewContext returns a new Context.
func NewContext(options ...ContextOption) Context {
	cfg := &ContextConfig{
		IDs: newIDs(),
	}
	for _, option := range options {
		option(cfg)
	}

	return &parseContext{
		store:         make([]interface{}, ContextKeyMax+1),
		refs:          map[string]Reference{},
		ids:           cfg.IDs,
		blockOffset:   -1,
		blockIndent:   -1,
		delimiters:    nil,
		lastDelimiter: nil,
		openedBlocks:  []Block{},
	}
}

func (p *parseContext) Get(key ContextKey) interface{} {
	return p.store[key]
}

func (p *parseContext) ComputeIfAbsent(key ContextKey, f func() interface{}) interface{} {
	v := p.store[key]
	if v == nil {
		v = f()
		p.store[key] = v
	}
	return v
}

func (p *parseContext) Set(key ContextKey, value interface{}) {
	p.store[key] = value
}

func (p *parseContext) IDs() IDs {
	return p.ids
}

func (p *parseContext) BlockOffset() int {
	return p.blockOffset
}

func (p *parseContext) SetBlockOffset(v int) {
	p.blockOffset = v
}

func (p *parseContext) BlockIndent() int {
	return p.blockIndent
}

func (p *parseContext) SetBlockIndent(v int) {
	p.blockIndent = v
}

func (p *parseContext) LastDelimiter() *Delimiter {
	return p.lastDelimiter
}

func (p *parseContext) FirstDelimiter() *Delimiter {
	return p.delimiters
}

func (p *parseContext) PushDelimiter(d *Delimiter) {
	if p.delimiters == nil {
		p.delimiters = d
		p.lastDelimiter = d
	} else {
		l := p.lastDelimiter
		p.lastDelimiter = d
		l.NextDelimiter = d
		d.PreviousDelimiter = l
	}
}

func (p *parseContext) RemoveDelimiter(d *Delimiter) {
	if d.PreviousDelimiter == nil {
		p.delimiters = d.NextDelimiter
	} else {
		d.PreviousDelimiter.NextDelimiter = d.NextDelimiter
		if d.NextDelimiter != nil {
			d.NextDelimiter.PreviousDelimiter = d.PreviousDelimiter
		}
	}
	if d.NextDelimiter == nil {
		p.lastDelimiter = d.PreviousDelimiter
	}
	if p.delimiters != nil {
		p.delimiters.PreviousDelimiter = nil
	}
	if p.lastDelimiter != nil {
		p.lastDelimiter.NextDelimiter = nil
	}
	d.NextDelimiter = nil
	d.PreviousDelimiter = nil
	if d.Length != 0 {
		ast.MergeOrReplaceTextSegment(d.Parent(), d, d.Segment)
	} else {
		d.Parent().RemoveChild(d.Parent(), d)
	}
}

func (p *parseContext) ClearDelimiters(bottom ast.Node) {
	if p.lastDelimiter == nil {
		return
	}
	var c ast.Node
	for c = p.lastDelimiter; c != nil && c != bottom; {
		prev := c.PreviousSibling()
		if d, ok := c.(*Delimiter); ok {
			p.RemoveDelimiter(d)
		}
		c = prev
	}
}

func (p *parseContext) AddReference(ref Reference) {
	key := util.ToLinkReference(ref.Label())
	if _, ok := p.refs[key]; !ok {
		p.refs[key] = ref
	}
}

func (p *parseContext) Reference(label string) (Reference, bool) {
	v, ok := p.refs[label]
	return v, ok
}

func (p *parseContext) References() []Reference {
	ret := make([]Reference, 0, len(p.refs))
	for _, v := range p.refs {
		ret = append(ret, v)
	}
	return ret
}

func (p *parseContext) String() string {
	refs := []string{}
	for _, r := range p.refs {
		refs = append(refs, r.String())
	}

	return fmt.Sprintf("Context{Store:%#v, Refs:%s}", p.store, strings.Join(refs, ","))
}

func (p *parseContext) OpenedBlocks() []Block {
	return p.openedBlocks
}

func (p *parseContext) SetOpenedBlocks(v []Block) {
	p.openedBlocks = v
}

func (p *parseContext) LastOpenedBlock() Block {
	if l := len(p.openedBlocks); l != 0 {
		return p.openedBlocks[l-1]
	}
	return Block{}
}

func (p *parseContext) IsInLinkLabel() bool {
	tlist := p.Get(linkLabelStateKey)
	return tlist != nil
}

// State represents parser's state.
// State is designed to use as a bit flag.
type State int

const (
	// None is a default value of the [State].
	None State = 1 << iota

	// Continue indicates parser can continue parsing.
	Continue

	// Close indicates parser cannot parse anymore.
	Close

	// HasChildren indicates parser may have child blocks.
	HasChildren

	// NoChildren indicates parser does not have child blocks.
	NoChildren

	// RequireParagraph indicates parser requires that the last node
	// must be a paragraph and is not converted to other nodes by
	// ParagraphTransformers.
	RequireParagraph
)

// A Config struct is a data structure that holds configuration of the Parser.
type Config struct {
	Options               map[OptionName]interface{}
	BlockParsers          util.PrioritizedSlice /*<BlockParser>*/
	InlineParsers         util.PrioritizedSlice /*<InlineParser>*/
	ParagraphTransformers util.PrioritizedSlice /*<ParagraphTransformer>*/
	ASTTransformers       util.PrioritizedSlice /*<ASTTransformer>*/
	EscapedSpace          bool
}

// NewConfig returns a new Config.
func NewConfig() *Config {
	return &Config{
		Options:               map[OptionName]interface{}{},
		BlockParsers:          util.PrioritizedSlice{},
		InlineParsers:         util.PrioritizedSlice{},
		ParagraphTransformers: util.PrioritizedSlice{},
		ASTTransformers:       util.PrioritizedSlice{},
	}
}

// An Option interface is a functional option type for the Parser.
type Option interface {
	SetParserOption(*Config)
}

// OptionName is a name of parser options.
type OptionName string

// Attribute is an option name that spacify attributes of elements.
const optAttribute OptionName = "Attribute"

type withAttribute struct {
}

func (o *withAttribute) SetParserOption(c *Config) {
	c.Options[optAttribute] = true
}

// WithAttribute is a functional option that enables custom attributes.
func WithAttribute() Option {
	return &withAttribute{}
}

// A Parser interface parses Markdown text into AST nodes.
type Parser interface {
	// Parse parses the given Markdown text into AST nodes.
	Parse(reader text.Reader, opts ...ParseOption) ast.Node

	// AddOption adds the given option to this parser.
	AddOptions(...Option)
}

// A SetOptioner interface sets the given option to the object.
type SetOptioner interface {
	// SetOption sets the given option to the object.
	// Unacceptable options may be passed.
	// Thus implementations must ignore unacceptable options.
	SetOption(name OptionName, value interface{})
}

// A BlockParser interface parses a block level element like Paragraph, List,
// Blockquote etc.
type BlockParser interface {
	// Trigger returns a list of characters that triggers Parse method of
	// this parser.
	// If Trigger returns a nil, Open will be called with any lines.
	Trigger() []byte

	// Open parses the current line and returns a result of parsing.
	//
	// Open must not parse beyond the current line.
	// If Open has been able to parse the current line, Open must advance a reader
	// position by consumed byte length.
	//
	// If Open has not been able to parse the current line, Open should returns
	// (nil, NoChildren). If Open has been able to parse the current line, Open
	// should returns a new Block node and returns HasChildren or NoChildren.
	Open(parent ast.Node, reader text.Reader, pc Context) (ast.Node, State)

	// Continue parses the current line and returns a result of parsing.
	//
	// Continue must not parse beyond the current line.
	// If Continue has been able to parse the current line, Continue must advance
	// a reader position by consumed byte length.
	//
	// If Continue has not been able to parse the current line, Continue should
	// returns Close. If Continue has been able to parse the current line,
	// Continue should returns (Continue | NoChildren) or
	// (Continue | HasChildren)
	Continue(node ast.Node, reader text.Reader, pc Context) State

	// Close will be called when the parser returns Close.
	Close(node ast.Node, reader text.Reader, pc Context)

	// CanInterruptParagraph returns true if the parser can interrupt paragraphs,
	// otherwise false.
	CanInterruptParagraph() bool

	// CanAcceptIndentedLine returns true if the parser can open new node when
	// the given line is being indented more than 3 spaces.
	CanAcceptIndentedLine() bool
}

// An InlineParser interface parses an inline level element like CodeSpan, Link etc.
type InlineParser interface {
	// Trigger returns a list of characters that triggers Parse method of
	// this parser.
	// Trigger characters must be a punctuation or a halfspace.
	// Halfspaces triggers this parser when character is any spaces characters or
	// a head of line
	Trigger() []byte

	// Parse parse the given block into an inline node.
	//
	// Parse can parse beyond the current line.
	// If Parse has been able to parse the current line, it must advance a reader
	// position by consumed byte length.
	Parse(parent ast.Node, block text.Reader, pc Context) ast.Node
}

// A CloseBlocker interface is a callback function that will be
// called when block is closed in the inline parsing.
type CloseBlocker interface {
	// CloseBlock will be called when a block is closed.
	CloseBlock(parent ast.Node, block text.Reader, pc Context)
}

// A ParagraphTransformer transforms parsed Paragraph nodes.
// For example, link references are searched in parsed Paragraphs.
type ParagraphTransformer interface {
	// Transform transforms the given paragraph.
	Transform(node *ast.Paragraph, reader text.Reader, pc Context)
}

// ASTTransformer transforms entire Markdown document AST tree.
type ASTTransformer interface {
	// Transform transforms the given AST tree.
	Transform(node *ast.Document, reader text.Reader, pc Context)
}

// DefaultBlockParsers returns a new list of default BlockParsers.
// Priorities of default BlockParsers are:
//
//	SetextHeadingParser, 100
//	ThematicBreakParser, 200
//	ListParser, 300
//	ListItemParser, 400
//	CodeBlockParser, 500
//	ATXHeadingParser, 600
//	FencedCodeBlockParser, 700
//	BlockquoteParser, 800
//	HTMLBlockParser, 900
//	ParagraphParser, 1000
func DefaultBlockParsers() []util.PrioritizedValue {
	return []util.PrioritizedValue{
		util.Prioritized(NewSetextHeadingParser(), 100),
		util.Prioritized(NewThematicBreakParser(), 200),
		util.Prioritized(NewListParser(), 300),
		util.Prioritized(NewListItemParser(), 400),
		util.Prioritized(NewCodeBlockParser(), 500),
		util.Prioritized(NewATXHeadingParser(), 600),
		util.Prioritized(NewFencedCodeBlockParser(), 700),
		util.Prioritized(NewBlockquoteParser(), 800),
		util.Prioritized(NewHTMLBlockParser(), 900),
		util.Prioritized(NewParagraphParser(), 1000),
	}
}

// DefaultInlineParsers returns a new list of default InlineParsers.
// Priorities of default InlineParsers are:
//
//	CodeSpanParser, 100
//	LinkParser, 200
//	AutoLinkParser, 300
//	RawHTMLParser, 400
//	EmphasisParser, 500
func DefaultInlineParsers() []util.PrioritizedValue {
	return []util.PrioritizedValue{
		util.Prioritized(NewCodeSpanParser(), 100),
		util.Prioritized(NewLinkParser(), 200),
		util.Prioritized(NewAutoLinkParser(), 300),
		util.Prioritized(NewRawHTMLParser(), 400),
		util.Prioritized(NewEmphasisParser(), 500),
	}
}

// DefaultParagraphTransformers returns a new list of default ParagraphTransformers.
// Priorities of default ParagraphTransformers are:
//
//	LinkReferenceParagraphTransformer, 100
func DefaultParagraphTransformers() []util.PrioritizedValue {
	return []util.PrioritizedValue{
		util.Prioritized(LinkReferenceParagraphTransformer, 100),
	}
}

// A Block struct holds a node and correspond parser pair.
type Block struct {
	// Node is a BlockNode.
	Node ast.Node
	// Parser is a BlockParser.
	Parser BlockParser
}

type parser struct {
	options               map[OptionName]interface{}
	blockParsers          [256][]BlockParser
	freeBlockParsers      []BlockParser
	inlineParsers         [256][]InlineParser
	closeBlockers         []CloseBlocker
	paragraphTransformers []ParagraphTransformer
	astTransformers       []ASTTransformer
	escapedSpace          bool
	config                *Config
	initSync              sync.Once
}

type withBlockParsers struct {
	value []util.PrioritizedValue
}

func (o *withBlockParsers) SetParserOption(c *Config) {
	c.BlockParsers = append(c.BlockParsers, o.value...)
}

// WithBlockParsers is a functional option that allow you to add
// BlockParsers to the parser.
func WithBlockParsers(bs ...util.PrioritizedValue) Option {
	return &withBlockParsers{bs}
}

type withInlineParsers struct {
	value []util.PrioritizedValue
}

func (o *withInlineParsers) SetParserOption(c *Config) {
	c.InlineParsers = append(c.InlineParsers, o.value...)
}

// WithInlineParsers is a functional option that allow you to add
// InlineParsers to the parser.
func WithInlineParsers(bs ...util.PrioritizedValue) Option {
	return &withInlineParsers{bs}
}

type withParagraphTransformers struct {
	value []util.PrioritizedValue
}

func (o *withParagraphTransformers) SetParserOption(c *Config) {
	c.ParagraphTransformers = append(c.ParagraphTransformers, o.value...)
}

// WithParagraphTransformers is a functional option that allow you to add
// ParagraphTransformers to the parser.
func WithParagraphTransformers(ps ...util.PrioritizedValue) Option {
	return &withParagraphTransformers{ps}
}

type withASTTransformers struct {
	value []util.PrioritizedValue
}

func (o *withASTTransformers) SetParserOption(c *Config) {
	c.ASTTransformers = append(c.ASTTransformers, o.value...)
}

// WithASTTransformers is a functional option that allow you to add
// ASTTransformers to the parser.
func WithASTTransformers(ps ...util.PrioritizedValue) Option {
	return &withASTTransformers{ps}
}

type withEscapedSpace struct {
}

func (o *withEscapedSpace) SetParserOption(c *Config) {
	c.EscapedSpace = true
}

// WithEscapedSpace is a functional option indicates that a '\' escaped half-space(0x20) should not trigger parsers.
func WithEscapedSpace() Option {
	return &withEscapedSpace{}
}

type withOption struct {
	name  OptionName
	value interface{}
}

func (o *withOption) SetParserOption(c *Config) {
	c.Options[o.name] = o.value
}

// WithOption is a functional option that allow you to set
// an arbitrary option to the parser.
func WithOption(name OptionName, value interface{}) Option {
	return &withOption{name, value}
}

// NewParser returns a new Parser with given options.
func NewParser(options ...Option) Parser {
	config := NewConfig()
	for _, opt := range options {
		opt.SetParserOption(config)
	}

	p := &parser{
		options: map[OptionName]interface{}{},
		config:  config,
	}

	return p
}

func (p *parser) AddOptions(opts ...Option) {
	for _, opt := range opts {
		opt.SetParserOption(p.config)
	}
}

func (p *parser) addBlockParser(v util.PrioritizedValue, options map[OptionName]interface{}) {
	bp, ok := v.Value.(BlockParser)
	if !ok {
		panic(fmt.Sprintf("%v is not a BlockParser", v.Value))
	}
	tcs := bp.Trigger()
	so, ok := v.Value.(SetOptioner)
	if ok {
		for oname, ovalue := range options {
			so.SetOption(oname, ovalue)
		}
	}
	if tcs == nil {
		p.freeBlockParsers = append(p.freeBlockParsers, bp)
	} else {
		for _, tc := range tcs {
			if p.blockParsers[tc] == nil {
				p.blockParsers[tc] = []BlockParser{}
			}
			p.blockParsers[tc] = append(p.blockParsers[tc], bp)
		}
	}
}

func (p *parser) addInlineParser(v util.PrioritizedValue, options map[OptionName]interface{}) {
	ip, ok := v.Value.(InlineParser)
	if !ok {
		panic(fmt.Sprintf("%v is not a InlineParser", v.Value))
	}
	tcs := ip.Trigger()
	so, ok := v.Value.(SetOptioner)
	if ok {
		for oname, ovalue := range options {
			so.SetOption(oname, ovalue)
		}
	}
	if cb, ok := ip.(CloseBlocker); ok {
		p.closeBlockers = append(p.closeBlockers, cb)
	}
	for _, tc := range tcs {
		if p.inlineParsers[tc] == nil {
			p.inlineParsers[tc] = []InlineParser{}
		}
		p.inlineParsers[tc] = append(p.inlineParsers[tc], ip)
	}
}

func (p *parser) addParagraphTransformer(v util.PrioritizedValue, options map[OptionName]interface{}) {
	pt, ok := v.Value.(ParagraphTransformer)
	if !ok {
		panic(fmt.Sprintf("%v is not a ParagraphTransformer", v.Value))
	}
	so, ok := v.Value.(SetOptioner)
	if ok {
		for oname, ovalue := range options {
			so.SetOption(oname, ovalue)
		}
	}
	p.paragraphTransformers = append(p.paragraphTransformers, pt)
}

func (p *parser) addASTTransformer(v util.PrioritizedValue, options map[OptionName]interface{}) {
	at, ok := v.Value.(ASTTransformer)
	if !ok {
		panic(fmt.Sprintf("%v is not a ASTTransformer", v.Value))
	}
	so, ok := v.Value.(SetOptioner)
	if ok {
		for oname, ovalue := range options {
			so.SetOption(oname, ovalue)
		}
	}
	p.astTransformers = append(p.astTransformers, at)
}

// A ParseConfig struct is a data structure that holds configuration of the Parser.Parse.
type ParseConfig struct {
	Context Context
}

// A ParseOption is a functional option type for the Parser.Parse.
type ParseOption func(c *ParseConfig)

// WithContext is a functional option that allow you to override
// a default context.
func WithContext(context Context) ParseOption {
	return func(c *ParseConfig) {
		c.Context = context
	}
}

func (p *parser) Parse(reader text.Reader, opts ...ParseOption) ast.Node {
	p.initSync.Do(func() {
		p.config.BlockParsers.Sort()
		for _, v := range p.config.BlockParsers {
			p.addBlockParser(v, p.config.Options)
		}
		for i := range p.blockParsers {
			if p.blockParsers[i] != nil {
				p.blockParsers[i] = append(p.blockParsers[i], p.freeBlockParsers...)
			}
		}

		p.config.InlineParsers.Sort()
		for _, v := range p.config.InlineParsers {
			p.addInlineParser(v, p.config.Options)
		}
		p.config.ParagraphTransformers.Sort()
		for _, v := range p.config.ParagraphTransformers {
			p.addParagraphTransformer(v, p.config.Options)
		}
		p.config.ASTTransformers.Sort()
		for _, v := range p.config.ASTTransformers {
			p.addASTTransformer(v, p.config.Options)
		}
		p.escapedSpace = p.config.EscapedSpace
		p.config = nil
	})
	c := &ParseConfig{}
	for _, opt := range opts {
		opt(c)
	}
	if c.Context == nil {
		c.Context = NewContext()
	}
	pc := c.Context
	root := ast.NewDocument()
	p.parseBlocks(root, reader, pc)

	blockReader := text.NewBlockReader(reader.Source(), nil)
	p.walkBlock(root, func(node ast.Node) {
		p.parseBlock(blockReader, node, pc)
	})
	for _, at := range p.astTransformers {
		at.Transform(root, reader, pc)
	}

	// root.Dump(reader.Source(), 0)
	return root
}

func (p *parser) transformParagraph(node *ast.Paragraph, reader text.Reader, pc Context) bool {
	for _, pt := range p.paragraphTransformers {
		pt.Transform(node, reader, pc)
		if node.Parent() == nil {
			return true
		}
	}
	return false
}

func (p *parser) closeBlocks(from, to int, reader text.Reader, pc Context) {
	blocks := pc.OpenedBlocks()
	for i := from; i >= to; i-- {
		node := blocks[i].Node
		paragraph, ok := node.(*ast.Paragraph)
		if ok && node.Parent() != nil {
			p.transformParagraph(paragraph, reader, pc)
		}
		if node.Parent() != nil { // closes only if node has not been transformed
			blocks[i].Parser.Close(blocks[i].Node, reader, pc)
		}
	}
	if from == len(blocks)-1 {
		blocks = blocks[0:to]
	} else {
		blocks = append(blocks[0:to], blocks[from+1:]...)
	}
	pc.SetOpenedBlocks(blocks)
}

type blockOpenResult int

const (
	paragraphContinuation blockOpenResult = iota + 1
	newBlocksOpened
	noBlocksOpened
)

func (p *parser) openBlocks(parent ast.Node, blankLine bool, reader text.Reader, pc Context) blockOpenResult {
	result := blockOpenResult(noBlocksOpened)
	continuable := false
	lastBlock := pc.LastOpenedBlock()
	if lastBlock.Node != nil {
		continuable = ast.IsParagraph(lastBlock.Node)
	}
retry:
	var bps []BlockParser
	line, _ := reader.PeekLine()
	w, pos := util.IndentWidth(line, reader.LineOffset())
	if w >= len(line) {
		pc.SetBlockOffset(-1)
		pc.SetBlockIndent(-1)
	} else {
		pc.SetBlockOffset(pos)
		pc.SetBlockIndent(w)
	}
	if line == nil || line[0] == '\n' {
		goto continuable
	}
	bps = p.freeBlockParsers
	if pos < len(line) {
		bps = p.blockParsers[line[pos]]
		if bps == nil {
			bps = p.freeBlockParsers
		}
	}
	if bps == nil {
		goto continuable
	}

	for _, bp := range bps {
		if continuable && result == noBlocksOpened && !bp.CanInterruptParagraph() {
			continue
		}
		if w > 3 && !bp.CanAcceptIndentedLine() {
			continue
		}
		lastBlock = pc.LastOpenedBlock()
		last := lastBlock.Node
		node, state := bp.Open(parent, reader, pc)
		if node != nil {
			// Parser requires last node to be a paragraph.
			// With table extension:
			//
			//     0
			//     -:
			//     -
			//
			// '-' on 3rd line seems a Setext heading because 1st and 2nd lines
			// are being paragraph when the Settext heading parser tries to parse the 3rd
			// line.
			// But 1st line and 2nd line are a table. Thus this paragraph will be transformed
			// by a paragraph transformer. So this text should be converted to a table and
			// an empty list.
			if state&RequireParagraph != 0 {
				if last == parent.LastChild() {
					// Opened paragraph may be transformed by ParagraphTransformers in
					// closeBlocks().
					lastBlock.Parser.Close(last, reader, pc)
					blocks := pc.OpenedBlocks()
					pc.SetOpenedBlocks(blocks[0 : len(blocks)-1])
					if p.transformParagraph(last.(*ast.Paragraph), reader, pc) {
						// Paragraph has been transformed.
						// So this parser is considered as failing.
						continuable = false
						goto retry
					}
				}
			}
			node.SetBlankPreviousLines(blankLine)
			if last != nil && last.Parent() == nil {
				lastPos := len(pc.OpenedBlocks()) - 1
				p.closeBlocks(lastPos, lastPos, reader, pc)
			}
			parent.AppendChild(parent, node)
			result = newBlocksOpened
			be := Block{node, bp}
			pc.SetOpenedBlocks(append(pc.OpenedBlocks(), be))
			if state&HasChildren != 0 {
				parent = node
				goto retry // try child block
			}
			break // no children, can not open more blocks on this line
		}
	}

continuable:
	if result == noBlocksOpened && continuable {
		state := lastBlock.Parser.Continue(lastBlock.Node, reader, pc)
		if state&Continue != 0 {
			result = paragraphContinuation
		}
	}
	return result
}

type lineStat struct {
	lineNum int
	level   int
	isBlank bool
}

func isBlankLine(lineNum, level int, stats []lineStat) bool {
	l := len(stats)
	if l == 0 {
		return true
	}
	for i := l - 1 - level; i >= 0; i-- {
		s := stats[i]
		if s.lineNum == lineNum && s.level <= level {
			return s.isBlank
		} else if s.lineNum < lineNum {
			break
		}
	}
	return false
}

func (p *parser) parseBlocks(parent ast.Node, reader text.Reader, pc Context) {
	pc.SetOpenedBlocks(nil)
	blankLines := make([]lineStat, 0, 128)
	for { // process blocks separated by blank lines
		_, _, ok := reader.SkipBlankLines()
		if !ok {
			return
		}
		// first, we try to open blocks
		if p.openBlocks(parent, true, reader, pc) != newBlocksOpened {
			return
		}
		reader.AdvanceLine()
		blankLines = blankLines[0:0]
		for { // process opened blocks line by line
			openedBlocks := pc.OpenedBlocks()
			l := len(openedBlocks)
			if l == 0 {
				break
			}
			lastIndex := l - 1
			for i := 0; i < l; i++ {
				be := openedBlocks[i]
				line, _ := reader.PeekLine()
				if line == nil {
					p.closeBlocks(lastIndex, 0, reader, pc)
					reader.AdvanceLine()
					return
				}
				lineNum, _ := reader.Position()
				blankLines = append(blankLines, lineStat{lineNum, i, util.IsBlank(line)})
				// If node is a paragraph, p.openBlocks determines whether it is continuable.
				// So we do not process paragraphs here.
				if !ast.IsParagraph(be.Node) {
					state := be.Parser.Continue(be.Node, reader, pc)
					if state&Continue != 0 {
						// When current node is a container block and has no children,
						// we try to open new child nodes
						if state&HasChildren != 0 && i == lastIndex {
							isBlank := isBlankLine(lineNum-1, i+1, blankLines)
							p.openBlocks(be.Node, isBlank, reader, pc)
							break
						}
						continue
					}
				}
				// current node may be closed or lazy continuation
				isBlank := isBlankLine(lineNum-1, i, blankLines)
				thisParent := parent
				if i != 0 {
					thisParent = openedBlocks[i-1].Node
				}
				lastNode := openedBlocks[lastIndex].Node
				result := p.openBlocks(thisParent, isBlank, reader, pc)
				if result != paragraphContinuation {
					// lastNode is a paragraph and was transformed by the paragraph
					// transformers.
					if openedBlocks[lastIndex].Node != lastNode {
						lastIndex--
					}
					p.closeBlocks(lastIndex, i, reader, pc)
				}
				break
			}

			reader.AdvanceLine()
		}
	}
}

func (p *parser) walkBlock(block ast.Node, cb func(node ast.Node)) {
	for c := block.FirstChild(); c != nil; c = c.NextSibling() {
		p.walkBlock(c, cb)
	}
	cb(block)
}

const (
	lineBreakHard uint8 = 1 << iota
	lineBreakSoft
	lineBreakVisible
)

func (p *parser) parseBlock(block text.BlockReader, parent ast.Node, pc Context) {
	if parent.IsRaw() {
		return
	}
	escaped := false
	source := block.Source()
	block.Reset(parent.Lines())
	for {
	retry:
		line, _ := block.PeekLine()
		if line == nil {
			break
		}
		lineLength := len(line)
		var lineBreakFlags uint8
		hasNewLine := line[lineLength-1] == '\n'
		if ((lineLength >= 3 && line[lineLength-2] == '\\' &&
			line[lineLength-3] != '\\') || (lineLength == 2 && line[lineLength-2] == '\\')) && hasNewLine { // ends with \\n
			lineLength -= 2
			lineBreakFlags |= lineBreakHard | lineBreakVisible
		} else if ((lineLength >= 4 && line[lineLength-3] == '\\' && line[lineLength-2] == '\r' &&
			line[lineLength-4] != '\\') || (lineLength == 3 && line[lineLength-3] == '\\' && line[lineLength-2] == '\r')) &&
			hasNewLine { // ends with \\r\n
			lineLength -= 3
			lineBreakFlags |= lineBreakHard | lineBreakVisible
		} else if lineLength >= 3 && line[lineLength-3] == ' ' && line[lineLength-2] == ' ' &&
			hasNewLine { // ends with [space][space]\n
			lineLength -= 3
			lineBreakFlags |= lineBreakHard
		} else if lineLength >= 4 && line[lineLength-4] == ' ' && line[lineLength-3] == ' ' &&
			line[lineLength-2] == '\r' && hasNewLine { // ends with [space][space]\r\n
			lineLength -= 4
			lineBreakFlags |= lineBreakHard
		} else if hasNewLine {
			// If the line ends with a newline character, but it is not a hardlineBreak, then it is a softLinebreak
			// If the line ends with a hardlineBreak, then it cannot end with a softLinebreak
			// See https://spec.commonmark.org/0.30/#soft-line-breaks
			lineBreakFlags |= lineBreakSoft
		}

		l, startPosition := block.Position()
		n := 0
		for i := 0; i < lineLength; i++ {
			c := line[i]
			if c == '\n' {
				break
			}
			isSpace := util.IsSpace(c) && c != '\r' && c != '\n'
			isPunct := util.IsPunct(c)
			if (isPunct && !escaped) || isSpace && !(escaped && p.escapedSpace) || i == 0 {
				parserChar := c
				if isSpace || (i == 0 && !isPunct) {
					parserChar = ' '
				}
				ips := p.inlineParsers[parserChar]
				if ips != nil {
					block.Advance(n)
					n = 0
					savedLine, savedPosition := block.Position()
					if i != 0 {
						_, currentPosition := block.Position()
						ast.MergeOrAppendTextSegment(parent, startPosition.Between(currentPosition))
						_, startPosition = block.Position()
					}
					var inlineNode ast.Node
					for _, ip := range ips {
						inlineNode = ip.Parse(parent, block, pc)
						if inlineNode != nil {
							break
						}
						block.SetPosition(savedLine, savedPosition)
					}
					if inlineNode != nil {
						parent.AppendChild(parent, inlineNode)
						goto retry
					}
				}
			}
			if escaped {
				escaped = false
				n++
				continue
			}

			if c == '\\' {
				escaped = true
				n++
				continue
			}

			escaped = false
			n++
		}
		if n != 0 {
			block.Advance(n)
		}
		currentL, currentPosition := block.Position()
		if l != currentL {
			continue
		}
		diff := startPosition.Between(currentPosition)
		var text *ast.Text
		if lineBreakFlags&(lineBreakHard|lineBreakVisible) == lineBreakHard|lineBreakVisible {
			text = ast.NewTextSegment(diff)
		} else {
			text = ast.NewTextSegment(diff.TrimRightSpace(source))
		}
		text.SetSoftLineBreak(lineBreakFlags&lineBreakSoft != 0)
		text.SetHardLineBreak(lineBreakFlags&lineBreakHard != 0)
		parent.AppendChild(parent, text)
		block.AdvanceLine()
	}

	ProcessDelimiters(nil, pc)
	for _, ip := range p.closeBlockers {
		ip.CloseBlock(parent, block, pc)
	}

}
</file>

<file path="extension/cjk_test.go">
package extension

import (
	"testing"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/testutil"
)

func TestEscapedSpace(t *testing.T) {
	markdown := goldmark.New(goldmark.WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))
	no := 1
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Without spaces around an emphasis started with east asian punctuations, it is not interpreted as an emphasis(as defined in CommonMark spec)",
			Markdown:    "太郎は**「こんにちわ」**と言った\nんです",
			Expected:    "<p>太郎は**「こんにちわ」**と言った\nんです</p>",
		},
		t,
	)

	no = 2
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "With spaces around an emphasis started with east asian punctuations, it is interpreted as an emphasis(but remains unnecessary spaces)",
			Markdown:    "太郎は **「こんにちわ」** と言った\nんです",
			Expected:    "<p>太郎は <strong>「こんにちわ」</strong> と言った\nんです</p>",
		},
		t,
	)

	// Enables EscapedSpace
	markdown = goldmark.New(goldmark.WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	),
		goldmark.WithExtensions(NewCJK(WithEscapedSpace())),
	)

	no = 3
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "With spaces around an emphasis started with east asian punctuations,it is interpreted as an emphasis",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言った\nんです",
			Expected:    "<p>太郎は<strong>「こんにちわ」</strong>と言った\nんです</p>",
		},
		t,
	)

	// ' ' triggers Linkify extension inline parser.
	// Escaped spaces should not trigger the inline parser.

	markdown = goldmark.New(goldmark.WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	),
		goldmark.WithExtensions(
			NewCJK(WithEscapedSpace()),
			Linkify,
		),
	)

	no = 4
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Escaped space and linkfy extension",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言った\nんです",
			Expected:    "<p>太郎は<strong>「こんにちわ」</strong>と言った\nんです</p>",
		},
		t,
	)
}

func TestEastAsianLineBreaks(t *testing.T) {
	markdown := goldmark.New(goldmark.WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	))
	no := 1
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks are rendered as a newline, so some asian users will see it as an unnecessary space",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言った\nんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と言った\nんです</p>",
		},
		t,
	)

	// Enables EastAsianLineBreaks

	markdown = goldmark.New(goldmark.WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	),
		goldmark.WithExtensions(NewCJK(WithEastAsianLineBreaks())),
	)

	no = 2
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks between east asian wide characters are ignored",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言った\nんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と言ったんです</p>",
		},
		t,
	)

	no = 3
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks between western characters are rendered as a newline",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言ったa\nbんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と言ったa\nbんです</p>",
		},
		t,
	)

	no = 4
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks between a western character and an east asian wide character are rendered as a newline",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言ったa\nんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と言ったa\nんです</p>",
		},
		t,
	)

	no = 5
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks between an east asian wide character and a western character are rendered as a newline",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言った\nbんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と言った\nbんです</p>",
		},
		t,
	)

	// WithHardWraps take precedence over WithEastAsianLineBreaks
	markdown = goldmark.New(goldmark.WithRendererOptions(
		html.WithHardWraps(),
		html.WithXHTML(),
		html.WithUnsafe(),
	),
		goldmark.WithExtensions(NewCJK(WithEastAsianLineBreaks())),
	)
	no = 6
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "WithHardWraps take precedence over WithEastAsianLineBreaks",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言った\nんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と言った<br />\nんです</p>",
		},
		t,
	)

	// Tests with EastAsianLineBreaksStyleSimple
	markdown = goldmark.New(goldmark.WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	),
		goldmark.WithExtensions(
			NewCJK(WithEastAsianLineBreaks()),
			Linkify,
		),
	)
	no = 7
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "WithEastAsianLineBreaks and linkfy extension",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言った\r\nんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と言ったんです</p>",
		},
		t,
	)
	no = 8
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks between east asian wide characters or punctuations are ignored",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と、\r\n言った\r\nんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と、言ったんです</p>",
		},
		t,
	)
	no = 9
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks between an east asian wide character and a western character are ignored",
			Markdown:    "私はプログラマーです。\n東京の会社に勤めています。\nGoでWebアプリケーションを開発しています。",
			Expected:    "<p>私はプログラマーです。東京の会社に勤めています。\nGoでWebアプリケーションを開発しています。</p>",
		},
		t,
	)

	// Tests with EastAsianLineBreaksCSS3Draft
	markdown = goldmark.New(goldmark.WithRendererOptions(
		html.WithXHTML(),
		html.WithUnsafe(),
	),
		goldmark.WithExtensions(
			NewCJK(WithEastAsianLineBreaks(EastAsianLineBreaksCSS3Draft)),
		),
	)
	no = 10
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks between a western character and an east asian wide character are ignored",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言ったa\nんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と言ったaんです</p>",
		},
		t,
	)

	no = 11
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks between an east asian wide character and a western character are ignored",
			Markdown:    "太郎は\\ **「こんにちわ」**\\ と言った\nbんです",
			Expected:    "<p>太郎は\\ <strong>「こんにちわ」</strong>\\ と言ったbんです</p>",
		},
		t,
	)

	no = 12
	testutil.DoTestCase(
		markdown,
		testutil.MarkdownTestCase{
			No:          no,
			Description: "Soft line breaks between an east asian wide character and a western character are ignored",
			Markdown:    "私はプログラマーです。\n東京の会社に勤めています。\nGoでWebアプリケーションを開発しています。",
			Expected:    "<p>私はプログラマーです。東京の会社に勤めています。GoでWebアプリケーションを開発しています。</p>",
		},
		t,
	)

}
</file>

<file path="_test/extra.txt">
1
//- - - - - - - - -//
*	A
    B
//- - - - - - - - -//
<ul>
<li>A
B</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//



2
//- - - - - - - - -//
**test**\
test**test**\
**test**test\
test**test**
//- - - - - - - - -//
<p><strong>test</strong><br />
test<strong>test</strong><br />
<strong>test</strong>test<br />
test<strong>test</strong></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



3
//- - - - - - - - -//
>*	>
> 	1
>		2
>3
//- - - - - - - - -//
<blockquote>
<ul>
<li>
<blockquote>
</blockquote>
</li>
</ul>
<p>1
2
3</p>
</blockquote>
//= = = = = = = = = = = = = = = = = = = = = = = =//



4
//- - - - - - - - -//
`test`a`test`
//- - - - - - - - -//
<p><code>test</code>a<code>test</code></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



5
//- - - - - - - - -//
_**TL/DR** - [Go see summary.](#my-summary-area)_
//- - - - - - - - -//
<p><em><strong>TL/DR</strong> - <a href="#my-summary-area">Go see summary.</a></em></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



6
//- - - - - - - - -//
[This link won't be rendered
correctly](https://geeksocket.in/some-long-link-here "This is the
place where everything breaks")
//- - - - - - - - -//
<p><a href="https://geeksocket.in/some-long-link-here" title="This is the
place where everything breaks">This link won't be rendered
correctly</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



7
//- - - - - - - - -//
[](./target.md)
//- - - - - - - - -//
<p><a href="./target.md"></a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



8
//- - - - - - - - -//
[]()
//- - - - - - - - -//
<p><a href=""></a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



9
//- - - - - - - - -//
[daß] is the old german spelling of [dass]

[daß]: www.das-dass.de
//- - - - - - - - -//
<p><a href="www.das-dass.de">daß</a> is the old german spelling of <a href="www.das-dass.de">dass</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



10
//- - - - - - - - -//
1. First step.

   ~~~
   aaa
   ---
   bbb
   ~~~

2. few other steps.
//- - - - - - - - -//
<ol>
<li>
<p>First step.</p>
<pre><code>aaa
---
bbb
</code></pre>
</li>
<li>
<p>few other steps.</p>
</li>
</ol>
//= = = = = = = = = = = = = = = = = = = = = = = =//



11: delimiters between ascii punctuations should be parsed
//- - - - - - - - -//
`{%`_name_`%}`
//- - - - - - - - -//
<p><code>{%</code><em>name</em><code>%}</code></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//



12: the alt attribute of img should be escaped
//- - - - - - - - -//
!["](quot.jpg)
!['](apos.jpg)
![<](lt.jpg)
![>](gt.jpg)
![&](amp.jpg) 
//- - - - - - - - -//
<p><img src="quot.jpg" alt="&quot;" />
<img src="apos.jpg" alt="'" />
<img src="lt.jpg" alt="&lt;" />
<img src="gt.jpg" alt="&gt;" />
<img src="amp.jpg" alt="&amp;" /></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


13: fenced code block starting with tab inside list
//- - - - - - - - -//
* foo
  ```Makefile
  foo
  	foo
  ```
//- - - - - - - - -//
<ul>
<li>foo
<pre><code class="language-Makefile">foo
	foo
</code></pre>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//

14: fenced code block inside list, mismatched tab start
//- - - - - - - - -//
* foo
  ```Makefile
  foo
 	foo
  ```
//- - - - - - - - -//
<ul>
<li>foo
<pre><code class="language-Makefile">foo
  foo
</code></pre>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//


15: fenced code block inside nested list
//- - - - - - - - -//
* foo
  -  bar
     ```Makefile
     foo
     	foo
     ```
//- - - - - - - - -//
<ul>
<li>foo
<ul>
<li>bar
<pre><code class="language-Makefile">foo
	foo
</code></pre>
</li>
</ul>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//

16: indented code block starting with a tab.
//- - - - - - - - -//
* foo
   
      foo
      	foo

//- - - - - - - - -//
<ul>
<li>
<p>foo</p>
<pre><code>foo
	foo
</code></pre>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//

17: fenced code block in list, empty line, spaces on start
//- - - - - - - - -//
* foo
  ```Makefile
  foo
  
  foo
  ```
//- - - - - - - - -//
<ul>
<li>foo
<pre><code class="language-Makefile">foo

foo
</code></pre>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//

18: fenced code block in list, empty line, no spaces on start
//- - - - - - - - -//
* foo
  ```Makefile
  foo

  foo
  ```
//- - - - - - - - -//
<ul>
<li>foo
<pre><code class="language-Makefile">foo

foo
</code></pre>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//


19: fenced code block inside nested list, empty line, spaces on start
//- - - - - - - - -//
* foo
  -  bar
     ```Makefile
     foo

     foo
     ```
//- - - - - - - - -//
<ul>
<li>foo
<ul>
<li>bar
<pre><code class="language-Makefile">foo

foo
</code></pre>
</li>
</ul>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//


20: fenced code block inside nested list, empty line, no space on start
//- - - - - - - - -//
* foo
  -  bar
     ```Makefile
     foo

     foo
     ```
//- - - - - - - - -//
<ul>
<li>foo
<ul>
<li>bar
<pre><code class="language-Makefile">foo

foo
</code></pre>
</li>
</ul>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//

21: Fenced code block within list can start with tab
//- - - - - - - - -//
- List

    ```
    A
    	B
    C
    ```
//- - - - - - - - -//
<ul>
<li>
<p>List</p>
<pre><code>A
	B
C
</code></pre>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//

22: Indented code block within list can start with tab
//- - - - - - - - -//
- List

      A
      	B
      C

a
//- - - - - - - - -//
<ul>
<li>
<p>List</p>
<pre><code>A
	B
C
</code></pre>
</li>
</ul>
<p>a</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

23: Emphasis corner case(yuin/goldmark#245)
//- - - - - - - - -//
a* b c d *e*
//- - - - - - - - -//
<p>a* b c d <em>e</em></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

24: HTML block tags can contain trailing spaces
//- - - - - - - - -//
<aaa >
//- - - - - - - - -//
<aaa >
//= = = = = = = = = = = = = = = = = = = = = = = =//

25: Indented code blocks can start with tab
//- - - - - - - - -//
		x
//- - - - - - - - -//
<pre><code>	x
</code></pre>
//= = = = = = = = = = = = = = = = = = = = = = = =//

26: NUL bytes must be replaced with U+FFFD
    OPTIONS: {"enableEscape": true}
//- - - - - - - - -//
hello\x00world

<?\x00
//- - - - - - - - -//
<p>hello\ufffdworld</p>
<?\uFFFD
//= = = = = = = = = = = = = = = = = = = = = = = =//

27: Newlines in code spans must be preserved as a space
    OPTIONS: {"enableEscape": true}
//- - - - - - - - -//
`\n`

`x\n`

`\nx`
//- - - - - - - - -//
<p><code> </code></p>
<p><code>x </code></p>
<p><code> x</code></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

28: Single # is a heading level 1
//- - - - - - - - -//
#
//- - - - - - - - -//
<h1></h1>
//= = = = = = = = = = = = = = = = = = = = = = = =//

29: An empty list item cannot interrupt a paragraph
//- - - - - - - - -//
x
*
//- - - - - - - - -//
<p>x
*</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

30: A link reference definition followed by a single quote without closer
//- - - - - - - - -//
[x]

[x]: <>
'
//- - - - - - - - -//
<p><a href="">x</a></p>
<p>'</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

31: A link reference definition followed by a double quote without closer
//- - - - - - - - -//
[x]

[x]: <>
"
//- - - - - - - - -//
<p><a href="">x</a></p>
<p>&quot;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


32: Hex character entities must be limited to 6 characters
//- - - - - - - - -//
&#x0000041;
//- - - - - - - - -//
<p>&amp;#x0000041;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

33: \x01 should be escaped all the time
    OPTIONS: {"enableEscape": true}
//- - - - - - - - -//
[x](\x01)
//- - - - - - - - -//
<p><a href="%01">x</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

34: A form feed should not be treated as a space
    OPTIONS: {"enableEscape": true}
//- - - - - - - - -//
x \f
//- - - - - - - - -//
<p>x \f</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

35: A link reference definition can contain a new line
//- - - - - - - - -//
This is a [test][foo
bar] 1...2..3...

[foo bar]: /
//- - - - - - - - -//
<p>This is a <a href="/">test</a> 1...2..3...</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

36: Emphasis and links
//- - - - - - - - -//
_a[b_c_](d)
//- - - - - - - - -//
<p>_a<a href="d">b_c_</a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

37: Tabs and spaces
    OPTIONS: {"enableEscape": true}
//- - - - - - - - -//
\t\t x\n
//- - - - - - - - -//
<pre><code>\t x\n</code></pre>
//= = = = = = = = = = = = = = = = = = = = = = = =//

38: Decimal HTML entity literals should allow 7 digits
//- - - - - - - - -//
&#7654321;
//- - - - - - - - -//
<p>\uFFFD</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

39: Decimal HTML entities should not be interpreted as octal when starting with a 0
//- - - - - - - - -//
&#0100;
//- - - - - - - - -//
<p>d</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

40: Invalid HTML tag names
//- - - - - - - - -//
<1>

<a:>

<a\f>

< p>
//- - - - - - - - -//
<p>&lt;1&gt;</p>
<p>&lt;a:&gt;</p>
<p>&lt;a\f&gt;</p>
<p>&lt; p&gt;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

41: Link references can not contain spaces after link label
//- - - - - - - - -//
[x]
:>

[o] :x
//- - - - - - - - -//
<p>[x]
:&gt;</p>
<p>[o] :x</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

42: Unclosed link reference titles can interrupt link references
//- - - - - - - - -//
[r]:
<>
'

[o]:
x
'
//- - - - - - - - -//
<p>'</p>
<p>'</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

43: A link containing an image containing a link should disable the outer link
//- - - - - - - - -//
[ ![ [b](c) ](x) ](y)
//- - - - - - - - -//
<p>[ <img src="x" alt=" b " /> ](y)</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

44: An empty list item(with trailing spaces) cannot interrupt a paragraph
//- - - - - - - - -//
a
*  
//- - - - - - - - -//
<p>a
*</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

45: Multiple empty list items
//- - - - - - - - -//
-

-
//- - - - - - - - -//
<ul>
<li></li>
<li></li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//

46: Vertical tab should not be treated as spaces
    OPTIONS: {"enableEscape": true}
//- - - - - - - - -//
\v
//- - - - - - - - -//
<p>\v</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

47: Escape back slashes should not be treated as hard line breaks
//- - - - - - - - -//
\\\\
a
//- - - - - - - - -//
<p>\
a</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

48: Multiple paragraphs in tight list
//- - - - - - - - -//
- a
  >
  b
//- - - - - - - - -//
<ul>
<li>a
<blockquote>
</blockquote>
b</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//


49: A list item that is indented up to 3 spaces after an empty list item
//- - - - - - - - -//
1.

   1. b

-

  - b
//- - - - - - - - -//
<ol>
<li></li>
<li>
<p>b</p>
</li>
</ol>
<ul>
<li></li>
<li>
<p>b</p>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//


50: Spaces before a visible hard linebreak should be preserved
//- - - - - - - - -//
a \
b
//- - - - - - - - -//
<p>a <br />
b</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


51: Empty line in a fenced code block under list items
//- - - - - - - - -//
* This is a list item
    ```
    This is a test

    This line will be dropped.
    This line will be displayed.
    ```
//- - - - - - - - -//
<ul>
<li>This is a list item
<pre><code>This is a test

This line will be dropped.
This line will be displayed.
</code></pre>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//


52: windows-style newline and HTMLs
    OPTIONS: {"enableEscape": true}
//- - - - - - - - -//
<a \r\nhref='link'>link</a>

<video autoplay muted loop>\r\n<source src=\"https://example.com/example.mp4\" type=\"video/mp4\">\r\nYour browser does not support the video tag.\r\n</video>
//- - - - - - - - -//
<p><a \r\nhref='link'>link</a></p>
<video autoplay muted loop>\r\n<source src=\"https://example.com/example.mp4\" type=\"video/mp4\">\r\nYour browser does not support the video tag.\r\n</video>
//= = = = = = = = = = = = = = = = = = = = = = = =//


53: HTML comment without trailing new lines
    OPTIONS: {"trim": true}
//- - - - - - - - -//
<!--
-->
//- - - - - - - - -//
<!--
-->
//= = = = = = = = = = = = = = = = = = = = = = = =//


54: Escaped characters followed by a null character
    OPTIONS: {"enableEscape": true}
//- - - - - - - - -//
\\\x00\"
//- - - - - - - - -//
<p>\\\ufffd&quot;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


55: inline HTML comment
//- - - - - - - - -//
a <!-- b --> c

a <!-- b -->
//- - - - - - - - -//
<p>a <!-- b --> c</p>
<p>a <!-- b --></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//


56: An empty list followed by blockquote
//- - - - - - - - -//
1.
> This is a quote.
//- - - - - - - - -//
<ol>
<li></li>
</ol>
<blockquote>
<p>This is a quote.</p>
</blockquote>
//= = = = = = = = = = = = = = = = = = = = = = = =//

57: Tabbed fenced code block within a list
//- - - - - - - - -//
1.
	```
	```
//- - - - - - - - -//
<ol>
<li>
<pre><code></code></pre>
</li>
</ol>
//= = = = = = = = = = = = = = = = = = = = = = = =//


58: HTML end tag without trailing new lines
    OPTIONS: {"trim": true}
//- - - - - - - - -//
<pre>
</pre>
//- - - - - - - - -//
<pre>
</pre>
//= = = = = = = = = = = = = = = = = = = = = = = =//

59: Raw HTML tag with one new line
//- - - - - - - - -//
<img src=./.assets/logo.svg
/>
//- - - - - - - - -//
<p><img src=./.assets/logo.svg
/></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

60: Raw HTML tag with multiple new lines
//- - - - - - - - -//
<img src=./.assets/logo.svg

/>
//- - - - - - - - -//
<p>&lt;img src=./.assets/logo.svg</p>
<p>/&gt;</p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

61: Image alt with a new line
//- - - - - - - - -//
![alt
text](logo.png)
//- - - - - - - - -//
<p><img src="logo.png" alt="alt
text" /></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

62: Image alt with an escaped character 
//- - - - - - - - -//
![\`alt](https://example.com/img.png)
//- - - - - - - - -//
<p><img src="https://example.com/img.png" alt="`alt" /></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

63: Emphasis in link label
//- - - - - - - - -//
[*[a]*](b)
//- - - - - - - - -//
<p><a href="b"><em>[a]</em></a></p>
//= = = = = = = = = = = = = = = = = = = = = = = =//

64: Nested list under an empty list item
//- - - - - - - - -//
- 
  - foo
//- - - - - - - - -//
<ul>
<li>
<ul>
<li>foo</li>
</ul>
</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//

65: Nested fenced code block with tab
//- - - - - - - - -//
>  ```
>	0
>  ```
//- - - - - - - - -//
<blockquote>
<pre><code> 0
</code></pre>
</blockquote>
//= = = = = = = = = = = = = = = = = = = = = = = =//

66: EOF should be rendered as a newline with an unclosed block(w/ TAB)
//- - - - - - - - -//
>  ```
>	0
//- - - - - - - - -//
<blockquote>
<pre><code> 0
</code></pre>
</blockquote>
//= = = = = = = = = = = = = = = = = = = = = = = =//

67: EOF should be rendered as a newline with an unclosed block
//- - - - - - - - -//
>  ```
>   0
//- - - - - - - - -//
<blockquote>
<pre><code> 0
</code></pre>
</blockquote>
//= = = = = = = = = = = = = = = = = = = = = = = =//

68: HTML comments in list items
//- - - - - - - - -//
- test
  <!--
    Test
  -->
- test2
//- - - - - - - - -//
<ul>
<li>test
<!--
  Test
-->
</li>
<li>test2</li>
</ul>
//= = = = = = = = = = = = = = = = = = = = = = = =//
</file>

<file path="renderer/html/html.go">
// Package html implements renderer that outputs HTMLs.
package html

import (
	"bytes"
	"fmt"
	"strconv"
	"unicode"
	"unicode/utf8"

	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/renderer"
	"github.com/yuin/goldmark/util"
)

// A Config struct has configurations for the HTML based renderers.
type Config struct {
	Writer              Writer
	HardWraps           bool
	EastAsianLineBreaks EastAsianLineBreaks
	XHTML               bool
	Unsafe              bool
}

// NewConfig returns a new Config with defaults.
func NewConfig() Config {
	return Config{
		Writer:              DefaultWriter,
		HardWraps:           false,
		EastAsianLineBreaks: EastAsianLineBreaksNone,
		XHTML:               false,
		Unsafe:              false,
	}
}

// SetOption implements renderer.NodeRenderer.SetOption.
func (c *Config) SetOption(name renderer.OptionName, value interface{}) {
	switch name {
	case optHardWraps:
		c.HardWraps = value.(bool)
	case optEastAsianLineBreaks:
		c.EastAsianLineBreaks = value.(EastAsianLineBreaks)
	case optXHTML:
		c.XHTML = value.(bool)
	case optUnsafe:
		c.Unsafe = value.(bool)
	case optTextWriter:
		c.Writer = value.(Writer)
	}
}

// An Option interface sets options for HTML based renderers.
type Option interface {
	SetHTMLOption(*Config)
}

// TextWriter is an option name used in WithWriter.
const optTextWriter renderer.OptionName = "Writer"

type withWriter struct {
	value Writer
}

func (o *withWriter) SetConfig(c *renderer.Config) {
	c.Options[optTextWriter] = o.value
}

func (o *withWriter) SetHTMLOption(c *Config) {
	c.Writer = o.value
}

// WithWriter is a functional option that allow you to set the given writer to
// the renderer.
func WithWriter(writer Writer) interface {
	renderer.Option
	Option
} {
	return &withWriter{writer}
}

// HardWraps is an option name used in WithHardWraps.
const optHardWraps renderer.OptionName = "HardWraps"

type withHardWraps struct {
}

func (o *withHardWraps) SetConfig(c *renderer.Config) {
	c.Options[optHardWraps] = true
}

func (o *withHardWraps) SetHTMLOption(c *Config) {
	c.HardWraps = true
}

// WithHardWraps is a functional option that indicates whether softline breaks
// should be rendered as '<br>'.
func WithHardWraps() interface {
	renderer.Option
	Option
} {
	return &withHardWraps{}
}

// EastAsianLineBreaks is an option name used in WithEastAsianLineBreaks.
const optEastAsianLineBreaks renderer.OptionName = "EastAsianLineBreaks"

// A EastAsianLineBreaks is a style of east asian line breaks.
type EastAsianLineBreaks int

const (
	//EastAsianLineBreaksNone renders line breaks as it is.
	EastAsianLineBreaksNone EastAsianLineBreaks = iota
	// EastAsianLineBreaksSimple follows east_asian_line_breaks in Pandoc.
	EastAsianLineBreaksSimple
	// EastAsianLineBreaksCSS3Draft follows CSS text level3 "Segment Break Transformation Rules" with some enhancements.
	EastAsianLineBreaksCSS3Draft
)

func (b EastAsianLineBreaks) softLineBreak(thisLastRune rune, siblingFirstRune rune) bool {
	switch b {
	case EastAsianLineBreaksNone:
		return false
	case EastAsianLineBreaksSimple:
		return !(util.IsEastAsianWideRune(thisLastRune) && util.IsEastAsianWideRune(siblingFirstRune))
	case EastAsianLineBreaksCSS3Draft:
		return eastAsianLineBreaksCSS3DraftSoftLineBreak(thisLastRune, siblingFirstRune)
	}
	return false
}

func eastAsianLineBreaksCSS3DraftSoftLineBreak(thisLastRune rune, siblingFirstRune rune) bool {
	// Implements CSS text level3 Segment Break Transformation Rules with some enhancements.
	// References:
	//   - https://www.w3.org/TR/2020/WD-css-text-3-20200429/#line-break-transform
	//   - https://github.com/w3c/csswg-drafts/issues/5086

	// Rule1:
	//   If the character immediately before or immediately after the segment break is
	//   the zero-width space character (U+200B), then the break is removed, leaving behind the zero-width space.
	if thisLastRune == '\u200B' || siblingFirstRune == '\u200B' {
		return false
	}

	// Rule2:
	//   Otherwise, if the East Asian Width property of both the character before and after the segment break is
	//   F, W, or H (not A), and neither side is Hangul, then the segment break is removed.
	thisLastRuneEastAsianWidth := util.EastAsianWidth(thisLastRune)
	siblingFirstRuneEastAsianWidth := util.EastAsianWidth(siblingFirstRune)
	if (thisLastRuneEastAsianWidth == "F" ||
		thisLastRuneEastAsianWidth == "W" ||
		thisLastRuneEastAsianWidth == "H") &&
		(siblingFirstRuneEastAsianWidth == "F" ||
			siblingFirstRuneEastAsianWidth == "W" ||
			siblingFirstRuneEastAsianWidth == "H") {
		return unicode.Is(unicode.Hangul, thisLastRune) || unicode.Is(unicode.Hangul, siblingFirstRune)
	}

	// Rule3:
	//   Otherwise, if either the character before or after the segment break belongs to
	//   the space-discarding character set and it is a Unicode Punctuation (P*) or U+3000,
	//   then the segment break is removed.
	if util.IsSpaceDiscardingUnicodeRune(thisLastRune) ||
		unicode.IsPunct(thisLastRune) ||
		thisLastRune == '\u3000' ||
		util.IsSpaceDiscardingUnicodeRune(siblingFirstRune) ||
		unicode.IsPunct(siblingFirstRune) ||
		siblingFirstRune == '\u3000' {
		return false
	}

	// Rule4:
	//   Otherwise, the segment break is converted to a space (U+0020).
	return true
}

type withEastAsianLineBreaks struct {
	eastAsianLineBreaksStyle EastAsianLineBreaks
}

func (o *withEastAsianLineBreaks) SetConfig(c *renderer.Config) {
	c.Options[optEastAsianLineBreaks] = o.eastAsianLineBreaksStyle
}

func (o *withEastAsianLineBreaks) SetHTMLOption(c *Config) {
	c.EastAsianLineBreaks = o.eastAsianLineBreaksStyle
}

// WithEastAsianLineBreaks is a functional option that indicates whether softline breaks
// between east asian wide characters should be ignored.
func WithEastAsianLineBreaks(e EastAsianLineBreaks) interface {
	renderer.Option
	Option
} {
	return &withEastAsianLineBreaks{e}
}

// XHTML is an option name used in WithXHTML.
const optXHTML renderer.OptionName = "XHTML"

type withXHTML struct {
}

func (o *withXHTML) SetConfig(c *renderer.Config) {
	c.Options[optXHTML] = true
}

func (o *withXHTML) SetHTMLOption(c *Config) {
	c.XHTML = true
}

// WithXHTML is a functional option indicates that nodes should be rendered in
// xhtml instead of HTML5.
func WithXHTML() interface {
	Option
	renderer.Option
} {
	return &withXHTML{}
}

// Unsafe is an option name used in WithUnsafe.
const optUnsafe renderer.OptionName = "Unsafe"

type withUnsafe struct {
}

func (o *withUnsafe) SetConfig(c *renderer.Config) {
	c.Options[optUnsafe] = true
}

func (o *withUnsafe) SetHTMLOption(c *Config) {
	c.Unsafe = true
}

// WithUnsafe is a functional option that renders dangerous contents
// (raw htmls and potentially dangerous links) as it is.
func WithUnsafe() interface {
	renderer.Option
	Option
} {
	return &withUnsafe{}
}

// A Renderer struct is an implementation of renderer.NodeRenderer that renders
// nodes as (X)HTML.
type Renderer struct {
	Config
}

// NewRenderer returns a new Renderer with given options.
func NewRenderer(opts ...Option) renderer.NodeRenderer {
	r := &Renderer{
		Config: NewConfig(),
	}

	for _, opt := range opts {
		opt.SetHTMLOption(&r.Config)
	}
	return r
}

// RegisterFuncs implements NodeRenderer.RegisterFuncs .
func (r *Renderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	// blocks

	reg.Register(ast.KindDocument, r.renderDocument)
	reg.Register(ast.KindHeading, r.renderHeading)
	reg.Register(ast.KindBlockquote, r.renderBlockquote)
	reg.Register(ast.KindCodeBlock, r.renderCodeBlock)
	reg.Register(ast.KindFencedCodeBlock, r.renderFencedCodeBlock)
	reg.Register(ast.KindHTMLBlock, r.renderHTMLBlock)
	reg.Register(ast.KindList, r.renderList)
	reg.Register(ast.KindListItem, r.renderListItem)
	reg.Register(ast.KindParagraph, r.renderParagraph)
	reg.Register(ast.KindTextBlock, r.renderTextBlock)
	reg.Register(ast.KindThematicBreak, r.renderThematicBreak)

	// inlines

	reg.Register(ast.KindAutoLink, r.renderAutoLink)
	reg.Register(ast.KindCodeSpan, r.renderCodeSpan)
	reg.Register(ast.KindEmphasis, r.renderEmphasis)
	reg.Register(ast.KindImage, r.renderImage)
	reg.Register(ast.KindLink, r.renderLink)
	reg.Register(ast.KindRawHTML, r.renderRawHTML)
	reg.Register(ast.KindText, r.renderText)
	reg.Register(ast.KindString, r.renderString)
}

func (r *Renderer) writeLines(w util.BufWriter, source []byte, n ast.Node) {
	l := n.Lines().Len()
	for i := 0; i < l; i++ {
		line := n.Lines().At(i)
		r.Writer.RawWrite(w, line.Value(source))
	}
}

// GlobalAttributeFilter defines attribute names which any elements can have.
var GlobalAttributeFilter = util.NewBytesFilterString(`accesskey,autocapitalize,autofocus,class,contenteditable,dir,draggable,enterkeyhint,hidden,id,inert,inputmode,is,itemid,itemprop,itemref,itemscope,itemtype,lang,part,role,slot,spellcheck,style,tabindex,title,translate`) // nolint:lll

func (r *Renderer) renderDocument(
	w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	// nothing to do
	return ast.WalkContinue, nil
}

// HeadingAttributeFilter defines attribute names which heading elements can have.
var HeadingAttributeFilter = GlobalAttributeFilter

func (r *Renderer) renderHeading(
	w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.Heading)
	if entering {
		_, _ = w.WriteString("<h")
		_ = w.WriteByte("0123456"[n.Level])
		if n.Attributes() != nil {
			RenderAttributes(w, node, HeadingAttributeFilter)
		}
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString("</h")
		_ = w.WriteByte("0123456"[n.Level])
		_, _ = w.WriteString(">\n")
	}
	return ast.WalkContinue, nil
}

// BlockquoteAttributeFilter defines attribute names which blockquote elements can have.
var BlockquoteAttributeFilter = GlobalAttributeFilter.ExtendString(`cite`)

func (r *Renderer) renderBlockquote(
	w util.BufWriter, source []byte, n ast.Node, entering bool) (ast.WalkStatus, error) {
	if entering {
		if n.Attributes() != nil {
			_, _ = w.WriteString("<blockquote")
			RenderAttributes(w, n, BlockquoteAttributeFilter)
			_ = w.WriteByte('>')
		} else {
			_, _ = w.WriteString("<blockquote>\n")
		}
	} else {
		_, _ = w.WriteString("</blockquote>\n")
	}
	return ast.WalkContinue, nil
}

func (r *Renderer) renderCodeBlock(w util.BufWriter, source []byte, n ast.Node, entering bool) (ast.WalkStatus, error) {
	if entering {
		_, _ = w.WriteString("<pre><code>")
		r.writeLines(w, source, n)
	} else {
		_, _ = w.WriteString("</code></pre>\n")
	}
	return ast.WalkContinue, nil
}

func (r *Renderer) renderFencedCodeBlock(
	w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.FencedCodeBlock)
	if entering {
		_, _ = w.WriteString("<pre><code")
		language := n.Language(source)
		if language != nil {
			_, _ = w.WriteString(" class=\"language-")
			r.Writer.Write(w, language)
			_, _ = w.WriteString("\"")
		}
		_ = w.WriteByte('>')
		r.writeLines(w, source, n)
	} else {
		_, _ = w.WriteString("</code></pre>\n")
	}
	return ast.WalkContinue, nil
}

func (r *Renderer) renderHTMLBlock(
	w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.HTMLBlock)
	if entering {
		if r.Unsafe {
			l := n.Lines().Len()
			for i := 0; i < l; i++ {
				line := n.Lines().At(i)
				r.Writer.SecureWrite(w, line.Value(source))
			}
		} else {
			_, _ = w.WriteString("<!-- raw HTML omitted -->\n")
		}
	} else {
		if n.HasClosure() {
			if r.Unsafe {
				closure := n.ClosureLine
				r.Writer.SecureWrite(w, closure.Value(source))
			} else {
				_, _ = w.WriteString("<!-- raw HTML omitted -->\n")
			}
		}
	}
	return ast.WalkContinue, nil
}

// ListAttributeFilter defines attribute names which list elements can have.
var ListAttributeFilter = GlobalAttributeFilter.ExtendString(`start,reversed,type`)

func (r *Renderer) renderList(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.List)
	tag := "ul"
	if n.IsOrdered() {
		tag = "ol"
	}
	if entering {
		_ = w.WriteByte('<')
		_, _ = w.WriteString(tag)
		if n.IsOrdered() && n.Start != 1 {
			_, _ = fmt.Fprintf(w, " start=\"%d\"", n.Start)
		}
		if n.Attributes() != nil {
			RenderAttributes(w, n, ListAttributeFilter)
		}
		_, _ = w.WriteString(">\n")
	} else {
		_, _ = w.WriteString("</")
		_, _ = w.WriteString(tag)
		_, _ = w.WriteString(">\n")
	}
	return ast.WalkContinue, nil
}

// ListItemAttributeFilter defines attribute names which list item elements can have.
var ListItemAttributeFilter = GlobalAttributeFilter.ExtendString(`value`)

func (r *Renderer) renderListItem(w util.BufWriter, source []byte, n ast.Node, entering bool) (ast.WalkStatus, error) {
	if entering {
		if n.Attributes() != nil {
			_, _ = w.WriteString("<li")
			RenderAttributes(w, n, ListItemAttributeFilter)
			_ = w.WriteByte('>')
		} else {
			_, _ = w.WriteString("<li>")
		}
		fc := n.FirstChild()
		if fc != nil {
			if _, ok := fc.(*ast.TextBlock); !ok {
				_ = w.WriteByte('\n')
			}
		}
	} else {
		_, _ = w.WriteString("</li>\n")
	}
	return ast.WalkContinue, nil
}

// ParagraphAttributeFilter defines attribute names which paragraph elements can have.
var ParagraphAttributeFilter = GlobalAttributeFilter

func (r *Renderer) renderParagraph(w util.BufWriter, source []byte, n ast.Node, entering bool) (ast.WalkStatus, error) {
	if entering {
		if n.Attributes() != nil {
			_, _ = w.WriteString("<p")
			RenderAttributes(w, n, ParagraphAttributeFilter)
			_ = w.WriteByte('>')
		} else {
			_, _ = w.WriteString("<p>")
		}
	} else {
		_, _ = w.WriteString("</p>\n")
	}
	return ast.WalkContinue, nil
}

func (r *Renderer) renderTextBlock(w util.BufWriter, source []byte, n ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		if n.NextSibling() != nil && n.FirstChild() != nil {
			_ = w.WriteByte('\n')
		}
	}
	return ast.WalkContinue, nil
}

// ThematicAttributeFilter defines attribute names which hr elements can have.
var ThematicAttributeFilter = GlobalAttributeFilter.ExtendString(`align,color,noshade,size,width`)

func (r *Renderer) renderThematicBreak(
	w util.BufWriter, source []byte, n ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		return ast.WalkContinue, nil
	}
	_, _ = w.WriteString("<hr")
	if n.Attributes() != nil {
		RenderAttributes(w, n, ThematicAttributeFilter)
	}
	if r.XHTML {
		_, _ = w.WriteString(" />\n")
	} else {
		_, _ = w.WriteString(">\n")
	}
	return ast.WalkContinue, nil
}

// LinkAttributeFilter defines attribute names which link elements can have.
var LinkAttributeFilter = GlobalAttributeFilter.ExtendString(`download,hreflang,media,ping,referrerpolicy,rel,shape,target`) // nolint:lll

func (r *Renderer) renderAutoLink(
	w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.AutoLink)
	if !entering {
		return ast.WalkContinue, nil
	}
	_, _ = w.WriteString(`<a href="`)
	url := n.URL(source)
	label := n.Label(source)
	if n.AutoLinkType == ast.AutoLinkEmail && !bytes.HasPrefix(bytes.ToLower(url), []byte("mailto:")) {
		_, _ = w.WriteString("mailto:")
	}
	_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))
	if n.Attributes() != nil {
		_ = w.WriteByte('"')
		RenderAttributes(w, n, LinkAttributeFilter)
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString(`">`)
	}
	_, _ = w.Write(util.EscapeHTML(label))
	_, _ = w.WriteString(`</a>`)
	return ast.WalkContinue, nil
}

// CodeAttributeFilter defines attribute names which code elements can have.
var CodeAttributeFilter = GlobalAttributeFilter

func (r *Renderer) renderCodeSpan(w util.BufWriter, source []byte, n ast.Node, entering bool) (ast.WalkStatus, error) {
	if entering {
		if n.Attributes() != nil {
			_, _ = w.WriteString("<code")
			RenderAttributes(w, n, CodeAttributeFilter)
			_ = w.WriteByte('>')
		} else {
			_, _ = w.WriteString("<code>")
		}
		for c := n.FirstChild(); c != nil; c = c.NextSibling() {
			segment := c.(*ast.Text).Segment
			value := segment.Value(source)
			if bytes.HasSuffix(value, []byte("\n")) {
				r.Writer.RawWrite(w, value[:len(value)-1])
				r.Writer.RawWrite(w, []byte(" "))
			} else {
				r.Writer.RawWrite(w, value)
			}
		}
		return ast.WalkSkipChildren, nil
	}
	_, _ = w.WriteString("</code>")
	return ast.WalkContinue, nil
}

// EmphasisAttributeFilter defines attribute names which emphasis elements can have.
var EmphasisAttributeFilter = GlobalAttributeFilter

func (r *Renderer) renderEmphasis(
	w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.Emphasis)
	tag := "em"
	if n.Level == 2 {
		tag = "strong"
	}
	if entering {
		_ = w.WriteByte('<')
		_, _ = w.WriteString(tag)
		if n.Attributes() != nil {
			RenderAttributes(w, n, EmphasisAttributeFilter)
		}
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString("</")
		_, _ = w.WriteString(tag)
		_ = w.WriteByte('>')
	}
	return ast.WalkContinue, nil
}

func (r *Renderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.Link)
	if entering {
		_, _ = w.WriteString("<a href=\"")
		if r.Unsafe || !IsDangerousURL(n.Destination) {
			_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))
		}
		_ = w.WriteByte('"')
		if n.Title != nil {
			_, _ = w.WriteString(` title="`)
			r.Writer.Write(w, n.Title)
			_ = w.WriteByte('"')
		}
		if n.Attributes() != nil {
			RenderAttributes(w, n, LinkAttributeFilter)
		}
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString("</a>")
	}
	return ast.WalkContinue, nil
}

// ImageAttributeFilter defines attribute names which image elements can have.
var ImageAttributeFilter = GlobalAttributeFilter.ExtendString(`align,border,crossorigin,decoding,height,importance,intrinsicsize,ismap,loading,referrerpolicy,sizes,srcset,usemap,width`) // nolint: lll

func (r *Renderer) renderImage(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		return ast.WalkContinue, nil
	}
	n := node.(*ast.Image)
	_, _ = w.WriteString("<img src=\"")
	if r.Unsafe || !IsDangerousURL(n.Destination) {
		_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))
	}
	_, _ = w.WriteString(`" alt="`)
	r.renderTexts(w, source, n)
	_ = w.WriteByte('"')
	if n.Title != nil {
		_, _ = w.WriteString(` title="`)
		r.Writer.Write(w, n.Title)
		_ = w.WriteByte('"')
	}
	if n.Attributes() != nil {
		RenderAttributes(w, n, ImageAttributeFilter)
	}
	if r.XHTML {
		_, _ = w.WriteString(" />")
	} else {
		_, _ = w.WriteString(">")
	}
	return ast.WalkSkipChildren, nil
}

func (r *Renderer) renderRawHTML(
	w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		return ast.WalkSkipChildren, nil
	}
	if r.Unsafe {
		n := node.(*ast.RawHTML)
		l := n.Segments.Len()
		for i := 0; i < l; i++ {
			segment := n.Segments.At(i)
			_, _ = w.Write(segment.Value(source))
		}
		return ast.WalkSkipChildren, nil
	}
	_, _ = w.WriteString("<!-- raw HTML omitted -->")
	return ast.WalkSkipChildren, nil
}

func (r *Renderer) renderText(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		return ast.WalkContinue, nil
	}
	n := node.(*ast.Text)
	segment := n.Segment
	if n.IsRaw() {
		r.Writer.RawWrite(w, segment.Value(source))
	} else {
		value := segment.Value(source)
		r.Writer.Write(w, value)
		if n.HardLineBreak() || (n.SoftLineBreak() && r.HardWraps) {
			if r.XHTML {
				_, _ = w.WriteString("<br />\n")
			} else {
				_, _ = w.WriteString("<br>\n")
			}
		} else if n.SoftLineBreak() {
			if r.EastAsianLineBreaks != EastAsianLineBreaksNone && len(value) != 0 {
				sibling := node.NextSibling()
				if sibling != nil && sibling.Kind() == ast.KindText {
					if siblingText := sibling.(*ast.Text).Value(source); len(siblingText) != 0 {
						thisLastRune := util.ToRune(value, len(value)-1)
						siblingFirstRune, _ := utf8.DecodeRune(siblingText)
						if r.EastAsianLineBreaks.softLineBreak(thisLastRune, siblingFirstRune) {
							_ = w.WriteByte('\n')
						}
					}
				}
			} else {
				_ = w.WriteByte('\n')
			}
		}
	}
	return ast.WalkContinue, nil
}

func (r *Renderer) renderString(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		return ast.WalkContinue, nil
	}
	n := node.(*ast.String)
	if n.IsCode() {
		_, _ = w.Write(n.Value)
	} else {
		if n.IsRaw() {
			r.Writer.RawWrite(w, n.Value)
		} else {
			r.Writer.Write(w, n.Value)
		}
	}
	return ast.WalkContinue, nil
}

func (r *Renderer) renderTexts(w util.BufWriter, source []byte, n ast.Node) {
	for c := n.FirstChild(); c != nil; c = c.NextSibling() {
		if s, ok := c.(*ast.String); ok {
			_, _ = r.renderString(w, source, s, true)
		} else if t, ok := c.(*ast.Text); ok {
			_, _ = r.renderText(w, source, t, true)
		} else {
			r.renderTexts(w, source, c)
		}
	}
}

var dataPrefix = []byte("data-")

// RenderAttributes renders given node's attributes.
// You can specify attribute names to render by the filter.
// If filter is nil, RenderAttributes renders all attributes.
func RenderAttributes(w util.BufWriter, node ast.Node, filter util.BytesFilter) {
	for _, attr := range node.Attributes() {
		if filter != nil && !filter.Contains(attr.Name) {
			if !bytes.HasPrefix(attr.Name, dataPrefix) {
				continue
			}
		}
		_, _ = w.WriteString(" ")
		_, _ = w.Write(attr.Name)
		_, _ = w.WriteString(`="`)
		// TODO: convert numeric values to strings
		var value []byte
		switch typed := attr.Value.(type) {
		case []byte:
			value = typed
		case string:
			value = util.StringToReadOnlyBytes(typed)
		}
		_, _ = w.Write(util.EscapeHTML(value))
		_ = w.WriteByte('"')
	}
}

// A Writer interface writes textual contents to a writer.
type Writer interface {
	// Write writes the given source to writer with resolving references and unescaping
	// backslash escaped characters.
	Write(writer util.BufWriter, source []byte)

	// RawWrite writes the given source to writer without resolving references and
	// unescaping backslash escaped characters.
	RawWrite(writer util.BufWriter, source []byte)

	// SecureWrite writes the given source to writer with replacing insecure characters.
	SecureWrite(writer util.BufWriter, source []byte)
}

var replacementCharacter = []byte("\ufffd")

// A WriterConfig struct has configurations for the HTML based writers.
type WriterConfig struct {
	// EscapedSpace is an option that indicates that a '\' escaped half-space(0x20) should not be rendered.
	EscapedSpace bool
}

// A WriterOption interface sets options for HTML based writers.
type WriterOption func(*WriterConfig)

// WithEscapedSpace is a WriterOption indicates that a '\' escaped half-space(0x20) should not be rendered.
func WithEscapedSpace() WriterOption {
	return func(c *WriterConfig) {
		c.EscapedSpace = true
	}
}

type defaultWriter struct {
	WriterConfig
}

// NewWriter returns a new Writer.
func NewWriter(opts ...WriterOption) Writer {
	w := &defaultWriter{}
	for _, opt := range opts {
		opt(&w.WriterConfig)
	}
	return w
}

func escapeRune(writer util.BufWriter, r rune) {
	if r < 256 {
		v := util.EscapeHTMLByte(byte(r))
		if v != nil {
			_, _ = writer.Write(v)
			return
		}
	}
	_, _ = writer.WriteRune(util.ToValidRune(r))
}

func (d *defaultWriter) SecureWrite(writer util.BufWriter, source []byte) {
	n := 0
	l := len(source)
	for i := 0; i < l; i++ {
		if source[i] == '\u0000' {
			_, _ = writer.Write(source[i-n : i])
			n = 0
			_, _ = writer.Write(replacementCharacter)
			continue
		}
		n++
	}
	if n != 0 {
		_, _ = writer.Write(source[l-n:])
	}
}

func (d *defaultWriter) RawWrite(writer util.BufWriter, source []byte) {
	n := 0
	l := len(source)
	for i := 0; i < l; i++ {
		v := util.EscapeHTMLByte(source[i])
		if v != nil {
			_, _ = writer.Write(source[i-n : i])
			n = 0
			_, _ = writer.Write(v)
			continue
		}
		n++
	}
	if n != 0 {
		_, _ = writer.Write(source[l-n:])
	}
}

func (d *defaultWriter) Write(writer util.BufWriter, source []byte) {
	escaped := false
	var ok bool
	limit := len(source)
	n := 0
	for i := 0; i < limit; i++ {
		c := source[i]
		if escaped {
			if util.IsPunct(c) {
				d.RawWrite(writer, source[n:i-1])
				n = i
				escaped = false
				continue
			}
			if d.EscapedSpace && c == ' ' {
				d.RawWrite(writer, source[n:i-1])
				n = i + 1
				escaped = false
				continue
			}
		}
		if c == '\x00' {
			d.RawWrite(writer, source[n:i])
			d.RawWrite(writer, replacementCharacter)
			n = i + 1
			escaped = false
			continue
		}
		if c == '&' {
			pos := i
			next := i + 1
			if next < limit && source[next] == '#' {
				nnext := next + 1
				if nnext < limit {
					nc := source[nnext]
					// code point like #x22;
					if nnext < limit && nc == 'x' || nc == 'X' {
						start := nnext + 1
						i, ok = util.ReadWhile(source, [2]int{start, limit}, util.IsHexDecimal)
						if ok && i < limit && source[i] == ';' && i-start < 7 {
							v, _ := strconv.ParseUint(util.BytesToReadOnlyString(source[start:i]), 16, 32)
							d.RawWrite(writer, source[n:pos])
							n = i + 1
							escapeRune(writer, rune(v))
							continue
						}
						// code point like #1234;
					} else if nc >= '0' && nc <= '9' {
						start := nnext
						i, ok = util.ReadWhile(source, [2]int{start, limit}, util.IsNumeric)
						if ok && i < limit && i-start < 8 && source[i] == ';' {
							v, _ := strconv.ParseUint(util.BytesToReadOnlyString(source[start:i]), 10, 32)
							d.RawWrite(writer, source[n:pos])
							n = i + 1
							escapeRune(writer, rune(v))
							continue
						}
					}
				}
			} else {
				start := next
				i, ok = util.ReadWhile(source, [2]int{start, limit}, util.IsAlphaNumeric)
				// entity reference
				if ok && i < limit && source[i] == ';' {
					name := util.BytesToReadOnlyString(source[start:i])
					entity, ok := util.LookUpHTML5EntityByName(name)
					if ok {
						d.RawWrite(writer, source[n:pos])
						n = i + 1
						d.RawWrite(writer, entity.Characters)
						continue
					}
				}
			}
			i = next - 1
		}
		if c == '\\' {
			escaped = true
			continue
		}
		escaped = false
	}
	d.RawWrite(writer, source[n:])
}

// DefaultWriter is a default instance of the Writer.
var DefaultWriter = NewWriter()

var bDataImage = []byte("data:image/")
var bPng = []byte("png;")
var bGif = []byte("gif;")
var bJpeg = []byte("jpeg;")
var bWebp = []byte("webp;")
var bSvg = []byte("svg+xml;")
var bJs = []byte("javascript:")
var bVb = []byte("vbscript:")
var bFile = []byte("file:")
var bData = []byte("data:")

func hasPrefix(s, prefix []byte) bool {
	return len(s) >= len(prefix) && bytes.Equal(bytes.ToLower(s[0:len(prefix)]), bytes.ToLower(prefix))
}

// IsDangerousURL returns true if the given url seems a potentially dangerous url,
// otherwise false.
func IsDangerousURL(url []byte) bool {
	if hasPrefix(url, bDataImage) && len(url) >= 11 {
		v := url[11:]
		if hasPrefix(v, bPng) || hasPrefix(v, bGif) ||
			hasPrefix(v, bJpeg) || hasPrefix(v, bWebp) ||
			hasPrefix(v, bSvg) {
			return false
		}
		return true
	}
	return hasPrefix(url, bJs) || hasPrefix(url, bVb) ||
		hasPrefix(url, bFile) || hasPrefix(url, bData)
}
</file>

<file path="README.md">
goldmark
==========================================

[![https://pkg.go.dev/github.com/yuin/goldmark](https://pkg.go.dev/badge/github.com/yuin/goldmark.svg)](https://pkg.go.dev/github.com/yuin/goldmark)
[![https://github.com/yuin/goldmark/actions?query=workflow:test](https://github.com/yuin/goldmark/actions/workflows/test.yaml/badge.svg?branch=master&event=push)](https://github.com/yuin/goldmark/actions?query=workflow:test)
[![https://coveralls.io/github/yuin/goldmark](https://coveralls.io/repos/github/yuin/goldmark/badge.svg?branch=master)](https://coveralls.io/github/yuin/goldmark)
[![https://goreportcard.com/report/github.com/yuin/goldmark](https://goreportcard.com/badge/github.com/yuin/goldmark)](https://goreportcard.com/report/github.com/yuin/goldmark)

> A Markdown parser written in Go. Easy to extend, standards-compliant, well-structured.

goldmark is compliant with CommonMark 0.31.2.

- [goldmark playground](https://yuin.github.io/goldmark/playground/) : Try goldmark online. This playground is built with WASM(5-10MB).

Motivation
----------------------
I needed a Markdown parser for Go that satisfies the following requirements:

- Easy to extend.
    - Markdown is poor in document expressions compared to other light markup languages such as reStructuredText.
    - We have extensions to the Markdown syntax, e.g. PHP Markdown Extra, GitHub Flavored Markdown.
- Standards-compliant.
    - Markdown has many dialects.
    - GitHub-Flavored Markdown is widely used and is based upon CommonMark, effectively mooting the question of whether or not CommonMark is an ideal specification.
        - CommonMark is complicated and hard to implement.
- Well-structured.
    - AST-based; preserves source position of nodes.
- Written in pure Go.

[golang-commonmark](https://gitlab.com/golang-commonmark/markdown) may be a good choice, but it seems to be a copy of [markdown-it](https://github.com/markdown-it).

[blackfriday.v2](https://github.com/russross/blackfriday/tree/v2) is a fast and widely-used implementation, but is not CommonMark-compliant and cannot be extended from outside of the package, since its AST uses structs instead of interfaces.

Furthermore, its behavior differs from other implementations in some cases, especially regarding lists: [Deep nested lists don't output correctly #329](https://github.com/russross/blackfriday/issues/329), [List block cannot have a second line #244](https://github.com/russross/blackfriday/issues/244), etc.

This behavior sometimes causes problems. If you migrate your Markdown text from GitHub to blackfriday-based wikis, many lists will immediately be broken.

As mentioned above, CommonMark is complicated and hard to implement, so Markdown parsers based on CommonMark are few and far between.

Features
----------------------

- **Standards-compliant.**  goldmark is fully compliant with the latest [CommonMark](https://commonmark.org/) specification.
- **Extensible.**  Do you want to add a `@username` mention syntax to Markdown?
  You can easily do so in goldmark. You can add your AST nodes,
  parsers for block-level elements, parsers for inline-level elements,
  transformers for paragraphs, transformers for the whole AST structure, and
  renderers.
- **Performance.**  goldmark's performance is on par with that of cmark,
  the CommonMark reference implementation written in C.
- **Robust.**  goldmark is tested with `go test --fuzz`.
- **Built-in extensions.**  goldmark ships with common extensions like tables, strikethrough,
  task lists, and definition lists.
- **Depends only on standard libraries.**

Installation
----------------------
```bash
$ go get github.com/yuin/goldmark
```


Usage
----------------------
Import packages:

```go
import (
    "bytes"
    "github.com/yuin/goldmark"
)
```


Convert Markdown documents with the CommonMark-compliant mode:

```go
var buf bytes.Buffer
if err := goldmark.Convert(source, &buf); err != nil {
  panic(err)
}
```

With options
------------------------------

```go
var buf bytes.Buffer
if err := goldmark.Convert(source, &buf, parser.WithContext(ctx)); err != nil {
  panic(err)
}
```

| Functional option | Type | Description |
| ----------------- | ---- | ----------- |
| `parser.WithContext` | A `parser.Context` | Context for the parsing phase. |

Context options
----------------------

| Functional option | Type | Description |
| ----------------- | ---- | ----------- |
| `parser.WithIDs` | A `parser.IDs` | `IDs` allows you to change logics that are related to element id(ex: Auto heading id generation). |


Custom parser and renderer
--------------------------
```go
import (
    "bytes"
    "github.com/yuin/goldmark"
    "github.com/yuin/goldmark/extension"
    "github.com/yuin/goldmark/parser"
    "github.com/yuin/goldmark/renderer/html"
)

md := goldmark.New(
          goldmark.WithExtensions(extension.GFM),
          goldmark.WithParserOptions(
              parser.WithAutoHeadingID(),
          ),
          goldmark.WithRendererOptions(
              html.WithHardWraps(),
              html.WithXHTML(),
          ),
      )
var buf bytes.Buffer
if err := md.Convert(source, &buf); err != nil {
    panic(err)
}
```

| Functional option | Type | Description |
| ----------------- | ---- | ----------- |
| `goldmark.WithParser` | `parser.Parser`  | This option must be passed before `goldmark.WithParserOptions` and `goldmark.WithExtensions` |
| `goldmark.WithRenderer` | `renderer.Renderer`  | This option must be passed before `goldmark.WithRendererOptions` and `goldmark.WithExtensions`  |
| `goldmark.WithParserOptions` | `...parser.Option`  |  |
| `goldmark.WithRendererOptions` | `...renderer.Option` |  |
| `goldmark.WithExtensions` | `...goldmark.Extender`  |  |

Parser and Renderer options
------------------------------

### Parser options

| Functional option | Type | Description |
| ----------------- | ---- | ----------- |
| `parser.WithBlockParsers` | A `util.PrioritizedSlice` whose elements are `parser.BlockParser` | Parsers for parsing block level elements. |
| `parser.WithInlineParsers` | A `util.PrioritizedSlice` whose elements are `parser.InlineParser` | Parsers for parsing inline level elements. |
| `parser.WithParagraphTransformers` | A `util.PrioritizedSlice` whose elements are `parser.ParagraphTransformer` | Transformers for transforming paragraph nodes. |
| `parser.WithASTTransformers` | A `util.PrioritizedSlice` whose elements are `parser.ASTTransformer` | Transformers for transforming an AST. |
| `parser.WithAutoHeadingID` | `-` | Enables auto heading ids. |
| `parser.WithAttribute` | `-` | Enables custom attributes. Currently only headings supports attributes. |

### HTML Renderer options

| Functional option | Type | Description |
| ----------------- | ---- | ----------- |
| `html.WithWriter` | `html.Writer` | `html.Writer` for writing contents to an `io.Writer`. |
| `html.WithHardWraps` | `-` | Render newlines as `<br>`.|
| `html.WithXHTML` | `-` | Render as XHTML. |
| `html.WithUnsafe` | `-` | By default, goldmark does not render raw HTML or potentially dangerous links. With this option, goldmark renders such content as written. |

### Built-in extensions

- `extension.Table`
    - [GitHub Flavored Markdown: Tables](https://github.github.com/gfm/#tables-extension-)
- `extension.Strikethrough`
    - [GitHub Flavored Markdown: Strikethrough](https://github.github.com/gfm/#strikethrough-extension-)
- `extension.Linkify`
    - [GitHub Flavored Markdown: Autolinks](https://github.github.com/gfm/#autolinks-extension-)
- `extension.TaskList`
    - [GitHub Flavored Markdown: Task list items](https://github.github.com/gfm/#task-list-items-extension-)
- `extension.GFM`
    - This extension enables Table, Strikethrough, Linkify and TaskList.
    - This extension does not filter tags defined in [6.11: Disallowed Raw HTML (extension)](https://github.github.com/gfm/#disallowed-raw-html-extension-).
    If you need to filter HTML tags, see [Security](#security).
    - If you need to parse github emojis, you can use [goldmark-emoji](https://github.com/yuin/goldmark-emoji) extension.
- `extension.DefinitionList`
    - [PHP Markdown Extra: Definition lists](https://michelf.ca/projects/php-markdown/extra/#def-list)
- `extension.Footnote`
    - [PHP Markdown Extra: Footnotes](https://michelf.ca/projects/php-markdown/extra/#footnotes)
- `extension.Typographer`
    - This extension substitutes punctuations with typographic entities like [smartypants](https://daringfireball.net/projects/smartypants/).
- `extension.CJK`
    - This extension is a shortcut for CJK related functionalities.

### Attributes
The `parser.WithAttribute` option allows you to define attributes on some elements.

Currently only headings support attributes.

**Attributes are being discussed in the
[CommonMark forum](https://talk.commonmark.org/t/consistent-attribute-syntax/272).
This syntax may possibly change in the future.**


#### Headings

```
## heading ## {#id .className attrName=attrValue class="class1 class2"}

## heading {#id .className attrName=attrValue class="class1 class2"}
```

```
heading {#id .className attrName=attrValue}
============
```

### Table extension
The Table extension implements [Table(extension)](https://github.github.com/gfm/#tables-extension-), as
defined in [GitHub Flavored Markdown Spec](https://github.github.com/gfm/).

Specs are defined for XHTML, so specs use some deprecated attributes for HTML5.

You can override alignment rendering method via options.

| Functional option | Type | Description |
| ----------------- | ---- | ----------- |
| `extension.WithTableCellAlignMethod` | `extension.TableCellAlignMethod` | Option indicates how are table cells aligned. |

### Typographer extension

The Typographer extension translates plain ASCII punctuation characters into typographic-punctuation HTML entities.

Default substitutions are:

| Punctuation | Default entity |
| ------------ | ---------- |
| `'`           | `&lsquo;`, `&rsquo;` |
| `"`           | `&ldquo;`, `&rdquo;` |
| `--`       | `&ndash;` |
| `---`      | `&mdash;` |
| `...`      | `&hellip;` |
| `<<`       | `&laquo;` |
| `>>`       | `&raquo;` |

You can override the default substitutions via `extensions.WithTypographicSubstitutions`:

```go
markdown := goldmark.New(
    goldmark.WithExtensions(
        extension.NewTypographer(
            extension.WithTypographicSubstitutions(extension.TypographicSubstitutions{
                extension.LeftSingleQuote:  []byte("&sbquo;"),
                extension.RightSingleQuote: nil, // nil disables a substitution
            }),
        ),
    ),
)
```

### Linkify extension

The Linkify extension implements [Autolinks(extension)](https://github.github.com/gfm/#autolinks-extension-), as
defined in [GitHub Flavored Markdown Spec](https://github.github.com/gfm/).

Since the spec does not define details about URLs, there are numerous ambiguous cases.

You can override autolinking patterns via options.

| Functional option | Type | Description |
| ----------------- | ---- | ----------- |
| `extension.WithLinkifyAllowedProtocols` | `[][]byte \| []string` | List of allowed protocols such as `[]string{ "http:" }` |
| `extension.WithLinkifyURLRegexp` | `*regexp.Regexp` | Regexp that defines URLs, including protocols |
| `extension.WithLinkifyWWWRegexp` | `*regexp.Regexp` | Regexp that defines URL starting with `www.`. This pattern corresponds to [the extended www autolink](https://github.github.com/gfm/#extended-www-autolink) |
| `extension.WithLinkifyEmailRegexp` | `*regexp.Regexp` | Regexp that defines email addresses` |

Example, using [xurls](https://github.com/mvdan/xurls):

```go
import "mvdan.cc/xurls/v2"

markdown := goldmark.New(
    goldmark.WithRendererOptions(
        html.WithXHTML(),
        html.WithUnsafe(),
    ),
    goldmark.WithExtensions(
        extension.NewLinkify(
            extension.WithLinkifyAllowedProtocols([]string{
                "http:",
                "https:",
            }),
            extension.WithLinkifyURLRegexp(
                xurls.Strict(),
            ),
        ),
    ),
)
```

### Footnotes extension

The Footnote extension implements [PHP Markdown Extra: Footnotes](https://michelf.ca/projects/php-markdown/extra/#footnotes).

This extension has some options:

| Functional option | Type | Description |
| ----------------- | ---- | ----------- |
| `extension.WithFootnoteIDPrefix` | `[]byte \| string` |  a prefix for the id attributes.|
| `extension.WithFootnoteIDPrefixFunction` | `func(gast.Node) []byte` |  a function that determines the id attribute for given Node.|
| `extension.WithFootnoteLinkTitle` | `[]byte \| string` |  an optional title attribute for footnote links.|
| `extension.WithFootnoteBacklinkTitle` | `[]byte \| string` |  an optional title attribute for footnote backlinks. |
| `extension.WithFootnoteLinkClass` | `[]byte \| string` |  a class for footnote links. This defaults to `footnote-ref`. |
| `extension.WithFootnoteBacklinkClass` | `[]byte \| string` |  a class for footnote backlinks. This defaults to `footnote-backref`. |
| `extension.WithFootnoteBacklinkHTML` | `[]byte \| string` |  a class for footnote backlinks. This defaults to `&#x21a9;&#xfe0e;`. |

Some options can have special substitutions. Occurrences of “^^” in the string will be replaced by the corresponding footnote number in the HTML output. Occurrences of “%%” will be replaced by a number for the reference (footnotes can have multiple references).

`extension.WithFootnoteIDPrefix` and `extension.WithFootnoteIDPrefixFunction` are useful if you have multiple Markdown documents displayed inside one HTML document to avoid footnote ids to clash each other.

`extension.WithFootnoteIDPrefix` sets fixed id prefix, so you may write codes like the following:

```go
for _, path := range files {
    source := readAll(path)
    prefix := getPrefix(path)

    markdown := goldmark.New(
        goldmark.WithExtensions(
            NewFootnote(
                WithFootnoteIDPrefix(path),
            ),
        ),
    )
    var b bytes.Buffer
    err := markdown.Convert(source, &b)
    if err != nil {
        t.Error(err.Error())
    }
}
```

`extension.WithFootnoteIDPrefixFunction` determines an id prefix by calling given function, so you may write codes like the following:

```go
markdown := goldmark.New(
    goldmark.WithExtensions(
        NewFootnote(
                WithFootnoteIDPrefixFunction(func(n gast.Node) []byte {
                    v, ok := n.OwnerDocument().Meta()["footnote-prefix"]
                    if ok {
                        return util.StringToReadOnlyBytes(v.(string))
                    }
                    return nil
                }),
        ),
    ),
)

for _, path := range files {
    source := readAll(path)
    var b bytes.Buffer

    doc := markdown.Parser().Parse(text.NewReader(source))
    doc.Meta()["footnote-prefix"] = getPrefix(path)
    err := markdown.Renderer().Render(&b, source, doc)
}
```

You can use [goldmark-meta](https://github.com/yuin/goldmark-meta) to define a id prefix in the markdown document:


```markdown
---
title: document title
slug: article1
footnote-prefix: article1
---

# My article

```

### CJK extension
CommonMark gives compatibilities a high priority and original markdown was designed by westerners. So CommonMark lacks considerations for languages like CJK.

This extension provides additional options for CJK users.

| Functional option | Type | Description |
| ----------------- | ---- | ----------- |
| `extension.WithEastAsianLineBreaks` | `...extension.EastAsianLineBreaksStyle` | Soft line breaks are rendered as a newline. Some asian users will see it as an unnecessary space. With this option, soft line breaks between east asian wide characters will be ignored. This defaults to `EastAsianLineBreaksStyleSimple`. |
| `extension.WithEscapedSpace` | `-` | Without spaces around an emphasis started with east asian punctuations, it is not interpreted as an emphasis(as defined in CommonMark spec). With this option, you can avoid this inconvenient behavior by putting 'not rendered' spaces around an emphasis like `太郎は\ **「こんにちわ」**\ といった`. |

#### Styles of Line Breaking

| Style | Description |
| ----- | ----------- |
| `EastAsianLineBreaksStyleSimple` | Soft line breaks are ignored if both sides of the break are east asian wide character. This behavior is the same as [`east_asian_line_breaks`](https://pandoc.org/MANUAL.html#extension-east_asian_line_breaks) in Pandoc. |
| `EastAsianLineBreaksCSS3Draft` | This option implements CSS text level3 [Segment Break Transformation Rules](https://drafts.csswg.org/css-text-3/#line-break-transform) with [some enhancements](https://github.com/w3c/csswg-drafts/issues/5086). |

#### Example of `EastAsianLineBreaksStyleSimple`

Input Markdown:

```md
私はプログラマーです。
東京の会社に勤めています。
GoでWebアプリケーションを開発しています。
```

Output:

```html
<p>私はプログラマーです。東京の会社に勤めています。\nGoでWebアプリケーションを開発しています。</p>
```

#### Example of `EastAsianLineBreaksCSS3Draft`

Input Markdown:

```md
私はプログラマーです。
東京の会社に勤めています。
GoでWebアプリケーションを開発しています。
```

Output:

```html
<p>私はプログラマーです。東京の会社に勤めています。GoでWebアプリケーションを開発しています。</p>
```

Security
--------------------
By default, goldmark does not render raw HTML or potentially-dangerous URLs.
If you need to gain more control over untrusted contents, it is recommended that you
use an HTML sanitizer such as [bluemonday](https://github.com/microcosm-cc/bluemonday).

Benchmark
--------------------
You can run this benchmark in the `_benchmark` directory.

### against other golang libraries

blackfriday v2 seems to be the fastest, but as it is not CommonMark compliant, its performance cannot be directly compared to that of the CommonMark-compliant libraries.

goldmark, meanwhile, builds a clean, extensible AST structure, achieves full compliance with
CommonMark, and consumes less memory, all while being reasonably fast.

- MBP 2019 13″(i5, 16GB), Go1.17

```
BenchmarkMarkdown/Blackfriday-v2-8                   302           3743747 ns/op         3290445 B/op      20050 allocs/op
BenchmarkMarkdown/GoldMark-8                         280           4200974 ns/op         2559738 B/op      13435 allocs/op
BenchmarkMarkdown/CommonMark-8                       226           5283686 ns/op         2702490 B/op      20792 allocs/op
BenchmarkMarkdown/Lute-8                              12          92652857 ns/op        10602649 B/op      40555 allocs/op
BenchmarkMarkdown/GoMarkdown-8                        13          81380167 ns/op         2245002 B/op      22889 allocs/op
```

### against cmark (CommonMark reference implementation written in C)

- MBP 2019 13″(i5, 16GB), Go1.17

```
----------- cmark -----------
file: _data.md
iteration: 50
average: 0.0044073057 sec
------- goldmark -------
file: _data.md
iteration: 50
average: 0.0041611990 sec
```

As you can see, goldmark's performance is on par with cmark's.

Extensions
--------------------
### List of extensions

- [goldmark-meta](https://github.com/yuin/goldmark-meta): A YAML metadata
  extension for the goldmark Markdown parser.
- [goldmark-highlighting](https://github.com/yuin/goldmark-highlighting): A syntax-highlighting extension
  for the goldmark markdown parser.
- [goldmark-emoji](https://github.com/yuin/goldmark-emoji): An emoji
  extension for the goldmark Markdown parser.
- [goldmark-mathjax](https://github.com/litao91/goldmark-mathjax): Mathjax support for the goldmark markdown parser
- [goldmark-pdf](https://github.com/stephenafamo/goldmark-pdf): A PDF renderer that can be passed to `goldmark.WithRenderer()`.
- [goldmark-hashtag](https://github.com/abhinav/goldmark-hashtag): Adds support for `#hashtag`-based tagging to goldmark.
- [goldmark-wikilink](https://github.com/abhinav/goldmark-wikilink): Adds support for `[[wiki]]`-style links to goldmark.
- [goldmark-anchor](https://github.com/abhinav/goldmark-anchor): Adds anchors (permalinks) next to all headers in a document.
- [goldmark-figure](https://github.com/mangoumbrella/goldmark-figure): Adds support for rendering paragraphs starting with an image to `<figure>` elements.
- [goldmark-frontmatter](https://github.com/abhinav/goldmark-frontmatter): Adds support for YAML, TOML, and custom front matter to documents.
- [goldmark-toc](https://github.com/abhinav/goldmark-toc): Adds support for generating tables-of-contents for goldmark documents.
- [goldmark-mermaid](https://github.com/abhinav/goldmark-mermaid): Adds support for rendering [Mermaid](https://mermaid-js.github.io/mermaid/) diagrams in goldmark documents.
- [goldmark-pikchr](https://github.com/jchenry/goldmark-pikchr): Adds support for rendering [Pikchr](https://pikchr.org/home/doc/trunk/homepage.md) diagrams in goldmark documents.
- [goldmark-embed](https://github.com/13rac1/goldmark-embed): Adds support for rendering embeds from YouTube links.
- [goldmark-latex](https://github.com/soypat/goldmark-latex): A $\LaTeX$ renderer that can be passed to `goldmark.WithRenderer()`.
- [goldmark-fences](https://github.com/stefanfritsch/goldmark-fences): Support for pandoc-style [fenced divs](https://pandoc.org/MANUAL.html#divs-and-spans) in goldmark.
- [goldmark-d2](https://github.com/FurqanSoftware/goldmark-d2): Adds support for [D2](https://d2lang.com/) diagrams.
- [goldmark-katex](https://github.com/FurqanSoftware/goldmark-katex): Adds support for [KaTeX](https://katex.org/) math and equations.
- [goldmark-img64](https://github.com/tenkoh/goldmark-img64): Adds support for embedding images into the document as DataURL (base64 encoded).
- [goldmark-enclave](https://github.com/quailyquaily/goldmark-enclave): Adds support for embedding youtube/bilibili video, X's [oembed X](https://publish.x.com/), [tradingview chart](https://www.tradingview.com/widget/)'s chart, [quaily widget](https://quaily.com), [spotify embeds](https://developer.spotify.com/documentation/embeds), [dify embed](https://dify.ai/) and html audio into the document.
- [goldmark-wiki-table](https://github.com/movsb/goldmark-wiki-table): Adds support for embedding Wiki Tables.
- [goldmark-tgmd](https://github.com/Mad-Pixels/goldmark-tgmd): A Telegram markdown renderer that can be passed to `goldmark.WithRenderer()`.
- [goldmark-treeblood](https://github.com/Wyatt915/goldmark-treeblood): Renders $\LaTeX$ expressions as MathML (pure Go, no external dependencies).

### Loading extensions at runtime
[goldmark-dynamic](https://github.com/yuin/goldmark-dynamic) allows you to write a goldmark extension in Lua and load it at runtime without re-compilation.

Please refer to  [goldmark-dynamic](https://github.com/yuin/goldmark-dynamic) for details.


goldmark internal(for extension developers)
----------------------------------------------
### Overview
goldmark's Markdown processing is outlined in the diagram below.

```
            <Markdown in []byte, parser.Context>
                           |
                           V
            +-------- parser.Parser ---------------------------
            | 1. Parse block elements into AST
            |   1. If a parsed block is a paragraph, apply 
            |      ast.ParagraphTransformer
            | 2. Traverse AST and parse blocks.
            |   1. Process delimiters(emphasis) at the end of
            |      block parsing
            | 3. Apply parser.ASTTransformers to AST
                           |
                           V
                      <ast.Node>
                           |
                           V
            +------- renderer.Renderer ------------------------
            | 1. Traverse AST and apply renderer.NodeRenderer
            |    corespond to the node type

                           |
                           V
                        <Output>
```

### Parsing
Markdown documents are read through `text.Reader` interface.

AST nodes do not have concrete text. AST nodes have segment information of the documents, represented by `text.Segment` .

`text.Segment` has 3 attributes: `Start`, `End`, `Padding` .

(TBC)

**TODO**

See `extension` directory for examples of extensions.

Summary:

1. Define AST Node as a struct in which `ast.BaseBlock` or `ast.BaseInline` is embedded.
2. Write a parser that implements `parser.BlockParser` or `parser.InlineParser`.
3. Write a renderer that implements `renderer.NodeRenderer`.
4. Define your goldmark extension that implements `goldmark.Extender`.


Donation
--------------------
BTC: 1NEDSyUmo4SMTDP83JJQSWi1MvQUGGNMZB

License
--------------------
MIT

Author
--------------------
Yusuke Inuzuka
</file>

</files>
